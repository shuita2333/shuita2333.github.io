<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZYH&#39;s blog</title>
  
  
  <link href="https://zhangyuanhe.top/atom.xml" rel="self"/>
  
  <link href="https://zhangyuanhe.top/"/>
  <updated>2024-01-17T12:45:52.392Z</updated>
  <id>https://zhangyuanhe.top/</id>
  
  <author>
    <name>Charmes</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://zhangyuanhe.top/2024/01/17/BUPT_note/Notes%20on%20Complex%20network/"/>
    <id>https://zhangyuanhe.top/2024/01/17/BUPT_note/Notes%20on%20Complex%20network/</id>
    <published>2024-01-17T12:45:01.320Z</published>
    <updated>2024-01-17T12:45:52.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复杂网络-彭海朋"><a href="#复杂网络-彭海朋" class="headerlink" title="复杂网络 彭海朋"></a>复杂网络 彭海朋</h1><h2 id="虫口方程"><a href="#虫口方程" class="headerlink" title="虫口方程"></a>虫口方程</h2><h1 id="第零讲"><a href="#第零讲" class="headerlink" title="第零讲"></a>第零讲</h1><p>$$<br>x_{n+1}&#x3D;\gamma x_n(1-x_n)<br>$$</p><p>在不控制的条件下，人口每25年增加一倍，即按几何级数增长。<em>xn</em>+1 &#x3D; <em>𝛾xn</em>。修正就是计入限制虫口增长的负因素。虫口数目太多时，由于争夺有限的食物和生存空间发生咬斗，由于接触传染而导致疾病蔓延，争斗使虫口数目减少的事件，这些事件的数目比例于<em>xn^</em>2。</p><h2 id="Logistic映射（Logistic-Map）"><a href="#Logistic映射（Logistic-Map）" class="headerlink" title="Logistic映射（Logistic Map）"></a>Logistic映射（Logistic Map）</h2><p>$$<br>x_{n+1}&#x3D;rx_n(1-x_n)<br>$$</p><p>分叉与周期倍增（Bifurcation &amp; Period Doubling）</p><p>對初始值的敏感性</p><p>混沌内部的自相似结构</p><h1 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h1><h2 id="复杂网络的数学描述"><a href="#复杂网络的数学描述" class="headerlink" title="复杂网络的数学描述"></a>复杂网络的数学描述</h2><p>网络G&#x3D;（V, E），由点集V（G）和边集E（G）组成的一个图，可分为无向、有向和加权网络<br>令ei∈ E（G），每条边ei有V（G）中的一对点(u,v)与之对应；如果任意(u,v)与(v,u)对应同一条边，则称为无向网络，否则为有向网络；如果任意∣ei ∣ &#x3D;1，则称为无权网络，否则为加权网络。</p><p>——复杂网络是对复杂系统的一种抽象</p><h2 id="对网络拓扑结构的描述"><a href="#对网络拓扑结构的描述" class="headerlink" title="对网络拓扑结构的描述"></a>对网络拓扑结构的描述</h2><p><strong>几何量及其分布</strong></p><p>度（Degree）：朋友的个数<br>集聚系数（群系数）（Clustering coefficient）：朋友的朋友还是不是朋友的情况<br>最短路径（Shortest path）：两个顶点之间边数最少的路径<br>介数（Betweenness）：经过我的最短路径的条数</p><h2 id="网络的基本模型"><a href="#网络的基本模型" class="headerlink" title="网络的基本模型"></a>网络的基本模型</h2><ul><li>规则网<br>(a) 完全连接; (b) 最近邻居连接; (c) 星形连接; (d) Lattice; … (z) Layers</li><li>随机图</li><li>小世界网络</li><li>Scale-Free 网络</li></ul><h3 id="ER-随机图模型"><a href="#ER-随机图模型" class="headerlink" title="ER 随机图模型"></a>ER 随机图模型</h3><p>特征:<br>连通性:Poisson 分布<br>齐次特征:每个节点大约有相同的<br>连接数:节点数不增加</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled.png" alt="Untitled"></p><h3 id="小世界网络"><a href="#小世界网络" class="headerlink" title="小世界网络"></a>小世界网络</h3><p>特征:<br>齐次性:每个节点有大约相同的连接数<br>节点不增加</p><h3 id="Scale-Free网络的基本特征"><a href="#Scale-Free网络的基本特征" class="headerlink" title="Scale Free网络的基本特征"></a>Scale Free网络的基本特征</h3><p>Power Law Degree Distribution（幂律度分布）</p><p>$$<br>P(k)\propto k^{-\gamma} \ \ \ \ \ln P(k)\propto -\gamma\ln k\P(\lambda k)\propto(\lambda k)^{-\gamma}&#x3D;\lambda^{-\gamma}k^{-\gamma}&#x3D;\lambda^{-\gamma}P(k)<br>$$</p><p>1、自相似结构<br>2、两极分化，高度弥散</p><p><strong>六度分隔（Six Degrees of Separation）理论</strong>。简单地说：“你和任何一个陌生人之间所间隔的人不会超六个，也就是说，最多通过六个人你就能够认识任何一个陌生人。”</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table><thead><tr><th></th><th>E&#x2F;R随机图模型</th><th>现实生活的复杂网络</th></tr></thead><tbody><tr><td>平均距离</td><td>小&#x2F;大</td><td>小</td></tr><tr><td>聚类系数</td><td>大&#x2F;小</td><td>大(Small-world feature)</td></tr><tr><td>度分布</td><td>二项式&#x2F;Poisson</td><td>幂指数(Scale-free feature)</td></tr></tbody></table><p>直径：两点间最短距离的最大值</p><h2 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h2><p>分形和不规则形状的几何有关。</p><p>分形（Fractal)：局部与整体具有相似性，或者说在标度变换下具有相似性的几何形体。</p><p>曼德勃鲁集</p><p>分形音乐</p><h3 id="分维"><a href="#分维" class="headerlink" title="分维"></a>分维</h3><p>假设ε是小立方体一边的长度， N （ε）是用此小立方体覆盖被测形体所得的数目，维数公式意味着通过用边长为ε的小立方体覆盖被测形体来确定形体的维数。对于通常的规则物体 ，覆盖一根单位 长度的线 段所需 的数目要 N （ε）＝1／ε，覆盖一个单位边长的正方形，N(ε)＝（1／ε）2 ，覆盖单位边 长的立方体，N （ε）＝（1／ε）3。从这三个式子可见维数公式也适用于通常的维数含义。</p><h1 id="复杂网络病毒的行为分析"><a href="#复杂网络病毒的行为分析" class="headerlink" title="复杂网络病毒的行为分析"></a>复杂网络病毒的行为分析</h1><h3 id="恶意代码的基础知识"><a href="#恶意代码的基础知识" class="headerlink" title="恶意代码的基础知识"></a>恶意代码的基础知识</h3><p>恶意代码是最头痛的安全问题之一，它甚至是整个软件安全的核心。虽然单独对付某台设备上的指定恶意代码并不难，但是，网上各种各样的海量恶意代码，却像癌细胞一样，危害着安全，而且，既杀之不绝，又严重消耗正常体能。</p><blockquote><p>狭义上说，恶意代码是指故意编制或设置的、会产生威胁或潜在威胁的计算机代码（软件）。最常见的恶意代码有计算机病毒、特洛伊木马、计算机蠕虫、后门、逻辑炸弹等。<br>广义上说，恶意代码还指那些没有作用却会带来危险的代码，比如，流氓软件和广告推送等。</p></blockquote><p>恶意代码的入侵手段主要有三类：利用软件漏洞、利用用户的误操作、前两者的混合。</p><p>恶意代码的主要传播方式是病毒式传播</p><h2 id="死亡型病毒的动力学分析"><a href="#死亡型病毒的动力学分析" class="headerlink" title="死亡型病毒的动力学分析"></a>死亡型病毒的动力学分析</h2><blockquote><p>设网络的用户数为N，在t时刻，已经受害的用户数为T(t)，暂未受害的用户数为S(t)，那么，有恒等式S(t)+T(t)&#x3D;N。<br>再令f(S,T)为在“已有T人受害，S人暂未受害”条件下，受害事件发生率，于是，有下面两个微分方程<br>dT(t)&#x2F;dt&#x3D;f(S,T) 和 dS(t)&#x2F;dt&#x3D;-f(S,T)</p></blockquote><p>在生物医学的流行病学中，有一个可借鉴的概念是传染力λ(T)，它表示在已有T台设备中毒的情况下，暂未中毒的设备与中毒者相连接的概率，所以，f(S,T)&#x3D;λ(T)S；<br>另一个概念是传染率β，它表示一个未中毒设备在连接到中毒者后，被传染的概率；所以，λ(T)&#x3D;βT。于是，f(S,T)&#x3D;λ(T)S&#x3D;βTS，即，它是一个双线性函数。</p><h2 id="康复型病毒的动力学分析"><a href="#康复型病毒的动力学分析" class="headerlink" title="康复型病毒的动力学分析"></a>康复型病毒的动力学分析</h2><blockquote><p>与死亡型模型不同，在康复型模型中，受害用户在经过救治后，又可以康复成为暂未受害的用户，当然，该用户也可能再次受害。<br>其实，绝大部分恶意代码，特别是诱骗类恶意代码，都是这种康复型的。</p></blockquote><p>在此，除了10.2节中的S、T、F(S,T)和N等概念外，我们再引入另一个概念，即g(T)，它表示在T个受害者中，有g(T)个用户被康复成正常健康用户，从而，变成暂未受害用户。<br>若用γ表示康复率（生物医学经验告诉我们：每个受害者，在下一小段时间δt内，被康复的概率为γδt+0(δt)2。并且受害者被康复的时间，服从均值为1&#x2F;γ的指数分布。）那么：g(T)&#x3D;γT</p><p>由此，我们可以得到微分方程组：<br>dT(t)&#x2F;dt&#x3D;f(S,T)-g(T)&#x3D;βTS-γT和 dS(t)&#x2F;dt&#x3D;-f(S,T)+g(T)&#x3D;-βTS+γT<br>若令u(t)&#x3D;S(t)&#x2F;N， v(t)&#x3D;T(t)&#x2F;N， t’&#x3D;γt和R0&#x3D;βN&#x2F;γ，那么，上面的两个微分方程就变为：<br>du&#x2F;dt&#x3D;-(R0u-1)v 和dv&#x2F;dt&#x3D;(R0u-1)v<br>其定义域为：D&#x3D;{0≤u≤1,0≤v≤1,u+v&#x3D;1}</p><p><strong>定理10.1：针对康复型恶意代码，如果R0&lt;1，那么，康复型恶意代码就会最终被消灭，即，无人受害；反过来，如果R0&gt;1，那么，康复型恶意代码就会在一定范围内长期为害，具体地说，受害者人数将长期徘徊在N(1-1&#x2F;R0)附近。</strong></p><h2 id="免疫型病毒的动力学分析"><a href="#免疫型病毒的动力学分析" class="headerlink" title="免疫型病毒的动力学分析"></a>免疫型病毒的动力学分析</h2><p>设S、T、γ、β和N等概念与10.3节相同，又记R(t)为t时刻被康复（具有了免疫力）的用户数。于是，在任何一个时刻，都恒有N&#x3D;S(t)+T(t)+R(t)<br>为了使相关公式看起来简单一些，分别用S(t)&#x2F;N、T(t)&#x2F;N和R(t)&#x2F;N去代替S(t)、T(t)和R(t)并且仍然采用原来的记号来表示S(t)、T(t)和R(t)，此时便有S(t)+T(t)+R(t)&#x3D;1<br>简单来说，S(t)、T(t)和R(t)分别代表暂未受害、正受害和受害康复且具有免疫力的用户，各占总用户数的比例。</p><p><strong>定理10.2：针对免疫型恶意代码，当F0&lt;1时，此恶意代码不会爆发，并随着时间的推移，会自动消灭；当F0&gt;1时，该恶意代码会在一定的时段内爆发，受害者人数达到一个最大值Tmax后，才开始递减，并最终消灭。更深入地，Tmax在总人数中所占的比例为1-ρ+ρln(ρ&#x2F;S0)<br>在这里S0表示刚开始时，暂未受害的人数比例。</strong></p><h2 id="开机和关机对免疫型病毒的影响"><a href="#开机和关机对免疫型病毒的影响" class="headerlink" title="开机和关机对免疫型病毒的影响"></a>开机和关机对免疫型病毒的影响</h2><blockquote><p>以上所有小节的分析，都假定活跃用户数固定为N。但是，在实际情况下，当然有例外。比如，某用户主动关机后，任何恶意代码对他都不构成威胁，此时活跃用户就减少一个；当某用户终端中毒后被宕（dang）机，这里活跃用户数也减少一个；当新用户开机（或进入网络）后，他又可能成为恶意代码的攻击对象，这时，活跃用户数又增加一个等。</p></blockquote><p><strong>定理10.3：记P0&#x3D;β&#x2F;(γ+μ)，那么，在情况1之下，<br>当P0≤1时，该免疫型恶意代码一定会随着时间的推移，最终自动消灭；<br>当P0≥1时，该免疫型恶意代码一定会随着时间的推移，最终在$S&#x3D;1&#x2F;P_0、T&#x3D;μ(P_0-1)&#x2F;β、R&#x3D;1-1&#x2F;P_0-μ(P_0-1)&#x2F;β$点处达到全局渐近稳定，即，最终健康终端的比例为$S&#x3D;1&#x2F;P_0$，受害终端的比例为$T&#x3D;μ(P_0-1)&#x2F;β$，获得免疫力的终端比例为$R&#x3D;1-1&#x2F;P_0-μ(P_0-1)&#x2F;β$。</strong></p><h2 id="预防措施的效果分析"><a href="#预防措施的效果分析" class="headerlink" title="预防措施的效果分析"></a>预防措施的效果分析</h2><p>我们虽然不能强求全体用户都采取预防措施，但是，如果有比例为p的用户采取了预防措施（比例为q的用户偷了懒，此处，p+q&#x3D;1），那么，我们发现：只要当p足够大时，仍然能够消灭该恶意代码。</p><p><strong>定理10.5：在10.5节的情况1中，如果在暂未受害的终端中，采取了预防措施终端数的比例p≥1-1&#x2F;P0，这里P0&#x3D;β&#x2F;(γ+μ)，那么，该免疫型恶意代码一定会随着时间的推移，最终自动消灭。</strong><br>此定理告诉我们：对付恶意代码，虽然不能指望全体人员都及时采取预防措施，但是，只要有足够多的人（占总人数比例超过P0&#x3D;β&#x2F;(γ+μ)）重视安全，并及时采取了预防措施，那么，该恶意代码就一定是可控的，甚至会最终被消灭。</p><h1 id="回声状态网络"><a href="#回声状态网络" class="headerlink" title="回声状态网络"></a>回声状态网络</h1><p>人工神经网络（Artificial Neural Network）是由大量处理单元互联组成的非线性、自适应信息处理系统 。</p><p>人工神经网络按照性能分为两类：<br>（1）静态神经网络 Static Neural Network<br>（2）动态神经网络 Recurrent Neural Network<br>其中，动态神经网络又称为递归神经网络</p><p>两种网络对比：</p><p>静态网络数学表达式：</p><p>$$<br>y&#x3D;\sigma(\sum^n_{i&#x3D;1}\omega_1x_1+\sigma_1)<br>$$</p><p>静态网络数学表达式：</p><p>$$<br>y&#x3D;\sigma(\sum^n_{i&#x3D;1}\omega_1x_1(t-\tau_i)+\sigma_1)<br>$$</p><p>对比表达式，我们可以看出：动态网络内部存在带延迟因子的反馈连接，可以更好的反映动态系统的特性和演化行为 。而静态网络没有这种能力。</p><p>回声状态状态网络作为一种新型的递归神经网络，无论是建模还是学习算法，都已经与传统的递归神经网络差别很大。<br>ESN网络特点：<br>（1） 它的核心结构是一个随机生成、且保持不 变的储备池（Reservoir）<br>（2）其输出权值是唯一需要调整的部分<br>（3）简单的线性回归就可完成网络的训练</p><h2 id="ESN的结构和运行机理"><a href="#ESN的结构和运行机理" class="headerlink" title="ESN的结构和运行机理"></a>ESN的结构和运行机理</h2><p>ESN网络的核心结构是一个“储备池”。所谓的储备池就是随机生成的、大规模的、稀疏连接（SD通常保持1%~5%连接 ）的递归结构。<br>注：SD是储备池中相互连接的神经元占总的神经元N的百分比</p><p>从结构上讲，ESN是一种特殊类型的递归神经网络，其基本思想:使用大规模随机连接的递归网络，取代经典神经网络中的中间层，从而简化网络的训练过程。<br>我们假设系统具有M个输入单元，N个内部处理单元（Processing Elements，PE），即N个内部神经元，同时具有L个输出单元。</p><p>那么输入单元u（n）内部状态x（n）以及输出单元y（n）在n时刻值分别为：</p><p>$$<br>u(n)&#x3D;[u_1(n),u_2(n),\dots,u_M(n)]^T\ x(n)&#x3D;[x_1(n),x_2(n),\dots,x_N(n)]^T\ y(n)&#x3D;[y_1(n),y_2(n),\dots,y_L(n)]^T<br>$$</p><p>则回声状态网络状态方程为：</p><p>$$<br>x(n+1)&#x3D;f(Wx(n)+W_{in}u(n)+W_{back})y(n)\ y(n+1)&#x3D;f_{out}(W_{out}[x(n+1),u(n+1),y(n)]+W_{bias}^{out})<br>$$</p><h2 id="ESN的储备池"><a href="#ESN的储备池" class="headerlink" title="ESN的储备池"></a>ESN的储备池</h2><p>虽然有大量的研究是关于如何获得与具体问题相关的“好”的储备池，但是并没有形成一个系统的方法，多数研究是从实验的角度进行的。这也是目前ESN方法遇到的最大的挑战。<br>ESN的最终性能是由储备池的各个参数决定的，下面首先简要介绍储备池的四个关键参数。</p><p><strong>储备池内部连接权谱半径SR</strong></p><p><strong>储备池规模N</strong></p><p><strong>储备池输入单元尺度IS</strong></p><p><strong>储备池稀疏程度SD</strong></p><p>关于IS的规则：<br>如果需要处理的任务的非线性越强，那么输人单元尺度越大。<br>该原则的本质是通过输入单元尺度IS，将输入变换到神经元激活函数funtion相应的范围。<br>注：神经元激活函数的不同输入范围，其非线性程度不同。</p><h1 id="智能优化算法"><a href="#智能优化算法" class="headerlink" title="智能优化算法"></a>智能优化算法</h1><p>牛顿迭代法、共轭梯度法、单纯形法、黄金分割</p><h2 id="课上重点"><a href="#课上重点" class="headerlink" title="课上重点"></a>课上重点</h2><p>求</p><p>$$<br>\min(x_1^2+2x_2^2)&#x3D;E<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复杂网络-彭海朋&quot;&gt;&lt;a href=&quot;#复杂网络-彭海朋&quot; class=&quot;headerlink&quot; title=&quot;复杂网络 彭海朋&quot;&gt;&lt;/a&gt;复杂网络 彭海朋&lt;/h1&gt;&lt;h2 id=&quot;虫口方程&quot;&gt;&lt;a href=&quot;#虫口方程&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>信息系统安全课程笔记</title>
    <link href="https://zhangyuanhe.top/2024/01/10/BUPT_note/Notes%20on%20Information%20System%20Security/"/>
    <id>https://zhangyuanhe.top/2024/01/10/BUPT_note/Notes%20on%20Information%20System%20Security/</id>
    <published>2024-01-10T13:00:00.000Z</published>
    <updated>2024-01-17T12:37:31.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息系统安全"><a href="#信息系统安全" class="headerlink" title="信息系统安全"></a>信息系统安全</h1><h1 id="信息系统发展趋势（自学）"><a href="#信息系统发展趋势（自学）" class="headerlink" title="信息系统发展趋势（自学）"></a>信息系统发展趋势（自学）</h1><h1 id="第一讲-信息系统概述"><a href="#第一讲-信息系统概述" class="headerlink" title="第一讲  信息系统概述"></a>第一讲  信息系统概述</h1><h2 id="信息系统架构"><a href="#信息系统架构" class="headerlink" title="信息系统架构"></a>信息系统架构</h2><h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a><strong><strong>单机架构</strong></strong></h3><p>在网站开设初期，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。</p><h3 id="第一次演进：Tomcat与数据库分开部署"><a href="#第一次演进：Tomcat与数据库分开部署" class="headerlink" title="第一次演进：Tomcat与数据库分开部署"></a><strong><strong>第一次演进：Tomcat与数据库分开部署</strong></strong></h3><p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能</p><h3 id="第二次演进：引入本地缓存和分布式缓存"><a href="#第二次演进：引入本地缓存和分布式缓存" class="headerlink" title="第二次演进：引入本地缓存和分布式缓存"></a><strong><strong>第二次演进：引入本地缓存和分布式缓存</strong></strong></h3><p>在Tomcat服务器增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的HTML页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力</p><h3 id="第三次演进：引入反向代理实现负载均衡"><a href="#第三次演进：引入反向代理实现负载均衡" class="headerlink" title="第三次演进：引入反向代理实现负载均衡"></a><strong><strong>第三次演进：引入反向代理实现负载均衡</strong></strong></h3><p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发</p><h3 id="第四次演进：数据库读、写分离"><a href="#第四次演进：数据库读、写分离" class="headerlink" title="第四次演进：数据库读、写分离"></a><strong><strong>第四次演进：数据库读、写分离</strong></strong></h3><p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据</p><h3 id="第五次演进：数据库按业务分库"><a href="#第五次演进：数据库按业务分库" class="headerlink" title="第五次演进：数据库按业务分库"></a><strong><strong>第五次演进：数据库按业务分库</strong></strong></h3><p>把不同业务的数据保存到不同的数据库中，降低业务之间的资源竞争，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决</p><h3 id="第六次演进：把大表拆分为小表"><a href="#第六次演进：把大表拆分为小表" class="headerlink" title="第六次演进：把大表拆分为小表"></a><strong><strong>第六次演进：把大表拆分为小表</strong></strong></h3><p>这种做法显著增加了数据库运维的难度，对DBA的要求较高!!!</p><p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀地分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能</p><h3 id="第七次演进：使用LVS或F5使多个Nginx负载均衡"><a href="#第七次演进：使用LVS或F5使多个Nginx负载均衡" class="headerlink" title="第七次演进：使用LVS或F5使多个Nginx负载均衡"></a><strong><strong>第七次演进：使用LVS或F5使多个Nginx负载均衡</strong></strong></h3><p>LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。</p><h3 id="第八次演进：通过DNS轮询实现机房间的负载均衡"><a href="#第八次演进：通过DNS轮询实现机房间的负载均衡" class="headerlink" title="第八次演进：通过DNS轮询实现机房间的负载均衡"></a><strong><strong>第八次演进：通过DNS轮询实现机房间的负载均衡</strong></strong></h3><p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href="http://www.taobao.com时,dns服务器会使用轮询策略或其他策略,来选择某个ip供用户访问/">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问</a></p><h3 id="第九次演进：引入NoSQL数据库和搜索引擎等技术"><a href="#第九次演进：引入NoSQL数据库和搜索引擎等技术" class="headerlink" title="第九次演进：引入NoSQL数据库和搜索引擎等技术"></a><strong><strong>第九次演进：引入NoSQL数据库和搜索引擎等技术</strong></strong></h3><p>针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key&#x2F;value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决</p><h3 id="第十次演进：大应用拆分为小应用"><a href="#第十次演进：大应用拆分为小应用" class="headerlink" title="第十次演进：大应用拆分为小应用"></a><strong><strong>第十次演进：大应用拆分为小应用</strong></strong></h3><p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决</p><h3 id="第十一次演进：复用的功能抽离成微服务"><a href="#第十一次演进：复用的功能抽离成微服务" class="headerlink" title="第十一次演进：复用的功能抽离成微服务"></a><strong><strong>第十一次演进：复用的功能抽离成微服务</strong></strong></h3><p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理</p><h3 id="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"><a href="#第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异" class="headerlink" title="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"></a><strong><strong>第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异</strong></strong></h3><p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong><strong>架构</strong></strong></h2><p>架构（architecture）是针对某种特定目标系统的普遍性</p><p>问题而提供的具有体系性质的、通用的解决方案，是对复</p><p>杂系统的一种共性的体系抽象，目的是帮助人们能够正确、</p><p>合理地理解、设计和最终构建复杂的系统。</p><h3 id="信息系统体系架构分析的必要性：系统的复杂度"><a href="#信息系统体系架构分析的必要性：系统的复杂度" class="headerlink" title="信息系统体系架构分析的必要性：系统的复杂度"></a><strong><strong>信息系统体系架构分析的必要性：系统的复杂度</strong></strong></h3><p>从系统分析方法论的角度看，如果一个系统过于复杂，则对其进行分析的最好方法就是按照某种角度对整个系统进行<strong>解构</strong>。</p><h1 id="第二讲-信息系统安全概述"><a href="#第二讲-信息系统安全概述" class="headerlink" title="第二讲 信息系统安全概述"></a>第二讲 信息系统安全概述</h1><p>攻击致命度：攻击所具有的固话危害程度</p><p>描述网络威胁信息的结构化语言：STIX（结构化威胁信息表达式）</p><h2 id="信息系统的脆弱性"><a href="#信息系统的脆弱性" class="headerlink" title="信息系统的脆弱性"></a>信息系统的脆弱性</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>硬件电路也可以设计后门（在电容器累计电荷，触发操作）</p><p><strong>Intel AMT存在高危漏洞</strong></p><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>软件问题漏洞来自于软件的复杂性</p><h3 id="攻防不对称性"><a href="#攻防不对称性" class="headerlink" title="攻防不对称性"></a><strong><strong>攻防不对称性</strong></strong></h3><table><thead><tr><th>攻击可以在任意时刻发起</th><th>防御必须随时警惕</th></tr></thead><tbody><tr><td>攻击可以选择一个薄弱点进行</td><td>防御必须全线设防</td></tr><tr><td>攻击包含了对未知缺陷的探测</td><td>防御只能对已知的攻击防御</td></tr><tr><td>攻击常在暗处，具隐蔽性</td><td>防御常在明处，表面看起来完美，使人容易疏忽，丧失警惕</td></tr><tr><td>攻击可以肆意进行</td><td>防御必须遵循一定的规则</td></tr></tbody></table><ul><li>网络是个整体，攻击可以从任何一个薄弱点发起</li><li>网络攻击已自动化和智能化</li><li>安全响应速度要求越来越快，但面对海量安全事件，人力无法及时有效地分析处理</li></ul><h2 id="网络切片带来的安全挑战"><a href="#网络切片带来的安全挑战" class="headerlink" title="网络切片带来的安全挑战"></a><strong><strong>网络切片带来的安全挑战</strong></strong></h2><p>网络切片对网络构建带来了一定的挑战，需要考虑以下安全需求：</p><ul><li>切片授权与接入控制</li><li>切片间的资源冲突</li><li>切片间的安全隔离</li><li>切片用户的隐私保护</li><li>以切片方式隔离故障网元</li></ul><h2 id="信息系统安全实现"><a href="#信息系统安全实现" class="headerlink" title="信息系统安全实现"></a><strong><strong>信息系统安全实现</strong></strong></h2><p>信息系统安全保障是在信息系统的整个生命周期中，通过对信息系统的风险分析，制定并执行相应的安全保障策略，从技术、管理、工程和人员等方面提出安全保障要求，确保信息系统的保密性、完整性和可用性，降低安全风险到可接受的程度，从而保障系统实现组织机构的使命</p><h2 id="信息系统安全保障模型⎯⎯CMM框架"><a href="#信息系统安全保障模型⎯⎯CMM框架" class="headerlink" title="信息系统安全保障模型⎯⎯CMM框架"></a><strong><strong>信息系统安全保障模型⎯⎯CMM框架</strong></strong></h2><p>第一能力级别0：未实施<br>第二能力级别1：基本执行<br>第三能力级别2：计划跟踪<br>第四能力级别3：充分定义<br>第五能力级别4：量化控制<br>第六能力级别5：持续改进</p><h2 id="信息系统安全的理解"><a href="#信息系统安全的理解" class="headerlink" title="信息系统安全的理解"></a><strong><strong>信息系统安全的理解</strong></strong></h2><p>信息网络的硬件、软件及其系统中的数据受到保护，不受偶然的或者恶意的原因而遭到破坏、更改、泄露，系统连续可靠正常地运行，信息服务不中断。</p><h3 id="信息系统安全的实质"><a href="#信息系统安全的实质" class="headerlink" title="信息系统安全的实质"></a><strong><strong>信息系统安全的实质</strong></strong></h3><p><strong><strong>安全＝及时的检测和处理</strong></strong></p><p>$$<br>P_t&gt;Dt+R_t<br>$$</p><p>防护时间<em>Pt</em>：黑客在到达攻击目标之前需要攻破很多的设备（路由器，交换机）、系统（NT，UNIX）和防火墙等障碍，在黑客达到目标之前的时间</p><p>在黑客攻击过程中，我们检测到他的活动的所用时间称之为<em>Dt</em>，检测到黑客的行为后，我们需要作出响应，这段时间称之为<em>Rt</em>.</p><h2 id="应对威胁的方式——拟态主动防御"><a href="#应对威胁的方式——拟态主动防御" class="headerlink" title="应对威胁的方式——拟态主动防御"></a><strong><strong>应对威胁的方式——拟态主动防御</strong></strong></h2><h3 id="拟态路由器"><a href="#拟态路由器" class="headerlink" title="拟态路由器"></a><strong><strong>拟态路由器</strong></strong></h3><p>拟态路由器在其架构中引入多个异构冗余的路由执行体，通过对各个执行体维护的路由表项进行共识裁决，生成拟态路由器的路由表；通过对执行体的策略调度，可以实现拟态路由器对外呈现特征的不确定变化。在满足一定差异化设计的前提下，不同的执行体存在完全相同漏洞或后门的概率极低，攻击者即使控制了部分执行体，其恶意行为也很容易被拟态裁决机制所阻断，从而极大地提高路由器应对网络攻击的能力。</p><h3 id="拟态域名服务器"><a href="#拟态域名服务器" class="headerlink" title="拟态域名服务器"></a><strong>拟态域名服务器</strong></h3><p>拟态域名服务器以遏制域名解析服务漏洞后门的可利用性、建立内生安全防御机制、大幅提高攻击者的攻击难度和代价为出发点，可以在不改变现有域名协议和地址解析设施的基础上，通过拟态防御设备的增量部署，能够有效防御针对域名系统的域名投毒、域名劫持攻击等各种已知和未知域名攻击，能够提供安全可靠的域名解析服务。</p><h3 id="拟态Web虚拟机"><a href="#拟态Web虚拟机" class="headerlink" title="拟态Web虚拟机"></a><strong>拟态Web虚拟机</strong></h3><p>拟态Web虚拟机利用云平台部署空间上的优势，构建功能等价、多样化、动态化的异构虚拟web服务器池，采用动态执行体调度、数据库指令异构化、多余度（共识）表决等技术，建立多维动态变换的运行空间，阻断攻击链，大幅增加传统web服务和虚拟环境中的漏洞及后门利用难度，在不影响web服务性能的前提下，保证服务功能的安全可信</p><h3 id="拟态云服务器"><a href="#拟态云服务器" class="headerlink" title="拟态云服务器"></a><strong>拟态云服务器</strong></h3><p>拟态化的云服务器通过构建功能等价的异构云服务器池的方法，采用动态执行体调度、多余度（共识）表决、异常发现、线上（下）清洗等技术，及时阻断基于执行体软硬件漏洞后门等的“差模”攻击，使得蓄意攻击难以奏效。</p><h3 id="拟态防火墙"><a href="#拟态防火墙" class="headerlink" title="拟态防火墙"></a><strong>拟态防火墙</strong></h3><p>拟态化的云服务器通过构建功能等价的异构云服务器池的方法，采用动态执行体调度、多余度（共识）表决、异常发现、线上（下）清洗等技术，及时阻断基于执行体软硬件漏洞后门等的“差模”攻击，使得蓄意攻击难以奏效</p><h1 id="第三讲-安全需求及安全策略"><a href="#第三讲-安全需求及安全策略" class="headerlink" title="第三讲 安全需求及安全策略"></a><strong>第三讲 安全需求及安全策略</strong></h1><h2 id="安全需求的定义"><a href="#安全需求的定义" class="headerlink" title="安全需求的定义"></a><strong><strong>安全需求的定义</strong></strong></h2><p><strong>安全需求</strong>就是在设计一个安全系统时<strong>期望得到的安全保障</strong></p><h3 id="一般性的安全需求"><a href="#一般性的安全需求" class="headerlink" title="一般性的安全需求"></a><strong><strong>一般性的安全需求</strong></strong></h3><ul><li><strong>机密性需求</strong>，防止信息被泄漏给未授权的用户</li><li><strong>完整性需求，</strong>防止未授权用户对信息的修改</li><li><strong>可用性需求，</strong>保证授权用户对系统信息的可访问性</li><li><strong>可记账性需求，</strong>防止用户对访问过某信息或执行过某一操作以否认</li></ul><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a><strong><strong>安全策略</strong></strong></h2><p>针对面临的威胁决定采用何种对策的方法</p><ul><li>安全策略为针对威胁而选择和实行对策提供了框架</li></ul><h2 id="最常用的安全策略"><a href="#最常用的安全策略" class="headerlink" title="最常用的安全策略"></a><strong><strong>最常用的安全策略</strong></strong></h2><p><strong><strong>访问控制策略</strong></strong></p><p>系统必须选择下列三类相关属性制定访问控制策略</p><p>➢<strong>主体属性</strong></p><p>主体是系统内行为的发起者，通常是用户发起的进程</p><ul><li>信息的访问者（用户）</li><li>信息的拥有者</li><li>系统管理员</li></ul><p>➢<strong>客体属性</strong></p><p>➢<strong>系统环境（上下文）</strong></p><h2 id="自主访问控制策略"><a href="#自主访问控制策略" class="headerlink" title="自主访问控制策略"></a><strong><strong>自主访问控制策略</strong></strong></h2><p>❖ 自主访问控制的优点</p><p>➢ 访问模式设定灵活。</p><ul><li>读；写；执行；“每隔一周的周五可以读”；“读完文件x后才能</li></ul><p>读此文件”等等</p><p>➢ 具有较好的适应性，常用与商用OS和应用中</p><p>❖ 自主访问控制的缺点</p><p>➢ 不能防范木马和某些形式的恶意代码。</p><h2 id="强制访问控制策略"><a href="#强制访问控制策略" class="headerlink" title="强制访问控制策略"></a><strong><strong>强制访问控制策略</strong></strong></h2><h3 id="Bell-LaPadula模型"><a href="#Bell-LaPadula模型" class="headerlink" title="Bell-LaPadula模型"></a><strong><strong>Bell-LaPadula模型</strong></strong></h3><p><strong>公开 受限 秘密 机密 高密</strong></p><p>BLP 保密模型基于两种规则来保障数据的机密度与敏感度：</p><p>➢ 不上读（NRU）⎯⎯主体不可读安全级别高于它的数据</p><p>➢ 不下写（NWD）⎯⎯主体不可写安全级别低于它的数据</p><p><strong>BLP</strong>模型允许用户读取安全级别比他低的资源；相反地，写入对象的安全级别只能高于用户级别。</p><h3 id="防火墙所实现的单向访问机制"><a href="#防火墙所实现的单向访问机制" class="headerlink" title="防火墙所实现的单向访问机制"></a><strong>防火墙所实现的单向访问机制</strong></h3><p>防火墙所实现的单向访问机制不允许敏感数据从内部网络（例：其安全级别为“机密”）流向Internet（安全级别为“公开”）。</p><p>➢ 防火墙提供“不上读”功能来阻止Internet对内部网络的访问；</p><p>➢ 提供“不下写”功能来限制进入内部的数据流只能经由由内向外发起的连接流入（例如，允许HTTP的“GET”操作而拒绝“POST”操作，或阻止任何外发的邮件）。</p><h3 id="BIBA完整性模型"><a href="#BIBA完整性模型" class="headerlink" title="BIBA完整性模型"></a><strong>BIBA完整性模型</strong></h3><p>BIBA模型基于两种规则来保障数据的完整性的保密性：</p><p>➢ <strong>不下读（NRU）属性主体不能读取安全级别低于它的数据</strong></p><p>➢ <strong>不上写（NWD）属性主体不能写入安全级别高于它的数据</strong></p><h2 id="强制访问控制策略-1"><a href="#强制访问控制策略-1" class="headerlink" title="强制访问控制策略"></a><strong>强制访问控制策略</strong></h2><p>❖ <strong>最显著的特征</strong>：全局性和永久性</p><p>➢ 无论何时何地，主体和客体的标签是不会改变的。</p><p>➢ <strong>全局性</strong>：对特定的信息，从任何地方访问，它的敏感级别相同</p><p>➢ <strong>永久性</strong>：对特定的信息，在任何时间访问，它的敏感级别相同</p><p>➢ 上述特征在多级安全体系中称为“<strong>宁静性原则</strong>”（tranquility）</p><p>❖ 一旦不满足该原则，无法从根本上防备木马和恶意代码</p><h2 id="SSR安全模型"><a href="#SSR安全模型" class="headerlink" title="SSR安全模型"></a><strong><strong>SSR安全模型</strong></strong></h2><ol><li>当标签级别为“中级别”的主体访问标签级别为“高级别”的客体时，主体对客体无任何访问权限(no read up, no write up）。</li><li>当标签级别为“中级别”的主体访问标签级别为“中级别”的客体时，主体对客体持所有权限。</li><li>当标签级别为“中级别”的主体访问标签级别为“低级别”的客体时，主体对客体拥有只读权限（nowrite down）。</li></ol><p><strong>SSR安全模型的主要特点</strong></p><ol><li><p>信息流只能从低级别流向高级，确保的信息的保密性。</p></li><li><p>高级别主体对低级别客体的访问只能进行读取，确保了低级别资源的完整性</p></li></ol><h3 id="主体颗粒度扩充"><a href="#主体颗粒度扩充" class="headerlink" title="主体颗粒度扩充"></a><strong>主体颗粒度扩充</strong></h3><p>主体颗粒度扩充主要是把主体的颗粒度从用户级别扩充到进程级别，扩充的目的是为了实现更加细化的安全策略以保证信息系统的安全。</p><h3 id="SSR安全模型的应用"><a href="#SSR安全模型的应用" class="headerlink" title="SSR安全模型的应用"></a><strong><strong>SSR安全模型的应用</strong></strong></h3><p><strong>涉密系统方案</strong></p><p>通过应用SSR安全模型，信息流只能从低级别流向高级别，而不能往下，即使某一级别的用户受到病毒感染或者黑客渗透，其也只能感染和阅读自己的信息与读取下级的信息，确保了保密性。高权限用户无法篡改低权限用户的文件，保证了文件的完整性，避免了官大压人的现象，可以保证递交文件的真实可靠。</p><p><strong>病毒防治方案</strong></p><p>信息的访问需要程序，因此程序往往是被攻击对象，攻击了程序就可以访问其对应的文件甚至其他程序的文件。应用SSR安全模型以后，把主体颗粒度扩充到进程，让程序与程序需要文件进行绑定，然后再将程序本身进行只读保护，既能保证程序不被感染，又能防止对象被非法程序访问，从而保证了应用系统的安全性</p><h2 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a><strong><strong>访问控制列表</strong></strong></h2><p><strong>访问控制列表（ACL）</strong></p><p>访问控制列表是一系列允许或拒绝数据的指令的集合。</p><p><strong>读取第三层、第四层包头信息</strong></p><p><strong>根据预先定义好的规则对包进行过滤</strong></p><ul><li><p>**标准ACL:**只使用数据包的源地址作为测试条件。所有决定是基于源IP地址的。</p><p>  标准访问列表的创建根据 “动作”＋“源地址”，即允许谁、拒绝谁的方法来创建</p></li><li><p>**扩展ACL:**可以测试IP包的第3层和第4层报头中的字段。包括源IP地址、目的IP地址、网络层报头中的协议字段（如，TCP、UDP、ICMP等）以及位于传输层报头中的端口号。<br>扩展列表的放置——靠近源地址</p></li><li><p>**命名ACL:**命名ACL以列表名代替列表编号来定义IP访问控制列表，同样包括标准和扩展两种列表，定义过滤的语句与编号方式中相似。</p></li></ul><h3 id="通配掩码"><a href="#通配掩码" class="headerlink" title="通配掩码"></a><strong>通配掩码</strong></h3><p>路由器使用<strong>IP地址和通配掩码</strong>（wildcard-mask）一起来分辨匹配的地址范围，它跟子网掩码刚好相反。</p><p>它不像子网掩码告诉路由器IP地址的哪一位属于网络号一样，通配符掩码告诉路由器为了判断出匹配，它需要检查IP地址中的多少位。</p><p>有了通配掩码，可以只使用两个32位的号码来确定IP地址的范围，<strong>这是十分方便的</strong></p><ul><li>通配掩码（wildcard mask）是分成4字节的32bit数</li><li>通配掩码与IP地址位位配对，相应位为0&#x2F;1，用于表示如何对待IP地址中的相应位</li></ul><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled.png" alt="Untitled"></p><p>IP地址的第三个字节为16（00010000）。通配掩码中的前四位为0，告诉路由器要匹配IP地址的前四位（0000）。由于最后的四位被忽略，则所有的在范围16（00010000）到31（00011111）的都将被允许，相应的通配掩码位是1。</p><h1 id="第四讲安全风险评估"><a href="#第四讲安全风险评估" class="headerlink" title="第四讲安全风险评估"></a><strong>第四讲安全风险评估</strong></h1><h2 id="风险评估涉及标准"><a href="#风险评估涉及标准" class="headerlink" title="风险评估涉及标准"></a><strong><strong>风险评估涉及标准</strong></strong></h2><p>ISO&#x2F;IEA</p><h2 id="风险（Risk）的概念"><a href="#风险（Risk）的概念" class="headerlink" title="风险（Risk）的概念"></a><strong><strong>风险（Risk）的概念</strong></strong></h2><p>风险指在某一特定环境下，在某一特定时间段内，特定的威胁利用资产的一种或一组薄弱点，导致资产的丢失或损害的潜在可能性，即特定威胁事件发生的可能性与后果的结合</p><p><strong>安全风险组成的四要素：</strong>信息系统资产（Asset）、信息系统脆弱性（Vulnerability）、信息安全威胁（Threat）、信息系统安全保护措施（Safeguard）。</p><h2 id="风险处置策略"><a href="#风险处置策略" class="headerlink" title="风险处置策略"></a><strong><strong>风险处置策略</strong></strong></h2><p><strong>降低风险（Reduce Risk）</strong>采取适当的控制措施来降低风险，包括技术手段和管理手段，如安装防火墙，</p><p>杀毒软件，或是改善不规范的工作流程、制定业务连续性计划，等等。</p><p><strong>避免风险（Avoid Risk）</strong>通过消除可能导致风险发生的条件来避免风险的发生，如将公司内外网隔离</p><p>以避免来自互联网的攻击，或是将机房安置在不可能造成水患的位置，等等。</p><p>**转移风险（Transfer Risk)**将风险全部或者部分地转移到其他责任方，例如购买商业保险。</p><p><strong>接受风险（Accept Risk）</strong>在实施了其他风险应对措施之后，对于残留的风险，可以有意识地选择接受。</p><h2 id="风险评估的要素"><a href="#风险评估的要素" class="headerlink" title="风险评估的要素"></a><strong><strong>风险评估的要素</strong></strong></h2><p><strong>风险评估围绕着资产、威胁、脆弱性和安全措施这些基本要素展开。</strong></p><p>需要充分考虑业务战略、资产价值、安全需求、安全事件、残余风险等与这些基本要素相关的各类属性。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%201.png" alt="Untitled"></p><h3 id="信息系统安全风险计算模型（GB-T20984-2007）"><a href="#信息系统安全风险计算模型（GB-T20984-2007）" class="headerlink" title="信息系统安全风险计算模型（GB&#x2F;T20984-2007）"></a><strong><strong>信息系统安全风险计算模型（GB&#x2F;T20984-2007）</strong></strong></h3><p>风险计算模型是对通过风险分析计算风险值过程的抽象，它主要包括资产评估、威胁评估、脆弱性评估。</p><h3 id="安全风险评估的框架及流程（GB-T20984-2007）"><a href="#安全风险评估的框架及流程（GB-T20984-2007）" class="headerlink" title="安全风险评估的框架及流程（GB&#x2F;T20984-2007）"></a><strong><strong>安全风险评估的框架及流程（GB&#x2F;T20984-2007）</strong></strong></h3><p>① 对资产进行识别，并对资产的重要性进行赋值；<br>② 对威胁进行识别，描述威胁的属性，并对威胁出现的频率赋值；<br>③ 对资产的脆弱性进行识别，并对具体资产的脆弱性的严重程度赋值；<br>④ 根据威胁和脆弱性的识别结果判断安全事件发生的可能性；<br>⑤ 根据脆弱性的严重程度及安全事件所作用资产的重要性计算安全事件的损失；<br>⑥ 根据安全事件发生的可能性以及安全事件的损失，计算安全事件一旦发生对组织的影响，即风险值。</p><h2 id="资产分类方法"><a href="#资产分类方法" class="headerlink" title="资产分类方法"></a><strong><strong>资产分类方法</strong></strong></h2><table><thead><tr><th>分类</th><th>示例</th></tr></thead><tbody><tr><td>数据</td><td>保存在信息媒介上的各种数据资料，包括源代码、数据库数据、系统文档、运行管理规程、计划、报告、用户手册、各类纸质的文档等</td></tr><tr><td>软件</td><td>系统软件：操作系统、数据库管理系统、语句包、开发系统等</td></tr><tr><td>应用软件：办公软件、数据库软件、各类工具软件等</td><td></td></tr><tr><td>源程序：各种共享源代码、自行或合作开发的各种代码等</td><td></td></tr><tr><td>硬件</td><td>网络设备：路由器、网关、交换机等</td></tr><tr><td>计算机设备：大型机、小型机、服务器、工作站、台式计算机、便携计算机等</td><td></td></tr><tr><td>存储设备：磁带机、磁盘阵列、磁带、光盘、软盘、移动硬盘等</td><td></td></tr><tr><td>传输线路：光纤、双绞线等</td><td></td></tr><tr><td>保障设备：UPS、变电设备等、空调、保险柜、文件柜、门禁、消防设施等</td><td></td></tr><tr><td>安全保障：防火墙、入侵检测系统、身份鉴别等</td><td></td></tr><tr><td>其他：打印机、复印机、扫描仪、传真机等</td><td></td></tr><tr><td>服务</td><td>信息服务：对外依赖该系统开展的各类服务</td></tr><tr><td>网络服务：各种网络设备、设施提供的网络连接服务</td><td></td></tr><tr><td>办公服务：为提高效率而开发的管理信息系统，包括各种内部配置管理、文件流转管理等服务</td><td></td></tr><tr><td>人员</td><td>掌握重要信息和核心业务的人员，如主机维护主管、网络维护主管及应用项目经理等</td></tr><tr><td>其他</td><td>企业形象、客户关系等</td></tr></tbody></table><h3 id="资产等级计算公式"><a href="#资产等级计算公式" class="headerlink" title="资产等级计算公式"></a><strong><strong>资产等级计算公式</strong></strong></h3><p>AV&#x3D;F(AC, AI, AA)</p><p>Asset Value 资产价值</p><p>Asset Confidentiality 资产保密性赋值</p><p>Asset Integrity 资产完整性赋值</p><p>Asset Availability 资产可用性赋值</p><p>例1：AV&#x3D;MAX(AC, AI, AA)</p><p>例2：AV&#x3D;AC+AI+AA</p><p>例3：AV&#x3D;AC×AI×AA</p><h2 id="威胁来源列表"><a href="#威胁来源列表" class="headerlink" title="威胁来源列表"></a><strong><strong>威胁来源列表</strong></strong></h2><table><thead><tr><th>来源</th><th></th><th>描述</th></tr></thead><tbody><tr><td>环境因素</td><td></td><td>断电、静电、灰尘、潮湿、温度、鼠蚁虫害、电磁干扰、洪灾、火灾、地震、意外 事故等环境危害或自然灾害，以及软件、硬件、数据、通信线路等方面的故障</td></tr><tr><td>人为因素</td><td>恶意人员</td><td>不满的或有预谋的内部人员对信息系统进行恶意破坏；</td></tr><tr><td>采用自主或内外勾结的方式盗窃机密信息或进行篡改，获取利益外部人员利用信息系统的脆弱性,对网络或系统的机密性、完整性和可用性进行破坏，以获取利益或炫耀能力</td><td></td><td></td></tr><tr><td>人为因素</td><td>非恶意人员</td><td>内部人员由于缺乏责任心，或者由于不关心和不专注，或者没有遵循规章制度和操作流程而导致故障或信息损坏；</td></tr><tr><td>内部人员由于缺乏培训、专业技能不足、不具备岗 位技能要求而导致信息系统故障或被攻击</td><td></td><td></td></tr></tbody></table><h2 id="风险计算方法"><a href="#风险计算方法" class="headerlink" title="风险计算方法"></a><strong>风险计算方法</strong></h2><p><strong>风险值&#x3D;<em>R</em>(A, T, V) &#x3D; <em>R</em>(<em>L</em>(T, V), <em>F</em>(Ia,Va))</strong></p><p><strong>R</strong>安全风险计算函数</p><p><strong>A</strong>资产</p><p><strong>T</strong>威胁</p><p><strong>V</strong>脆弱性</p><p><strong>Ia</strong>安全事件所作用的资产价值</p><p><strong>Va</strong> 脆弱性严重程度</p><p><strong>L</strong>威胁利用资产的脆弱性导致安全事件发生的可能性</p><p><strong>F</strong>安全事件发生后产生的损失</p><h2 id="残留风险评价"><a href="#残留风险评价" class="headerlink" title="残留风险评价"></a><strong>残留风险评价</strong></h2><ul><li>绝对安全（即零风险）是不可能的</li><li>实施安全控制后会有残留风险或残存风险（Residual Risk）</li><li>为了确保信息安全，应该确保残留风险在可接受的范围内：</li></ul><p>➢ 残留风险Rr ＝ 原有的风险R0 － 控制ΔR</p><p>➢ 残留风险Rr ≤ 可接受的风险Rt</p><p><strong><strong>风险评估应贯穿于信息系统生命周期的各阶段</strong></strong></p><p><strong><strong>规划阶段的风险评估</strong></strong></p><p>规划阶段的评估结果应体现在信息系统整体规划或项目建议书中。</p><p><strong><strong>设计阶段的风险评估</strong></strong></p><p>设计阶段的评估可以以安全建设方案评审的方式进行，判定方案所提供的安全功能与信息技术安全技术标准的符合性。评估结果应体现在信息系统需求分析报告或建设实施方案中。</p><p><strong><strong>实施阶段的风险评估</strong></strong></p><p>本阶段风险评估可以采取对照实施方案和标准要求的方式，对实际建设结果进行测试、分析。</p><p><strong><strong>运行维护阶段的风险评估</strong></strong></p><p>运行维护阶段的风险评估应定期执行；当组织的业务流程、系统状况发生重大变更时，也应进行风险评估。</p><p><strong><strong>废弃阶段的风险评估</strong></strong></p><p>信息系统的维护技术人员和管理人员均应该参与此阶段的评估</p><p><strong><strong>一种新的风险评估⎯⎯数据风险评估</strong></strong></p><h2 id="风险评估项目实施过程"><a href="#风险评估项目实施过程" class="headerlink" title="风险评估项目实施过程"></a><strong><strong>风险评估项目实施过程</strong></strong></h2><p><strong>策划 准备 实施 报告 跟踪</strong></p><h1 id="第五讲-信息系统等级保护"><a href="#第五讲-信息系统等级保护" class="headerlink" title="第五讲  信息系统等级保护"></a><strong>第五讲  信息系统等级保护</strong></h1><h3 id="什么是等级保护"><a href="#什么是等级保护" class="headerlink" title="什么是等级保护"></a><strong>什么是等级保护</strong></h3><p>网络安全等级保护是指对国家重要信息、法人和其他组织及公民的专有信息以及公开信息和存储、传输、处理这些信息的信息系统分等级实行安全保护，对信息系统中使用的信息安全产品实行按等级管理，对信息系统中发生的信息安全事件分等级响应、处置</p><p><strong><strong>定级对象</strong></strong></p><p>也称等级保护对象、网络安全等级保护工作的作用对象</p><p>包括网络基础设施（广电网、电信网、专用通信网络等）、云计算平台系统、大数据平台系统、物联网、工业控制系统、采用移动互联技术的系统等</p><h2 id="等级保护有“五个规定动作”"><a href="#等级保护有“五个规定动作”" class="headerlink" title="等级保护有“五个规定动作”"></a><strong><strong>等级保护有“五个规定动作”</strong></strong></h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%202.png" alt="Untitled"></p><h2 id="等级保护主要工作流程"><a href="#等级保护主要工作流程" class="headerlink" title="等级保护主要工作流程"></a><strong><strong>等级保护主要工作流程</strong></strong></h2><p>1 <strong>定级  定级是等级保护的首要环节</strong></p><p>2 <strong>备案 备案是等级保护的核心</strong></p><p>3 <strong>建设整改 建设整改是等级保护工作落实的关键</strong></p><p>4 <strong>等级测评 等级测评是评价安全保护状况的方法</strong></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%203.png" alt="Untitled"></p><h1 id="第六讲-物理安全"><a href="#第六讲-物理安全" class="headerlink" title="第六讲 物理安全"></a><strong>第六讲 物理安全</strong></h1><h2 id="环境安全"><a href="#环境安全" class="headerlink" title="环境安全"></a><strong><strong>环境安全</strong></strong></h2><ul><li>安防技术</li><li>计算机机房的温度、湿度、洁净度</li><li>计算机机房的用电安全技术</li><li>计算机机房安全管理制度</li></ul><h3 id="机房三度要求"><a href="#机房三度要求" class="headerlink" title="机房三度要求"></a><strong><strong>机房三度要求</strong></strong></h3><blockquote><p>温度：机房温度一般应控制在18～22℃</p><p>湿度：相对湿度一般控制在40％～60％为宜</p><p>洁净度：尘埃颗粒直径&lt;0.5<em>m</em>，含尘量&lt;1万颗&#x2F;升</p></blockquote><p>GB50174-2008 电子信息系统机房设计规范</p><h3 id="防火与防水要求"><a href="#防火与防水要求" class="headerlink" title="防火与防水要求"></a><strong><strong>防火与防水要求</strong></strong></h3><p>为避免火灾、水灾，应采取如下具体措施:<br>（1）隔离<br>（2）火灾报警系统<br>（3）灭火设施<br>（4）管理措施</p><h3 id="机房防盗要求"><a href="#机房防盗要求" class="headerlink" title="机房防盗要求"></a><strong><strong>机房防盗要求</strong></strong></h3><h3 id="机房防鼠"><a href="#机房防鼠" class="headerlink" title="机房防鼠"></a><strong><strong>机房防鼠</strong></strong></h3><h3 id="防静电措施"><a href="#防静电措施" class="headerlink" title="防静电措施"></a><strong>防静电措施</strong></h3><blockquote><p> 机房的内装修材料一般应避免使用挂毯、地毯等吸尘、容易产生静电的材料，而应采用乙烯材料。</p><p>为了防静电，机房一般要安装防静电地板。</p><p> 机房内应保持一定湿度，特别是在干燥季节应适当增加空气湿度，以免因干燥而产生静电。</p></blockquote><h3 id="接地要求"><a href="#接地要求" class="headerlink" title="接地要求"></a><strong>接地要求</strong></h3><p>接地可以为计算机系统的数字电路提供一个稳定的0V参考电位</p><h1 id="第七讲-可靠性的基本概念"><a href="#第七讲-可靠性的基本概念" class="headerlink" title="第七讲 可靠性的基本概念"></a><strong>第七讲 可靠性的基本概念</strong></h1><h3 id="可靠性的定义"><a href="#可靠性的定义" class="headerlink" title="可靠性的定义"></a><strong><strong>可靠性的定义</strong></strong></h3><p>在规定的条件下、在给定的时间内，系统能实施应有功能的能力。</p><h3 id="可靠性参数"><a href="#可靠性参数" class="headerlink" title="可靠性参数"></a><strong><strong>可靠性参数</strong></strong></h3><p>$T_{MTTF}：$平均失效前时间</p><p>$T_{MTBF}：$平均故障间隔时间</p><p>$R：$<strong><strong>可靠度</strong></strong></p><p>$λ：$<strong><strong>失效率</strong></strong></p><h3 id="寿命"><a href="#寿命" class="headerlink" title="寿命"></a><strong><strong>寿命</strong></strong></h3><p>通常用一个非负随机变量$<em><strong>X</strong></em>$来描述产品的寿命。</p><p>$<em><strong>X</strong></em>$的分布函数为</p><p>$<em>F(t) &#x3D; P{X \le t}，t\ge0</em>$</p><p>有了寿命分布<em>F</em>(<em>t</em>) ，就知道产品的平均寿命</p><p>$EX&#x3D;\int_0^\infty tdF(t)$</p><h3 id="可靠度R"><a href="#可靠度R" class="headerlink" title="可靠度R"></a><em><strong><em>可靠度</em>R</strong></em></h3><p>产品在时刻 <em>t</em> 之前都正常工作（不失效）的概率，即产品在时刻 <em>t</em>的生存概率，称为无故障工作概率（可靠度函数）</p><p>$$<br>R(t)&#x3D;P{X&gt;t}&#x3D;\int_0^\infty dF(t)&#x3D;\int_0^\infty f(t)dt \<br>𝑹(t) +F(t)&#x3D;1<br>$$</p><blockquote><p>假设 C 是一个具有 <em>N</em> 个元器件的数字系统，在一定的条件和环境（如温度、湿度、电压等）下运行，并且随着时间 <em>t</em> 的推移质量逐步下降</p></blockquote><p>系统<strong>C</strong>在时刻 <em>t</em> 能正常工作的概率 $<em><strong>R(t)&#x3D;S(t)&#x2F;N</strong></em>$</p><p>**<em>R</em>(<em>t</em>)**称为系统 <strong>C</strong> 在时刻 <em>t</em> 的可靠度。</p><h3 id="失效率λ"><a href="#失效率λ" class="headerlink" title="失效率λ"></a><strong><strong>失效率λ</strong></strong></h3><p>假设<em>F</em>(<em>t</em>)是绝对连续的，即存在分布密度函数$<em>f(t)&#x3D;F’(t)</em>$且$F(t)&#x3D;\int_0^tf(x)dx$</p><blockquote><p>将发生故障的条件概率密度叫做失效率。<br>$λ(t)&#x3D;f(t)&#x2F;R(t)&#x3D;-R’(t)&#x2F;R(t)$<br>失效率**λ(<em>t</em>)**表示系统中元器件失效的速率。</p></blockquote><h3 id="λ-t-的浴缸形曲线（Bathtub-curve）"><a href="#λ-t-的浴缸形曲线（Bathtub-curve）" class="headerlink" title="**λ(t)的浴缸形曲线（Bathtub-curve）"></a>**<strong>λ(<em>t</em>)的浴缸形曲线（Bathtub-curve）</strong></h3><p><strong>第一阶段 早期失效期（Infant Mortality）</strong></p><p>器件在开始使用时失效率很高，但随着产品工作时间的增加，失效率迅速降低。这一阶段失效的原因大多是由于设计、原材料和制造过程中的缺陷造成的。为了缩短这一阶段的时间，产品应在投入运行前进行试运转，以便及早发现、修正和排除故障；或通过试验进行筛选，剔除不合格品。</p><p><strong>第二阶段 偶然失效期，也称随机失效期（Random Failures）</strong></p><p>这一阶段的特点是失效率较低，且较稳定，往往可近似看作常数。这一时期是产品的良好使用阶段。由于在这一阶段中，产品失效率近似为一常数，故设<em></em>(<em>t</em>)&#x3D;<em>λ</em>（常数）由可靠度计算公式得$R(t)&#x3D;e^{-λt}$ 这一式表明<strong>设备的可靠性与失效率成指数关系</strong>。</p><p><strong>第三阶段 耗损失效期（Wearout）</strong></p><p>该阶段的失效率随时间的延长而急速增加，主要原因是器件的损失己非常的严重，寿命快到尽头了，可适当的维修或直接更换。</p><p>**<strong><em>R</em>(<em>t</em>)和λ的关系</strong></p><p>可靠性不仅是时间<em>t</em>的函数，而且与失效率<strong><strong>λ</strong></strong>有着密切的关联。</p><p>$$<br>R(t)&#x3D;e^{\int^t_0\lambda(t)dt }<br>$$</p><h3 id="可维修产品的平均维修时间"><a href="#可维修产品的平均维修时间" class="headerlink" title="可维修产品的平均维修时间"></a><strong><strong>可维修产品的平均维修时间</strong></strong></h3><p>可维修产品的可维护性平均维修时间（MTTR，Mean Time To Repair）来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间（即设备处于故障状态时间的平均值，或设备修复时间的平均值）。系统的可维护性越好，平均维修时间越短</p><p>$$<br>MTTR&#x3D;\int^\infty _0t\mu(t)dt<br>$$</p><blockquote><p>$<em>\mu(t)</em>$是维修时间的概率密度函数</p></blockquote><h3 id="可维修产品的维修性指标：可用性"><a href="#可维修产品的维修性指标：可用性" class="headerlink" title="可维修产品的维修性指标：可用性"></a><strong><strong>可维修产品的维修性指标：可用性</strong></strong></h3><p>可维修产品的可用性定义为：</p><p>$$<br>\frac{MTBF}{MTBF+MTTR}*100%<br>$$</p><p><strong>计算机系统可靠性举例</strong></p><p>已知世界上第一代电子管计算机ENIAC有20000个电子管，假<br>设每个电子管的失效率为&#x3D;0.5%&#x2F;kh（千小时），试求：<br>（1）该计算机的MTTF；<br>（2）若要求计算机的可靠性在95%以上，则至多可以工作多久？</p><p>$$<br>MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i}&#x3D;\frac{1}{\frac{0.05}{100}*\frac{1}{1000}*20000}&#x3D;\frac{1}{0.01}&#x3D;100H\ R(t)&#x3D;e^{-\frac{t}{MTTF}}\ t&#x3D;5H<br>$$</p><h2 id="系统可靠性模型"><a href="#系统可靠性模型" class="headerlink" title="系统可靠性模型"></a><strong><strong>系统可靠性模型</strong></strong></h2><p><strong>可靠性模型：描述了系统及其组成单元之间的故障逻辑关系</strong></p><h3 id="串联系统"><a href="#串联系统" class="headerlink" title="串联系统"></a><strong><strong>串联系统</strong></strong></h3><p>假设第<em>i</em>个部件的寿命为$<em><strong>X_i</strong></em>$，可靠度为$<em>R_i(t)&#x3D;P{X_i &gt;t}，i&#x3D;1, 2, …,n,</em>$第$<em>i</em>$个部件的失效率为$<em>\lambda_i(t)</em>$$，X_1，X_2 ，…，X_n$相互独立。若</p><p>初始时刻$<em>t&#x3D;0</em>$，所有部件都是新的，且同时开始工作。</p><p>(1) 系统的寿命是： $X&#x3D;min{X_1 ，X_2，…，X_n}$</p><p>(2) 系统的可靠度是：</p><p>$$<br>R(t)&#x3D;P{min(X_1 ，X_2，…，X_n)&gt;t}&#x3D;\Pi^n_{i&#x3D;1}R_i(t)\ &#x3D;\Pi^n_{i&#x3D;1}exp{-\int^t_0\lambda_i(u)du}<br>$$</p><p>(3) 系统的失效率为：</p><p>$$<br>\lambda(t)&#x3D;-\frac{R’(t)}{R(t)}&#x3D;\sum^n_{i&#x3D;1}\lambda_i(t)<br>$$</p><p>(4) 系统的平均寿命为:</p><p>$$<br>MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\int^\infty_0exp{-\int^t_0\lambda(u)du}dt<br>$$</p><p>当$R_i(t)&#x3D;exp{-\lambda_t}，i&#x3D;1, 2, …, n$时（及当第<em>i</em>个部件的命遵从参数为$<em>\lambda_i</em>$的</p><p>指数分布时），系统的可靠度和平均寿命为</p><p>$$<br>R(t)&#x3D;exp{-\sum^n_{i&#x3D;1}\lambda_it}\ MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i}<br>$$</p><h3 id="并联系统"><a href="#并联系统" class="headerlink" title="并联系统"></a><strong><strong>并联系统</strong></strong></h3><p>(1) 系统的寿命是： $X&#x3D;max{X_1，X_2，…，X_n<br>}$</p><p>(2) 系统的可靠度是：</p><p>$$<br>R(t)&#x3D;P{max(X_1 ，X_2，…，X_n)&gt;t}\ &#x3D;1-P{max(X_1 ，X_2，…，X_n)\le t } \ &#x3D;1-\Pi^n_{i&#x3D;1}[1-R_i(t)]<br>$$</p><p>(3) 系统的平均寿命为：</p><p>$$<br>MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\sum^n_{i&#x3D;1}\frac{1}{\lambda_i}\ &#x3D;sum_{1\le&lt;i&lt;j\le n}\frac{1}{\lambda_1+\lambda_j}+…+(-1)^{n-1}\frac{1}{\lambda_1+…+\lambda_n}<br>$$</p><h1 id="第八讲-信息系统的可靠性"><a href="#第八讲-信息系统的可靠性" class="headerlink" title="第八讲 信息系统的可靠性"></a><strong>第八讲 信息系统的可靠性</strong></h1><h3 id="计算机系统可靠性"><a href="#计算机系统可靠性" class="headerlink" title="计算机系统可靠性"></a><strong>计算机系统可靠性</strong></h3><p><strong>硬件可靠性</strong></p><p>硬件在使用过程中有磨损、材料的老化、变质和使用环境等多种因素</p><p><strong>软件可靠性</strong></p><p>软件使用期间无磨损;存在物质老化和变质</p><h2 id="提高信息系统可靠性的途径"><a href="#提高信息系统可靠性的途径" class="headerlink" title="提高信息系统可靠性的途径"></a><strong><strong>提高信息系统可靠性的途径</strong></strong></h2><p><strong>提高可靠性有两个方面：一是尽量使系统在规定时间内少发生故障和错误；二是发生了故障能迅速排除。</strong></p><h3 id="提高硬件可靠性"><a href="#提高硬件可靠性" class="headerlink" title="提高硬件可靠性"></a><strong><strong>提高硬件可靠性</strong></strong></h3><p><strong>设计</strong></p><p>结构优化<br>功能合理</p><p><strong>环境</strong></p><p>符合相关的标准和要求</p><p><strong>使用</strong></p><p>符合操作规程<br>减少人为失误</p><blockquote><p><strong>冗余设计</strong></p><p>故障容错是利用冗余的元部件来屏蔽已发生的故障对系统的影响。</p><p>三模冗余（TMR，Triple Modular Redundancy）的基本原理是：系统输入通过3个功能相同的模块，产生的3个结果送到多数表决器进行表决，即三中取二的原则，如果模块中有一个出错，而另外两个模块正常，则表决器的输出正确，从而可以屏蔽一个故障。</p><p><strong>TMR的缺点是：如果3个模块的输出各不相同，则无法进行多数表决；若有两个模块出现一致的故障，则表决的结果会出现错误。</strong></p></blockquote><h2 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h2><p><strong><strong>程序运行监视系统</strong></strong></p><p>程序运行监视系统WTD（“看门狗”），是一种软硬件结合的抗程序“跑飞”的措施。其硬件是一个用于产生定时 <em>T</em> 的计数器或单稳触发器。其定时输出端接至CPU 的复位线，而其定时清零则由CPU 控制。</p><p>在正常情况下，程序启动WTD 后，即以小于<em>T</em> 的间隔 <em>t</em> 将其清零一次，这样WTD 的定时溢出就不会发生。在受到干扰的异常情况下，程序的正常执行顺序被破坏，不可能周期性地将WTD清零，导致WTD定时溢出，使系统复位，CPU 摆脱因程序“跑飞”造成的瘫痪状态</p><h3 id="软件可靠性模型"><a href="#软件可靠性模型" class="headerlink" title="软件可靠性模型"></a><strong><strong>软件可靠性模型</strong></strong></h3><p><strong><strong>失效时间间隔模型</strong></strong></p><p>这类模型最常用的方法是假定第<em>i</em>个失效到第<em>i</em>+1个失效间隔时间服从某一分布，而分布的参数依赖于各间隔时间内程序中的残留错误数。通过测试所得到的失效间隔时间数据来估计模型的参数，由获得的模型可以估算软件的可靠度以及各失效间的平均工作时间等</p><p><strong><strong>Jelinski-Moranda模型</strong></strong></p><p>系统基本假设如下：<br>（1）软件中的固有错误数<em>N</em>是一个未知的常数；<br>（2）软件中的各个错误是相互独立的，每个错误导致系统发生失效的可能性大致相同,各次失效间隔时间也相互独立；<br>（3）软件错误被发现后立即排除，每次排除一个错误且不引入新的错误，排除错误的时间忽略不计；<br>（4）软件的失效率在每个失效间隔时间内是常数，其数值正比于程序中残留的错误数，在第$<em>i</em>$个测试区间$<em>t_i</em>$，其失效率函数为:$\lambda(t_i)&#x3D;\phi(N-i+1)$,$\phi$为比例常数 。</p><p><strong><strong>缺陷计数模型</strong></strong></p><p>这类模型关心的是在<strong>特定的时间间隔内软件的错误数或失效数</strong>，并假定故障累计数服从某个己知的随机过程，过程强度是时间的离散或连续函数，根据在给定的测试时间间隔发现的错误数或失效数来估计故障强度、均值等参数。</p><p><strong><strong>错误植入模型</strong></strong></p><p>这类模型的基本思路是通过将一组已知的错误人为地植入到一个固有错误总数尚不清楚的程序中，然后在程序的测试中观察并统计发现的植入错误数和程序总的错误数，通过计数的比值估计程序的固有错误总数，从而得到软件可靠度及其有关指标。这类模型的代表是Mills的超几何分布模型。</p><p><strong><strong>基于输入域的模型</strong></strong></p><p>这类模型的基本研究方法是根据程序的使用情况，找出程序可能输入的概率分布，根据这种分布产生一个测试用例的集合。由于得到输入的分布难度较大，一般将输入域划分成等价类，每个等价类与程序的一条执行路径相联。在输入域上随机抽取测试用例，执行相应的程序测试，观测故障，从而推断出各项指标。这类模型以Nelson模型为代表，还有Brown-Lipow的基于输入域模型和Ramamoorthy-Bastani的基于输入域模型</p><h2 id="网络可靠性"><a href="#网络可靠性" class="headerlink" title="网络可靠性"></a><strong><strong>网络可靠性</strong></strong></h2><p><strong>故障定义</strong>– <strong>网络不能在用户期望的时间范围内将物质、信息、能量按用户需求完整、正确地在网络中传输的状态或事件</strong></p><p><strong><strong>计算机网络可靠性定义</strong></strong></p><p>在人为或自然的破坏作用下，网络在特定环境和规定时间内，充分完成规定的通信功能的能力。<strong>环境、时间和充分完成功能是这一定义的三要素。</strong></p><p>当传输设备和交换设备发生故障时网络可以维持正常业务的程度</p><h1 id="第九讲-信息系统的容错技术"><a href="#第九讲-信息系统的容错技术" class="headerlink" title="第九讲 信息系统的容错技术"></a><strong>第九讲 信息系统的容错技术</strong></h1><h2 id="容错的概念"><a href="#容错的概念" class="headerlink" title="容错的概念"></a><strong><strong>容错的概念</strong></strong></h2><p>容忍故障，即故障一旦发生时能够<strong>自动检测</strong>出来并使系统能够<strong>自动恢复正常运行</strong></p><p><strong>容错设计的软件可以有某些规定数目的故障但不导致失效，但对无容错的软件而言，故障即失效。</strong></p><h2 id="容错的主要内容"><a href="#容错的主要内容" class="headerlink" title="容错的主要内容"></a><strong><strong>容错的主要内容</strong></strong></h2><p><strong>故障检测和诊断</strong></p><p>故障检测（Fault Detection）：判断系统是否存在故障的过程<br><strong>故障检测的作用是确认系统是否发生了故障，指示故障的状态，即查找故障源和故障性质。一般来说，故障检测只能找到错误点（错误单元），不能准确找到故障点。</strong></p><p>故障诊断（Fault Diagnosis）：检测出系统存在故障后要进行故障的定位，找出故障所在的位置</p><p><strong>故障屏蔽技术</strong></p><p>故障屏蔽技术是防止系统中的故障在该系统的信息结构中产生差错的各种措施的总称，其实质是在故障效应达到模块的输出以前，利用冗余资源将故障影响掩盖起来，达到容错目的</p><p><strong>冗余技术</strong></p><p>三模冗余可以由用户手动完成，也可以依靠工具完成。Xilinx推出了XIlInXtMrtool ，可以方便地实现三模冗余设计，并且可以方便地配置被冗余项，大大方便了用户</p><p><strong>时间冗余技术</strong></p><p><strong>基本思想：</strong>重复执行指令或者一段程序来消除故障的影响，以达到容错的效果，它是用消耗时间来换取容错的目的。</p><p><strong>信息冗余技术</strong></p><p>信息容错技术是通过在数据中附加冗余的信息位来达到故障检测和容错的目的</p><p><strong>软件冗余技术</strong></p><p>软件容错是指在出现有限数目的软件故障的情况下，系统仍可提供连续正确执行的内在能力。其目的是屏蔽软件故障，恢复因出故障而影响的运行进程。</p><p>实现软件容错的基本方法，是将若干个根据同一需求说明编写的不同程序（即多版本程序），在不同空间同时运行，然后在每一个设置点通过表决或接收测试进行表决。</p><h2 id="典型的容错应用"><a href="#典型的容错应用" class="headerlink" title="典型的容错应用"></a><strong><strong>典型的容错应用</strong></strong></h2><p><strong><strong>热备份（Hot-Standby）</strong></strong></p><p>M运行，S后备；</p><p>M故障，S接管作M；</p><p>原M修复，S归还M。</p><h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a><strong><strong>RAID</strong></strong></h3><p>廉价磁盘冗余阵列（Redundant Arrays of Inexpensive Disks），以多个低成本磁盘构成磁盘子系统，提供比单一硬盘更完备的可靠性和高性能</p><p><strong>数据基带条阵列（RAID0）</strong></p><p>分块无校验型，无冗余存储。简单将数据分配到各个磁盘上，不提供真正容错性。带区化至少需要2个硬盘，可支持8&#x2F;16&#x2F;32个磁盘</p><p> <strong>优点</strong></p><p>➢允许多个小区组合成一个大分</p><p>➢更好地利用磁盘空间，延长磁盘寿命</p><p>➢多个硬盘并行工作，提高了读写性能</p><p> <strong>缺点</strong></p><p>➢不提供数据保护，任一磁盘失效，数据可能丢失，且不能自动恢复。</p><p><strong>磁盘镜象（RAID1）</strong></p><p>每一组盘至少两台，数据同时以同样的方式写到两个盘上，两个盘互为镜象。磁盘镜象可以是分区镜象、全盘镜象。容错方式以空间换取，实施可以采用镜象或者双工技术。</p><p> <strong>优点</strong></p><p>➢ 可靠性高，策略简单，恢复数据时不必停机。</p><p> <strong>缺点</strong></p><p>➢ 有效容量只有总容量的1&#x2F;2，利用率50%。由于磁盘冗余，硬件</p><p>开销较大，成本较高</p><p><strong>循环奇偶校验阵列（RAID5）</strong></p><p>与RAID4类似，但校验数据不固定在一个磁盘上，而是循环地依次分布在不同的磁盘上，也称块间插入分布校验。它是目前采用最多、最流行的方式，至少需要3个硬盘。</p><p> 优点</p><p>➢ 校验分布在多个磁盘中，写操作可以同时处理；</p><p>➢ 为读操作提供了最优的性能；</p><p>➢ 一个磁盘失效，分布在其他盘上的信息足够完成数据重建 。</p><p> 缺点</p><p>➢ 数据重建会降低读性能；</p><p>➢ 每次计算校验信息，写操作开销会增大，是一般存储操作时间的3倍</p>]]></content>
    
    
    <summary type="html">信息系统安全的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://zhangyuanhe.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>信息论与编码课程笔记</title>
    <link href="https://zhangyuanhe.top/2024/01/10/BUPT_note/Notes%20on%20Information%20Theory%20and%20Coding/"/>
    <id>https://zhangyuanhe.top/2024/01/10/BUPT_note/Notes%20on%20Information%20Theory%20and%20Coding/</id>
    <published>2024-01-10T13:00:00.000Z</published>
    <updated>2024-01-17T12:37:33.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息论与编码"><a href="#信息论与编码" class="headerlink" title="信息论与编码"></a>信息论与编码</h1><h1 id="第一章-信息论与编码理论概述"><a href="#第一章-信息论与编码理论概述" class="headerlink" title="第一章 信息论与编码理论概述"></a>第一章 信息论与编码理论概述</h1><h2 id="信息论与编码理论概述"><a href="#信息论与编码理论概述" class="headerlink" title="信息论与编码理论概述"></a>信息论与编码理论概述</h2><p>自从汉明码开始，各种信道编码获得了长足的发展，如</p><ul><li>格雷码，Reed-Muller码，循环码，Reed-Solomon码,BCH码</li><li>卷积码，Turbo码，LDPC码，Polar码</li><li>级联码，网格编码调制，代数几何码</li><li>编织卷积码，纠删码，空时码</li><li>网络编码，量子纠错码，二维码</li><li>基于信息论与编码理论的安全技术</li></ul><h3 id="编码机制"><a href="#编码机制" class="headerlink" title="编码机制"></a>编码机制</h3><ul><li>编码：信息从一种形式或格式转换为另一种形式的过程。</li><li>编码机制：用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。</li></ul><h3 id="信源编码"><a href="#信源编码" class="headerlink" title="信源编码"></a>信源编码</h3><p>目的：提高通信的有效性，即以更少的符号来表示原始消息</p><p>通过减少消息符号序列中的冗余度，提高平均信息量</p><h3 id="随机错误"><a href="#随机错误" class="headerlink" title="随机错误"></a>随机错误</h3><ul><li>随机错误：接收序列中的传输错误是随机出现的。</li><li>随机错误信道：这样的信道称为随机错误信道。</li></ul><h3 id="突发错误"><a href="#突发错误" class="headerlink" title="突发错误"></a>突发错误</h3><p>突发错误：不同状态特性下，错误出现的概率不一样，这种错误为突发错误。</p><h3 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h3><p>目的：检测和纠正由于非人为(自然)因素引起的传输错误</p><p>设计机制：通过对消息符号序列加入冗余信息，使得接收方收到信号后，可以通过这些冗余信息进行检错和纠错</p><h2 id="数字通信系统的组成及各种信道"><a href="#数字通信系统的组成及各种信道" class="headerlink" title="数字通信系统的组成及各种信道"></a>数字通信系统的组成及各种信道</h2><h3 id="数字通信系统模型"><a href="#数字通信系统模型" class="headerlink" title="数字通信系统模型"></a>数字通信系统模型</h3><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled.png" alt="Untitled"></p><h3 id="无记忆信道和有记忆信道"><a href="#无记忆信道和有记忆信道" class="headerlink" title="无记忆信道和有记忆信道"></a>无记忆信道和有记忆信道</h3><p>无记忆信道：如果在给定时间间隔上，检测器的输出只与在该时间间隔上传送的信号有关，而与任何前面时间的传送的信号无关，称此信道为无记忆信道。该信道可以用如下公式表示：</p><p>$$<br>P(Y&#x2F;X)&#x3D; \prod_n p(y_n&#x2F;x_n)<br>$$</p><p>有记忆信道：一种M元输入、Q元输出的信道模型。该信道可以用如下公式表示：</p><p>$$<br>P(y_n&#x2F;x_{n-k+1},…,x_{n-1},x_n)<br>$$</p><h3 id="离散无记忆-DMC-信道"><a href="#离散无记忆-DMC-信道" class="headerlink" title="离散无记忆(DMC)信道"></a>离散无记忆(DMC)信道</h3><p>是一种M元输入、Q元输出的信道模型。</p><p>条件概率P(Y&#x2F;X)是描述该信道的最好方式，也叫做转移概率，其中X表示调制器输入符号，Y表示解调器输出符号，P(Y&#x2F;X)表示发送为X接收为Y的概率。</p><h3 id="二元对称-BSC-信道"><a href="#二元对称-BSC-信道" class="headerlink" title="二元对称(BSC)信道"></a>二元对称(BSC)信道</h3><p>信道矩阵：一个信道也可由它的转移概率组成的矩阵来表示。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%201.png" alt="Untitled"></p><h3 id="信道矩阵"><a href="#信道矩阵" class="headerlink" title="信道矩阵"></a>信道矩阵</h3><p>一般离散单符号信道的信道矩阵为：</p><p>$$<br>\begin{bmatrix} P(b_1|a_1) &amp; P(b_2|a_1) &amp; \dots &amp; P(b_s|a_1) \ P(b_1|a_2) &amp; P(b_2|a_2) &amp; \dots &amp; P(b_s|a_2) \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \P(b_1|a_r) &amp; P(b_2|a_r) &amp; \dots &amp; P(b_s|a_r)  \end{bmatrix}<br>$$</p><h3 id="加性高斯白噪声-AWGN-信道"><a href="#加性高斯白噪声-AWGN-信道" class="headerlink" title="加性高斯白噪声(AWGN)信道"></a>加性高斯白噪声(AWGN)信道</h3><ul><li>加性噪声：叠加在信号上的一种噪声。</li><li>白噪声：噪声的功率谱密度在所有的频率上均为一常数。</li><li>高斯白噪声：白噪声取值的概率分布服从高斯分布，其自相关系数为无延时的冲击函数。</li></ul><h2 id="通信系统涉及的一些基本概念"><a href="#通信系统涉及的一些基本概念" class="headerlink" title="通信系统涉及的一些基本概念"></a>通信系统涉及的一些基本概念</h2><h3 id="信息传输率"><a href="#信息传输率" class="headerlink" title="信息传输率"></a>信息传输率</h3><ul><li>符号传输率：为1&#x2F;T，每T秒传输一个编码符号，即单位时间内传输的符号个数。</li><li>码速率：编码后的数据流中有用部分的比例，对于(n,k)线性分组码，码速率为R&#x3D;k&#x2F;n，即k个信息比特对应于传送n个符号。</li><li>信息传输率(数据率)：在编码系统中，若码速率是R&#x3D;k&#x2F;n，则信息传输率(数据率)为R&#x2F;T(bit&#x2F;s)。</li></ul><h3 id="信道带宽"><a href="#信道带宽" class="headerlink" title="信道带宽"></a>信道带宽</h3><p>除了噪声的作用造成信号改变外，所有的通信系统都会因为带宽有限而造成信号失真。</p><ul><li>最小信道带宽：为基本保证信号不因带宽原因而失真，粗略估计等于W&#x3D;1&#x2F;(2T)(Hz)。</li><li>未编码系统：数据率1&#x2F;T&#x3D;2W，受到带宽影响。</li><li>二元编码系统：数据率R&#x2F;T&#x3D;2RW。同未编码系统相比，若要保持数据率不变，则要求带宽扩展1&#x2F;R倍。</li></ul><h3 id="AWGN信道的分组编码系统"><a href="#AWGN信道的分组编码系统" class="headerlink" title="AWGN信道的分组编码系统"></a>AWGN信道的分组编码系统</h3><p>译码器的条件错误概率：已知接收序列Y时</p><p>$$<br>P_e(H_m&#x2F;Y),P_e(X_m&#x2F;Y)<br>$$</p><p>译码器的错误概率：</p><p>$$<br>P_e(H_m)&#x3D;P_e(X_m)&#x3D;\sum_Y P_e(X_m&#x2F;Y)P(Y)<br>$$</p><h3 id="最佳译码规则和最大后验概率译码"><a href="#最佳译码规则和最大后验概率译码" class="headerlink" title="最佳译码规则和最大后验概率译码"></a>最佳译码规则和最大后验概率译码</h3><ul><li><p><strong>最佳译码规则</strong>：能够使译码错误概率P(E)达到最小的译码规则</p></li><li><p>由于接收序列Y是译码前产生的，所以P(Y)与译码规则无关</p></li><li><p>最佳译码规则必须对所有Y，使得</p><p>  $$<br>  P(E&#x2F;Y)\cong P(Y \neq X&#x2F;Y)<br>  $$</p><p>  &#96;最小，即 P(Y&#x3D;X&#x2F;Y) 最大。</p></li><li><p><strong>最大后验概率译码</strong>：对于每个输入Y，如果译码器能在码字集合中选择一个码字，作为发送码字的估值，并且使P(X&#x2F;Y)最大，则这种译码规则一定能使译码器输出的错误概率最小。</p></li></ul><h3 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h3><p>Bayes公式：</p><p>$$<br>\uparrow P(X&#x2F;Y)&#x3D;\frac{P(Y&#x2F;X)P(X)}{P(Y)} \公式(1)<br>$$</p><ul><li>对于给定的Y，可选择能使公式(1)右边最大的向量作为X的估计值。</li><li>如果所有码字都是等可能的，即P(X)是常数，那么公式(1)左边最大，就推导出P(Y&#x2F;X)最大。</li><li>P(Y&#x2F;X)：叫做似然函数、信道转移概率。</li></ul><h3 id="最大似然译码"><a href="#最大似然译码" class="headerlink" title="最大似然译码"></a>最大似然译码</h3><ul><li><p>定义：若能在码字集合选择合适的码字X，使得P(Y&#x2F;X)最大，则这种译码规则被称为最大似然译码。</p></li><li><p>对数似然函数：由于lnx与x是单调关系，故有lnP(Y&#x2F;X)。</p></li><li><p>对于离散无记忆信道，由于</p><p>  $$<br>  P(Y&#x2F;X)&#x3D;\sum_n P(y_i&#x2F;x_i)<br>  $$</p><p>  所以</p><p>  $$<br>  \ln P(Y&#x2F;X)&#x3D;\sum_n \ln P(y_i&#x2F;x_i)<br>  $$</p></li><li><p>MLD：对应的译码器称为最大似然译码器。</p></li><li><p>MLD规则：是最为可行的一种译码规则。</p></li><li><p>对于DMC和BSC信道是一种最佳译码准则。但是在某些情况下并不是最佳的译码规则，如当发送端不是以等概率发送码字的时候。</p></li></ul><h3 id="BSC信道的最大似然译码"><a href="#BSC信道的最大似然译码" class="headerlink" title="BSC信道的最大似然译码"></a>BSC信道的最大似然译码</h3><p>$$<br>P(y_i&#x2F;x_i)&#x3D;\begin{cases} 1-p&amp;  y_i&#x3D;x_i\p&amp; y_i\neq x_i \end{cases}<br>$$</p><p>Y为二元序列，用d(Y, X)表示Y和X之间的距离，即不同位数的个数</p><p>$$<br>\ln P(Y&#x2F;X)&#x3D;d(y,X)\ln p+(n-d(Y,X))\ln (1-p) &#x3D;\ d(Y,X)\ln \frac {p}{1-p} +n\ln(1-p)<br>$$</p><p>即想要P(Y&#x2F;X)最大，则需要d(Y, X)最小</p><p>最小距离译码器：在BSC中，MLD规则变成了选择能使Y和X之间的汉明距离为最小的向量，作为码字X的估计值</p><h1 id="数据安全中的数学问题"><a href="#数据安全中的数学问题" class="headerlink" title="数据安全中的数学问题"></a>数据安全中的数学问题</h1><p>语义</p><p>语法：01比特</p><p>语用</p><h2 id="信道编码"><a href="#信道编码" class="headerlink" title="信道编码"></a>信道编码</h2><p>y&#x3D;Ax+b mod  q</p><p>分组码</p><p>循环码</p><p>卷积码</p><h2 id="LDPC码"><a href="#LDPC码" class="headerlink" title="LDPC码"></a>LDPC码</h2><p>有低密度的稀疏矩阵，就表示是LDPC码</p><h2 id="压缩感知"><a href="#压缩感知" class="headerlink" title="压缩感知"></a>压缩感知</h2><p>y&#x3D;Ax+b</p><p>如果x稀疏，A满足一定的条件，通过y A可以找到x</p><p>由于A不可逆，无法通过求找到x</p><p>现实中的x一般并不稀疏，进过一个变化之后，再一组正交基上可以进行稀疏表示</p><h3 id="矩阵A与x维数不匹配"><a href="#矩阵A与x维数不匹配" class="headerlink" title="矩阵A与x维数不匹配"></a>矩阵A与x维数不匹配</h3><p>格密码，编码，压缩感知都有对测量矩阵尺寸多样性的需求</p><h3 id="半张量积压缩感知"><a href="#半张量积压缩感知" class="headerlink" title="半张量积压缩感知"></a>半张量积压缩感知</h3><p>$$<br>y&#x3D;a\ltimes x+b<br>$$</p><h1 id="第二章-信息论基础与信源编码理论"><a href="#第二章-信息论基础与信源编码理论" class="headerlink" title="第二章 信息论基础与信源编码理论"></a>第二章 信息论基础与信源编码理论</h1><p>信息的定义：信息是事物运动状态或存在方式不确定性的描述</p><h2 id="自信息"><a href="#自信息" class="headerlink" title="自信息"></a>自信息</h2><p>定义：考虑离散随机变量X，其样本空间为{xi, i&#x3D;1, 2,…,n}，则事件X&#x3D;xi的自信息的定义为</p><p>$$<br>I(x_i)&#x3D;log(\frac{1}{P(x_i)})&#x3D;-logP(x_i)<br>$$</p><blockquote><p>自信息的单位由对数的底来决定，以2为底，单位就是比特(bits)，以e为底就是奈特(nats)。自信息非负。</p></blockquote><h2 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h2><p>定义： xi和yi之间的互信息定义为</p><p>$$<br>I(x_i;y_i)&#x3D;log(\frac{P(x_i|y_i)}{P(x_i)})<br>$$</p><p>互信息的性质：</p><p>性质1：互易性 I(xi;yi)&#x3D; I(yi;xi)。<br>性质2：当xi和yi是统计上独立的，即P(xi|yi)&#x3D; P(xi)，则I(xi;yi)&#x3D;0。<br>性质3：互信息量可以是正的，也可以是负的。</p><blockquote><p>思考题：计算二元对称(BSC)信道的互信息量?</p><p>计算二元对称信道（Binary Symmetric Channel，BSC）的互信息量（Mutual Information）可以使用以下的LaTeX公式表示：</p><p><em>I</em>(<em>X</em>;<em>Y</em>)&#x3D;<em>H</em>(<em>Y</em>)−<em>H</em>(<em>Y</em>∣<em>X</em>)</p><p>其中：</p><ul><li><p><em>I</em>(<em>X</em>;<em>Y</em>) 表示信道输入 <em>X</em> 和输出 <em>Y</em> 之间的互信息量。</p></li><li><p><em>H</em>(<em>Y</em>) 表示接收端输出 <em>Y</em> 的熵（Entropy），可以用以下公式计算：</p><p>  $$<br>  H(Y) &#x3D; -\sum_{i&#x3D;1}^{2} P(Y&#x3D;y_i) \cdot \log_2(P(Y&#x3D;y_i))<br>  $$</p></li></ul><p>这里的 <em>y</em>1 和 <em>y</em>2 分别表示接收到的0和1的可能性，<em>P</em>(<em>Y</em>&#x3D;<em>yi</em>) 是接收到符号 <em>yi</em> 的概率。</p><ul><li><p><em>H</em>(<em>Y</em>∣<em>X</em>) 表示在已知输入 <em>X</em> 的条件下，接收端输出 <em>Y</em> 的条件熵（Conditional Entropy），可以用以下公式计算：</p><p>  $$<br>  H(Y|X) &#x3D; -\sum_{i&#x3D;1}^{2} \sum_{j&#x3D;1}^{2} P(X&#x3D;x_j, Y&#x3D;y_i) \cdot \log_2\left(\frac{P(X&#x3D;x_j, Y&#x3D;y_i)}{P(X&#x3D;x_j)}\right)<br>  $$</p></li></ul><p>对于二元对称信道（BSC），错误概率 p 相等，即 P(Y&#x3D;0∣X&#x3D;1)&#x3D;P(Y&#x3D;1∣X&#x3D;0)&#x3D;p，而 P(Y&#x3D;0∣X&#x3D;0)&#x3D;P(Y&#x3D;1∣X&#x3D;1)&#x3D;1−p。因此，可以使用这些概率值来计算上述公式中的各项。</p></blockquote><h2 id="平均自信息量-信息熵"><a href="#平均自信息量-信息熵" class="headerlink" title="平均自信息量(信息熵)"></a>平均自信息量(信息熵)</h2><p>定义：离散随机变量X的平均自信息定义为，其样本空间为{xi, i&#x3D;1, 2,…,n}，则事件X&#x3D;xi的平均自信息量的定义为</p><p>$$<br>H(X)&#x3D;E{log(\frac{1}{P(x_i)})}&#x3D;\sum^n_{i&#x3D;1}P(x_i)I(x_i)&#x3D;-\sum^n_{i&#x3D;1}P(x-_i)logP(x_i)<br>$$</p><p>其中H(X)表示每个信源符号的平均信息量。</p><h2 id="平均条件自信息量-条件熵"><a href="#平均条件自信息量-条件熵" class="headerlink" title="平均条件自信息量(条件熵)"></a>平均条件自信息量(条件熵)</h2><p>定义：平均条件自信息H(X|Y)定义为</p><p>$$<br>H(X|Y)&#x3D;\sum^n_{i&#x3D;1}\sum^m_{j&#x3D;1}P(x_iy_i)log\frac{1}{P(x_i|y_i)}<br>$$</p><blockquote><p>思考题：计算二元对称(BSC)信道的平均条件自信息量(条件熵)?</p></blockquote><h2 id="无失真信源编码"><a href="#无失真信源编码" class="headerlink" title="无失真信源编码"></a>无失真信源编码</h2><h3 id="等长信源编码定理"><a href="#等长信源编码定理" class="headerlink" title="等长信源编码定理"></a>等长信源编码定理</h3><p>定理: 一个熵为H(X)的离散无记忆信源，若对信源长为N的符号序列进行等长编码，设码字是从r个字母的码符号集合中，选取l个码元组成。对于任意的ε&gt;0，只要满足</p><p>$$<br>\frac{l}{N}\geq \frac{H(X)+\varepsilon}{log\gamma}<br>$$</p><p>则当N足够大时，可实现几乎无失真编码，即译码错误概率可为任意小。</p><h3 id="变长码"><a href="#变长码" class="headerlink" title="变长码"></a>变长码</h3><table><thead><tr><th>字母</th><th>码字</th><th>字母</th><th>码字</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>E</td><td>10</td></tr><tr><td>B</td><td>1</td><td>F</td><td>11</td></tr><tr><td>C</td><td>00</td><td>G</td><td>000</td></tr><tr><td>D</td><td>01</td><td>H</td><td>111</td></tr></tbody></table><p>若对字母序列ABADCAB进行编码，则得到0 1 0 01 00 0 1<br>译码不唯一：可能被译为DADAAAB(01 0 01 0 0 0 1)<br>或者AEDGB(0 10 01 000 1)</p><blockquote><p>注：变长码必须是惟一可译码，才能实现无失真编码。</p></blockquote><h3 id="变长信源编码定理"><a href="#变长信源编码定理" class="headerlink" title="变长信源编码定理"></a>变长信源编码定理</h3><p>定理:一个熵为H(X)的离散无记忆信源，并有r个码元的码符号集合，总可以找到一种无失真编码方法，构成惟一可译码，使其平均码长满足</p><p>$$<br>\frac{H(X)}{logr}\leq\bar{L}&lt;\frac{H(X)}{logr}+1<br>$$</p><p>则当N足够大时，可实现几乎无失真编码，即译码错误概率可为任意小。</p><h3 id="信道的信息传输率"><a href="#信道的信息传输率" class="headerlink" title="信道的信息传输率"></a>信道的信息传输率</h3><p>变长信源编码定理中的极限值H(X)&#x2F;logr同等长信源编码定理中的极限值是一致的。</p><p>定义：信道的信息传输率(码率)为</p><p>$$<br>R&#x3D;\frac{H(X)}{logr}<br>$$</p><p>得到编码后信道的信息传输率为</p><p>$$<br>R\le\bar{L}<br>$$</p><h2 id="经典的信源编码方法"><a href="#经典的信源编码方法" class="headerlink" title="经典的信源编码方法"></a>经典的信源编码方法</h2><h3 id="信源编码—霍夫曼-Huffman-编码"><a href="#信源编码—霍夫曼-Huffman-编码" class="headerlink" title="信源编码—霍夫曼(Huffman)编码"></a>信源编码—霍夫曼(Huffman)编码</h3><p>一个离散无记忆信源有7个符号xi, i&#x3D;1,..,7，P(X&#x3D;x1)&#x3D;0.37, P(X&#x3D;x2)&#x3D;0.33, P(X&#x3D;x3)&#x3D;0.16, P(X&#x3D;x4)&#x3D;0.07, P(X&#x3D;x5)&#x3D;0.04, P(X&#x3D;x6)&#x3D;0.02, P(X&#x3D;x7)&#x3D;0.01, 将7个信源符号按照概率递减的顺序进行排序，构造如图8所示的霍夫曼树。<br>按照编码路径从后往前返回，就得到对应的码字x7&#x3D;111111, x6&#x3D;111110, x5&#x3D;11110, x4&#x3D;1110，x3&#x3D;110, x2&#x3D;10，x1&#x3D;0。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%202.png" alt="Untitled"></p><blockquote><p>思考题：如何编程序实现霍夫曼编码?</p><ol><li>构建霍夫曼树：<ul><li>统计输入数据中每个字符的频率。</li><li>创建叶子节点，每个叶子节点代表一个字符，并将频率作为节点的权重。</li><li>将叶子节点放入一个优先队列（最小堆）中，以便频率最低的节点位于队列的前面。</li><li>重复以下步骤，直到只剩下一个节点为止：<ul><li>从队列中弹出两个频率最低的节点。</li><li>创建一个新的节点，其权重等于这两个节点的权重之和。</li><li>将新节点插入队列中。</li></ul></li><li>最后队列中剩下的节点就构成了霍夫曼树。</li></ul></li><li>生成霍夫曼编码：<ul><li>遍历霍夫曼树，从根节点开始，分别向左和向右遍历树的边。</li><li>每次向左移动时，将编码中添加一个 0，每次向右移动时，将编码中添加一个 1。</li><li>当到达叶子节点时，您就得到了字符的霍夫曼编码。</li></ul></li><li>构建编码表：<ul><li>将每个字符与其对应的霍夫曼编码存储在一个编码表中，以便在编码和解码过程中使用。</li></ul></li><li>编码和解码：<ul><li>使用编码表将输入数据编码为霍夫曼编码。</li><li>使用霍夫曼树将霍夫曼编码解码为原始数据。</li></ul></li></ol></blockquote><h3 id="游程编码"><a href="#游程编码" class="headerlink" title="游程编码"></a>游程编码</h3><p>游程：信源输出的字符序列中，各种字符连续的重复出现的字符串的个数。<br>游程编码：就是将这种字符序列映射成字符串的长度和字符串的位置的标志序列。<br>游程编码常用作图形文件的编码方式，如.bmp和.tiff。</p><blockquote><p>例子：考虑比特序列11111111111111100000000000000000001111，可以被表示成(15,1),(19,0),(4,1)，字符最长的重复的数目为19，因此，把该比特序列编码为(01111,1), (10011,0), (00100,1)，此时压缩率为18:38&#x3D;1:2.11。</p></blockquote><blockquote><p>思考题：如何编程序实现游程编码?</p><ol><li><strong>统计字符频率</strong>：<ul><li>首先，需要扫描输入文本并统计每个字符的频率。这是构建霍夫曼树的基础，因为频率高的字符将具有较短的编码。</li></ul></li><li><strong>构建霍夫曼树</strong>：<ul><li>基于字符频率，构建霍夫曼树。通常，使用一个优先队列（最小堆）来管理节点，每个节点代表一个字符及其频率。在构建过程中，反复合并两个最小频率的节点，创建一个新的节点，并将其插入回队列，直到队列中只剩下一个节点，即根节点，表示整个霍夫曼树已构建完成。</li></ul></li><li><strong>生成霍夫曼编码</strong>：<ul><li>遍历霍夫曼树，从根节点开始，每当沿着左子树移动时添加0，沿着右子树移动时添加1。当到达叶子节点时，记录下当前路径所对应的字符的编码。</li></ul></li><li><strong>构建编码表</strong>：<ul><li>将每个字符和它对应的霍夫曼编码存储在一个编码表中，以便在编码和解码过程中使用。</li></ul></li><li><strong>编码文本</strong>：<ul><li>使用编码表将输入文本中的字符编码为霍夫曼编码。</li></ul></li><li><strong>解码文本</strong>：<ul><li>使用霍夫曼树将霍夫曼编码解码为原始文本。</li></ul></li></ol></blockquote><h3 id="LZ-Lemple-Ziv-编码"><a href="#LZ-Lemple-Ziv-编码" class="headerlink" title="LZ(Lemple-Ziv)编码"></a>LZ(Lemple-Ziv)编码</h3><p>分段的方法：1)游程先取第一个符号作为第一段，然后再继续分段；2)若有出现与前面符号一样时，就再添加紧跟后面的一个符号一起组成一段；3)尽可能取最少个连着的符号并保证各段都不相同；4)以此类推，直至信源符号序列结束。<br>编码方法：首先去掉最后一个符号，然后看剩下的字符串在字典中的排序，这个排序值转换成二进制数作为指针X的值，最后一个信源符号作为码字第2项d的值，即得到码字(X, d)。</p><blockquote><p>例子：考虑比特序列101011011010101011，根据上面的编码方法可把该比特序列分段为1, 0, 10, 11, 01, 101, 010, 1011。<br>码字为：(000,1),( 000,0), (001,0), (001,1), (010,1), (011,1), (101,0), (110,1)。</p></blockquote><blockquote><p>思考题：如何编程序实现LZ编码?</p><ol><li><strong>初始化字典</strong>：创建一个空的字典，其中包含所有可能的单个字符作为初始词条。</li><li><strong>扫描输入数据</strong>：从左到右扫描输入数据，逐步构建编码输出。开始时，当前扫描位置指向输入数据的第一个字符。</li><li><strong>查找最长匹配</strong>：在字典中查找与当前扫描位置匹配的最长字符串（前缀），这个字符串必须存在于字典中。如果找到匹配，就将扫描位置移动到匹配字符串的末尾，否则将当前字符作为一个字典词条。</li><li><strong>输出编码</strong>：将匹配字符串的索引（或编码）输出到结果中，并将匹配字符串后的字符作为下一个字典词条的一部分。</li><li><strong>更新字典</strong>：将新的字典词条添加到字典中，以便下次匹配时使用。</li><li><strong>重复步骤3到步骤5</strong>，直到扫描完成整个输入数据。</li></ol></blockquote><h2 id="纠错码的理论基础"><a href="#纠错码的理论基础" class="headerlink" title="纠错码的理论基础"></a>纠错码的理论基础</h2><h3 id="信道容量"><a href="#信道容量" class="headerlink" title="信道容量"></a>信道容量</h3><p>定义：考虑某种概率分布为P(x)的离散无记忆信源，对于一个固定的信道，信道容量被定义为最大的平均互信息，此时传输每个符号平均获得的信息量最大，即对于每个固定的信道可以达到最大的信息传输率，即</p><p>$$<br>C&#x3D;\max_{P(X_j)}I(X;Y)&#x3D;\max_{P(X_J)}\sum^{q-1}<em>{j&#x3D;1}\sum^{r-1}</em>{i&#x3D;o}P(x_j)P(y_i|x_j)\log \frac {P(y_i|x_j)}{P(y_i)}<br>$$</p><p>其约束条件为</p><p>$$<br>P(x_j)\ge0\ ,\sum^{q-1}_{j&#x3D;0}P(x_j)&#x3D;1<br>$$</p><blockquote><p>思考题：如何计算给定某种信道的信道容量?</p><ol><li><p><strong>确定信道模型</strong>：首先，需要明确定义所使用的信道模型。不同的信道（例如二进制对称信道、高斯信道、无线信道等）具有不同的数学表示和特性。你需要了解信道的概率分布和噪声性质。</p></li><li><p><strong>计算信道容量</strong>：使用香农-哈特利定理来计算信道容量。该定理的公式如下：</p><p> $$<br> C+B·\log_2(1+SNR)<br> $$</p><p> 其中，</p><ul><li><em>C</em> 表示信道容量（比特每秒，bps）。</li><li><em>B</em> 表示信道的带宽（赫兹，Hz），它表示信号传输的频率范围。</li><li>SNRSNR 表示信噪比，定义为信号功率与噪声功率之比。通常以对数（以分贝为单位）表示。</li></ul></li><li><p><strong>SNR计算</strong>：计算信噪比（SNR）是信道容量计算的关键。SNR的计算方式取决于信道的特性。例如，在高斯信道中，SNR通常表示为信号功率与噪声功率之比。</p></li><li><p><strong>确定带宽</strong>：带宽（B）是信号传输的频率范围，通常以赫兹（Hz）表示。带宽的选择与具体的通信系统和应用有关。</p></li></ol></blockquote><h3 id="纠错编码的理论基础"><a href="#纠错编码的理论基础" class="headerlink" title="纠错编码的理论基础"></a>纠错编码的理论基础</h3><p>香农编码定理：如果系统的传输率小于信道容量，那么适当选择编码技术就能实现可靠通信，即可以将差错率减小到任意小的程度。</p><h3 id="信道编码定理"><a href="#信道编码定理" class="headerlink" title="信道编码定理"></a>信道编码定理</h3><p>定理：假设DMS有信源字符集X，熵为每信源符号H(X)比特，而且信源每Ts秒产生一个符号，那么信源的平均信息率为每秒H(X)&#x2F;Ts比特，假设信道可以每Tc秒使用一次，而信道容量为每次信道使用C比特，那么每单位时间的信道容量为每秒钟C&#x2F;Tc比特。如果H(X)&#x2F;Ts≤ C&#x2F;Tc，那么就存在编码方案使得在有噪声的信道上传输的信源消息，能够以任意小的错误概率进行恢复。</p><h1 id="第三章-线性分组"><a href="#第三章-线性分组" class="headerlink" title="第三章 线性分组"></a>第三章 线性分组</h1><h2 id="分组码"><a href="#分组码" class="headerlink" title="分组码"></a>分组码</h2><blockquote><p><strong>分组码：将消息序列分组进行编码</strong></p></blockquote><p>每组消息u有k个信息位，共有$2^k$个不同的消息</p><blockquote><p><strong>码字：编码器按照一定规则将每个输入消息u变换成二元n重v，n&gt;k，这个二元n重v称作消息u的码字或码矢。</strong></p></blockquote><p>所有$2^k$个码字组成的集合称作是分组码</p><blockquote><p>为什么在分组码中码字的个数是$2^k$个?<br>当编码字的位数是$2^k$时，这些码字可以更容易地排列成矩阵，例如二维数组，以便进行操作和计算。这种排列方式在编码和解码时通常更加高效。</p></blockquote><h2 id="线性分组码"><a href="#线性分组码" class="headerlink" title="线性分组码"></a>线性分组码</h2><p>线性分组码即具有线性性质的分组码</p><p><strong>定义：长为n，有$2^k$个码字的分组码，当且仅当其$2^k$个码字构成GF(2)上所有n重矢量空间的一个k维子空间时，称作线性(n, k)分组码。</strong></p><h2 id="生成矩阵"><a href="#生成矩阵" class="headerlink" title="生成矩阵"></a>生成矩阵</h2><p>∵ 线性(n,k)分组码C是一个k维子空间<br>∴ 在码C中能找到k个线性独立的码字$g_0, g_1,…, g_{k-1}，$使得C中的每个码字v都是这k个码字的一种线性组合，即 $v&#x3D;u_0g_0+u_1g_1+…+u_{k-1}g_{k-1}$</p><blockquote><p>生成矩阵：将k个线性独立的码字作为行，得到k×n阶矩阵</p><p>$$<br>G&#x3D;<br>\begin{pmatrix}<br>g_0\g_1\ \vdots \g_{k-1}<br>\end{pmatrix}&#x3D;\begin{pmatrix}<br>g_{00}&amp;g_{01}&amp;\dots&amp;g_{0n-1}\g_{10}&amp;g_{11}&amp;\dots&amp;g_{1n-1}\ \vdots \g_{(k-1)0}&amp;g_{(k-1)1}&amp;\dots&amp;g_{(k-1)n-1}<br>\end{pmatrix}<br>$$</p></blockquote><h2 id="一致校验-监督-矩阵"><a href="#一致校验-监督-矩阵" class="headerlink" title="一致校验(监督)矩阵"></a>一致校验(监督)矩阵</h2><p>∵ (n,k)线性码有r(r&#x3D;n-k)个校验码元<br>∴ 必须有r个独立的线性方程</p><p>对于任一码字c, 有cHT&#x3D;0</p><p>$∵c&#x3D;iG\<br>∴ GH^T&#x3D;0$</p><blockquote><p>校验矩阵：该矩阵由r行n列组成，即</p><p>$$<br>H&#x3D;\begin{pmatrix}<br>h_{1,n}&amp;h_{1,n-1}&amp;\dots&amp;h_{1,1}\h_{2,n}&amp;h_{2,n-1}&amp;\dots&amp;h_{2,1}\ \vdots \h_{r,n}&amp;h_{r,n-1}&amp;\dots&amp;h_{r,1}<br>\end{pmatrix}<br>$$</p></blockquote><p>一致校验矩阵的标准形式：经过初等变换，得到$H&#x3D;[Q I_r]$</p><h2 id="线性系统分组码"><a href="#线性系统分组码" class="headerlink" title="线性系统分组码"></a>线性系统分组码</h2><p><strong>定义：若(n,k)线性分组码C的生成矩阵形如$G&#x3D;[P I_k]$或$G&#x3D;[I_k P])$，此时称C为线性系统分组码。</strong></p><p>$$<br>G&#x3D;<br>\begin{pmatrix}<br>g_0\g_1\ \vdots \g_{k-1}<br>\end{pmatrix}&#x3D;[P \ I_k]&#x3D;\begin{pmatrix}<br>p_{0,0}&amp;p_{0,1}&amp;\dots&amp;p_{0,n-k-1}&amp; \vdots&amp;1&amp;0&amp;0&amp;\dots&amp;0 \p_{1,0}&amp;p_{1,1}&amp;\dots&amp;p_{1,n-k-1}&amp; \vdots&amp;0&amp;1&amp;0&amp;\dots&amp;0 \ p_{2,0}&amp;p_{2,1}&amp;\dots&amp;p_{2,n-k-1}&amp; \vdots&amp;0&amp;0&amp;1&amp;\dots&amp;0\ \vdots\ p_{k-1,0}&amp;p_{k-1,1}&amp;\dots&amp;p_{k-1,n-k-1}&amp; \vdots&amp;0&amp;0&amp;0&amp;\dots&amp;1<br>\end{pmatrix}<br>$$</p><p>此时，如果用任意消息u同G做乘法，就会发现每个码字都可以被分成两个部分：消息部分和冗余部分</p><h2 id="一致校验方程"><a href="#一致校验方程" class="headerlink" title="一致校验方程"></a>一致校验方程</h2><p>对于线性系统分组码</p><p>$$<br>v&#x3D;u·G&#x3D;(u_0,u_1,\dots,u_{k-1})·\begin{pmatrix}<br>p_{0,0}&amp;p_{0,1}&amp;\dots&amp;p_{0,n-k-1}&amp; \vdots&amp;1&amp;0&amp;0&amp;\dots&amp;0 \p_{1,0}&amp;p_{1,1}&amp;\dots&amp;p_{1,n-k-1}&amp; \vdots&amp;0&amp;1&amp;0&amp;\dots&amp;0 \ p_{2,0}&amp;p_{2,1}&amp;\dots&amp;p_{2,n-k-1}&amp; \vdots&amp;0&amp;0&amp;1&amp;\dots&amp;0\ \vdots\ p_{k-1,0}&amp;p_{k-1,1}&amp;\dots&amp;p_{k-1,n-k-1}&amp; \vdots&amp;0&amp;0&amp;0&amp;\dots&amp;1<br>\end{pmatrix}<br>$$</p><p>对应于消息$u&#x3D;(u_0,u_1,\dots,u_{k-1})$的码字是$v&#x3D;(v_0,v_1,\dots,v_{n-1})&#x3D;u·G$，即$v_{n-k+i}&#x3D;u_i , 0≤i≤k-1$</p><p>$v_j&#x3D;u_0p_{0j}+u_1p{1j}+…+u_{k-1}p_{k-1j}, 0≤j≤n-k-1$</p><p>上面两个式子正好反映系统的组成特性，最后这n-k个方程称为码C的一致校验方程。</p><h2 id="对偶码"><a href="#对偶码" class="headerlink" title="对偶码"></a>对偶码</h2><p><strong>定义：令S是$V_n$的k维子空间，并令$S_d$是$V_n$中这样矢量的集合，即对S中的任意u和$S_d$中的任意v，有u·v&#x3D;0，则$S_d$也是$V_n$的一个子空间，它称为S的对偶空间或零化空间。</strong></p><p>定理：令S是$V_n$中的一个k维子空间，则S的对偶空间的维数是n-k。</p><p>对偶码：以H为生成矩阵得到的(n,n-k)码称为码C的对偶码,记为$C_d$。</p><h2 id="系统码的一致校验矩阵"><a href="#系统码的一致校验矩阵" class="headerlink" title="系统码的一致校验矩阵"></a>系统码的一致校验矩阵</h2><p>若码C的生成矩阵具有系统形式$G&#x3D;[P I_k]$或$[I_k P]$，则其一致校验矩阵形如H&#x3D;$[I_{n-k} P^T]$或$H&#x3D;[P^T I_{n-k}]$。</p><h2 id="伴随式"><a href="#伴随式" class="headerlink" title="伴随式"></a>伴随式</h2><p>伴随式：当接收到r后，译码器计算下述n-k重$S&#x3D;r·H……T &#x3D;(s_0, s_1,…, s_{n-k-1})$则称S为r的伴随式。</p><p>当且仅当是一个码字(即无传输错误)时有S&#x3D;0，否则错误矢量本身就是一个码字，此时出现了不可检错误。只要码C设计适当，就几乎不会出现不可检错误。</p><h2 id="伴随式纠错"><a href="#伴随式纠错" class="headerlink" title="伴随式纠错"></a>伴随式纠错</h2><p>根据伴随式定义， 我们有$S&#x3D;r·H^T &#x3D;(v+e)·H^T&#x3D;v·H^T+e·H^T&#x3D;e·H^T$</p><p>可以看出，伴随式是错误图样的组合，即伴随式包含了一定程度的错误图样信息，因而可以用来纠错——伴随式纠错。</p><blockquote><p>考虑某(7,3)码，该码的生成矩阵G和H为</p><p>$$<br>G&#x3D;\begin{pmatrix}   0&amp;1&amp;1&amp;1&amp;1&amp;0&amp;0\     1&amp;0&amp;1&amp;1&amp;0&amp;1&amp;0\      1&amp;1&amp;1&amp;0&amp;0&amp;0&amp;1\end{pmatrix}, H&#x3D;\begin{pmatrix}   1&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1\     0&amp;1&amp;0&amp;0&amp;1&amp;0&amp;1\      0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0\       0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0\end{pmatrix}<br>$$</p><p>令u&#x3D;(101),v&#x3D;(1001101)是发送码字，r&#x3D;(0001101)是接收矢量，收到r后首先计算S&#x3D;r·HT &#x3D;(1000)≠0，由伴随式和错误图样的关系方程有：1&#x3D;e0+e5+e6, 0&#x3D;e1+e4+e6, 0&#x3D;e2+e4+e5+e6, 0&#x3D;e3+e4+e5, 则得到23&#x3D;8个错误图样(1000000), (1010111), (1101011), … …, 其中(1000000)是非零分量最少的图样，考虑BSC信道，则(1000000)是最为可能的错误矢量，因而确定v&#x3D;r+e&#x3D;(0001101)+ (1000000)&#x3D;(1001101)</p></blockquote><h2 id="汉明重量"><a href="#汉明重量" class="headerlink" title="汉明重量"></a>汉明重量</h2><p><strong>汉明重量：令v&#x3D;(v0, v1,…, vn-1)是二元n重，v的汉明重量w(v) 定义为v中非零分量的个数。</strong></p><blockquote><p>举例：设有两个码字{0100,1111},则它们的汉明重量为w(0100)&#x3D;1, w(1111)&#x3D;4</p></blockquote><p>重量分布：对于码长为n的一个分组码, 不同的码字可能具有 相同的汉明重量, 若记Ai为该码中汉明重量为i的码字个数, 称{A0, A1,…, An}是该码的重量分布。</p><h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p><strong>定义：令u&#x3D;(u0, u1,…, un-1)和v&#x3D;(v0, v1,…, vn-1)是两个二元n重，则u和v之间的汉明距离d(u, v)定义为u+v的汉明重量。</strong></p><blockquote><p>举例：设有两个码字{0100,1111},则它们的汉明距离d(0100, 1111)&#x3D;3</p></blockquote><p>汉明距离的性质：</p><ol><li>非负性，d(u, v)≥0；</li><li>d(u, v)&#x3D;0，当且仅当u&#x3D;v的时候；</li><li>对称性： d(u, v) &#x3D;d(v, u) ；</li><li>三角不等式： d(u, v)+d(v, w)≥d(u, w)</li></ol><h2 id="距离分布"><a href="#距离分布" class="headerlink" title="距离分布"></a>距离分布</h2><p><strong>定义：在(n,k)码中，任意两个码字之间都有一个汉明距离，两组不同码字之间可能有相同的汉明距离。若记Di(0≤i≤n)为距离为i的码字组数，那么称{D0, D1,…,Dn}为此分组码的距离分布，并且称能够使Di≠0的那个最小整数i为该码的最小码间距离。</strong></p><p>特别的，对于线性分组码，有如下定理：(n,k)线性码的最小码间距离等于非零码字的最小汉明重量。</p><blockquote><p><strong>定理：设(n,k)线性码C的最小码间距离为d，则1)若d≥t+1，则码C能检测t个随机错误；2)若d≥2t+1，则码C能纠正t个随机错误；3)若d≥t+e+1，则码C能纠正t (t≤e)个随机错误，同时还能检测e个随机错误。</strong></p></blockquote><p>定理：(n,k,d*)线性码C的最小码间距离d<strong>满足d</strong>≤n-k+1</p><p><strong>定义：若(n,k)线性码的最小码间距离d满足d&#x3D;n-k+1，那么称该码为最大距离可分码，简称MDS码。</strong></p><h2 id="标准阵"><a href="#标准阵" class="headerlink" title="标准阵"></a>标准阵</h2><p>令(n,k)线性码C的所有码字是接收矢量r是一个n重，则按如下的方式构造码C的标准阵：</p><p>$$<br>\begin{bmatrix}   v_1&#x3D;0&amp;v_2&amp;\dots&amp;v_i&amp;\dots&amp;v_{2^k}\     e_2&amp;e_2+v_2&amp;\dots&amp;e_2+v_i&amp;\dots&amp;e_2+v_{2^k}\      e_3&amp;e_3+v_2&amp;\dots&amp;e_3+v_i&amp;\dots&amp;e_3+v_{2^k}\   \vdots  \ e_{2^{n+k}}&amp;e_{2^{n+k}}+v_2&amp;\dots&amp;e_{2^{n+k}}+v_i&amp;\dots&amp;e_{2^{n+k}}+v_{2^k}\ \end{bmatrix}<br>$$</p><p>性质1：同一行中任意两个n重之和为一个码字。<br>性质2：在标准阵中，同一行没有两个n重是相同的，每个n重在且仅在一行中出现。</p><blockquote><p>性质2的证明：</p></blockquote><ol><li>假设第l行有2个n重是相同的，如对i≠j有$e_l+v_i&#x3D;e_l+v_j$，即$v_i&#x3D;v_j$，这与标准阵的构造相矛盾，故性质2的第一句话得证。</li><li>首先由定义知每个n重至少出现一次，假设一个n重在第l行和第m行(l&lt;m)都出现，则必存在i，使得该n重等于$e_l+v_i$，且存在j，使得该n重等于$e_m+v_j$，即有$e_m&#x3D;e_l+(v_i+v_j)&#x3D;e_l+v_s$，这意味着$e_m$在第l行，这与标准阵的构造定义相矛盾。<blockquote></blockquote></li></ol><h2 id="陪集"><a href="#陪集" class="headerlink" title="陪集"></a>陪集</h2><p>定义：标准阵中共有$2_{n-k}$行，它们称为码C的陪集。<br>陪集首：每个陪集中的第一个n重$e_i$称为陪集首。陪集中的任 何一个元素都可以作为陪集首，需要做置换操作。</p><p>对于一个码字$v_i$, 如果信道造成的错误图样是陪集首, 则接收矢量r在陪集中, 此时, 可以将接收矢量正确的译码为$v_i$; 否则, 若信道造成的错误图样不是陪集首, 则会造成错误译码。</p><blockquote><p>定理：陪集首是可纠正的错误图样，共有2n-k个可纠正的错误图样。</p></blockquote><h2 id="基于标准阵的译码方法"><a href="#基于标准阵的译码方法" class="headerlink" title="基于标准阵的译码方法"></a>基于标准阵的译码方法</h2><p>方法：如果接收矢量r落在标准阵中的第i行第j列，那么就将r译码为vj，同时错误图样为ei，即$r&#x3D;e_i+v_j$。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%203.png" alt="Untitled"></p><p>缺点：当所考虑的码C的n和k的值都很大的时候，标准阵列的长度就变得非常的巨大，此时，用标准阵来译码就变得不实用了。</p><h2 id="最小距离译码方法"><a href="#最小距离译码方法" class="headerlink" title="最小距离译码方法"></a>最小距离译码方法</h2><p>方法：对BSC信道，为了使译码错误概率最小，可以选择汉明重量最小的n重做为陪集首，即将接收矢量r译码为与r的汉明距离最小的那个码字。</p><blockquote><p>举例：考虑码C&#x3D;{00000,01010,10101,11111}，<br>该码的最小距离是2。<br>如果传输的码字是11111，接收的矢量是11110，那么，<br>d(11110, 00000)&#x3D;4, d(11110, 01010)&#x3D;2,<br>d(11110, 10101)&#x3D;3, d(11110, 11111)&#x3D;1。<br>用最小距离译码方法可以得出传输的码字就是11111这样的结论。</p></blockquote><blockquote><p>思考题：有办法来给标准阵降阶么?<br>结合前面计算伴随式的例子，可以知道伴随式比标准阵的长度短很多。因此，可以用伴随式译码来代替标准阵译码方法。</p></blockquote><h2 id="伴随式译码"><a href="#伴随式译码" class="headerlink" title="伴随式译码"></a>伴随式译码</h2><p>定理：一个陪集的所有$2^k$个n重有同样的伴随式。不同陪集的伴随式不同。</p><p>证明：如果x,y属于同一个陪集，那么</p><p>$$<br>\Leftrightarrow x+C&#x3D;y+C\ \Leftrightarrow x-y \in C\ \Leftrightarrow(x-y)H^T&#x3D;0\ \Leftrightarrow xH^T&#x3D;yH^T\ \Leftrightarrow S(x)&#x3D;S(y)<br>$$</p><p>伴随式译码举例:</p><p>举例：考虑码C&#x3D;{0000,1011,0101,1110}，对应的标准阵就是</p><p>$$<br>\begin{matrix}   0000&amp;1011&amp;0101&amp;1110&amp;00\ 1000&amp;0011&amp;1101&amp;0110&amp;11\ 0100&amp;1111&amp;0001&amp;1010&amp;01\ 0010&amp;1001&amp;0111&amp;1100&amp;10\ 陪集首&amp;&amp;&amp;&amp;伴随式\end{matrix}<br>$$</p><p>如果接收矢量是v&#x3D;(1101)，先通过公式$S&#x3D;vH^T$求出伴随式(11)，确定对应的陪集首(1000)，这就是错误向量e。然后根据e+v&#x3D;(1000)+(1101)求出传输的码字为(0101)</p><h2 id="完备码"><a href="#完备码" class="headerlink" title="完备码"></a>完备码</h2><p>定义：一个能达到汉明界的码成为完备码，满足</p><p>$$<br>M\begin{Bmatrix}\begin{pmatrix}n\0  \end{pmatrix}+ \begin{pmatrix}n\1  \end{pmatrix}(q-1)+ \begin{pmatrix}n\2  \end{pmatrix}(q-1)^2+ \dots+\begin{pmatrix}n\t  \end{pmatrix}(q-1)^t \end{Bmatrix} &#x3D;q^n<br>$$</p><p>其中, M为码字数目, q是q元, n是码长, t是纠错能力</p><p>特殊的, 对于二元完备码, 满足$2^{n-k}&#x3D;\sum^{t}_{i&#x3D;0}\begin{pmatrix}n\i  \end{pmatrix}$</p><h2 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h2><p>定理：q元汉明码Ham(r,q)是参数为(n,k,d)的线性码，其中,$r&#x3D;n-k, n&#x3D;(q^r-1)&#x2F;(q-1), k&#x3D;(q^r-1)&#x2F;(q-1)-r, d_{min}&#x3D;3$。</p><p>特殊的, 对于二元汉明码, 满足$(n, k)&#x3D;(2^r-1, 2^r-1-r)$。</p><blockquote><p>构造汉明码的两种方法：</p></blockquote><ol><li>构造H阵的标准形式H&#x3D;[Q Ir], Q是构造Ir后剩下的2r-1-r列任意排列。</li><li>H阵的列是按r重表示的二进制数的顺序排列。<blockquote></blockquote></li></ol><h1 id="第四章-循环码"><a href="#第四章-循环码" class="headerlink" title="第四章 循环码"></a>第四章 循环码</h1><p>循环移位：将n重$v&#x3D;(v_{n-1}, v_{n-2}, … , v_1, v_0)$的分量循环左移一位, 得到另一个n重$v(1)&#x3D;(v_{n-2}, … , v_1, v_0, v_{n-1})$, 称为v的循环移位。若v的分量循环左移i位, 得到$v(i)&#x3D;(v_{n-i-1}, … , v_1, v_0, v_{n-1}, … , v_{n-i})$。</p><p>循环码的定义：一个(n, k)线性码C，若它的每个码字的任何循环移位都仍然是一个码字，则称此码为循环码。</p><blockquote><p>循环码的优势：具有许多固有的代数结构，可以找到各种实用的译码方法，使用具有反馈的线性移位寄存器可以容易的实现编码和伴随式计算。</p></blockquote><h2 id="码字多项式"><a href="#码字多项式" class="headerlink" title="码字多项式"></a>码字多项式</h2><p>码字多项式：为研究循环码的代数特性，将码字$v&#x3D;(v_{n-1}, v_{n-2}, … , v_1, v_0)$的各个分量看成是多项式</p><p>$$<br>v(x)&#x3D;\sum^{n-1}<em>{i&#x3D;0}v_ix^i&#x3D;v</em>{n-1}x^{n-1}+\dots+v_1x+v_0<br>$$</p><p>的系数，此多项式称为v的码字多项式。</p><p>对应于码矢v(i)&#x3D;( vn-i-1, … , v1, v0, vn-1, … , vn-i)的码字多项式为$v^{(i)}(x)&#x3D;v_{n-i-1}x^{n-1}+v_{n-i-2}x^{n-2}+…+v_1x^{i+1}+v_0x^i+v_{n-1}x^{i-1}+…+v_{n-i+1}x+v_{n-i}$</p><p>码字多项式$v^{(i)}(x)$就是$x^iv^{(0)}(x)&#x2F;(x^n+1)$的余式。</p><h2 id="循环码的代数性质"><a href="#循环码的代数性质" class="headerlink" title="循环码的代数性质"></a>循环码的代数性质</h2><blockquote><p>定理1：循环码C中次数最低的非零码字多项式是唯一的。</p></blockquote><p>证明：令$g(x)&#x3D;\sum^r_{i&#x3D;0}g_ix_i,g_r&#x3D;1$是C中次数最低的码字多项式，若g(x)不唯一，则存在另一个码字多项式$g*(x)&#x3D;\sum^r_{i&#x3D;0}g^*_ix_i,g^*_r&#x3D;1$ ，由线性性质可知，g(x)+g*(x)也是一个码字多项式，但它的次数小于r，和前提矛盾，因此，循环码C中次数最低的非零码字多项式是唯一的。证毕。</p><blockquote><p>定理2：若$g(x)&#x3D;x^r+g_{r-1}x^{r-1}+…+g_1x+g_0$是(n, k)循环码C中次数最低的非零码字多项式, 则必有$g_0&#x3D;1$。</p></blockquote><p>证明：若$g_0&#x3D;0$，则$g(x)&#x3D;x(x^{r-1}+g_{r-1}x^{r-2}+…+g_2x+g_1)$，将g(x)循环左移n-1位之后，可以得到一个次数更低的码字多项式，其次数为r-1，和前提矛盾，则必有$g_0&#x3D;1$。证毕。<br>结合定理1和定理2，知在(n,k)循环码中，次数最低的非零码字多项式形如$g(x)&#x3D;x^r+g_{r-1}x^{r-1}+…+g_1x+1$。</p><p>考虑多项式$g^{(1)}(x)&#x3D;xg(x), g^{(2)}(x)&#x3D;x^2g(x),…，g^{(n-r-1)}(x)&#x3D;x^{n-r-1}g(x)$都是g(x)的循环移位, 它们都是码字多项式, 次数分别为r+1, r+2, …, n-1。<br>根据码字多项式的线性性质可知，它们的任意线性组合<br>$v(x)&#x3D;u_{n-r-1}x^{n-r-1}g(x)+…+u_1xg(x)+u_0g(x)&#x3D;(u_{n-r-1}x^{n-r-1}+…+u_1x+u_0)g(x)$也是C的码字多项式。<br>(n, k)循环码的码字多项式, 次数分别为r, r+1, r+2, … , n-1，次数小于或等于n-1并且是g(x)的倍式的二元多项式共有$2^{n-r}$个, 它们是(n, k)循环码C的所有码字, 因此, 必有k&#x3D;n-r或r&#x3D;n-k。</p><blockquote><p>定理3：若g(x)是(n, k)循环码C中次数最低的非零码字多项式，一个次数小于或等于n-1的二元多项式f(x)是码字多项式当且仅当f(x)是g(x)的倍式。</p></blockquote><p>证明：反证法。设f(x)是码字多项式且其次数小于或等于n-1,假设f(x)&#x3D;a(x)g(x)+b(x), deg(b(x))&lt;r，<br>由线性性质知b(x)&#x3D;f(x)+a(x)g(x)也是一个码字多项式,而deg(b(x))&lt;deg(g(x))，这和前提矛盾，则只能当f(x)是g(x)的倍式的时候，f(x)是码字多项式。证毕。</p><h2 id="生成多项式"><a href="#生成多项式" class="headerlink" title="生成多项式"></a>生成多项式</h2><blockquote><p>定理1：在(n,k)循环码C中存在且仅存在一个次数为n-k的码字多项式$g(x)&#x3D;x^{n-k}+g_{n-k-1}x^{n-k-1}+…+g_2x^2+g_1x+1$，称为生成多项式，使得每个次数小于或等于n-1的二元多项式是码字多项式当且仅当此多项式是g(x)的倍式。</p></blockquote><blockquote><p>定理2：(n, k)循环码的生成多项式g(x)是$x^n+1$的因式。</p></blockquote><p>证明：根据：码字多项式$v^{(i)}(x)$就是$x^iv^{(0)}(x)&#x2F;(x^n+1)$的余式。则有$x^kg(x)&#x3D;(x^n+1)+g^{(k)}(x)$，而$g^{(k)}(x)$是g(x)的k次循环移位，也是码字多项式，因此，它是g(x)的倍式。</p><blockquote><p>定理3：若g(x)是一个n-k次多项式，并且是$x^n+1$的因式，则g(x)生成一个(n, k)循环码。</p></blockquote><h2 id="循环码的生成矩阵"><a href="#循环码的生成矩阵" class="headerlink" title="循环码的生成矩阵"></a>循环码的生成矩阵</h2><p>考虑以$g(x)&#x3D;\sum^{n-k}_{i&#x3D;0}g_ix^i$为生成矩阵的(n,k)循环码C，由于$g(x), xg(x), … , x^{k-1}g(x)$张成C，将这k个多项式的k个n重做为k×n阶矩阵的行，一般选择前k-1位为0的向量作为g(x)，则得到C的生成矩阵为</p><p>$$<br>G(x)&#x3D;\begin{bmatrix} x^{K-1}g(x)\ \dots \xg(x)\g(x) \end{bmatrix}&#x3D;\begin{bmatrix} g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0&amp;0&amp;0&amp;0&amp;\dots&amp;0\ 0&amp;g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0&amp;0&amp;0&amp;\dots&amp;0\ 0&amp;0&amp;g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0&amp;0&amp;\dots&amp;0\ \dots&amp;&amp;&amp;\dots&amp;&amp;&amp;&amp;&amp;&amp;\dots \ 0&amp;0&amp;\dots&amp;0&amp;0&amp;g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0\end{bmatrix}<br>$$</p><p>其中$g_0&#x3D;g_{n-k}&#x3D;1$</p><h2 id="一致校验矩阵"><a href="#一致校验矩阵" class="headerlink" title="一致校验矩阵"></a>一致校验矩阵</h2><p>因为生成多项式g(x)是$x^{n+1}$的因式, 所以存在另一个多项式$h(x)&#x3D;\sum^k_{i&#x3D;0}h_ix^i,h_k&#x3D;h_0&#x3D;1$ , 使得g(x)h(x)&#x3D;xn+1, 此多项式h(x)称为码C的校验多项式h(x), 故可以得到码C的一致校验矩阵H。<br>设$v&#x3D;(v_{n-1}, … , v_1,v_0 )$是C的一个码矢, 则v(x)&#x3D;a(x)g(x), 有$v(x)h(x)&#x3D;a(x)g(x)h(x)&#x3D;a(x)(x^n+1)&#x3D;a(x)x^n+a(x)$, 由于deg(a(x))≤k-1, 故在$a(x)x^n+a(x)$中不会出现$x^{n-1}, … , x^{k+1}, x^k$等各次幂, 于是v(x)h(x)的展开式中$x^{n-1}, … , x^{k+1}, x^k$的系数等于零。<br>因此, 得到以下n-k个方程$h_0v_{n-j}+h_1v_{n-j-1}+…+h_kv_{n-j-k}&#x3D;0, j&#x3D;1, … , n-k$。则码C的一致校验矩阵为</p><p>$$<br>H&#x3D;\begin{bmatrix}     h_k&amp;h_{k-1}&amp;h_{k-2}&amp;\dots&amp;h_0&amp;0&amp;0&amp;\dots&amp;0\ 0&amp;h_k&amp;h_{k-1}&amp;\dots&amp;h_1&amp;h_0&amp;0&amp;\dots&amp;0\ \dots\ 0&amp;0&amp;0&amp;\dots&amp;h_k&amp;h_{k-1}&amp;h_{k-2}&amp;\dots&amp;h_0\end{bmatrix}<br>$$</p><h2 id="系统循环码的编码方法"><a href="#系统循环码的编码方法" class="headerlink" title="系统循环码的编码方法"></a>系统循环码的编码方法</h2><p>给定循环码的生成多项式g(x), 可以使该码成为系统形式。<br>假定待编码的消息是$u&#x3D;(u_{k-1}, … , u_1, u_0 )$, 则对应的消息多项式为$u(x)&#x3D;u_{k-1}x^{k-1}+…+u_2x^2+u_1x+u_0$, 从而有$x^{n-k}u(x)&#x3D;u_{k-1}x^{n-1}+…+u_1x^{n-k+1}+u_0x^{n-k}$。<br>用生成多项式g(x)除xn-ku(x), 得到xn-ku(x)&#x3D; a(x)g(x)+b(x), deg(b(x))&lt;n-k。</p><blockquote><p>循环码的编码是由多项式的乘法、除法以及加法运算完成的, 这些运算都可以由移位寄存器、加法器以及门电路来实现。</p></blockquote><p>系统循环码的编码步骤如下：<br>步骤1：先用xn-k乘以消息多项式$u(x)&#x3D;u_{k-1}x^{k-1}+…+u_2x^2+u_1x+u_0$；<br>步骤2：用生成多项式g(x)除$x^{n-k}u(x)$，得到余式b(x)；<br>步骤3：联合b(x)和$x^{n-k}u(x)$，得到码字多项式$v(x)&#x3D;x^n-ku(x)+b(x)$</p><h2 id="复习：多项式的除法"><a href="#复习：多项式的除法" class="headerlink" title="复习：多项式的除法"></a>复习：多项式的除法</h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%204.png" alt="Untitled"></p><h2 id="g-x-除法电路编码器"><a href="#g-x-除法电路编码器" class="headerlink" title="g(x)除法电路编码器"></a>g(x)除法电路编码器</h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%205.png" alt="Untitled"></p><h2 id="伴随式计算和错误检测"><a href="#伴随式计算和错误检测" class="headerlink" title="伴随式计算和错误检测"></a>伴随式计算和错误检测</h2><p>伴随式定义为$S&#x3D;rH^T$<br>对系统循环码而言, $r(x)&#x3D;\sum^{n-1}<em>{i&#x3D;0}r_ix^i$是接收多项式$g(x)&#x3D;\sum^{n-k-1}</em>{i&#x3D;0}g_ix^i$,<br>是生成多项式, 用g(x)去除r(x)所得的余式, 就是伴随式s(x), 即r(x)&#x3D;a(x)g(x)+s(x)。<br>∵ r(x)&#x3D;v(x)+e(x), v(x)&#x3D;q(x)g(x), r(x)&#x3D;a(x)g(x)+s(x)<br>∴ q(x)g(x)+e(x)&#x3D;a(x)g(x)+s(x)<br>∴ e(x)&#x3D;[q(x)+a(x)]g(x)+s(x)</p><h2 id="伴随式的性质"><a href="#伴随式的性质" class="headerlink" title="伴随式的性质"></a>伴随式的性质</h2><p>性质1：令s(x)是接收多项式r(x)的伴随式, 则用生成多项式g(x)除xs(x)所得的余式$s^{(1)}(x)$就是r(x)循环移位一次$r^{(1)}(x)$的伴随式。<br>性质2：(n, k)循环码能够检测长度小于等于n-k的任何突发错误, 换句话说, 每个长度小于等于n-k的突发错误的伴随式不等于0。<br>性质3：伴随式等于生成多项式除错误图样后所得的余式。</p><blockquote><p>伴随式的这些性质对于译码非常有用。举例来说, 若e(x)是可以纠正的错误图样, 则e(x)的循环移位也是可以纠正的错误图样。</p></blockquote><h2 id="循环码的译码"><a href="#循环码的译码" class="headerlink" title="循环码的译码"></a>循环码的译码</h2><blockquote><p>循环码的译码分为3步：1)计算伴随式; 2)由伴随式得到错误图样; 3)纠正错误。</p></blockquote><h1 id="第五章-BCH码"><a href="#第五章-BCH码" class="headerlink" title="第五章 BCH码"></a>第五章 BCH码</h1><h2 id="BCH码简介"><a href="#BCH码简介" class="headerlink" title="BCH码简介"></a>BCH码简介</h2><p>BCH码的优势：纠错能力强, 能够纠正多个随机错误的循环码; 编译码设备不太复杂; 到目前为止, 对于其他线性码的研究方法, 都是先构造一个码, 然后找出它的最小距离, 以估计该码的纠错能力, 对于BCH码, 反过来, 从先指定这个码能纠正多少个随机错误开始进行研究。</p><h3 id="本原元和本原多项式"><a href="#本原元和本原多项式" class="headerlink" title="本原元和本原多项式"></a>本原元和本原多项式</h3><p>本原元：有限域上存在元素a，使得G中的每个非零元素都是a的某次幂的形式，该元素a称为本原元。</p><p>本原多项式：有限域GF(q)上的本原多项式f(x),是系数取自GF(q)上，以扩域$GF(q^m)$中本原元为根的最小多项式。</p><p>定理1：若$b_1,b_2,..,b_{q-1}$是有限域GF(q)上的所有非零元素，则$x^{q-1}-1&#x3D;(x-b_1)(x-b_2)…(x-b_{q-1})$。</p><h3 id="举例-GF-23-上的乘法运算"><a href="#举例-GF-23-上的乘法运算" class="headerlink" title="举例: GF(23)上的乘法运算"></a>举例: GF(23)上的乘法运算</h3><p>选择本原元a&#x3D;x, 本原多项式$p(x)&#x3D;x^3+x+1$</p><table><thead><tr><th>$a^{-\infty}&#x3D;x^{-\infty}&#x3D;0$</th><th>000</th></tr></thead><tbody><tr><td>$a^0&#x3D;x^0&#x3D;1$</td><td>001</td></tr><tr><td>$a^1&#x3D;x$</td><td>010</td></tr><tr><td>$a^2&#x3D;x^2$</td><td>100</td></tr><tr><td>$a^3&#x3D;x+1$</td><td>011</td></tr><tr><td>$a^4&#x3D;x^2+x$</td><td>110</td></tr><tr><td>$a^5&#x3D;x^2+x+1$</td><td>111</td></tr><tr><td>$a^6&#x3D;x^2+1$</td><td>101</td></tr><tr><td>$a^7&#x3D;a^0&#x3D;1$</td><td></td></tr></tbody></table><p>乘法运算：</p><p>$$<br>(010)·(100)<br>\leftrightarrow a^3·a^4&#x3D;1<br>\leftrightarrow001\ (011)·(110)<br>\leftrightarrow a^6·a^5&#x3D;a^4<br>\leftrightarrow110<br>$$</p><p>因为本原元a&#x3D;x, 所以p(a)&#x3D;0</p><p>$$<br>a^3+a+1&#x3D;(x+1)+x+1&#x3D;0\ (011)+(010)+(001)&#x3D;(000)<br>$$</p><h3 id="GF-2-上多项式根的特点"><a href="#GF-2-上多项式根的特点" class="headerlink" title="GF(2)上多项式根的特点"></a>GF(2)上多项式根的特点</h3><p>定理：若f(x)是系数取自GF(2)的多项式, 令b是GF(2)扩域中的元素, 若b是f(x)的根, 则对任意的l≥0, $b^{2l}$也是f(x)的根。</p><blockquote><p>注：元素$b^{2l}$称为b的共轭元，以上定理说明若是b多项式f(x)的根，则b的所有共轭元$b^{2l}$也是f(x)的根。</p></blockquote><p>举例：${a^1, a^2, a^4}$是共轭的元素，因为它们都是极小多项式$f_2(x)&#x3D;x^3+x+1$的根。</p><p>最低公倍式：若f(x)为a(x)与b(x)的所有公倍式中次数最低的，并且首项系数为1，记为LCM(a(x), b(x))。</p><h2 id="BCH码的定义"><a href="#BCH码的定义" class="headerlink" title="BCH码的定义"></a>BCH码的定义</h2><p>BCH码的定义：给定任一有限域GF(q)及其扩域$GF(q^m)$, 其中, q是素数或者素数幂, m为一个正整数。若码元是取自GF(q)上的一个循环码, 它的生成多项式g(x)的根集合R中含有以下2t个连续根${b^p, b^{p+1},.., b^{p+2t-1}}$, 则由g(x)生成的循环码称为q进制的BCH码, 其中$b∈GF(q^m)$是域中的n阶元素, $b^{p+i} ∈GF(q^m) (0≤i≤2t-1)$, p是任意整数。对于常见的情况, p等于0或者1。若p&#x3D;1, 称之为狭义的BCH码。</p><p>本原BCH码的定义：若g(x)的根中有一个是$GF(q^m)$的本原元, 码长$n&#x3D;q^m-1$, 此时就称g(x)生成的BCH码为本原BCH码; 否则就称为非本原BCH码, 其码长是$q^m-1$的因子。</p><h3 id="BCH码的构造"><a href="#BCH码的构造" class="headerlink" title="BCH码的构造"></a>BCH码的构造</h3><p>构造方法：设$f_i(x)$和$q_i$分别是$b^{p+i}(0≤i≤2t-1)$的最小多项式和阶, 则BCH码的生成多项式g(x)和码长n可分别表示为$g(x)&#x3D;LCM(f_0(x), f_1(x),…, f_{2t-1}(x)), n&#x3D;LCM(q_0, q_1,…, q_{2t-1})$。</p><blockquote><p>构造可以纠t个错误的BCH码(其码长$n&#x3D;q^m-1$)的生成多项式的步骤如下：<br>步骤1：选择一个阶数为m的本原多项式, 构造扩域$GF(q^m)$;<br>步骤2：找到对应于$b^i(i&#x3D;1,…,p)$的极小多项式$f_i(x)$;<br>步骤3：能纠t个错误的BCH码的生成多项式为$g(x)&#x3D;LCM(f_1(x), f_2(x),…, f_{2t}(x))$。</p></blockquote><h3 id="BCH码限定理"><a href="#BCH码限定理" class="headerlink" title="BCH码限定理"></a>BCH码限定理</h3><p>定理1：若BCH码的生成多项式g(x)的根含有2t个连续根, 则该码的最小距离d≥2t+1。</p><p>d&#x3D;2t+1称为该码的设计距离。</p><blockquote><p>注：一旦固定n和t, 就可以得到该BCH码的生成多项式, 信息位的长度k可以由生成多项式的阶数得到。</p></blockquote><p>当n不变的情况下，较大的t，就会使得k较小；即冗余度高，可以纠更多的错误。</p><blockquote><p><strong>思考题</strong>：如何在由GF(2)生成的扩域GF(24)上构造BCH码的生成多项式？</p></blockquote><p>考虑本原多项式$p(z)&#x3D;z^4+z+1$, 本原元a&#x3D;z, a的幂次可以生成$GF(2^4)$上的所有非零元素。</p><table><thead><tr><th>a的幂次</th><th>$GF(2^4)$上的非零元素</th><th>极小多项式</th></tr></thead><tbody><tr><td>$a^1$</td><td>$z$</td><td>$x^4+x+1$</td></tr><tr><td>$a^2$</td><td>$z^2$</td><td>$x^4+x+1$</td></tr><tr><td>$a^3$</td><td>$z^3$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^4$</td><td>$z+1$</td><td>$x^4+x+1$</td></tr><tr><td>$a^5$</td><td>$z^2+z$</td><td>$x^2+x+1$</td></tr><tr><td>$a^6$</td><td>$z^3+z^2$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^7$</td><td>$z^3+z+1$</td><td>$x^4+x^3+1$</td></tr><tr><td>$a^8$</td><td>$z^2+1$</td><td>$x^4+x+1$</td></tr><tr><td>$a^9$</td><td>$z^3+z$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^{10}$</td><td>$z^2+z+1$</td><td>$x^2+x+1$</td></tr><tr><td>$a^{11}$</td><td>$z^3+z^2+z$</td><td>$x^4+x+1$</td></tr><tr><td>$a^{12}$</td><td>$z^3+z^2+z+1$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^{13}$</td><td>$z^3+z^2+1$</td><td>$x^4+x^3+1$</td></tr><tr><td>$a^{14}$</td><td>$z^3+1$</td><td>$x^4+x^3+1$</td></tr><tr><td>$a^{15}$</td><td>1</td><td>x+1</td></tr></tbody></table><p>如果想要构造可以纠1个错误的BCH码的生成多项式, 即t&#x3D;1, 码长n&#x3D;15<br>BCH码的生成多项式为$g(x)&#x3D;LCM(f_1(x), f_2(x),…, f_{2t}(x))$<br>根据上页的表格来获得极小多项式f1(x)和f2(x)<br>因此, 得到如下的可以纠正一个错误的BCH码的生成多项式$g(x)&#x3D;LCM(f_1(x), f_2(x))&#x3D; LCM(x^4+x+1, x^4+x+1)&#x3D;x^4+x+1$<br>∵deg(g(x))&#x3D;4, ∴n-k&#x3D;4, k&#x3D;11, 这样就得到了一个可以纠一个错误的BCH(15, 11)码, 该码的设计距离d&#x3D;2t+1&#x3D;3<br>可以计算出该码的最小距离也是3，即该码的设计距离等于该码的最小距离</p><p>如果想要构造可以纠2个错误的BCH码的生成多项式, 即t&#x3D;2, 码长n&#x3D;15<br>BCH码的生成多项式为$g(x)&#x3D;LCM(f_1(x), f_2(x),…, f_{2t}(x))&#x3D; LCM(f_1(x), f_2(x), f_3(x), f_4(x))$<br>根据11页的表格来获得极小多项式f1(x)-f4(x)<br>于是得到$g(x)&#x3D;LCM(f_1(x), f_2(x) , f_3(x), f_4(x))&#x3D; LCM(x^4+x+1, x^4+x+1, x^4+x^3+x^2+x+1, x^4+x +1)&#x3D;(x^4+x+1)(x^4+x^3+ x^2+x+1) &#x3D;x^8+x^7+x^6+x^4+1$<br>∵deg(g(x))&#x3D;8，∴n-k&#x3D;8，k&#x3D;7, 这样就得到了一个可以纠一个错误的BCH(15,7)码，该码的设计距离d&#x3D;2t+1&#x3D;5<br>可以计算出该码的最小距离也是5。</p><h1 id="第六章-RM码"><a href="#第六章-RM码" class="headerlink" title="第六章 RM码"></a>第六章 RM码</h1><h3 id="RM码的优点和缺点"><a href="#RM码的优点和缺点" class="headerlink" title="RM码的优点和缺点"></a>RM码的优点和缺点</h3><p><strong>缺点</strong>：与BCH码相比，除了一阶RM码和中等码长的RM码外，RM码的最小距离比同样码长的BCH码的最小距离小。RM码的纠错性能不如Turbo码和LDPC码<br><strong>优点</strong>：RM码能用大逻辑译码算法，比BCH码用的迭代算法简单。译码延时短，无错误平层现象，其误码率会随着信噪比增加无限接近于零。因此，RM码可以适应多种不同的信道，满足有实时性要求的应用环境，既可以单独使用，也可以作为内码与RS码等级联使用，从而大大提升纠错性能</p><h2 id="线性码"><a href="#线性码" class="headerlink" title="线性码"></a>线性码</h2><p><strong>定义</strong>：一个码长为n的p元码C叫做线性码，是指C是向量空间$F_p^n$的向量子空间，即C满足如下的性质：对$F_p^n$中任意元素α和β，如果$c_1$和$c_2$属于C，则$αc_1+βc_2$也属于C。<br><strong>定理</strong>：设C是参数为(n,k)的p元线性码。<br>1)若G是C的一个生成矩阵，而H是Fp上一个(n−k)行n列的矩阵。则H是C的一个校验矩阵当且仅当$rank(H)&#x3D;n−k$，并且$HG^T&#x3D;0_{n−k,k}$；<br>2) 若$G&#x3D;(I_k,P), H&#x3D;(−P^T,I_{n−k})，$则G是C的一个生成矩阵当且仅当H是C的一个校验矩阵。</p><h2 id="向量外积"><a href="#向量外积" class="headerlink" title="向量外积"></a>向量外积</h2><p><strong>定义</strong>：设$a&#x3D;(a_{n−1},a_{n−2},···,a_0),b&#x3D;(b_{n−1},b_{n−2},···,b_0)$是GF(2)上的两个n维向量，则向量$(a_{n−1}b_{n−1},a_{n−2}b_{n−2},···,a_0b_0)$称为a与b的外积，记为a×b。</p><h2 id="布尔函数"><a href="#布尔函数" class="headerlink" title="布尔函数"></a>布尔函数</h2><p><strong>定义</strong>：设m为正整数，一个m元布尔函数$f&#x3D;f(x_1,···,x_m)$是由$F_2^m$到$F_2$的映射，即m个变量$x_1,···,x_m$均取值于$F_2$，并且函数值也属于$F_2$。<br>由于$F_2^m$中向量的个数为$2^m$，而f在每个向量的取值均彼此独立地可取1或0，所以m元布尔函数共有$2^{2^m}$个。</p><blockquote><p>例子：一元布尔函数f(x)共有$2^{2^1}&#x3D;4$个，它们是：<br>1）f(0)&#x3D;f(1)&#x3D;0，即f(x)≡0；<br>2）f(0)&#x3D;f(1)&#x3D;1,即f(x)≡1；<br>3）f(0)&#x3D;0,f(1)&#x3D;1，即f(x)&#x3D;x；<br>4）f(0)&#x3D;1,f(1)&#x3D;0，即f(x)&#x3D;x+1。</p></blockquote><p><strong>定理</strong>：每个m元布尔函数$g(x_1,···,x_m)$均可唯一地表示成$g(x_1,···,x_m)&#x3D;c+c_1x_1 + ··· +c_mx_m+c_{12}x_1x_2+c_{13}x_1x_3+ ··· + c_{m-1,m}x_{m-1}x_m+c_{123}x_1x_2x_3+ ··· + c_{12···m}x_1x_2···x_m$，其中所有系数和常数都属于$F_2$。</p><p>令$v_0&#x3D;(0,0,···,0), v_1&#x3D;(1,0,···,0), v_2&#x3D;(0,1,···,0), v_3&#x3D;(1,1,···,0), ··· ,v_n-1&#x3D;(1,1,···,1), n&#x3D; 2^m，$然后便可把每个m元布尔函数$f(x_1,···, x_m)$表示成$F_2^n$中的向量(也叫 f 的真值表或向量表示)，具体为$c_f&#x3D;(f(v_0), f(v_1),···, f(v_{n-1}))∈F_2^n, n&#x3D; 2^m$<br>这时布尔函数相加和相乘分别对应于向量按分量相加和相乘。</p><h2 id="RM码"><a href="#RM码" class="headerlink" title="RM码"></a>RM码</h2><p><strong>定义</strong>：设$m≥1, n&#x3D;2^m, 0≤r≤m$。向量空间$F_2^n$的子集合<br>$RM(r,m)&#x3D;{c_f&#x3D;(f(v_0), f(v_1),···, f(v_{n-1}))∈F_2^n|f∈B_m,deg(f)≤r}$<br>叫做r阶的Reed-Muller码(简称RM码)，这里$v_i∈F_2^m$。</p><p><strong>定理</strong>：RM码RM(r,m)是线性码，基本参数为$(n,k,d)&#x3D;(2^m,∑_{t&#x3D;0}^r\begin{pmatrix}m\t\end{pmatrix}),2^{m-r})$</p><h3 id="生成矩阵-1"><a href="#生成矩阵-1" class="headerlink" title="生成矩阵"></a>生成矩阵</h3><p>对于每一对正整数r和m(m&gt;r),有一个码长为$2^m$的RM码，称为码长为$2^m$的r阶RM码。它的生成矩阵是由矩阵块$G_0,G_1,···,G_r$组成的，即$G&#x3D;\begin{pmatrix}G_0\G_1\\dots\G_r\end{pmatrix}$</p><p>G0是码长为$n&#x3D;2^m$的全“1”向量<br>G1是$m×2^m$阶矩阵，即$G_1$是由所有长度为m的二进制的列向量组成的。$G_1$的最左边一列是全“0”向量，最后一列为全“1”向量，其他各列则是从左至右依递增顺序排列的二进制m重列向量<br>$G_l$的行是由所有$G_l$的l个行向量作外积所得的向量组成，因而$G_l$是一个$\begin{pmatrix} m\l\end{pmatrix}*2^m$阶矩阵。显然在G的行是线性无关的条件下，r阶RM码的信息位为$k&#x3D;1+\begin{pmatrix} m\l\end{pmatrix}+\begin{pmatrix} m\2\end{pmatrix}+\dots+\begin{pmatrix} m\r\end{pmatrix}$。</p><h3 id="RM码的构造"><a href="#RM码的构造" class="headerlink" title="RM码的构造"></a>RM码的构造</h3><p>从RM码的定义可以看出，一个r阶RM码可以通过增广一个(r-1)阶RM码得到，而一个(r-1)阶RM码可以由删信一个r阶RM码而获得，即通过简单计算，增加一个G矩阵分量或直接删除一个G矩阵分量<br>RM码的构造简单，纠错能力强，很容易根据需要设计出不同码长的RM码</p><h2 id="译码算法"><a href="#译码算法" class="headerlink" title="译码算法"></a>译码算法</h2><p>从RM码的生成矩阵G中可以看出，Gl的每行重量为$2^{m-l}$，这个结论对于一般的r阶RM码都是对的，因此，G的每行都有偶重量<br>在GF(2)上，因为两个偶重量向量之和必为偶重量，所以G的行线性组合有偶重量。即RM码的所有码字重量皆为偶数<br>由于Gr行的重量为$2^{m-l}$，因而r阶RM码的最小重量不大于$2^{m-l}$</p><p>里德算法是专门为RM码设计的译码算法<br>里德算法使用择多逻辑判决的方法从接收矢量直接恢复信息，而不计算错误图样<br>里德算法可以纠正r阶RM码出现的$(1&#x2F;2)×2^{m-r}−1$个随机错误，并恢复k位信息。这说明码的最小重量至少为$2^{m-r}−1$，又RM码的最小重量为偶数，因而r阶RM码最小重量至少为$2^{m-r}$<br>综上所述，r阶RM码最小重量为$2^{m-r}$，即RM码最小距离为$2^{m-r}$<br>将信息向量分成r+1段，即写成$m&#x3D;(I_0,I_1,⋯,I_r)$,其中$I_i$包含$\begin{pmatrix} m\l\end{pmatrix}$个信息位，于是编程可表示为$v&#x3D;I_0G_0+I_1G_1+⋯+I_rG_r$  (1.1)<br>如果接收码字$r&#x3D;v+e&#x3D;I_0G_0+I_1G_1+⋯+I_rG_r+e$  (1.2)， 其中e为错误图样<br>通过对r阶RM码的译码计算，由接收码字r恢复了第r段信息Ir，然后计算<br>$r(1)&#x3D;r-I_rG_r&#x3D;I_0G_0+I_1G_1+⋯+I_{r-1}G_{r-1}+e$  (1.3)<br>这就把由接收码字r恢复m的问题简化成由r(1)恢复信息$m^{(1)}&#x3D;(I_0,I_1,⋯,I_{r-1})$的问题<br>继续采用同样方法就可逐步恢复所有信息，最终完成r阶RM码的译码</p><h1 id="第七章-卷积码"><a href="#第七章-卷积码" class="headerlink" title="第七章 卷积码"></a>第七章 卷积码</h1><blockquote><p><strong>卷积码与分组码的区别</strong><br>卷积码有记忆性，分组码无记忆性<br>卷积码充分利用了各组信息之间的相关性，信息序列不被分段，而是被连续处理<br>通常，卷积码的n和k比分组码的n和k要小的多<br>在同样的编码效率下，卷积码的性能优于分组码<br>在相似的纠错能力下，卷积码的实现比分组码简单<br>卷积码必须用序列逻辑电路来实现，更适用于前向纠错系统；分组码是用组合逻辑电路来实现</p></blockquote><h2 id="离散序列的非循环卷积运算"><a href="#离散序列的非循环卷积运算" class="headerlink" title="离散序列的非循环卷积运算"></a>离散序列的非循环卷积运算</h2><p>定义：设f(n)和g(n)是两个序列，则序列f和g的离散卷积运算为</p><p>$$<br>(f*g)(m)&#x3D;\sum_nf(n)g(m-n)<br>$$</p><h2 id="二元-2-1-2-卷积码的编码器"><a href="#二元-2-1-2-卷积码的编码器" class="headerlink" title="二元(2,1,2)卷积码的编码器"></a>二元(2,1,2)卷积码的编码器</h2><p>编码器主要由m&#x3D;2级移位寄存器，n&#x3D;2个模2加法器组成。所有的卷积码编码器都可以用这种类型的线性前馈移位寄存器来实现。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%206.png" alt="Untitled"></p><h3 id="冲激响应"><a href="#冲激响应" class="headerlink" title="冲激响应"></a>冲激响应</h3><blockquote><p>冲激响应：编码器的冲激响应就是通过令u&#x3D;(100…)所得到的两个输出序列。</p></blockquote><p>因为编码器有m个存储单元，所以冲激响应(生成序列)至多持续m+1个时间单元，且可以写成</p><p>$$<br>g^{(1)}&#x3D;(g^{(1)}_0,g^{(1)}_1,…,g^{(1)}_m),g^{(2)}&#x3D;(g^{(2)}_0,g^{(2)}_1,…,g^{(2)}_m)<br>$$</p><p>其中上标表示第几个输出端</p><blockquote><p>图6.1的(2,1,2)卷积码的冲激响应为$g^{(1)}&#x3D;(111), g^{(2)}&#x3D;(101)$<br>另外，冲激响应向量还可以表示输入、移位寄存器和输出之间的连接关系，1表示有连接，0表示没有连接</p></blockquote><h3 id="输出序列"><a href="#输出序列" class="headerlink" title="输出序列"></a>输出序列</h3><p>信息序列$u&#x3D;(u_1,u_2,u_3,…)$每次进入编码器1比特，编码器的两个输出序列</p><p>$$<br>v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…)<br>$$</p><p>可以通过输入序列u和编码器的两个冲激响应作卷积运算而得到。</p><blockquote><p>若u&#x3D;(1011), 图6.1的(2,1,2)卷积码的冲激响应为$g……{(1)}&#x3D;(111), g^{(2)}&#x3D;(101)$，则该卷积码的输出序列为$V^{(1)}&#x3D;u^<em>g^{(1)}&#x3D;(110001)$</em>, $V^{(2)}&#x3D;u^<em>g^{(2)}&#x3D;(100111)$</em></p></blockquote><h3 id="码字"><a href="#码字" class="headerlink" title="码字"></a>码字</h3><p>输出序列分别为$v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…)$的$(2,1,m)$的卷积码的码字，为$V^{(1)}$和$V^{(2)}$的交错，即</p><p>$$<br>v&#x3D;(v^{(1)}_0,v^{(2)}_0,v^{(1)}_1,v^{(2)}_1,…)<br>$$</p><blockquote><p>图6.1的(2,1,2)卷积码，若u&#x3D;(1011), 冲激响应为$g^{(1)}&#x3D;(111)$, $g^{(2)}&#x3D;(101)$，该卷积码的输出序列为$V^{(1)}&#x3D;u^<em>g^{(1)}&#x3D;(110001)$</em>, $V^{(2)}&#x3D;u^*g^{(2)}&#x3D;(100111)$*，得到的码字为v&#x3D;(11,10,00,01,01,11)</p></blockquote><p>以u&#x3D;(u1,u2,u3,…)为输入, 以$g^{(1)}&#x3D;(g^{(1)}_0,g^{(1)}_1,…,g^{(1)}_m),g^{(2)}&#x3D;(g^{(2)}_0,g^{(2)}_1,…,g^{(2)}_m)$</p><p>为生成序列的(2,1,m)卷积码的输出序列分别由方程$V^{(1)}&#x3D;u^*g^{(1)}$<em>和$V^{(2)}&#x3D;u^</em>g^{(2)}$*得到。</p><blockquote><p>图6.1的(2,1,2)卷积码的编码方程为<br>另外，编码方程中每一项的系数，还可以表示输入、移位寄存器和输出之间的连接关系，1表示有连接，0表示没有连接。</p><p>$$<br>\begin{cases} V_l^{(1)}&#x3D;u_l+u_{l-1}+u_{l-2}\ V_l^{(2)}&#x3D;u_l+u_{l-2} \end{cases},[V_l^{(1)}V_l^{(2)}]&#x3D;[u_lu_{l-1}u_{l-2}]\begin{bmatrix} 1&amp;1\1&amp;0\1&amp;1\end{bmatrix}<br>$$</p></blockquote><h3 id="生成矩阵-2"><a href="#生成矩阵-2" class="headerlink" title="生成矩阵"></a>生成矩阵</h3><p>(2,1, m)卷积码的生成矩阵：将生成序列g(1)和g(2)交织后形成的半无限矩阵</p><p>$$<br>G&#x3D;\begin{bmatrix}g^{(1)}_0&amp;g^{(2)}_0&amp;g^{(1)}_1&amp;g^{(2)}_1&amp;g^{(1)}_2&amp;g^{(2)}_2&amp;\dots&amp;g^{(1)}_m&amp;g^{(2)}_m&amp;0&amp;0&amp;0&amp;0&amp;\dots\ 0&amp;0&amp;g^{(1)}_0&amp;g^{(2)}_0&amp;g^{(1)}<em>1&amp;g^{(2)}<em>1&amp;\dots &amp;g^{(1)}</em>{m-1}&amp;g^{(2)}</em>{m-1}&amp;g^{(1)}<em>m&amp;g^{(2)}<em>m&amp;0&amp;0&amp;\dots \0&amp;0&amp;0&amp;0&amp;g^{(1)}<em>0&amp;g^{(2)}<em>0&amp;\dots&amp;g^{(1)}</em>{m-2}&amp;g^{(2)}</em>{m-2}&amp;g^{(1)}</em>{m-1}&amp;g^{(2)}</em>{m-1}&amp;g^{(1)}_m&amp;g^{(2)}_m&amp;\dots\ &amp;&amp;&amp;&amp;&amp;&amp;\ddots\end{bmatrix}<br>$$</p><p>以u&#x3D;(u1,u2,u3,…)为输入, G为生成矩阵的(2,1,m)的卷积码的码字为V&#x3D;uG。</p><h3 id="二元-3-2-1-卷积码的编码器"><a href="#二元-3-2-1-卷积码的编码器" class="headerlink" title="二元(3,2,1)卷积码的编码器"></a>二元(3,2,1)卷积码的编码器</h3><p>编码器主要有2个输入，3个输出，主要由m&#x3D;1级移位寄存器，n&#x3D;3个模2加法器组成。</p><h3 id="二元-3-2-m-卷积码的输入序列"><a href="#二元-3-2-m-卷积码的输入序列" class="headerlink" title="二元(3,2,m)卷积码的输入序列"></a>二元(3,2,m)卷积码的输入序列</h3><p>对于一般的(3,2,m)卷积码，由于k&#x3D;2，即每次有2比特进入编码器，所以输入序列u可以写成$v&#x3D;(v^{(1)}_0,v^{(2)}_0,v^{(1)}_1,v^{(2)}_1,…)$或分开写成2个序列$v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…)$</p><p>二元(3,2,m)卷积码的冲激响应$g^{(j)}<em>i&#x3D;(g^{(j)}</em>{i0},g^{(j)}<em>{i1},…,g^{(j)}</em>{im}),i&#x3D;1,2,j&#x3D;1,2,3$</p><p>输出序列分别为</p><p>$$<br>v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…), v^{(3)}&#x3D;(v^{(3)}_0,v^{(3)}_1,…)<br>$$</p><p>的(3,2,m)的卷积码的码字为</p><p>$$<br>v&#x3D;(v^{(1)}_0,v^{(2)}_0,v^{(3)}_0,v^{(1)}_1,v^{(2)}_1,v^{(3)}_1,…)<br>$$</p><h2 id="卷积码编码器的存储级数"><a href="#卷积码编码器的存储级数" class="headerlink" title="卷积码编码器的存储级数"></a>卷积码编码器的存储级数</h2><p>对于(n,k,m)卷积码，当k&gt;1时，编码器及用来描述它的符号都比较复杂，并且该编码器所含的k个移位寄存器的长度未必相同。</p><blockquote><p>存储级数：若ki是第i个移位寄存器的长度，则称所有k个移位寄存器中的最大长度为存储级数，即编码器的存储级数m定义为$m&#x3D;\max_{1&lt;i&lt;k}k_i$</p></blockquote><h2 id="卷积码编码器的约束长度和码速率"><a href="#卷积码编码器的约束长度和码速率" class="headerlink" title="卷积码编码器的约束长度和码速率"></a>卷积码编码器的约束长度和码速率</h2><p>对于(n, k, m)卷积码，编码器中每个信息位要保持m+1时间个单位，每个时间单位都可以影响编码器输出中的任何一个，这由移位寄存器的连接决定。</p><blockquote><p>约束长度：对于(n,k,m)卷积码，编码器的约束长度定义为$n_A&#x3D;n(m+1)$</p></blockquote><p>约束长度可以解释成1比特信息对编码器输出可以造成影响的最大数目。</p><blockquote><p>码速率：对于(n,k,m)卷积码，其码速率r&#x3D;k&#x2F;n</p></blockquote><h2 id="2-1-m-卷积码的多项式描述"><a href="#2-1-m-卷积码的多项式描述" class="headerlink" title="(2, 1, m)卷积码的多项式描述"></a>(2, 1, m)卷积码的多项式描述</h2><p>信息序列：$u$表示成$u(x)$</p><p>生成多项式：$g^{(1)}$表示成$g^{(1)}(x)$, $g^{(2)}$表示成$g^{(2)}(x)$</p><p>输出序列：$V^{(1)}$表示成$V^{(1)}(x)$, $V^{(2)}$表示成$V^{(2)}(x),$<br>码字：$V$表示成$V(x)$。于是$V^{(1)}(x)&#x3D;u(x)g^{(1)}(x), V^{(2)}(x)&#x3D;u(x)g^{(2)}(x),$<br>码字：$V(x)&#x3D;V^{(1)}(x^2)+xV^{(2)}(x^2)$</p><h2 id="n-k-m-卷积码的转移函数矩阵"><a href="#n-k-m-卷积码的转移函数矩阵" class="headerlink" title="(n, k, m)卷积码的转移函数矩阵"></a>(n, k, m)卷积码的转移函数矩阵</h2><p>于编码器是线性系统, 同任何有k个输入n个输出的线性系统一样，总共有k×n个转移函数。k×n阶转移函数矩阵为</p><p>$$<br>G(x)&#x3D;\begin{bmatrix}g_1^{(1)}&amp;g_1^{(1)}&amp;\dots&amp;g_1^{(1)}\ g_2^{(1)}&amp;g_2^{(1)}&amp;\dots&amp;g_2^{(1)}\ \dots \ g_k^{(1)}&amp;g_k^{(1)}&amp;\dots&amp;g_k^{(1)}\   \end{bmatrix}<br>$$</p><p>于是，码字$V(x)&#x3D;u(x)G(x)$, 其中, $u(x)&#x3D;(u^{(1)}(x), u^{(2)}(x),…, u^{(k)}(x)), V(x)&#x3D;(V^{(1)}(x), V^{(2)}(x),…, V^{(n)}(x))$, 并路之后, 码字变成$V(x)&#x3D;V^{(1)}(x^n)+xV^{(2)}(x^n)+…+x^{n-1}V^{(n)}(xn)$</p><h2 id="维特比-Viterbi-译码系统"><a href="#维特比-Viterbi-译码系统" class="headerlink" title="维特比(Viterbi)译码系统"></a>维特比(Viterbi)译码系统</h2><p>(n,k,m)卷积码, 如输入序列为x，输出码字为c，经过有噪声的信号传输后，得到接收序列r，然后经过Viterbi译码器，得到序列y。</p><p>对于码率为r的(n,k,m) 卷积码, 输入的信息长度为L，则输入序列为<br>$x&#x3D;(x_0^{(1)}, x_0^{(2)},…, x_0^{(k)}, x_1^{(1)}, x_1^{(2)},…, x_1^{(k)},…, x_{L+m-1}^{(1)}, x_{L+m-1}^{ (2)},…, x_{L+m-1 }^{(k)})$<br>对应输出的码字序列为<br>$c&#x3D;(c_0^{(1)}, c_0^{(2)},…, c_0^{(n)}, c_1^{(1)}, c_1^{(2)},…, c_1^{(n)},…, c_{L+m-1}^{(1)}, c_{L+m-1 }^{(2)},…, c_{L+m-1}^{ (n)})$<br>其中下标表示时间。<br>消息序列的尾部需要m个0比特使得移位寄存器的状态归0。一般的，默认移位寄存器从全零状态开始，最终还是以全零状态结束。</p><h1 id="第八章-Turbo码"><a href="#第八章-Turbo码" class="headerlink" title="第八章 Turbo码"></a>第八章 Turbo码</h1><h3 id="Turbo码的优点"><a href="#Turbo码的优点" class="headerlink" title="Turbo码的优点"></a>Turbo码的优点</h3><p>在信噪比较低的高噪声环境下性能优越（信道条件差的移动通信系统中有很大的应用潜力），而且具有很强的抗衰落、抗干扰能力。<br>Turbo码具有超乎寻常的优异的译码性能，可以纠正高速率数据传输时发生的误码。在直扩（CDMA）系统中采用Turbo码技术可以进一步提高系统的容量。<br>在短帧情况下的仿真结果表明短交织Turbo码在AWGN信道和Rayleigh衰落信道下仍具有接近信道容量的纠错能力。</p><h3 id="Turbo码的缺点"><a href="#Turbo码的缺点" class="headerlink" title="Turbo码的缺点"></a>Turbo码的缺点</h3><p>为获得较高的性能，Turbo码的编译码方式较为复杂。<br>具有较大的译码时延，这是由于block长度较大、译码需要多次迭代造成的。这样非常不利实时业务或高速数据的传输。<br>BER(比特出错概率)在10−5后会出现误码平层，这是由于Turbo码的重量分布造成的。对于某些对BER要求较高的应用就不适合，当然通过交织器的设计能够提供更大的码间最小距离，从而降低误码平层。</p><h3 id="分量码"><a href="#分量码" class="headerlink" title="分量码"></a>分量码</h3><p>卷积码的类型多样，如非递归卷积码(NRC)、非系统卷积码(NSC)、递归系统卷积码(RSC)。<br>在实际的系统中，由于RSC有突出的优点而被广泛采用。RSC码在具有良好的译码性能，且存在较高的交织增益，译码性能也会随着交织长度增加而提高。</p><h3 id="交织器"><a href="#交织器" class="headerlink" title="交织器"></a>交织器</h3><p>交织器的主要功能是使码重分布合理，降低数据序列的相关性，增大输出码字的最小汉明距，实现随机编码。</p><p><strong>分组交织器</strong>：将数据序列按行的顺序写入m×n的矩阵，然后按列的顺序读出，即完成交织过程。相应的解交织过程就是将交织后的数据序列按列写入m×n矩阵，再按照行的顺序读出。</p><p><strong>伪随机交织器</strong>：指交织映射随机生成的交织器，每个长度为N的伪随机交织器共有N！种可能的交织形式。这种交织器采用给定的随机地址交织映射，由这个已知的交织表对输入信息序列进行映射。</p><h3 id="删余处理"><a href="#删余处理" class="headerlink" title="删余处理"></a>删余处理</h3><p>在编码完成后，将分量码输出的两路校验信息输入删余器，按照一定的规则删除一部分校验信息，减小信息的冗余度，从而提高编码效率。</p><h2 id="Turbo码编码器的结构"><a href="#Turbo码编码器的结构" class="headerlink" title="Turbo码编码器的结构"></a>Turbo码编码器的结构</h2><p>三种：并行级联卷积码(PCCC)、串行级联卷积码(SCCC)和混合级联卷积码(HCCC)</p><h3 id="并行级联卷积码-PCCC"><a href="#并行级联卷积码-PCCC" class="headerlink" title="并行级联卷积码(PCCC)"></a>并行级联卷积码(PCCC)</h3><p>随机交织器：将信息序列U进行比特位置重排列得到U1（内容不变）<br>分量编码器：生成校验序列 $X_{p1}$ 和 $X_{p2}$（一般两个编码器结构相同）<br>删余矩阵：为了提高码率，周期地删除一些校验位，形成校验位序列Xp<br>复接：未编码序列Xs与Xp经过复接后，生成Turbo码序列X</p><h2 id="Turbo码的码率"><a href="#Turbo码的码率" class="headerlink" title="Turbo码的码率"></a>Turbo码的码率</h2><p>若两个分量码的码率分别为R1和R2，则Turbo码的码率为</p><p>$$<br>R&#x3D;\frac{R_1R_2}{R_1+R_2-R_1R_2}<br>$$</p><h2 id="Turbo码的译码"><a href="#Turbo码的译码" class="headerlink" title="Turbo码的译码"></a>Turbo码的译码</h2><p>Turbo码有一重要特点是其译码较为复杂，比常规的卷积码要复杂的多。<br>这种复杂不仅在于其译码要采用迭代的过程，而且采用的算法本身也比较复杂。</p><h3 id="译码算法-1"><a href="#译码算法-1" class="headerlink" title="译码算法"></a>译码算法</h3><p><strong>MAP算法</strong>：MAP算法采用递推、迭代方法，将最大似然对数比函数作为软判决的输出。但由于该算法需要多次迭代，复杂度较高，运算量非常大，而且对数和指数的运算在数字电路中比较难以实现，导致其在工程实现上受到了很大程度的限制。<br><strong>Max-log-MAP算法</strong>：即最大值运算，在MAP算法基础上通过减少格图搜索状态来达到简化的目的。Max-log-MAP对MAP所做的修改是在对数域里对一些函数进行计算，这样省去了很多的指数的运算和对数域的运算，很大程度上降低了运算的复杂度，大大简化了运算量；但是由于在计算过程有一些近似处理，所以Max-log-MAP算法不是最优的。<br><strong>Log-MAP算法</strong>：即对数域算法，Robertson等人在Max-log-MAP算法基础上进行了一些修改，使得Log-MAP算法相比于Max-log-MAP算法只多了一些查表及加法运算，尽管提高了一点复杂度但是性能却得到很大的提高。<br><strong>SOVA算法</strong>：即软输出Viterbi译码，SOVA算法在标准Viterbi译码算法上进行了一些修改：在进行最大似然路径选择时必须参考其先验信息；不但需要给出每个比特译码的准确结果，还需要计算出每个比特译码的可靠性，通过一些计算从中获取一些关于译码比特的先验信息，从而为下次迭代做好准备，大大减小了运算量，但性能受到了损失，大约损失了1dB。</p><h1 id="第九章-二维码"><a href="#第九章-二维码" class="headerlink" title="第九章 二维码"></a>第九章 二维码</h1><h2 id="二维码的概念与原理"><a href="#二维码的概念与原理" class="headerlink" title="二维码的概念与原理"></a>二维码的概念与原理</h2><p>行排式二维码，又称堆积式二维码或层排式二维码，其编码原理是建立在一维条码基础之上，按需要堆积成二行或多行。</p><p>矩阵式二维码，又称棋盘式二维码，它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码。</p><h2 id="二维码的特点"><a href="#二维码的特点" class="headerlink" title="二维码的特点"></a>二维码的特点</h2><p><strong>可靠性强</strong><br>条形码的读取准确率远远超过人工记录，平均每15000个字符才会出现一个错误。<br><strong>效率高</strong><br>条形码的读取速度很快，相当于每秒40个字符。<br><strong>易于制作</strong><br>条形码的编写很简单，制作也仅仅需要印刷，被称为“可印刷的计算机语言”。<br><strong>高密度</strong><br>二维码通过利用垂直方向的堆积来提高条码的信息密度，而且采用高密度图形表示。<br><strong>构造简单</strong><br>条形码识别设备的构造简单，使用方便。<br><strong>灵活实用</strong><br>条形码符号可以手工键盘输入，也可以和有关设备组成识别系统实现自动化识别，还可以和其他控制设备联系起来实现整个系统的自动化管理。<br><strong>成本低</strong><br>与其它自动化识别技术相比较，条形码技术仅仅需要一小张贴纸和相对构造简单的光学扫描仪，成本相当低廉。<br><strong>纠错功能</strong><br>二维码不仅能防止错误，而且能纠正错误，即使条形码部分损坏，也能将正确的信息还原出来。<br><strong>多语言形式，可表示图像</strong><br>二维码具有字节表示模式，即提供了一种表示字节流的机制。不论何种语言文字它们在计算机中存储时以机内码的形式表现，而内部码都是字节码，可识别多种语言文字的条码。<br><strong>具有加密体制</strong><br>可以先用一定的加密算法将信息加密，再用二维码表示在识别二维条码时，再加以一定的解密算法，便可以恢复所表示的信息。</p><h2 id="QR码的生成与识别"><a href="#QR码的生成与识别" class="headerlink" title="QR码的生成与识别"></a>QR码的生成与识别</h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%207.png" alt="Untitled"></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%208.png" alt="Untitled"></p><p><strong>寻像图形、位置探测图形：</strong><br>协助扫描软件定位QR码并转换坐标系。<br>寻像图形包括三个相同的位置探测图形，分别位于图形中的左上角、右上角和左下角。每个位置探测图形由7*7个模块组成。如图，寻像图形为黑色区域。</p><p><strong>位置探测图形分隔符：</strong><br>区分功能图形和编码区域。<br>每个位置探测图形和编码区域之间有宽度为1个模块的分隔符。位置探测图形分隔符为灰色区域，此区域应为空白。</p><p><strong>定位图形：</strong><br>确定符号的密度和版本，提供决定模块坐标的基准位置。<br>定位图形为图中的茶色区域，水平和垂直的定位图形分别始于第6行和第6列。</p><p><strong>校正图形：</strong><br>在图像有一定程度损坏的情况下，译码软件可以通过它同步图像模块的坐标映像。<br>矫正图形的数量视符号和版本号而定，版本1没有校正图形，版本2及以上均含有校正图形。</p><p><strong>格式信息：</strong><br>存放纠错等级和掩模信息。<br>格式信息是一个15位数据，由2位纠错指示符+3位掩模图形参考+10位纠错码组成，为图中深蓝色区域。</p><p>同时，左下角格式信息编号8上方的橙色区域，此区域永远为深色模块，不用于存放任何信息。</p><p><strong>版本信息：</strong><br>用于存放QR码的版本号。<br>为图中红色区域，两个3*6模块。</p><p><strong>扩展图形：</strong><br>最初的目的是用于将来对QR码功能的扩展，并不用于对数据的编码。<br>扩展图形由位于符号右下角的一个4个模块组成的方块以及位于符号右边和下边的一些8个模块的块组成。8个模块的块的数目取决于符号的版本，计算公式为：<br>8模块的数目&#x3D;2*(N DIV 2)<br>其中N为版本号，DIV表示除法运算。<br>扩展图形为图中红框区域，即版本7中有6个8模块组成的块和1个4模块组成的块。</p><h3 id="QR码的纠错能力："><a href="#QR码的纠错能力：" class="headerlink" title="QR码的纠错能力："></a><strong>QR码的纠错能力：</strong></h3><table><thead><tr><th>级别</th><th>纠错能力</th></tr></thead><tbody><tr><td>L</td><td>约7%</td></tr><tr><td>M</td><td>约15%</td></tr><tr><td>Q</td><td>约25%</td></tr><tr><td>H</td><td>约30%</td></tr></tbody></table><h2 id="举例说明QR码的编码过程。"><a href="#举例说明QR码的编码过程。" class="headerlink" title="举例说明QR码的编码过程。"></a>举例说明QR码的编码过程。</h2><h2 id="识别步骤"><a href="#识别步骤" class="headerlink" title="识别步骤"></a>识别步骤</h2><p>条码定位<br>条码分割<br>解码</p><h3 id="条码定位"><a href="#条码定位" class="headerlink" title="条码定位"></a>条码定位</h3><p>定位采用以下步骤：<br>1.利用点运算的阈值理论将采集到的图像变为二值图像，即对图像进行二值化处理；<br>2.得到二值化图像后，对其进行膨胀运算；<br>3.对膨胀后的图像进行边缘检测得到条码区域的轮廓。<br>4.确定寻像图形<br>5.探测图形中心坐标<br>6.确定两个举例<br>7.确定版本号<br>8.构造位图<br>9.得到纠错等级和掩模图形</p><h3 id="条码分割"><a href="#条码分割" class="headerlink" title="条码分割"></a>条码分割</h3><p>分割采用以下步骤：<br>1.将原图像按比例缩小进行分割，计算其特征值；<br>2.分块继承父块纹理类别，结合其周围纹理类型进行修正；<br>3.重复步骤二直至图像被划分为2*2大小，分割结束；<br>4.分割结束后，图中可能出现的孤立的小区域可作为噪声删除。</p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><pre><code>得到一幅标准的条码图像后，对该符号进行网络取样，对网格每一个交点上的图像像素取样，并根据阈值确定是深色块还是浅色块。构造一个位图，用二进制的“1”表示深色像素，“0”表示浅色像素，从而得到条码的原始二进制序列值，然后对这些数据进行纠错和译码：1.异或处理（XOR）2.确定符号码字3.重新排列码字序列4.执行错误检测和纠错译码程序最后根据条码的逻辑编码规则把这些原始的数据位流转换成数据码字。</code></pre><h1 id="第十章-极化码"><a href="#第十章-极化码" class="headerlink" title="第十章 极化码"></a>第十章 极化码</h1><h2 id="极化码概述与研究现状"><a href="#极化码概述与研究现状" class="headerlink" title="极化码概述与研究现状"></a>极化码概述与研究现状</h2><p>极化码优点：<br>1、是目前唯一的香农信道容量可达的编码方式<br>2、有坚实的理论基础<br>3、编解码复杂度低<br>4、精细的码率调整机制（信息块长度可以一比特一比特的递减）<br>5、极化码的递归特性易于通过硬件实现（母码长度为N的Polar码可以用两个母码长度为N&#x2F;2的Polar码实现）</p><p>极化码缺点：<br>1、汉明距离较小，在短码情况下影响解码性能，一定程度上可以通过选择合适的冻结比特位置进行规避。适合长码编码。<br>2、SC译码延时较大。</p><h3 id="极化（Polar）码起源"><a href="#极化（Polar）码起源" class="headerlink" title="极化（Polar）码起源"></a>极化（Polar）码起源</h3><blockquote><p>截止频率越高，系统响应越快<br>因此Polar码的最初设计的出发点是为了提升截止频率</p></blockquote><p>在随机编码和最大似然条件下，信道截止速率R0决定了相应的码块的错误概率：</p><p>$$<br>P_e&#x3D;2^{−N∙R_0}<br>$$</p><p>其中，N为码块长度。实际信道的传输速率R小于R_0、使用随机编码和ML编码时，信道平均错误概率：</p><p>$$<br>P _e&#x3D;2^{−N（R_0−R）}<br>$$</p><h3 id="极化码的基本原理"><a href="#极化码的基本原理" class="headerlink" title="极化码的基本原理"></a>极化码的基本原理</h3><p>对于Polar码基本原理可以归结为三点：信道合并、信道分离、信道极化。其中信道合并和信道极化是在编码时完成的；信道分离是在解码时完成。</p><p><strong>信道选择：</strong><br>对于编码方案通常根据某种信道设计，Polar码主要考虑以下信道进行分析：</p><p>二进制离散无记忆信道（B-DMC）:二进制删除信道（BEC）;二进制对称信道（BSC）</p>]]></content>
    
    
    <summary type="html">信息论与编码的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://zhangyuanhe.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>复杂网络期末复习总结</title>
    <link href="https://zhangyuanhe.top/2024/01/02/BUPT_note/Review%20of%20Complex%20network/"/>
    <id>https://zhangyuanhe.top/2024/01/02/BUPT_note/Review%20of%20Complex%20network/</id>
    <published>2024-01-02T13:00:00.000Z</published>
    <updated>2024-01-17T12:44:05.446Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h4 id="度、度分布的概念"><a href="#度、度分布的概念" class="headerlink" title="度、度分布的概念"></a><strong>度、度分布的概念</strong></h4><p>度：在网络中，度是一个用来描述节点（即网络中的个体）的重要性的概念。节点的度是指与该节点直接相连的边的数量。</p><p>度分布：度分布是描述网络中每个节点度数的概率分布。它是一个统计量，可以反映整个网络的结构特征。</p><p>节点 <code>n</code> 的度 <code>k(n) = 该节点的连接数</code></p><p>平均度  <code>&lt;k&gt;</code></p><p>度函数: <code>P(k) ： 一个随机选取的节点有 k 个连接的概率</code></p></li><li><h4 id="介数（中心性）概念"><a href="#介数（中心性）概念" class="headerlink" title="介数（中心性）概念"></a><strong>介数（中心性）概念</strong></h4><p>任意一对节点间最短路径所经过的次数<br>一个节点的介数就是一个节点在网络中所有最短路径中出现的频率<br>介数反映了相应的节点或边在整个网络中的作用和影响力，是一个全局几何量。<br>介数用于描述节点之间的连接强度和在网络中的重要性。介数可以通过计算节点之间的最短路径长度来衡量节点之间的连通性，从而反映节点在网络中的地位和作用。</p><p>介数在现实生活中的意义非常广泛，以下是列举的一些可能的现实意义：</p><ol><li>社交网络分析：介数可以帮助我们分析社交网络中节点之间的连接强度和信息传播效率。例如，高介数的节点可能在网络中扮演着信息传播的关键角色，对于社交网络中的群体动态和信息传播具有重要的影响。</li><li>网络安全：介数可以用于分析网络攻击路径和防御策略。例如，攻击者可以通过寻找高介数的节点来攻击网络，因此了解节点的介数分布可以帮助我们更好地防御网络攻击。</li><li>交通网络分析：介数可以用于分析交通网络中节点之间的连通性和运输效率。高介数的节点可能在网络中扮演着重要的交通枢纽角色，对于交通网络的运行和优化具有重要的意义。</li></ol><p><strong>介数中心性：</strong><br>从每块中的任一节点到其他某块中的任一节点的最短路径必然要经过节点H。<br>这种以经过某个节点的最短路径的数目来刻画节点重要性的指标就称为介数中心性(Betweeness centrality)，简称介数(BC)。</p><p><strong>计算介数中心性：</strong></p><p>计算介数中心性（Betweenness Centrality）通常涉及以下几个步骤：</p><ol><li><p>确定网络的最短路径:</p><ul><li>对于网络中的每一对节点 ( (s, t) )，找出所有最短路径。最短路径可以使用如Dijkstra算法或Floyd-Warshall算法来计算。</li></ul></li><li><p>计算每个节点的介数中心性:</p><ul><li>对于每个节点 ( v )（不包括起点和终点），计算在所有最短路径中 ( v ) 出现的次数。</li><li>对于每一对节点 ( (s, t) )，如果存在多条最短路径，那么每条路径对节点 ( v ) 的贡献应考虑为 ( \frac{1}{\text{路径数}} )。</li><li>对于每个节点 ( v )，其介数中心性 ( C_B(v) ) 定义为它出现在所有最短路径中的次数的总和，通常标准化为 ( \frac{C_B(v)}{(\text{节点数} - 1)(\text{节点数} - 2)&#x2F;2} )。</li></ul></li><li><p>标准化:</p><ul><li>为了使介数中心性的值与网络大小无关，通常对介数中心性进行标准化。</li></ul></li></ol></li><li><h4 id="聚集系数"><a href="#聚集系数" class="headerlink" title="聚集系数"></a><strong>聚集系数</strong></h4><p>聚类系数是一个度量网络中节点聚集成群体的倾向。具体来说，它衡量一个节点的邻居节点之间相互连接的程度。在一个给定的节点上，聚类系数计算的是该节点的邻居之间实际存在的边数与可能存在的最大边数之间的比例。</p><p>例如，在社交网络中，一个人的聚类系数高意味着他们的朋友彼此之间也很可能是朋友。高聚类系数通常表明网络中存在紧密连接的社区或群体。相反，低聚类系数可能表明网络的联系更为分散。</p><p>在复杂网络分析中，聚类系数是理解网络结构特征的重要工具，它有助于揭示网络中的社区结构、小世界特性等。不同类型的网络（如社交网络、生物网络、技术网络）的聚类系数特性可能有显著差异。</p><p>集聚系数（群系数）（Clustering coefficient）： 朋友的朋友还是不是朋友的情况</p><p>集聚系数及其分布<br>$$<br>M&#x3D;\sum_{l\in E;x,y\in N_v}\varphi^x_l\varphi^y_l\C_v&#x3D;\frac{M}{C^2_n}<br>$$<br>正则网络的集聚系数</p><p>(a) 全连接网络   <code>C = 1</code></p><p>(b) 最近邻居网络 <code>C=3/4</code></p><p>(c) 星形网络    $$C_{star}&#x3D;0\ or\ c_{star}&#x3D;1$$</p><p>随机网络的集聚系数<code>C=p=&lt;k&gt;/N&lt;&lt;1</code></p></li><li><h4 id="粒子群算法"><a href="#粒子群算法" class="headerlink" title="粒子群算法"></a><strong>粒子群算法</strong></h4><p><strong>粒子群算法是一种基于鸟群捕食行为的优化算法，它利用群体中的个体对信息的共享和运动的演化来求解问题。</strong></p><p>粒子群优化（Particle Swarm Optimization，PSO）是一种基于种群的随机优化技术，其基本思想是受到鸟群觅食行为的启示。PSO 是一种群体智能（群体智能是一组集体智能，涵盖了多代理环境下的群体交互）。在一个 PSO 算法中，有一个种群在问题空间内飞行，每个个体（在这里被称为“粒子”）都有一个由速度和位置构成的向量。粒子通过追踪最佳粒子（个人的最佳）和整个群体中的最佳粒子（全局最佳）来更新其位置和速度。</p><p>PSO 算法的基本步骤包括初始化、速度和位置的设定、个体最佳和全局最佳的设定、更新速度和位置、以及更新个体最佳和全局最佳。</p><p>PSO 算法的主要优点包括：易于实现、收敛速度快、适用于解决不同类型的问题。这些优点使得 PSO 成为机器学习、神经网络和其他优化领域的重要候选者。</p><p>但是，虽然 PSO 有其优点，但它在算法的具体实现中仍有一些挑战需要克服，如学习率的设计、维数的影响以及全局搜索的难题等。因此，在使用 PSO 时，需要根据具体问题进行调整和优化。</p></li><li><h4 id="什么是小世界网络"><a href="#什么是小世界网络" class="headerlink" title="什么是小世界网络"></a><strong>什么是小世界网络</strong></h4><p><strong>这种网络属性意味着一些彼此并不相识的人，可以通过一条很短的熟人链条被联系在一起</strong></p><p>小世界网络是一种复杂网络模型，它具有两个主要的特点：</p><ol><li>节点度分布遵循幂律分布，即节点的度k（与该节点直接相连的节点数目）服从一个非常窄的小世界网络分布。这使得网络中的很多节点具有相对较高的度，从而保证了网络的聚集程度和连通性。</li><li>网络的平均路径长度非常短，即小世界效应显著。这意味着信息在网络中的传播速度非常快，信息传播的效率非常高。</li></ol><p>这种网络结构可以解释为，在网络中，一个人的朋友的朋友可能也是他的熟人，而网络中的节点数量却远少于实际的网络连接数量。这种特性使得小世界网络模型在社交网络、社交媒体、信息传播等领域得到了广泛的应用和关注。</p></li><li><h4 id="无标度网络特点"><a href="#无标度网络特点" class="headerlink" title="无标度网络特点"></a><strong>无标度网络特点</strong></h4><p>无标度网络是一种特殊的网络模型，其特点是节点的度分布遵循幂律分布，即大多数节点的度数相对较低，但也有少数节点具有非常高的度数，呈现出一种无标度的特性。</p><p>无标度网络的特点主要体现在以下几个方面：</p><ol><li><p>节点度分布的随机性：无标度网络中的节点度数分布是随机的，而且是非均衡的。这意味着节点的度数不是均匀分布的，而是集中分布在少数几个高度的节点上。</p></li><li><p>节点度的随机涨落：无标度网络中的节点度分布存在一个标度因子，而大多数节点的度数接近这个标度因子，但少数节点可能存在较大的偏差，从而导致节点的度数存在随机涨落。</p></li><li><p>网络的自相似性：无标度网络具有自相似性，即网络中的不同尺度具有相似的结构。这意味着在网络中，不同的节点之间存在着相似的关系，而这种关系并不是完全随机的。</p></li></ol><p>总之，无标度网络是一种特殊的网络模型，具有高度聚集性和自相似性等特点。这些特点使得无标度网络在许多领域中得到了广泛的应用和关注，如社交网络、信息传播、互联网等。</p></li><li><h4 id="六度分离概念"><a href="#六度分离概念" class="headerlink" title="六度分离概念"></a><strong>六度分离概念</strong></h4><p>六度分离概念是一个社交概念，指认为世界上任何两个人之间都只有六个人连接。这个概念是由哈佛大学的心理学教授Stanley Milgram在1967年提出的，他通过“小世界理论”认为，通过六度分离，任何两个不相识的人都可以通过熟人朋友等建立联系，形成一个社会网络。这个概念也说明了社交网络中人与人之间的联系的普遍性和重要性。</p></li><li><h4 id="混沌可预测性，混沌可预测吗？可长期预测还是可短期预测"><a href="#混沌可预测性，混沌可预测吗？可长期预测还是可短期预测" class="headerlink" title="混沌可预测性，混沌可预测吗？可长期预测还是可短期预测"></a><strong>混沌可预测性，混沌可预测吗？可长期预测还是可短期预测</strong></h4><p>混沌系统是否可预测取决于预测的时间尺度。一般来说，混沌系统在短期内的行为可能具有一定的可预测性，这是因为混沌系统通常具有敏感依赖于初值的特点，这意味着小的初始扰动在系统的演化过程中可能会放大，从而导致短期内的行为表现出一定的规律性。</p><p>然而，对于长期预测，混沌系统的可预测性变得更为复杂。一方面，混沌系统的动力学性质决定了它在长期内的行为可能呈现出随机性或复杂性，表现出“蝴蝶效应”的特点，即一个小扰动可能会在大范围内产生影响。这使得混沌系统的长期预测变得非常困难，甚至是不可能的。另一方面，对于某些混沌系统，如洛伦茨吸引子和 Rossler 吸引子等，在一定的条件下，长期行为也可能具有一定的可预测性。</p><p>总的来说，混沌系统是否可预测取决于预测的时间尺度。在短期内，混沌系统可能具有一定的可预测性，而在长期内，其行为可能呈现出随机性和复杂性，不可预测。不过，通过数学模型、计算机模拟和经验数据等手段，我们可以尝试对混沌系统进行短期或长期预测，从而为实际应用提供参考。</p></li><li><h4 id="列举复杂网络相关期刊"><a href="#列举复杂网络相关期刊" class="headerlink" title="列举复杂网络相关期刊"></a><strong>列举复杂网络相关期刊</strong></h4><p>复杂网络是一个多学科交叉的研究领域，覆盖物理学、计算机科学、数学和社会科学等多个领域。以下是一些主要的与复杂网络相关的期刊及其特点：</p><ol><li>Physical Review E</li></ol><ul><li><strong>特点</strong>：专注于统计、非线性和软物质物理学的研究。它包括了复杂网络的物理和数学特性的研究。</li></ul><ol start="2"><li>Social Networks</li></ol><ul><li><strong>特点</strong>：专注于社交网络的理论和实证研究。涵盖社交网络分析的方法和应用，包括社交网络中的结构和功能。</li></ul><ol start="3"><li>Network Science</li></ol><ul><li><strong>特点</strong>：涵盖网络科学的广泛主题，包括网络结构、动态和建模。适合跨学科研究，涉及社会学、经济学、计算机科学等领域。</li></ul><ol start="4"><li>Journal of Complex Networks</li></ol><ul><li><strong>特点</strong>：集中在复杂网络的数学、物理和计算机科学方面。包括网络理论的发展和网络模型的应用。</li></ul><ol start="5"><li>Advances in Complex Systems</li></ol><ul><li><strong>特点</strong>：研究复杂系统的多学科期刊，包括复杂网络的理论和应用研究。关注系统之间的相互作用和网络行为。</li></ul><ol start="6"><li>IEEE Transactions on Network Science and Engineering</li></ol><ul><li><strong>特点</strong>：由IEEE出版，集中在网络科学和工程领域的应用研究。包括网络动力学、优化和网络中的数据分析。</li></ul><ol start="7"><li>Chaos: An Interdisciplinary Journal of Nonlinear Science</li></ol><ul><li><strong>特点</strong>：专注于混沌理论及其在各种系统中的应用，包括复杂网络。涉及物理、工程、生物学和其他自然科学领域。</li></ul><ol start="8"><li>European Physical Journal B</li></ol><ul><li><strong>特点</strong>：涵盖凝聚态物理、统计物理、原子分子和光物理等领域，包括复杂网络的物理特性研究。</li></ul><ol start="9"><li>Computational Social Networks</li></ol><ul><li><strong>特点</strong>：专注于计算方法在社交网络分析中的应用。包括网络模型、社交媒体分析和社交网络挖掘等。</li></ul><ol start="10"><li>Discrete Dynamics in Nature and Society</li></ol><ul><li><strong>特点</strong>：涉及自然和社会科学中的离散动态系统，包括网络理论、图论和应用数学在复杂系统中的应用。</li></ul></li><li><h4 id="用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值"><a href="#用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值" class="headerlink" title="用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值"></a><strong>用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值</strong></h4><p><em>下面解释用遗传算法求函数$$ f(x)&#x3D;x2, x^2[0,31]$$的最大值的一些重要步骤。这里只介绍第一代群体的生成过程与结果</em></p><p>(1) 编码<br>由于在该例中$$x\in [0,31]$$，因此，将变量x编码为5位长的二进制形式。如x&#x3D;13可表示为01101</p><p>(2) 初始群体的生成</p><p> 随机产生初始群体的每个个体，群体的大小为4(如表1).</p><p>(3)适应度计算</p><p> 将每个个体x的函数值 f(x)作为该个体的适应度。如个体01101的适应度为 $$f(13)&#x3D;13^2&#x3D;169$$<br>(4) 选择<br>计算每个个体的适应度所占的比例 $$\frac{f_i}{\sum^n_{j&#x3D;1}f_i}$$</p><p>(5) 交叉与变异</p><p>这里采用简单交叉操作：首先对配对库中的个体进行随机配对；其次，在配对个体中随机设定交叉处，配对个体彼此交换部分信息(如表1)。于是得到4个新个体，这4个新个体就形成了新一代群体。        比较新旧群体，不难发现新群体中个体适应度的平均值和最大值都有明显的提高。由此可见，新群体中的个体的确是朝着期望的方向进化了。</p></li><li><h4 id="利用混沌神经网络求解函数最小值"><a href="#利用混沌神经网络求解函数最小值" class="headerlink" title="利用混沌神经网络求解函数最小值"></a><strong>利用混沌神经网络求解函数最小值</strong></h4><p>例如，求$\min\left( x_{1}^{2} + 2x_{2}^{2} \right) &#x3D; E$</p><ol><li>求偏导</li></ol><blockquote><p>$$\frac{\partial E}{\partial x_{1}} &#x3D; 2x_{1}\frac{\partial E}{\partial x_{2}} &#x3D; 4x_{2}$$</p></blockquote><ol start="2"><li>带入混沌神经网络</li></ol><p>$$\begin{aligned}<br> &amp; x_{1}(t) &#x3D; \frac{1}{1 + e^{- y_{1}(t)\left( 1 + \varepsilon_{1}(t)) \right.\ }} \<br> &amp; y_{1}(t + 1) &#x3D; ky_{1}(t) + \alpha\left( - 2x_{1} \right) - z_{1}(t)\left( x_{1}(t) - I_{0} \right) \<br> &amp; z_{1}(t + 1) &#x3D; (1 - \beta)z_{1}(t) \<br> &amp; \varepsilon_{1}(t + 1) &#x3D; (1 - \gamma)\varepsilon_{1}(t)<br>\end{aligned}$$</p><p>$$\begin{aligned}<br> &amp; x_{2}(t) &#x3D; \frac{1}{1 + e^{- y_{2}(t)\left( 1 + \varepsilon_{2}(t)) \right.\ }} \<br> &amp; y_{2}(t + 1) &#x3D; ky_{2}(t) + \alpha\left( - 4x_{2} \right) - z_{2}(t)\left( x_{2}(t) - I_{0} \right) \<br> &amp; z_{2}(t + 1) &#x3D; (1 - \beta)z_{2}(t) \<br> &amp; \varepsilon_{2}(t + 1) &#x3D; (1 - \gamma)\varepsilon_{2}(t)<br>\end{aligned}$$</p><p>（tips！注意到，偏导的地方要写成偏导的相反数！并且有n个偏导就要写n*4个式子）</p><ol start="3"><li>使用混沌神经网络迭代计算求解，得到最小值时，$x_{1} &#x3D; 0,x_{2} &#x3D; 0$，函数值$E &#x3D; 0$。</li></ol></li><li><h4 id="交叉耦合构造散列函数"><a href="#交叉耦合构造散列函数" class="headerlink" title="交叉耦合构造散列函数"></a><strong>交叉耦合构造散列函数</strong></h4><p>该方法以交叉耦合映象格子为核心,<br>充分利用其不同于普通时空混沌系统的优良的混乱扩散特性 .首先<br>,将明文分组并行注入交叉耦合映象格子的各格点<br>.然后通过多轮混沌迭代使其具有良好的混沌特性 ,并同时利用<br>Logistic映射作为密钥生成器,对结果进行混沌调制。</p><p><strong>主模块：</strong></p><p>①将消息 M分割成 t个消息块 $M_{1}\ldots,M_{t}$ 每个消息块包含 n个字节<br>,且最后一个块填充 Mt &#x3D;＊…＊10… 0l(M).其中,<br>l(M)表示M的长度的二进制形式, 长度为 64 bit,不足 64 bit时高位添 1个介符<br>1再补 0。n可根据实际需要取值。</p><p>②将每个消息块中各字节元素按对应的ASCII码线性变换，线性变换公式为</p><p>$$C_{i,j} &#x3D; \left{ \begin{aligned}<br> &amp; - \frac{M_{i,j}}{128}\ \ \ \  &amp; &amp; 0 \leqslant A\left( M_{i,j} \right) \leqslant 127 \<br> &amp; \frac{M_{i,j} - 128}{128}\ \ \ \  &amp; &amp; 128 \leqslant A\left( M_{i,j} \right) \leqslant 225<br>\end{aligned}\ (1) \right.\ $$</p><p>③令第 i个消息块对应 $C_{i,1}\ldots,C_{i,n}$分别为交叉耦合映象格子中<br>n个格子初值,<br>且$x_{0}(1) &#x3D; C_{i,1},x_{0}(2) &#x3D; C_{i,2},\ldots,x_{0}(n) &#x3D; C_{i,n}.$其中,<br>$x_{0}(0)$和$x_{0}(n + 1)$由密钥生成模块产生.</p><p>④应用交叉耦合映象格子模型进行 R轮初值迭代, 得到<br>$x_{R}(1)\ldots,x_{R}(n).$</p><p>⑤根据式 (1), 对 $x_{R}(1)\ldots,x_{R}(n)$进行逆变换,<br>得到$X_{R}(1)\ldots,X_{R}(n).$</p><p>⑥将$X_{R}(1)\ldots,X_{R}(n).$循环左移$L_{i}$字节，得到<br>$Y_{R}(1)\ldots,Y_{R}(n).$</p><p>⑦每个消息块依次执行 ③ ～ ⑥, t个消息块即可变为 t组<br>$Y_{R}(1)\ldots,Y_{R}(n).$</p><p>⑧将得到的 t组 n字节 $Y_{R}(1)\ldots,Y_{R}(n).$按比特位异或,得到 8n bit的<br>Hash值.</p><p><strong>密钥生成模块：</strong></p><p>①将 128 bit初始密钥线性映射到 0 ～ 1之间, 作为 Logistic映射的初值。</p><p>②第 i组消息在主模块中的子密钥以第 i-1 组中第 2个子密钥的值作为初值,<br>分别迭代 100 + A(i)和 100 +A(i)+n+1轮得到.</p><p>③将最后一组消息所对应的第 2个子密钥作为初值,迭代 t轮, 得到<br>t个实数$s_{1}\ldots,s_{t}$.主模块中移动字节数 $L_{i} &#x3D; s_{i}(n - 1)$</p></li></ol>]]></content>
    
    
    <summary type="html">复杂网络期末考试的初步总结，供学弟学妹参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="复习总结" scheme="https://zhangyuanhe.top/tags/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>信息系统安全期末复习总结</title>
    <link href="https://zhangyuanhe.top/2024/01/01/BUPT_note/Review%20of%20Information%20System%20Security/"/>
    <id>https://zhangyuanhe.top/2024/01/01/BUPT_note/Review%20of%20Information%20System%20Security/</id>
    <published>2024-01-01T13:00:00.000Z</published>
    <updated>2024-01-17T12:25:48.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h1><h2 id="信息系统概论"><a href="#信息系统概论" class="headerlink" title="信息系统概论"></a>信息系统概论</h2><h3 id="什么是信息系统"><a href="#什么是信息系统" class="headerlink" title="什么是信息系统"></a>什么是信息系统</h3><ul><li>信息系统是一个集成的组件集合，用于收集、存储和处理数据，以及传递信息、知识和数字产品。商业公司和其他组织依靠信息系统来执行和管理他们的运营、与客户和供应商互动，以及在市场上竞争。</li><li>信息系统是支持数据密集型应用程序的软件和硬件系统。</li></ul><h3 id="信息系统的架构、架构的复杂度"><a href="#信息系统的架构、架构的复杂度" class="headerlink" title="信息系统的架构、架构的复杂度"></a>信息系统的架构、架构的复杂度</h3><h4 id="单机架构"><a href="#单机架构" class="headerlink" title="*单机架构*"></a><em><strong>*单机架构*</strong></em></h4><p>在网站开设初期，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。</p><h4 id="第一次演进：Tomcat与数据库分开部署"><a href="#第一次演进：Tomcat与数据库分开部署" class="headerlink" title="*第一次演进：Tomcat与数据库分开部署*"></a><em><strong>*第一次演进：Tomcat与数据库分开部署*</strong></em></h4><p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能</p><h4 id="第二次演进：引入本地缓存和分布式缓存"><a href="#第二次演进：引入本地缓存和分布式缓存" class="headerlink" title="*第二次演进：引入本地缓存和分布式缓存*"></a><em><strong>*第二次演进：引入本地缓存和分布式缓存*</strong></em></h4><p>在Tomcat服务器增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的HTML页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力</p><h4 id="第三次演进：引入反向代理实现负载均衡"><a href="#第三次演进：引入反向代理实现负载均衡" class="headerlink" title="*第三次演进：引入反向代理实现负载均衡*"></a><em><strong>*第三次演进：引入反向代理实现负载均衡*</strong></em></h4><p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发</p><h4 id="第四次演进：数据库读、写分离"><a href="#第四次演进：数据库读、写分离" class="headerlink" title="*第四次演进：数据库读、写分离*"></a><em><strong>*第四次演进：数据库读、写分离*</strong></em></h4><p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据</p><h4 id="第五次演进：数据库按业务分库"><a href="#第五次演进：数据库按业务分库" class="headerlink" title="*第五次演进：数据库按业务分库*"></a><em><strong>*第五次演进：数据库按业务分库*</strong></em></h4><p>把不同业务的数据保存到不同的数据库中，降低业务之间的资源竞争，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决</p><h4 id="第六次演进：把大表拆分为小表"><a href="#第六次演进：把大表拆分为小表" class="headerlink" title="*第六次演进：把大表拆分为小表*"></a><em><strong>*第六次演进：把大表拆分为小表*</strong></em></h4><p>这种做法显著增加了数据库运维的难度，对DBA的要求较高!!!</p><p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀地分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能</p><h4 id="第七次演进：使用LVS或F5使多个Nginx负载均衡"><a href="#第七次演进：使用LVS或F5使多个Nginx负载均衡" class="headerlink" title="*第七次演进：使用LVS或F5使多个Nginx负载均衡*"></a><em><strong>*第七次演进：使用LVS或F5使多个Nginx负载均衡*</strong></em></h4><p>LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。</p><h4 id="第八次演进：通过DNS轮询实现机房间的负载均衡"><a href="#第八次演进：通过DNS轮询实现机房间的负载均衡" class="headerlink" title="*第八次演进：通过DNS轮询实现机房间的负载均衡*"></a><em><strong>*第八次演进：通过DNS轮询实现机房间的负载均衡*</strong></em></h4><p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href="http://www.taobao.com时,dns服务器会使用轮询策略或其他策略,来选择某个ip供用户访问/">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问</a></p><h4 id="第九次演进：引入NoSQL数据库和搜索引擎等技术"><a href="#第九次演进：引入NoSQL数据库和搜索引擎等技术" class="headerlink" title="*第九次演进：引入NoSQL数据库和搜索引擎等技术*"></a><em><strong>*第九次演进：引入NoSQL数据库和搜索引擎等技术*</strong></em></h4><p>针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key&#x2F;value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决</p><h4 id="第十次演进：大应用拆分为小应用"><a href="#第十次演进：大应用拆分为小应用" class="headerlink" title="*第十次演进：大应用拆分为小应用*"></a><em><strong>*第十次演进：大应用拆分为小应用*</strong></em></h4><p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决</p><h4 id="第十一次演进：复用的功能抽离成微服务"><a href="#第十一次演进：复用的功能抽离成微服务" class="headerlink" title="*第十一次演进：复用的功能抽离成微服务*"></a><em><strong>*第十一次演进：复用的功能抽离成微服务*</strong></em></h4><p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理</p><h4 id="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"><a href="#第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异" class="headerlink" title="*第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异*"></a><em><strong>*第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异*</strong></em></h4><p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构</p><h2 id="信息系统安全概论"><a href="#信息系统安全概论" class="headerlink" title="信息系统安全概论"></a>信息系统安全概论</h2><h3 id="信息系统常见的安全威胁"><a href="#信息系统常见的安全威胁" class="headerlink" title="信息系统常见的安全威胁"></a>信息系统常见的安全威胁</h3><h4 id="自然威胁"><a href="#自然威胁" class="headerlink" title="自然威胁"></a>自然威胁</h4><p>自然威胁通常不是故意造成的，但它们会对信息系统产生破坏性影响。</p><ol><li><p><strong>自然灾害</strong>：</p><ul><li>地震：可能破坏服务器室、数据中心和其他基础设施。</li><li>洪水：可能泛滥至关键设施，导致硬件损坏和数据丢失。</li><li>风暴和雷击：可能引起停电或电力浪涌，损坏设备。</li></ul></li><li><p><strong>火灾</strong>：</p><ul><li>火灾可能会摧毁物理设施，包括服务器、网络设备等。</li></ul></li><li><p><strong>环境变化</strong>：</p><ul><li>温度变化或湿度过高或过低都可能对敏感设备造成损害。</li></ul></li></ol><h4 id="人为威胁"><a href="#人为威胁" class="headerlink" title="人为威胁"></a>人为威胁</h4><p>人为威胁通常是有意为之的，旨在从中获利或者对信息系统产生破坏。</p><ol><li><strong>恶意软件攻击</strong>：<ul><li>病毒、蠕虫、特洛伊木马、勒索软件等。</li></ul></li><li><strong>网络钓鱼和社会工程</strong>：<ul><li>攻击者诱导用户提供敏感数据或执行不安全操作。</li></ul></li><li><strong>内部威胁</strong>：<ul><li>滥用权限、数据泄露或内部破坏活动。</li></ul></li><li><strong>数据泄露</strong>：<ul><li>由于不当的数据处理或安全措施不足导致敏感信息外泄。</li></ul></li><li><strong>篡改和破坏</strong>：<ul><li>数据或软件的故意篡改，以及对硬件的物理破坏。</li></ul></li><li><strong>拒绝服务（DoS&#x2F;DDoS）攻击</strong>：<ul><li>通过大量请求使网络服务不可用。</li></ul></li><li><strong>身份盗窃和冒用</strong>：<ul><li>盗用他人身份访问受限资源。</li></ul></li><li><strong>刻意的信息分发</strong>：<ul><li>例如，泄露机密文件，可能是出于政治、个人利益或其他原因.</li></ul></li></ol><h3 id="信息系统安全的概念"><a href="#信息系统安全的概念" class="headerlink" title="信息系统安全的概念"></a>信息系统安全的概念</h3><p>（1）基于信息保障的理解，信息系统安全保障是在信息系统的整个生命周期中，通过对信息系统的风险分析，制定并执行相应的安全保障策略，从技术、管理、工程和人员等方面提出安全保障要求，确保信息系统的保密性、完整性和可用性，降低安全风险到可接受的程度，从而保障系统实现组织机构的使命;</p><p>（2）基于风险控制的理解，即把系统的风险控制到一个可以接受的范围之内；</p><p>（3）基于状态迁移的理解，即系统的状态无论怎么迁移，也不可能进入对应不安全</p><p>状态的空间；</p><p>（4）基于时间的理解，即发现攻击的时间+做出响应的时间&lt;黑客实现攻击的时间；</p><p>（5）基于安全体系架构的理解，以云计算为例，讲稿提供了多种典型安全架构，它</p><p>们要么提供很好的隔离性，要么以可信、可控的方式，可以保证信息系统的业务连</p><p>续性。</p><p>（6）基于安全策略的理解，即一个信息系统是“安全系统”，指的是该系统达到了</p><p>当初设计时所制定的安全策略的要求。</p><h2 id="安全需求和安全策略"><a href="#安全需求和安全策略" class="headerlink" title="安全需求和安全策略"></a>安全需求和安全策略</h2><h3 id="安全需求，一般性的安全需求"><a href="#安全需求，一般性的安全需求" class="headerlink" title="安全需求，一般性的安全需求"></a>安全需求，一般性的安全需求</h3><p><strong>安全需求</strong>：就是在设计一个安全系统时<strong>期望得到的安全保障</strong></p><p><strong>一般性的安全需求</strong></p><p><strong>机密性需求</strong>，防止信息被泄漏给未授权的用户</p><p>​自主安全策略、强制安全策略；需知原则</p><p><strong>完整性需求，</strong>防止未授权用户对信息的修改</p><p>​维护系统资源在一个有效的、预期的状态，防止资源被不正确、不适当的修改；维</p><p>​护系统不同部分的一致性；防止在涉及记账或审计的事件中“舞弊”行为的发生。</p><p><strong>可用性需求，</strong>保证授权用户对系统信息的可访问性</p><p>​“授权用户的任何正确的输入，系统会有相应的正确的输出”</p><p><strong>可记账性需求，</strong>防止用户对访问过某信息或执行过某一操作以否认</p><p>​可对发生的事件、操作等进行回溯</p><h3 id="安全策略：访问控制策略（包括-DAC、MAC-等），如何从安全策略的角度理解信息系统安全"><a href="#安全策略：访问控制策略（包括-DAC、MAC-等），如何从安全策略的角度理解信息系统安全" class="headerlink" title="安全策略：访问控制策略（包括 DAC、MAC 等），如何从安全策略的角度理解信息系统安全"></a>安全策略：访问控制策略（包括 DAC、MAC 等），如何从安全策略的角度理解信息系统安全</h3><p>最典型的安全策略是自主访问控制策略DAC和强制访问控制策略MAC，它们描绘了大部分系统的实际需求，并且这两类策略在多数安 全系统中都提供了相应的实施机制。</p><p><strong>自主访问控制策略</strong></p><p>允许系统中信息的拥有者按照自己的意愿去指定谁可以以何种访问模式去访问该客体</p><p>❖ 自主访问控制策略通常</p><p>➢ 基于系统内用户（如用户ID），加上对用户的访问授权（如权能表），或者客体的访问属性（如访问控制表ACL）来决定该用户是否有某权限访问该客体</p><p>❖ 或者基于要访问信息的内容</p><p>❖ 或者基于用户当时所处的角色</p><p><strong>强制访问控制策略</strong></p><p>在强制访问控制系统中，所有主体（用户，进程）和客体（文件，数据）都被分配了安全标签，安全标签标识一个安全等级。</p><p>➢ 主体（用户，进程）被分配一个安全等级</p><p>➢ 客体（文件，数据）也被分配一个安全等级</p><p>➢ 访问控制执行时对主体和客体的安全级别进行比较</p><p><strong>访问控制策略的组成</strong></p><p><strong>主体</strong></p><p>系统内行为的发起者。通常是用户发起的进程</p><p><strong>客体</strong></p><p>系统内所有主体行为的直接承担者</p><p><strong>系统环境（上下文）</strong></p><p>系统主、客体属性之外的某些状态</p><p>从安全策略的角度理解信息系统安全涉及到制定一套全面的指导原则和框架，这些原则和框架能够指导组织在技术、流程和人力层面上采取措施，以确保信息系统的保密性、完整性和可用性。</p><h3 id="主体、客体及其属性"><a href="#主体、客体及其属性" class="headerlink" title="主体、客体及其属性"></a>主体、客体及其属性</h3><p><strong>主体是系统内行为的发起者，通常是用户发起的进程</strong></p><p>​<strong>信息的访问者（用户）</strong></p><p>​一个获得授权可以访问系统资源的自然人。</p><p>​授权包括：对信息的读&#x2F;写&#x2F;删除&#x2F;追加&#x2F;执行以及授予&#x2F;撤销另外一个用户对信息的访问权限等。</p><p>​<strong>信息的拥有者</strong></p><p>​该用户拥有对此信息的完全处理权限，除非该信息被系统另外加以访问控制。</p><p>​<strong>系统管理员</strong></p><p>​为使系统能正常运转，而对系统的运行进行管理的用户</p><p><strong>主体属性</strong></p><p>​<strong>用户ID&#x2F;组ID</strong> </p><p>​例如用于Unix按位的访问控制、常规自主访问控制</p><p>​<strong>用户访问许可级别</strong></p><p>​例如用于强制访问控制。</p><p>​<strong>权能表</strong></p><p>​例如用于强制访问控制。</p><p>​<strong>角色</strong></p><p>​例如用于Unix按位的访问控制、常规自主访问控制</p><p><strong>访问控制策略的相关方⎯⎯客体</strong></p><p>​<strong>一般客体</strong></p><p>​在系统内以客观、具体的形式存在的信息实体，如文件、目录等</p><p>​<strong>设备客体</strong></p><p>​指系统内的设备，如软盘、打印机等</p><p>​<strong>特殊客体</strong></p><p>​某些主体</p><p><strong>客体属性</strong></p><p>​<strong>敏感性标签</strong></p><p>​一个敏感性标签由2部分组成：信息的敏感性级别和范畴</p><p>​<strong>访问控制列表</strong></p><p>​表示系统中哪些用户可以对此信息进行何种访问</p><p>​由信息的拥有者加以管理</p><h3 id="访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码"><a href="#访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码" class="headerlink" title="访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码"></a>访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码</h3><p><strong>标准ACL_靠近目的地址</strong></p><p>只使用数据包的源地址作为测试条件。所有决定是基于源IP地址的。</p><p>标准访问列表的创建根据 “动作”＋“源地址” ，即允许谁、拒绝谁的方法来创建</p><p><strong>扩展ACL——基于源地址、目的地址、协议、端口_靠近源地址</strong></p><p>可以测试IP包的第3层和第4层报头中的字段。包括源IP地址、目的IP地址、网络层报头中的协议字段（如，TCP、UDP、ICMP等）以及位于传输层报头中的端口号。</p><p><strong>通配掩码</strong></p><p>路由器使用<strong>IP地址</strong>和<strong>通配掩码</strong>（wildcard-mask）一起来分辨匹配的地址范围，它跟子网掩码刚好相反。</p><p>它不像子网掩码告诉路由器IP地址的哪一位属于网络号一样，通配符掩码告诉路由器为了判断出匹配，它需要检查IP地址中的多少位。</p><p><strong>通配掩码某位是0</strong>表示检查相应bit位的值</p><p><strong>通配掩码某位是1</strong>表示不检查（忽略）相应位的值</p><h2 id="信息系统的风险评估"><a href="#信息系统的风险评估" class="headerlink" title="信息系统的风险评估"></a>信息系统的风险评估</h2><h3 id="风险的概念"><a href="#风险的概念" class="headerlink" title="风险的概念"></a>风险的概念</h3><p>风险指在某一特定环境下，在某一特定时间段内，特定的威胁利用资产的一种或一组薄弱点，导致资产的丢失或损害的潜在可能性，即特定威胁事件发生的可能性与后果的结合。</p><h3 id="什么是安全风险评估"><a href="#什么是安全风险评估" class="headerlink" title="什么是安全风险评估"></a>什么是安全风险评估</h3><p><strong>安全风险组成的四要素：</strong>信息系统资产（Asset）、信息系统脆弱性（Vulnerability）、信息安全威胁（Threat）、信息系统安全保 护措施（Safeguard）。</p><h3 id="风险评估的要素"><a href="#风险评估的要素" class="headerlink" title="风险评估的要素"></a>风险评估的要素</h3><p><strong>风险评估围绕着资产、威胁、脆弱性和安全措施这些基本要素展开。</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220191732221.png" alt="image-20231220191732221"></p><h2 id="信息系统等级保护"><a href="#信息系统等级保护" class="headerlink" title="信息系统等级保护"></a>信息系统等级保护</h2><h3 id="什么是等级保护，等级保护是《网络安全法》规定的一项基本制度"><a href="#什么是等级保护，等级保护是《网络安全法》规定的一项基本制度" class="headerlink" title="什么是等级保护，等级保护是《网络安全法》规定的一项基本制度"></a>什么是等级保护，等级保护是《网络安全法》规定的一项基本制度</h3><p><strong>网络安全等级保护是指对国家重要信息、法人和其他组织及公民的专有信息以及公开信息和存储、传输、处理这些信息的信息系统分等级实行安全保护，对信息系统中使用的信息安全产品实行按等级管理，对信息系统中发生的信息安全事件分等级响应、处置。</strong></p><p><strong>网络安全等级保护工作包括定级、备案、建设整改、等级测评、监督检查五个阶段。</strong></p><h2 id="信息系统的物理安全"><a href="#信息系统的物理安全" class="headerlink" title="信息系统的物理安全"></a>信息系统的物理安全</h2><h3 id="物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等"><a href="#物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等" class="headerlink" title="物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等"></a>物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等</h3><p><strong>环境安全</strong></p><p>对系统所在环境的安全保护</p><p>​<strong>机房三度要求</strong></p><p>​温度&#x2F;湿度&#x2F;洁净度</p><p>​<strong>防火与防水要求</strong></p><p>​为避免火灾、水灾，应采取如下具体措施:</p><p>​（1）隔离</p><p>​（2）火灾报警系统</p><p>​（3）灭火设施</p><p>​（4）管理措施</p><p>​<strong>机房防盗要求</strong></p><p>​<strong>机房防鼠</strong></p><p>​<strong>防静电措施</strong></p><p>​<strong>接地要求</strong></p><p>​<strong>防雷击措施</strong></p><p>​<strong>机房选址要求</strong></p><p><strong>线路安全</strong></p><p>窃听&#x2F;搭线窃听&#x2F;海底电缆窃听</p><p>光纤通信技术</p><p><strong>电源系统安全</strong></p><p>不间断电源（UPS）</p><p><strong>介质安全：</strong>电磁战</p><h3 id="电磁泄漏"><a href="#电磁泄漏" class="headerlink" title="电磁泄漏"></a>电磁泄漏</h3><p>电磁分析攻击作为最有效的旁路攻击技术之一，是通过在密码芯片周围放置线圈，测量芯片在运算期间辐射的电磁信号，研究电磁场与内部处理数据之间的相关性而获取内部秘密参量。</p><h3 id="电源调整器，不间断电源（UPS）"><a href="#电源调整器，不间断电源（UPS）" class="headerlink" title="电源调整器，不间断电源（UPS）"></a>电源调整器，不间断电源（UPS）</h3><h2 id="信息系统的可靠性"><a href="#信息系统的可靠性" class="headerlink" title="信息系统的可靠性"></a>信息系统的可靠性</h2><h3 id="可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）"><a href="#可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）" class="headerlink" title="可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）;"></a>可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）;</h3><h3 id="可维修产品、不可维修产品的可靠性指标，可用度"><a href="#可维修产品、不可维修产品的可靠性指标，可用度" class="headerlink" title="可维修产品、不可维修产品的可靠性指标，可用度"></a>可维修产品、不可维修产品的可靠性指标，可用度</h3><h4 id="可靠性的定义"><a href="#可靠性的定义" class="headerlink" title="*可靠性的定义*"></a><em><strong>*可靠性的定义*</strong></em></h4><p>在规定的条件下、在给定的时间内，系统能实施应有功能的能力。</p><h4 id="可靠性参数"><a href="#可靠性参数" class="headerlink" title="*可靠性参数*"></a><em><strong>*可靠性参数*</strong></em></h4><p>$T_{MTTF}：$平均失效前时间  <strong>不可修系统</strong></p><p>$T_{MTBF}：$平均故障间隔时间  <strong>可修系统</strong></p><p>$R：$<em><strong>*可靠度*</strong></em></p><p>$λ：$<em><strong>*失效率*</strong></em></p><h4 id="寿命"><a href="#寿命" class="headerlink" title="*寿命*"></a><em><strong>*寿命*</strong></em></h4><p>通常用一个非负随机变量$X$来描述产品的寿命。</p><p>$X$的分布函数为</p><p>$F(t) &#x3D; P{X \le t}，t\ge0$</p><p>有了寿命分布<em>F</em>(<em>t</em>) ，就知道产品的平均寿命</p><p>$EX&#x3D;\int_0^\infty tdF(t)$</p><h4 id="可靠度R"><a href="#可靠度R" class="headerlink" title="可靠度R"></a>可靠度R</h4><p>产品在时刻 <em>t</em> 之前都正常工作（不失效）的概率，即产品在时刻 <em>t</em>的生存概率，称为无故障工作概率（可靠度函数）</p><p>$$ R(t)&#x3D;P{X&gt;t}&#x3D;\int_0^\infty dF(t)&#x3D;\int_0^\infty f(t)dt \ 𝑹(t) +F(t)&#x3D;1$$</p><blockquote><p>假设 C 是一个具有 <em>N</em> 个元器件的数字系统，在一定的条件和环境（如温度、湿度、电压等）下运行，并且随着时间 <em>t</em> 的推移质量逐步下降</p></blockquote><p>系统<strong>C</strong>在时刻 <em>t</em> 能正常工作的概率<em>R(t)&#x3D;S(t)&#x2F;N</em></p><p>**<em>R</em>(<em>t</em>)**称为系统 <strong>C</strong> 在时刻 <em>t</em> 的可靠度。</p><h4 id="失效率λ"><a href="#失效率λ" class="headerlink" title="失效率λ"></a>失效率λ</h4><p>假设<em>F</em>(<em>t</em>)是绝对连续的，即存在分布密度函数$<em>f(t)&#x3D;F’(t)</em>$且$F(t)&#x3D;\int_0^tf(x)dx$</p><blockquote><p>将发生故障的条件概率密度叫做失效率。 $λ(t)&#x3D;f(t)&#x2F;R(t)&#x3D;-R’(t)&#x2F;R(t)$ 失效率**λ(<em>t</em>)**表示系统中元器件失效的速率。</p></blockquote><h4 id="λ-t-的浴缸形曲线（Bathtub-curve）"><a href="#λ-t-的浴缸形曲线（Bathtub-curve）" class="headerlink" title="λ(t)的浴缸形曲线（Bathtub-curve）"></a>λ(t)的浴缸形曲线（Bathtub-curve）</h4><p><strong>第一阶段 早期失效期（Infant Mortality）</strong></p><p>器件在开始使用时失效率很高，但随着产品工作时间的增加，失效率迅速降低。这一阶段失效的原因大多是由于设计、原材料和制造过程中的缺陷造成的。为了缩短这一阶段的时间，产品应在投入运行前进行试运转，以便及早发现、修正和排除故障；或通过试验进行筛选，剔除不合格品。</p><p><strong>第二阶段 偶然失效期，也称随机失效期（Random Failures）</strong></p><p>这一阶段的特点是失效率较低，且较稳定，往往可近似看作常数。这一时期是产品的良好使用阶段。由于在这一阶段中，产品失效率近似为一常数，故设<em></em>(<em>t</em>)&#x3D;<em>λ</em>（常数）由可靠度计算公式得$R(t)&#x3D;e^{-λt}$ 这一式表明<strong>设备的可靠性与失效率成指数关系</strong>。</p><p><strong>第三阶段 耗损失效期（Wearout）</strong></p><p>该阶段的失效率随时间的延长而急速增加，主要原因是器件的损失己非常的严重，寿命快到尽头了，可适当的维修或直接更换。</p><p>R(t)和λ的关系</p><p>可靠性不仅是时间<em>t</em>的函数，而且与失效率****λ****有着密切的关联。</p><p>$$ R(t)&#x3D;e^{\int^t_0\lambda(t)dt } $$</p><h4 id="可维修产品的平均维修时间"><a href="#可维修产品的平均维修时间" class="headerlink" title="*可维修产品的平均维修时间*"></a><em><strong>*可维修产品的平均维修时间*</strong></em></h4><p>可维修产品的可维护性平均维修时间（MTTR，Mean Time To Repair）来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间（即设备处于故障状态时间的平均值，或设备修复时间的平均值）。系统的可维护性越好，平均维修时间越短</p><p>$$ MTTR&#x3D;\int^\infty _0t\mu(t)dt$$</p><blockquote><p>$<em>\mu(t)</em>$是维修时间的概率密度函数</p></blockquote><h4 id="可维修产品的维修性指标：可用性"><a href="#可维修产品的维修性指标：可用性" class="headerlink" title="*可维修产品的维修性指标：可用性*"></a><em><strong>*可维修产品的维修性指标：可用性*</strong></em></h4><p>可维修产品的可用性定义为：</p><p>$$ \frac{MTBF}{MTBF+MTTR}*100% $$</p><p><strong>计算机系统可靠性举例</strong></p><p>已知世界上第一代电子管计算机ENIAC有20000个电子管，假 设每个电子管的失效率为&#x3D;0.5%&#x2F;kh（千小时），试求： （1）该计算机的MTTF； （2）若要求计算机的可靠性在95%以上，则至多可以工作多久？</p><p>$$ MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i}&#x3D;\frac{1}{\frac{0.05}{100}*\frac{1}{1000}*20000}&#x3D;\frac{1}{0.01}&#x3D;100H\ R(t)&#x3D;e^{-\frac{t}{MTTF}}\ t&#x3D;5H $$</p><h3 id="容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术"><a href="#容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术" class="headerlink" title="容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术"></a>容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术</h3><h4 id="故障检测和诊断"><a href="#故障检测和诊断" class="headerlink" title="故障检测和诊断"></a><strong>故障检测和诊断</strong></h4><p>故障检测（Fault Detection）：判断系统是否存在故障的过程故障检测的作用是确认系统是否发生了故障，指示故障的状态，即查找故障源和故障性质。一般来说，故障检测只能找到错误点（错误单元），不能准确找到故障点。</p><p>故障诊断（Fault Diagnosis）：检测出系统存在故障后要进行故障的定位，找出故障所在的位置。</p><h4 id="故障屏蔽技术"><a href="#故障屏蔽技术" class="headerlink" title="故障屏蔽技术"></a><strong>故障屏蔽技术</strong></h4><p>故障屏蔽技术是防止系统中的故障在该系统的信息结构中产生差错的各种措施的总称，其实质是在故障效应达到模块的输出以前，利用冗余资源将故障影响掩盖起来，达到容错目的。</p><h4 id="冗余技术"><a href="#冗余技术" class="headerlink" title="冗余技术"></a><strong>冗余技术</strong></h4><p>硬件冗余</p><p>时间冗余</p><p>软件冗余</p><p>信息冗余:<strong>奇偶校验</strong></p><p>所谓冗余就是超过系统实现正常功能的额外资源。</p><p><strong>硬件冗余：三模冗余</strong></p><p>三模冗余可以由用户手动完成，也可以依靠工具完成。Xilinx推出了XIlInXtMrtool ，可以方便地实现三模冗余设计，并且可以方便地配置被冗余项，大大方便了用户。</p><p><strong>时间冗余技术</strong></p><p>基本思想：重复执行指令或者一段程序来消除故障的影响，以达到容错的效果，它是用消耗时间来换取容错的目的</p><p><strong>三模冗余（TMR）</strong>是一种常见的容错技术，通过三个相同的系统或组件并行工作，并使用投票逻辑来确定最终输出。这种方式可以容忍一个子系统的故障，因为即便有一个子系统产生错误输出，另外两个正确的输出可以通过多数表决来决定正确的响应。</p><p>然而，TMR也有潜在的弱点，例如如果两个系统同时失败并产生了相同的错误输出，TMR可能会选择错误的结果。为了改进TMR的容错能力，可以采取以下措施：</p><h5 id="1-错误检测与恢复"><a href="#1-错误检测与恢复" class="headerlink" title="1. 错误检测与恢复"></a>1. 错误检测与恢复</h5><ul><li><strong>自我检查</strong>：在TMR系统中加入自检逻辑，使得每个模块在表决过程之前进行错误检查。</li><li><strong>错误恢复</strong>：当检测到错误时，启动错误恢复机制，如重置或重新同步该模块。</li><li><strong>动态重新配置</strong>：如果确定某个模块故障，可以动态将其从系统中移除并替换。</li></ul><h5 id="2-多数表决器与冗余"><a href="#2-多数表决器与冗余" class="headerlink" title="2. 多数表决器与冗余"></a>2. 多数表决器与冗余</h5><ul><li><strong>增加冗余级别</strong>：使用四模或更多模冗余系统来提高容错能力，如N模冗余可以容忍N&#x2F;2-1个错误。</li><li><strong>改进表决逻辑</strong>：采用更复杂的表决机制，例如加权表决、模糊逻辑表决或基于信任度的表决，以识别最可靠的模块输出。</li></ul><h5 id="3-组合多种容错技术"><a href="#3-组合多种容错技术" class="headerlink" title="3. 组合多种容错技术"></a>3. 组合多种容错技术</h5><ul><li><strong>时间冗余</strong>：在TMR系统中加入时间冗余技术，如回滚恢复或检查点，以便在出现错误时回到之前的状态。</li><li><strong>软件冗余</strong>：在不同的模块上运行不同版本的软件或算法（N版本编程），以降低软件故障的影响。</li></ul><h5 id="4-故障隔离与恢复"><a href="#4-故障隔离与恢复" class="headerlink" title="4. 故障隔离与恢复"></a>4. 故障隔离与恢复</h5><ul><li><strong>故障隔离</strong>：在系统中加入故障隔离机制，如隔离故障模块，阻止其影响其他模块。</li><li><strong>定期测试与维护</strong>：定期进行系统测试，以确保每个模块都在正常工作状态，并进行必要的维护和更新。</li></ul><h5 id="5-使用先进算法"><a href="#5-使用先进算法" class="headerlink" title="5. 使用先进算法"></a>5. 使用先进算法</h5><ul><li><strong>预测性故障处理</strong>：使用人工智能或机器学习算法来预测故障并提前处理，以减少故障的影响。</li><li><strong>比较和分析系统行为</strong>：对系统的行为进行实时分析，比较其与预期行为的差异来预测潜在的故障。</li></ul><p>通过结合这些改进措施，可以提高TMR系统的可靠性和容错能力，减少判决错误的可能性。然而，每种措施都可能带来额外的成本和复杂性，因此需要根据应用的关键性和可用资源来平衡设计选择。</p><h3 id="RAID-56重要"><a href="#RAID-56重要" class="headerlink" title="RAID(56重要)"></a>RAID(56重要)</h3><p>廉价磁盘冗余阵列（Redundant Arrays of Inexpensive Disks），以多个低成本磁盘构成磁盘子系统，提供比单一硬盘更完备的可靠性和高性能</p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220230358791.png" alt="image-20231220230358791"></p><p><strong>数据基带条阵列（RAID0）</strong></p><p>分块无校验型，无冗余存储。简单将数据分配到各个磁盘上，不提供真正容错性。带区化至少需要2个硬盘，可支持8&#x2F;16&#x2F;32个磁盘</p><p>优点</p><p>➢ 允许多个小区组合成一个大分</p><p>➢ 更好地利用磁盘空间，延长磁盘寿命</p><p>➢ 多个硬盘并行工作，提高了读写性能</p><p>缺点</p><p>➢ 不提供数据保护，任一磁盘失效，数据可能丢失，且不能自动恢复。</p><p><strong>磁盘镜象（RAID1）</strong></p><p>每一组盘至少两台，数据同时以同样的方式写到两个盘上，两个盘互为镜象。磁盘镜象可以是分区镜象、全盘镜象。容错方式以空间换取，实施可以采用镜象或者双工技术</p><p>优点</p><p>➢ 可靠性高，策略简单，恢复数据时不必停机。</p><p>缺点</p><p>➢ 有效容量只有总容量的1&#x2F;2，利用率50%。由于磁盘冗余，硬件开销较大，成本较高</p><p><strong>循环奇偶校验阵列（RAID5）</strong></p><p>与RAID4类似，但校验数据不固定在一个磁盘上，而是循环地依次分布在不同的磁盘上，也称块间插入分布校验。它是目前采用最多、最流行的方式，至少需要3个硬盘。</p><p>优点</p><p>➢ 校验分布在多个磁盘中，写操作可以同时处理；</p><p>➢ 为读操作提供了最优的性能；</p><p>➢ 一个磁盘失效，分布在其他盘上的信息足够完成数据重建 </p><p>缺点</p><p>➢ 数据重建会降低读性能；</p><p>➢ 每次计算校验信息，写操作开销会增大，是一般存储操作时间的3倍。</p><p><strong>二维奇偶校验阵列（RAID6）</strong></p><p>RAID6是指带有两种分布存储的检验信息的磁盘阵列，它是对RAID5的扩展，主要是用于要求数据绝对不能出错的场合，使用了二种奇偶校验方法，需要N+2个磁盘</p><h3 id="纠删码（Erasure-Code）"><a href="#纠删码（Erasure-Code）" class="headerlink" title="纠删码（Erasure Code）"></a>纠删码（Erasure Code）</h3><p>是一种前向错误纠正技术（Forward ErrorCorrection，FEC），主要应用在网络传输中避免包的丢失，存储系统利用它来提高存储可靠性。相比多副本复制而言， 纠删码能够以更小的数据冗余度获得更高数据可靠性， 但编码方式较复杂，需要大量计算 。</p><p>EC的定义：Erasure Code是一种编码技术，它可以将n份原始数据，增加m份数据，并能通过n+m份中的任意n份数据，还原为原始数据。即如果有任意小于等于m份的数据失效，仍然能通过剩下的数据还原出来。</p><h2 id="计算机取证"><a href="#计算机取证" class="headerlink" title="计算机取证"></a>计算机取证</h2><h3 id="什么是计算机取证"><a href="#什么是计算机取证" class="headerlink" title="什么是计算机取证"></a>什么是计算机取证</h3><p><strong>计算机取证不过是简单地将计算机调查和分析技术应用于对潜在的、有法律效力的证据的确定与获取上。</strong></p><p><strong>计算机取证是使用软件和工具，按照一些预先定义的程序全面地检查计算机系统，以提取和保护有关计算机犯罪的证据。</strong></p><p>综合：<strong>计算机取证是指对能够为法庭接受的、足够可靠和有说服性的，存在于计算机和相关外设中的计算机证据的确认、保护、提取和归档的过程。</strong></p><h3 id="潜在证据"><a href="#潜在证据" class="headerlink" title="潜在证据"></a>潜在证据</h3><p><strong>证据通常都是在可以存储数据的硬件驱动器、存储设备或媒体中发现的。</strong></p><p>计算机取证是指使用科学方法和技术收集、保存、分析计算机系统、网络、通信设备中的数据，以作为法庭上的证据。在计算机取证过程中，潜在证据可能包括各种形式的数据和信息，这些数据可能存储在不同的地方，包括但不限于：</p><ol><li><p><strong>硬盘驱动器：</strong> 存储在硬盘上的文件、删除的文件、隐藏或未分配的磁盘空间中的数据、日志文件、系统恢复点和磁盘映像。</p></li><li><p><strong>移动存储设备：</strong> 如USB闪存驱动器、外部硬盘、SD卡、手机及其他便携式存储媒介中的数据。</p></li><li><p><strong>操作系统日志：</strong> 包括系统事件日志、安全日志、应用程序日志，它们记录了用户活动、系统错误、登录尝试和其他系统事件。</p></li><li><p><strong>网络设备：</strong> 如路由器、交换机、防火墙的日志文件，以及其他网络传输数据，可能包括网络流量、IP地址、MAC地址、传输的数据包等。</p></li><li><p><strong>云存储和服务：</strong> 云端的数据，包括在线文档、电子邮件、日历、通讯录、上传的照片和视频等。</p></li><li><p><strong>电子邮件：</strong> 电子邮件内容、附件、邮件头信息、已删除的邮件等。</p></li><li><p><strong>浏览器历史记录：</strong> 包括网页浏览历史、下载历史、书签、Cookies、缓存文件等。</p></li><li><p><strong>社交媒体：</strong> 社交网络上的帐户信息、聊天记录、发布的内容、好友列表、登录时间等。</p></li><li><p><strong>软件和应用程序：</strong> 安装在系统上的软件和应用程序可能包含有关用户行为的信息。</p></li><li><p><strong>内存：</strong> RAM中可以找到许多运行时的信息，如正在或最近运行的程序、系统状态、打开的文件等。</p></li><li><p><strong>元数据：</strong> 文件和文档的元数据，如创建时间、最后修改时间、作者信息等。</p></li><li><p><strong>加密的数据：</strong> 加密文件、硬盘或设备，需要破解密码才能访问其中的数据。</p></li><li><p><strong>日志文件：</strong> 各种系统和应用程序生成的日志文件记录了许多系统事件和用户活动。</p></li><li><p><strong>注册表信息：</strong> Windows注册表包含了系统和应用程序的配置信息，用户活动和设备使用记录。</p></li></ol><p>在进行计算机取证时，不仅要收集上述信息，还需要保持证据的完整性和可用性。这通常涉及到创建原始数据的完整副本（即制作镜像）并使用哈希值来保证数据未被更改。取证分析人员应该遵循严格的程序和协议，确保证据链完整且在法律程序中可以接受。</p><h2 id="操作系统安全"><a href="#操作系统安全" class="headerlink" title="操作系统安全"></a>操作系统安全</h2><h3 id="操作系统安全的概念"><a href="#操作系统安全的概念" class="headerlink" title="操作系统安全的概念"></a>操作系统安全的概念</h3><p>操作系统安全是指一系列的措施和技术，旨在保护操作系统免受未经授权访问、使用、泄露、破坏、修改或拒绝服务攻击。操作系统是计算机硬件和用户之间的接口，它管理着计算机资源和应用程序的执行。由于操作系统在计算机网络中的核心作用，其安全性对整个计算系统的安全至关重要。（chat）</p><h3 id="操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道"><a href="#操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道" class="headerlink" title="操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道"></a>操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道</h3><p><strong>Lampson关于隐通道的定义</strong>按常规不会用于传送信息但却被利用于泄漏信息的信息传送渠道。</p><p><strong>TCSEC关于隐通道的定义</strong>可以被进程利用来以违反系统安全策略的方式进行非法传输信息的通信通道</p><p>➢ 存储隐通道<br>❖ 限制：进程P不能与进程Q通信。<br>❖ 共享：文件系统。<br>❖ 目的：进程P想发送一条消息给进程Q。<br>❖ 一种使用存储隐通道的方法：<br>    ➢ 进程P在两进程都能读的一个目录中创建一个名为“send”的文件<br>    ➢ 进程Q要读消息前，Q删除文件send➢ 进程P创建一个文件，命名为0bit或者1bit来代表要传输的比特；<br>    ➢ 进程Q记录这个比特，并删除这个文件<br>    ➢ …<br>    ➢ 最后进程P创建一个名为“end”的文件。通信结束。</p><p>➢ 时间隐通道</p><p>❖ 针对KVM&#x2F;370系统的研究发现，可以基于两个虚拟机接收的CPU时间片来建立隐通道<br>    ➢ 若发送方想要发送比特0，则立即释放CPU<br>    ➢ 否则它将使用全部的时间片<br>    ➢ 接收方通过获得CPU的速度可以推断出前者发送的是0还是1<br>❖ 共享资源：CPU时间</p><h3 id="基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU-等概念"><a href="#基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU-等概念" class="headerlink" title="基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU 等概念"></a>基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU 等概念</h3><p><strong>活动目录（Active Directory，缩写为AD）</strong>是微软公司开发的一种目录服务，用于Windows域网络。它主要提供授权和认证的服务，使用LDAP（轻量级目录访问协议）、Kerberos和DNS等标准协议。活动目录允许管理员在网络范围内管理权限和控制对网络资源的访问。</p><h4 id="域"><a href="#域" class="headerlink" title="域"></a><strong>域</strong></h4><p><strong>就是共享用户账号、计算机账号和安全策略的计算机集合</strong></p><p><strong>域是一个安全边界</strong>：资源在一个域中参与共享。</p><p>域中集中存储用户账号的计算机就是域控制器，域控制器存储着目录数据并管理用户域的交互关系，包括用户登录过程、身份验证和目录搜索等。</p><h4 id="活动目录和域控制器"><a href="#活动目录和域控制器" class="headerlink" title="活动目录和域控制器"></a><strong>活动目录和域控制器</strong></h4><p><strong>一个域中可有一个或多个域控制器，各域控制器间可以相互复制活动目录</strong></p><h4 id="组织单元-（OU）"><a href="#组织单元-（OU）" class="headerlink" title="组织单元 （OU）"></a>组织单元 （OU）</h4><p>OU是一种类型的目录对象⎯⎯容器，其作用主要用来委派对用户、组及资源集合的管理权限<br>    ◼ 控制用户&#x2F;组对资源的访问<br>    ◼ 建立&#x2F;应用组策略对象<br>    ◼ 实现管理委派<br>    ◼ 组织具有公共属性的对象，如打印机</p><h3 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h3><p><strong>组策略GPMC</strong>⎯⎯“一对多”的管理</p><p>组策略是Windows Server 2003操作系统中提供的一种重要的更新和配置管理技术。<br>     系统管理员使用组策略来为计算机和用户组管理桌面配置指定的选项<br>     组策略很灵活，它包括如下的一些选项：基于注册表的策略设置、安全设置、软件安装、脚本、计算机启动与关闭、用户登录和注销，文件重定向等<br>     Windows Server 2003包括几百种可以配置的组策略设置。组策略设置允许企业管理员通过增强和控制用户桌面来减少总的开销</p><p>• 策略提供大量定制桌面的管理<br>• 组策略管理控制台（GPMC）让管理工作更简单<br>• RsOP得到组策略应用的结果<br>• 主要优势：<br>• 降低管理、支持与培训成本<br>• 提升用户工作效率<br>• 允许极大量的定制项目 – 其扩展性不会牺牲定制的灵活性</p><h1 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2. 基本原理"></a>2. 基本原理</h1><h2 id="信息系统概论-1"><a href="#信息系统概论-1" class="headerlink" title="信息系统概论"></a>信息系统概论</h2><h3 id="针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术"><a href="#针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术" class="headerlink" title="针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术"></a>针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术</h3><p><strong>秒杀架构设计思路</strong></p><p><strong>将请求拦截在系统上游，降低下游压力：</strong>秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，甚至导致死锁，最终请求超时。</p><p><strong>充分利用缓存：</strong>利用缓存可极大提高系统读写速度。</p><p><strong>消息中间件：</strong>消息队列可以削峰，将拦截大量并发请求，这是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。</p><p><strong>限流，削峰，异步处理，内存缓存，可拓展</strong></p><p><strong>关键技术：</strong></p><ol><li><p><strong>负载均衡</strong>：通过使用负载均衡器分散流量至多个服务器，可以提高系统的处理能力</p></li><li><p><strong>分布式缓存</strong>：使用如Redis或Memcached这样的分布式缓存系统可以极大地减少数据库的压力，通过缓存热点数据来快速响应用户请求。</p></li><li><p><strong>数据库分离</strong>：将读操作和写操作分离，通过读写分离和数据库集群来提高数据库的并发处理能力。</p></li><li><p><strong>消息队列</strong>：引入消息队列，可以平衡负载和解耦服务，通过异步处理来提高系统的响应速度和吞吐量。</p></li><li><p><strong>限流与降级</strong>：通过限流算法防止系统超载，确保系统稳定性。在高流量情况下，及时的服务降级也很关键。</p></li><li><p><strong>数据分片与分区</strong>：对数据库进行水平分区或使用分布式数据库，可将数据分散在不同的节点上，减少单点负载。</p></li><li><p><strong>服务的无状态设计</strong>：确保服务无状态，这样可以无缝扩展服务实例以处理更多的并发请求。</p></li><li><p><strong>CDN</strong>：使用内容分发网络（CDN）可以将静态资源缓存到离用户更近的地方，减少主服务器的负担。</p></li><li><p><strong>动静分离</strong>：通过将动态内容和静态内容分开处理，可以提高处理速度和效率。</p></li><li><p><strong>弹性伸缩</strong>：云服务提供了基于需求自动扩展和缩减服务器实例数量的能力，可以根据流量的实时变化来调整资源。</p></li><li><p><strong>数据库优化</strong>：包括数据库索引优化、查询优化和合理的数据库架构设计，以减少查询时间和提高效率。</p></li><li><p><strong>应用性能监控（APM）</strong>：使用各种监控工具来实时监控应用程序的性能，快速定位并解决性能瓶颈问题。</p></li></ol><h2 id="信息系统安全概论-1"><a href="#信息系统安全概论-1" class="headerlink" title="信息系统安全概论"></a>信息系统安全概论</h2><h3 id="信息系统为什么是脆弱的？"><a href="#信息系统为什么是脆弱的？" class="headerlink" title="信息系统为什么是脆弱的？"></a>信息系统为什么是脆弱的？</h3><p><strong>硬件组件</strong></p><p>信息系统硬件组件的安全隐患多来源于设计，主要表现为物理安全方面的问题。</p><p><strong>软件组件</strong></p><p>软件组件的安全隐患来源于设计和软件工程中的问题。</p><p>➢ 漏洞</p><p>➢ 不必要的功能冗余引起安全脆弱性；</p><p>➢ 未按安全等级要求进行模块化设计，安全等级不能达到预期</p><p><strong>网络和通信协议</strong></p><p>➢ TCP&#x2F;IP协议族本身的缺陷</p><p>➢ 基于TCP&#x2F;IP协议Internet的安全隐患</p><p>• 缺乏对用户身份的鉴别</p><p>• 缺乏对路由协议的鉴别认证</p><p>• TCP&#x2F;UDP的缺陷</p><h3 id="攻防不对称性及应对思路，拟态主动防御"><a href="#攻防不对称性及应对思路，拟态主动防御" class="headerlink" title="攻防不对称性及应对思路，拟态主动防御"></a>攻防不对称性及应对思路，拟态主动防御</h3><p>攻防不对称性是指在网络安全中，攻击者和防御者所面临的条件和需求不同，进而导致的力量不平衡。具体来说，攻击者只需找到系统中的一个漏洞即可实施攻击，而防御者则需要保护系统的所有潜在脆弱点，这显然是一项更艰巨的任务。</p><p>攻防不对称性的特点包括：</p><ul><li><strong>成本不对称</strong>：攻击者通常花费较少资源就能发起有效攻击，而防御者则需要投入大量资源来防御潜在的多样化攻击。</li><li><strong>知识不对称</strong>：攻击者只需要知道特定的漏洞信息就可以发起攻击，而防御者则需要全面了解整个信息系统的安全状况。</li><li><strong>倡议不对称</strong>：攻击者可以挑选时间和地点发起攻击，而防御者则需要时刻准备应对意料之外的攻击。</li></ul><h4 id="应对思路"><a href="#应对思路" class="headerlink" title="应对思路"></a>应对思路</h4><p>在面对攻防不对称性的挑战时，防御者可以采取以下策略来增强安全防御能力：</p><ol><li><p><strong>分层防御</strong>：通过多层安全措施来保护信息系统，即使攻击者突破了一层防御，其他层次的安全措施仍然可以阻止攻击的进一步发展。</p></li><li><p><strong>最小权限原则</strong>：只授予用户或系统完成其职责所必需的信息访问权限，以此减少攻击面。</p></li><li><p><strong>持续监测和审计</strong>：实施实时监控和定期审计，确保对系统的异常行为和安全事件能够及时发现并响应。</p></li><li><p><strong>定期更新和补丁管理</strong>：确保所有系统和软件都安装了最新的安全更新和补丁。</p></li><li><p><strong>安全意识教育</strong>：提高组织内部用户的安全意识，减少因用户失误导致的安全事件。</p></li><li><p><strong>事故响应计划</strong>：制定并实施有效的事故响应计划，以便在发生安全事件时能够迅速采取行动，减轻损失。</p></li></ol><h4 id="拟态主动防御"><a href="#拟态主动防御" class="headerlink" title="拟态主动防御"></a>拟态主动防御</h4><p>拟态防御是一种新型的安全防御技术，其基本思想是通过动态变换系统的攻击面，使攻击者无法准确掌握目标系统的真实状态，从而增加攻击者的不确定性和攻击成本。拟态防御可以通过以下方式实现：</p><ul><li><strong>动态变换</strong>：定期或根据某种算法自动更改系统配置，如IP地址、端口号、协议等，使攻击者难以确定有效攻击向量。</li><li><strong>混淆技术</strong>：在系统中部署虚假的信息和服务，迷惑攻击者，引导其走向陷阱或死胡同。</li><li><strong>强化随机性</strong>：采用随机化技术在系统设计和运行中引入不确定性，比如随机分配资源和任务，让攻击路径变得难以预测。</li><li><strong>主动应对</strong>：系统能够监测到攻击行为时，主动调整策略或者改变系统行为，对攻击者造成反制。</li></ul><p>采用拟态防御可以显著提高攻击的难度，从而在一定程度上缓解攻防不对称的问题。然而，这也需要更高级的设计和管理能力，确保系统在变换的过程中不会影响正常服务。</p><h3 id="5G-对信息系统安全带来的挑战"><a href="#5G-对信息系统安全带来的挑战" class="headerlink" title="5G 对信息系统安全带来的挑战"></a>5G 对信息系统安全带来的挑战</h3><p>5G网络是第五代移动通信技术，它为用户提供了更高的数据传输速率、更低的延迟和更高的连接密度。尽管这些优点为用户带来了许多便利，但5G技术的引入也给信息系统安全带来了新的挑战：</p><ol><li><p><strong>更大的攻击面</strong>：5G网络支持更多的设备连接，包括物联网(IoT)设备，这大大扩展了潜在的攻击面。每个设备都可能成为攻击者的目标。</p></li><li><p><strong>供应链风险</strong>：5G网络涉及复杂的供应链，其中包括多家供应商的设备和软件。供应链的安全弱点可能会影响整个网络。</p></li><li><p><strong>端到端加密挑战</strong>：随着5G网络对加密和隐私保护的要求提高，确保端到端加密的有效实施变得更加困难。</p></li><li><p><strong>更高的带宽和低延迟带来的问题</strong>：虽然这些特性改善了用户体验，但它们也使得发起大规模、高速度的攻击（比如DDoS攻击）更加容易。</p></li><li><p><strong>设备鉴别和管理问题</strong>：随着设备数量的激增，有效地识别和管理这些设备，确保它们都是安全的和符合政策的，变得更加困难。</p></li><li><p><strong>切片管理的复杂性</strong>：5G网络采用了网络切片技术，为不同的服务需求提供定制化的网络环境。每个切片都需要单独管理，提出了对安全策略和隔离机制的高要求。</p></li><li><p><strong>移动边缘计算(MEC)的安全性</strong>：5G促进了MEC的发展，将计算能力带到网络边缘靠近用户。这种分散型计算架构带来了数据存储和处理的安全性问题。</p></li><li><p><strong>物理层和无线接口的威胁</strong>：5G网络的无线接口和物理层也可能面临攻击，例如通过嗅探、欺骗和重放攻击来威胁数据的保密性和完整性。</p></li></ol><h4 id="应对措施"><a href="#应对措施" class="headerlink" title="应对措施"></a>应对措施</h4><p>针对以上挑战，可以采取以下措施来提高5G网络的信息系统安全：</p><ul><li><strong>增强设备安全</strong>：确保所有接入网络的设备都符合严格的安全标准。</li><li><strong>多层安全策略</strong>：实现针对不同网络层次和业务类型的安全策略，包括物理、网络、应用层的安全措施。</li><li><strong>身份管理和访问控制</strong>：强化用户和设备的身份管理系统，实施有效的访问控制策略。</li><li><strong>网络监控和异常检测</strong>：使用先进的监控工具和机器学习技术来检测异常行为和潜在的安全威胁。</li><li><strong>加强供应链安全</strong>：对供应链合作伙伴进行严格的安全审查，确保所有组件都符合安全标准。</li><li><strong>安全架构设计</strong>：在设计网络和服务时，将安全作为核心考虑因素。</li><li><strong>隔离和随机性</strong>：运用网络切片和虚拟化技术，确保不同服务之间的隔离，以及在安全配置中加入随机性，提高攻击的难度。</li></ul><h3 id="信息系统安全保障模型：CMM-框架"><a href="#信息系统安全保障模型：CMM-框架" class="headerlink" title="信息系统安全保障模型：CMM 框架"></a>信息系统安全保障模型：CMM 框架</h3><p>在安全技术上，不仅要考虑具体的产品和技术，更要考虑信息系统的安全技术体系架构。</p><p>建立相应的安全保障管理体系，形成长效和持续改进的安全管理机制。</p><p>建立相应的安全保障管理体系，形成长效和持续改进的安全管理机制。</p><p>注重人的安全意识以及安全专业技能和能力等。</p><p><strong>安全保障能力维</strong></p><p>第一能力级别0：未实施</p><p>第二能力级别1：基本执行</p><p>第三能力级别2：计划跟踪</p><p>第四能力级别3：充分定义</p><p>第五能力级别4：量化控制</p><p>第六能力级别5：持续改进</p><h2 id="安全需求和安全策略-1"><a href="#安全需求和安全策略-1" class="headerlink" title="安全需求和安全策略"></a>安全需求和安全策略</h2><h3 id="常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）"><a href="#常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）" class="headerlink" title="常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）"></a>常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）</h3><h4 id="访问能力表（Capability-List-CL）"><a href="#访问能力表（Capability-List-CL）" class="headerlink" title="访问能力表（Capability List, CL）"></a>访问能力表（Capability List, CL）</h4><p>访问能力表是一种基于能力的访问控制机制，它将权限与用户（或用户的程序）关联起来，而不是与资源关联。每个用户都有一个能力列表，指明了该用户能够访问的资源以及相应的访问权限。</p><p><strong>主要特点</strong>：</p><ul><li>每个用户或进程都有一个与之关联的能力列表。</li><li>能力列表指出用户可以访问的资源及其访问权限（如读、写、执行）。</li><li>能力可以被传递或委托，使得用户可以将某些权限授予其他用户或进程。</li></ul><p><strong>优势</strong>：</p><ul><li>权限的分发和管理与具体的资源分离开来。</li><li>可以方便地为用户配置一组资源的权限。</li><li>更容易实现权限的细粒度控制。</li></ul><p><strong>劣势</strong>：</p><ul><li>管理能力列表可能会变得复杂，尤其是在用户数目众多、系统资源广泛的情况下。</li><li>如果能力列表被泄露或未受到妥善保护，可能会产生安全风险。</li></ul><h4 id="访问控制列表（Access-Control-List-ACL）"><a href="#访问控制列表（Access-Control-List-ACL）" class="headerlink" title="访问控制列表（Access Control List, ACL）"></a>访问控制列表（Access Control List, ACL）</h4><p>访问控制列表是一种更为常见的访问控制机制，它将权限与资源关联起来。对于系统中的每个资源（如文件、目录或设备），都有一个对应的ACL，列出了具有访问该资源权限的所有用户及其访问级别。</p><p><strong>主要特点</strong>：</p><ul><li>每个资源（如文件或目录）都有一个与之关联的访问控制列表。</li><li>ACL列出了具有访问权限的用户或用户组以及各自的权限。</li><li>管理者可以对每个资源设置不同用户或用户组的不同权限。</li></ul><p><strong>优势</strong>：</p><ul><li>权限与资源直接关联，容易理解和管理。</li><li>适用于需要对单个资源进行精细访问控制的情况。</li><li>多数操作系统和文件系统都原生支持ACL。</li></ul><p><strong>劣势</strong>：</p><ul><li>对于需要大量权限变更的环境，维护ACL可能会变得繁琐。</li><li>对于每个资源，都需要独立设置和维护权限，难以批量操作。</li></ul><p>总的来说，CL提供了一种以用户或进程为中心的权限管理方式，而ACL则是以资源为中心的权限管理方式。在实现安全策略时，选择哪一种机制取决于特定的应用场景、安全需求以及管理复杂性的考虑。</p><h3 id="常见的强制访问控制模型：Bell-LaPadula、BIBA-原理、优缺点及其应用"><a href="#常见的强制访问控制模型：Bell-LaPadula、BIBA-原理、优缺点及其应用" class="headerlink" title="常见的强制访问控制模型：Bell-LaPadula、BIBA 原理、优缺点及其应用"></a>常见的强制访问控制模型：Bell-LaPadula、BIBA 原理、优缺点及其应用</h3><p>Bell-LaPadula和Biba模型都是传统的访问控制模型，旨在保护信息系统的安全。这两个模型是为了不同的安全目标而设计的，分别关注保密性和完整性。</p><h3 id="Bell-LaPadula模型"><a href="#Bell-LaPadula模型" class="headerlink" title="Bell-LaPadula模型"></a>Bell-LaPadula模型</h3><p><strong>原理</strong>:<br>Bell-LaPadula模型是第一个用于计算机安全性的形式数学模型，主要关注保护数据的保密性。它是在军事和政府环境中应对机密信息泄露问题而创建的。Bell-LaPadula模型通过以下两个核心规则来实现保密性目标：</p><ol><li><p><strong>简单安全性属性（Simple Security Property，也称为”no read up”，NRU）</strong>:<br>用户不得读取高于其安全级别的数据，防止泄露敏感信息。</p></li><li><p><strong>星形安全性属性（Star Property，也称为”no write down”，NWD）</strong>:<br>用户不得写入低于其安全级别的数据，防止敏感信息流向较低安全级别。</p><p>BLP 保密模型基于两种规则来保障数据的机密度与敏感度：</p><p>➢ 不上读（NRU）⎯⎯主体不可读安全级别高于它的数据</p><p>➢ 不下写（NWD）⎯⎯主体不可写安全级别低于它的数据</p></li></ol><p><strong>优点</strong>:</p><ul><li>提供了明确的安全性规则，易于实施在需要严格访问控制的环境中。</li><li>对于保密性要求非常严格的系统，如军事或政府秘密项目，模型提供了坚实的理论基础。</li></ul><p><strong>缺点</strong>:</p><ul><li>过分强调安全性，可能会限制信息的合法共享和灵活性。</li><li>不处理数据完整性和可用性问题。</li></ul><p><strong>应用</strong>:<br>Bell-LaPadula模型主要适用于需要严格保密性控制的环境，例如军事、情报和政府部门的高安全级别系统。</p><h3 id="Biba模型"><a href="#Biba模型" class="headerlink" title="Biba模型"></a>Biba模型</h3><p><strong>原理</strong>:<br>Biba模型是另一种经典的安全性模型，它的设计目的是保护数据的完整性，防止未授权的信息修改。它通过以下两个主要的规则来实施：</p><ol><li><p><strong>简单完整性属性（Simple Integrity Property，也称为”no write up”，NWU）</strong>:<br>用户不得写入高于其安全级别的数据，防止将错误或低质量的信息传递到更高的完整性级别。</p></li><li><p><strong>星形完整性属性（Star Property，也称为”no read down”，NRD）</strong>:<br>用户不得读取低于其安全级别的数据，以免受到低质量数据的影响。</p><p>BIBA模型基于两种规则来保障数据的完整性的保密性：</p><p>➢ <strong>不下读（NRU）属性主体不能读取安全级别低于它的数据</strong></p><p>➢<strong>不上写（NWD）属性主体不能写入安全级别高于它的数据</strong></p></li></ol><p><strong>优点</strong>:</p><ul><li>强调了数据的完整性和一致性。</li><li>适用于需要保持数据不变性和准确性的应用场景。</li></ul><p><strong>缺点</strong>:</p><ul><li>与Bell-LaPadula模型类似，Biba也不处理系统的可用性问题。</li><li>在实际中可能会限制数据的正常使用和共享。</li></ul><p><strong>应用</strong>:<br>Biba模型适用于那些对数据完整性要求极高的场所，如银行系统、医疗记录系统和任何需要确保数据不被未经授权篡改的环境。</p><p>总的来说，Bell-LaPadula模型和Biba模型各自针对信息系统安全的不同方面提供了理论框架和保护措施。然而，它们在现代信息系统中的应用可能受限于其在灵活性和完整性（Bell-LaPadula）或保密性（Biba）方面的局限性。实际应用中，可能需要结合其他模型和策略，如Clark-Wilson模型（数据完整性和商业决策的正确性）或角色基访问控制（RBAC）模型（基于用户角色的权限分配），以满足现代信息系统的多样性安全需求。</p><p>从这两个属性来看，BIBA与BLP模型的两个属性是相反的：</p><p>➢ BLP模型提供保密性；</p><p>➢ BIBA模型对于数据的完整性提供保障。</p><h3 id="安全策略如何应用到防火墙等安全设备中"><a href="#安全策略如何应用到防火墙等安全设备中" class="headerlink" title="安全策略如何应用到防火墙等安全设备中"></a>安全策略如何应用到防火墙等安全设备中</h3><p><strong>Internet</strong>上用户的安全级别为“公开”，依照<strong>BIBA</strong>模型，Web服务器上数据的完整性将得</p><p>到保障，<strong>Internet</strong>上的用户只能读取服务器上的数据而不能更改它。因此，任何<strong>POST</strong>操作</p><p>将被拒绝。</p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220191040383.png" alt="image-20231220191040383"></p><h2 id="信息系统的风险评估-1"><a href="#信息系统的风险评估-1" class="headerlink" title="信息系统的风险评估"></a>信息系统的风险评估</h2><h3 id="风险处置策略"><a href="#风险处置策略" class="headerlink" title="风险处置策略"></a>风险处置策略</h3><p><strong>降低风险（Reduce Risk）</strong></p><p>采取适当的控制措施来降低风险，包括技术手段和管理手段，如安装防火墙，</p><p>杀毒软件，或是改善不规范的工作流程、制定业务连续性计划，等等。</p><p><strong>避免风险（Avoid Risk）</strong></p><p>通过消除可能导致风险发生的条件来避免风险的发生，如将公司内外网隔离</p><p>以避免来自互联网的攻击，或是将机房安置在不可能造成水患的位置，等等。</p><p><strong>转移风险（Transfer Risk)</strong></p><p>将风险全部或者部分地转移到其他责任方，例如购买商业保险。</p><p><strong>接受风险（Accept Risk）</strong></p><p>在实施了其他风险应对措施之后，对于残留的风险，可以有意识地选择接受。</p><h3 id="信息系统安全风险计算模型"><a href="#信息系统安全风险计算模型" class="headerlink" title="信息系统安全风险计算模型"></a>信息系统安全风险计算模型</h3><p>风险计算模型是对通过风险分析计算风险值过程的抽象，它主要包括资产评估、威胁评估、脆弱性评估。</p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220192309588.png" alt="image-20231220192309588"><img src="D:\my_data\blog\zyhblog-img\image-20231220192334775.png" alt="image-20231220192334775"><em><strong>*资产等级计算公式*</strong></em></p><p>AV&#x3D;F(AC, AI, AA)</p><p>Asset Value 资产价值</p><p>Asset Confidentiality 资产保密性赋值</p><p>Asset Integrity 资产完整性赋值</p><p>Asset Availability 资产可用性赋值</p><p>例1：AV&#x3D;MAX(AC, AI, AA)</p><p>例2：AV&#x3D;AC+AI+AA</p><p>例3：AV&#x3D;AC×AI×AA</p><h4 id="威胁来源列表"><a href="#威胁来源列表" class="headerlink" title="*威胁来源列表*"></a><em><strong>*威胁来源列表*</strong></em></h4><table><thead><tr><th>来源</th><th></th><th>描述</th></tr></thead><tbody><tr><td>环境因素</td><td></td><td>断电、静电、灰尘、潮湿、温度、鼠蚁虫害、电磁干扰、洪灾、火灾、地震、意外 事故等环境危害或自然灾害，以及软件、硬件、数据、通信线路等方面的故障</td></tr><tr><td>人为因素</td><td>恶意人员</td><td>不满的或有预谋的内部人员对信息系统进行恶意破坏；</td></tr><tr><td>采用自主或内外勾结的方式盗窃机密信息或进行篡改，获取利益外部人员利用信息系统的脆弱性,对网络或系统的机密性、完整性和可用性进行破坏，以获取利益或炫耀能力</td><td></td><td></td></tr><tr><td>人为因素</td><td>非恶意人员</td><td>内部人员由于缺乏责任心，或者由于不关心和不专注，或者没有遵循规章制度和操作流程而导致故障或信息损坏；</td></tr><tr><td>内部人员由于缺乏培训、专业技能不足、不具备岗 位技能要求而导致信息系统故障或被攻击</td><td></td><td></td></tr></tbody></table><h4 id="风险计算方法"><a href="#风险计算方法" class="headerlink" title="风险计算方法"></a><strong>风险计算方法</strong></h4><p>$$风险值&#x3D;R(A, T, V) &#x3D; R(L(T, V), F(Ia,Va))$$</p><p><strong>R</strong>安全风险计算函数</p><p><strong>A</strong>资产</p><p><strong>T</strong>威胁</p><p><strong>V</strong>脆弱性</p><p><strong>Ia</strong>安全事件所作用的资产价值</p><p><strong>Va</strong> 脆弱性严重程度</p><p><strong>L</strong>威胁利用资产的脆弱性导致安全事件发生的可能性</p><p><strong>F</strong>安全事件发生后产生的损失</p><h2 id="信息系统等级保护-1"><a href="#信息系统等级保护-1" class="headerlink" title="信息系统等级保护"></a>信息系统等级保护</h2><h3 id="等级保护主要工作流程，定级的流程，备案的流程，备案地点"><a href="#等级保护主要工作流程，定级的流程，备案的流程，备案地点" class="headerlink" title="等级保护主要工作流程，定级的流程，备案的流程，备案地点"></a>等级保护主要工作流程，定级的流程，备案的流程，备案地点</h3><p><img src="D:\my_data\blog\zyhblog-img\image-20231220213058592.png" alt="image-20231220213058592"></p><h4 id="等级保护主要工作流程"><a href="#等级保护主要工作流程" class="headerlink" title="*等级保护主要工作流程*"></a><em><strong>*等级保护主要工作流程*</strong></em></h4><p>1 <strong>定级  定级是等级保护的首要环节</strong></p><p>2 <strong>备案 备案是等级保护的核心</strong></p><p>3 <strong>建设整改 建设整改是等级保护工作落实的关键</strong></p><p>4 <strong>等级测评 等级测评是评价安全保护状况的方法</strong></p><h4 id="定级流程"><a href="#定级流程" class="headerlink" title="定级流程"></a><strong>定级流程</strong></h4><p><img src="D:\my_data\blog\zyhblog-img\image-20231220213206332.png" alt="image-20231220213206332"></p><h4 id="备案的流程"><a href="#备案的流程" class="headerlink" title="备案的流程"></a><strong>备案的流程</strong></h4><p>运营、使用单位在确定等级后到所在地的市级及以上公安机关备案。</p><p>• 新建二级及以上信息系统在投入运营后30日内、已运行的二级及以上信息系统在等级确定30日内备案。</p><p>• 公安机关对信息系统备案情况进行审核，对符合要求的在10个工作日内颁发等级保护备案证明。</p><p>• 对于定级不准的，应当重新定级、重新备案。对于重新定级的，公安机关一般会建议备案单位组织专家进行重新定级评审，并报上级主管部门审批。</p><h4 id="备案地点"><a href="#备案地点" class="headerlink" title="备案地点"></a><strong>备案地点</strong></h4><p><strong>二级以上信息系统</strong></p><p>由信息系统运营使用单位(备案单位)到地市级以上公安机关网络安全保卫部门办理备案手续，填写《信息系统安全等级保护备案表》 。</p><p><strong>隶属于省级的备案单位</strong></p><p>其跨地（市）联网运行的信息系统，由省级公安机关网络安全保卫部门受理备案</p><p><strong>隶属于中央的在京单位</strong></p><p>其跨省或者全国统一联网运行并由主管部门统一定级的信息系统，由主管部门向公安部备案。</p><p><strong>跨省或者全国统一联网运行的信息系统</strong></p><p>在各地运行、应用的分支系统，由所在地地市级以上公安机关网络安全保卫部门受理备案。</p><p><strong>各部委统一定级信息系统在各地的分支系统</strong></p><p>即使是上级主管部门定级的，也要到当地公安网络安全保卫部门备案。</p><h3 id="等级保护主要工作：定级备案，建设整改，等级测评，监督检查"><a href="#等级保护主要工作：定级备案，建设整改，等级测评，监督检查" class="headerlink" title="等级保护主要工作：定级备案，建设整改，等级测评，监督检查"></a>等级保护主要工作：定级备案，建设整改，等级测评，监督检查</h3><p>等级保护制度是针对信息系统安全的一系列规定和措施，旨在确保信息系统达到一定的安全保护等级。这个制度通常涵盖了信息系统的定级备案、建设整改、等级测评和监督检查等主要工作。接下来，我会逐一详细介绍这些工作。</p><h4 id="1-定级备案"><a href="#1-定级备案" class="headerlink" title="1. 定级备案"></a>1. 定级备案</h4><p>在定级备案阶段，信息系统的管理者或者所有者需要对系统进行安全等级的划分。这个过程包括：</p><ul><li><strong>安全等级的划分</strong>：依据信息系统的业务特点和安全需求，以及系统可能面临的安全威胁，将系统分类到不同的安全等级中。</li><li><strong>风险评估</strong>：对系统可能受到的各种威胁和脆弱性进行评估，以确定系统应达到的安全保护等级。</li><li><strong>文件备案</strong>：将信息系统的安全等级和相关的风险评估结果报告给相关的监管机构，进行备案。</li></ul><h4 id="2-建设整改"><a href="#2-建设整改" class="headerlink" title="2. 建设整改"></a>2. 建设整改</h4><p>一旦完成了系统的定级工作，接下来就是根据评定的安全等级来进行系统的安全建设或者整改。这个阶段的工作包括：</p><ul><li><strong>安全措施的落实</strong>：根据信息系统的安全等级，实施必要的安全保护措施，如物理安全、网络安全、主机安全、应用安全、数据安全和紧急响应等。</li><li><strong>制定安全管理制度</strong>：包括安全操作规程、安全事件处理流程、用户管理规定等。</li><li><strong>人员培训</strong>：对管理人员、操作人员进行安全意识和技能培训，确保相关人员能够理解和遵守安全规程。</li><li><strong>系统整改</strong>：针对安全评估中发现的问题，进行必要的技术整改和管理整改。</li></ul><h4 id="3-等级测评"><a href="#3-等级测评" class="headerlink" title="3. 等级测评"></a>3. 等级测评</h4><p>等级测评是对信息系统实施的安全保护措施进行评价的过程，以确保这些措施能够满足既定的安全需求。这个阶段包括：</p><ul><li><strong>安全测评</strong>：通过内部检查或者聘请外部专业机构来进行系统的安全测评。</li><li><strong>评估报告</strong>：生成测评报告，其中详细说明测评过程、发现的问题以及改进建议。</li><li><strong>整改落实</strong>：根据测评报告中的建议，对系统进行进一步的整改。</li></ul><h4 id="4-监督检查"><a href="#4-监督检查" class="headerlink" title="4. 监督检查"></a>4. 监督检查</h4><p>为了确保信息系统安全保护措施的持续有效，需要进行定期的监督检查。这包括：</p><ul><li><strong>定期审计</strong>：定期对系统的安全状况进行审计，确保持续遵守安全规程和政策。</li><li><strong>监督检查</strong>：监管机构可能会定期进行监督检查，以确保信息系统的安全保护措施得到有效实施。</li><li><strong>连续监控</strong>：实施实时监控系统，以便对安全事件做出快速响应。</li></ul><p>等级保护工作要求信息系统的所有者、管理者和使用者共同参与，它是一个持续的过程，需要随着威胁环境和技术的发展而不断调整和完善。在不同国家和地区，等级保护的具体实施标准和流程可能会有所不同，但上述介绍的核心内容通常是普遍适用的。</p><h2 id="信息系统的物理安全-1"><a href="#信息系统的物理安全-1" class="headerlink" title="信息系统的物理安全"></a>信息系统的物理安全</h2><h3 id="环境安全：机房的三度要求，常见的消防设计、防盗措施等"><a href="#环境安全：机房的三度要求，常见的消防设计、防盗措施等" class="headerlink" title="环境安全：机房的三度要求，常见的消防设计、防盗措施等"></a>环境安全：机房的三度要求，常见的消防设计、防盗措施等</h3><p>温度、湿度和洁净度并称为三度，为保证计算机网络系统的正常运行，对机房内的三度都有明确的要求。为使机房内的三度达到规定的要求，空调系统、去湿机、除尘器是必不可少的设备。重要的计算机系统安放处还应配备专用的空调系统，它比公用的空调系统在加湿、除尘等方面有更高的要求</p><p><strong>温度：机房温度一般应控制在18～22℃</strong></p><p><strong>湿度：相对湿度一般控制在40％～60％为宜</strong></p><p><strong>洁净度：尘埃颗粒直径&lt;0.5微米，含尘量&lt;1万颗&#x2F;升</strong></p><p>《七氟丙烷（HFC-227ea）洁净气体灭火系统设计规范》</p><p><strong>机房防盗要求</strong></p><p>视频监视系统是一种更为可靠的防盗设备，能对计算机网络系统的外围环境、操作环境进行实时全程监控。对重要的机房，还应采取特别的防盗措施，如值班守卫、出入口安装金属探测装置等。</p><p>在需要保护的重要设备、存储媒体和硬件上贴上特殊标签（如磁性标签），当有人非法携带这些重要设备或物品外出时，检测器就会发出报警信号。</p><p>将每台重要的设备通过光纤电缆串接起来，并使光束沿光纤传输，如果光束传输受阻，则自动报警</p><h3 id="供电安全：GB-T-2887-2000-规定的三类供电方式，电源防护措施，接地与防雷要求"><a href="#供电安全：GB-T-2887-2000-规定的三类供电方式，电源防护措施，接地与防雷要求" class="headerlink" title="供电安全：GB&#x2F;T 2887-2000 规定的三类供电方式，电源防护措施，接地与防雷要求"></a>供电安全：GB&#x2F;T 2887-2000 规定的三类供电方式，电源防护措施，接地与防雷要求</h3><p><strong>GB&#x2F;T 2887-2000将供电方式分为三类</strong></p><p>一类供电 需要建立不间断供电系统。兵工厂、大型钢厂、火箭发射基地、医院等.</p><p>二类供电 需要建立带备用的供电系统。</p><p>三类供电 按一般用户供电考虑。</p><p><strong>电源防护措施</strong></p><p>不间断电源</p><p>电源相关操作</p><p>​系统接地、正确开关机、电缆连接和卡的插拔、电源要匹配</p><p>电源调整器</p><p><strong>接地可以为计算机系统的数字电路提供一个稳定的0V参考电位</strong></p><h3 id="电磁泄漏产生的原理、电磁泄漏的途径及防护方法"><a href="#电磁泄漏产生的原理、电磁泄漏的途径及防护方法" class="headerlink" title="电磁泄漏产生的原理、电磁泄漏的途径及防护方法"></a>电磁泄漏产生的原理、电磁泄漏的途径及防护方法</h3><p>电磁泄漏指电子设备的杂散电磁能量通过导线或空间向外扩散。</p><p>任何处于工作状态的电磁信息设备，如计算机、打印机、复印机、传真机、手机电话等，都存在不同程度的电磁泄漏问题，这是无法摆脱的电磁现象。</p><p>如果这些泄漏“夹带”着设备所处理的信息，均可构成了电磁信息泄漏。</p><p><strong>电磁泄漏的途径</strong></p><p>以电磁波形式的辐射泄漏</p><p>电源线、控制线、信号线和地线造成的传导泄漏</p><p><strong>铜网式屏蔽室</strong></p><p>用于电子设备防电磁干扰、高频医疗设备、雷达产品实验测试等计量检测场所。</p><h2 id="信息系统的可靠性-1"><a href="#信息系统的可靠性-1" class="headerlink" title="信息系统的可靠性"></a>信息系统的可靠性</h2><h3 id="失效率的规律，失效率、寿命、可靠度三者之间关系的推导"><a href="#失效率的规律，失效率、寿命、可靠度三者之间关系的推导" class="headerlink" title="失效率的规律，失效率、寿命、可靠度三者之间关系的推导"></a>失效率的规律，失效率、寿命、可靠度三者之间关系的推导</h3><p>失效率（Failure Rate）、寿命（Lifetime）和可靠度（Reliability）是评估产品或系统性能的三个关键指标，并且它们之间存在一定的数学关系。下面是简要推导这些指标之间关系的过程。</p><h3 id="失效率（λ）"><a href="#失效率（λ）" class="headerlink" title="失效率（λ）"></a>失效率（λ）</h3><p>失效率通常表示为单位时间内的故障次数的期望值，通常使用“每小时故障数”（Failures per Hour）来表示。对于许多产品来说，失效率随时间的变化而变化，并且可以通过失效密度函数（failure density function）f(t)来描述。</p><h3 id="寿命（L）"><a href="#寿命（L）" class="headerlink" title="寿命（L）"></a>寿命（L）</h3><p>寿命通常是指产品或系统正常工作直到发生第一次故障所经历的时间。平均寿命可以通过失效率函数λ(t)来计算，如果λ(t)是恒定的，那么平均寿命就是失效率的倒数（1&#x2F;λ）。</p><h3 id="可靠度（R-t-）"><a href="#可靠度（R-t-）" class="headerlink" title="可靠度（R(t)）"></a>可靠度（R(t)）</h3><p>可靠度是指在特定时间t内系统或产品无故障正常工作的概率。它可以通过失效密度函数f(t)和可靠度函数R(t)来描述。可靠度函数是一个从零时刻开始到时间t的累积分布函数（CDF）的补，即：</p><p>$$ R(t) &#x3D; 1 - F(t) $$</p><p>其中，F(t)是累积分布函数，表示在时间t之前发生故障的概率。F(t)可以通过失效密度函数f(t)积分得到：</p><p>$$ F(t) &#x3D; \int_0^t f(x) dx $$</p><p>因此，可靠度R(t)也可以通过积分失效率λ(t)来表示：</p><p> $$R(t) &#x3D; e^{-\int_0^t \lambda(x) dx} $$</p><p>如果失效率是常数λ（即系统处于稳态失效率），则上述关系简化为：</p><p>$$ R(t) &#x3D; e^{-\lambda t} $$</p><p>所以，如果你知道了系统的失效率，你就可以计算出在任何给定时间t的可靠度。反过来，如果你知道了系统的可靠度函数，你也可以求出平均寿命（即平均无故障工作时间，MTTF），它是失效密度函数f(t)的期望值：</p><p>$$ MTTF &#x3D; \int_0^{\infty} t f(t) dt $$</p><p>对于恒定失效率的情况，MTTF简化为失效率的倒数：</p><p>$$MTTF &#x3D; \frac{1}{\lambda}$$</p><p>这些关系和推导基于对失效率和可靠度的连续时间分析。在实际应用中，失效率可能会随时间变化，例如对于新产品可能会遵循所谓的“浴盆曲线”（先下降后上升）。在这种情况下，以上简化的公式可能不适用，需要更复杂的模型来描述失效率随时间的变化。</p><h3 id="可靠性模型：串联，并联模型的寿命、可靠度推导"><a href="#可靠性模型：串联，并联模型的寿命、可靠度推导" class="headerlink" title="可靠性模型：串联，并联模型的寿命、可靠度推导"></a>可靠性模型：串联，并联模型的寿命、可靠度推导</h3><h4 id="串联系统"><a href="#串联系统" class="headerlink" title="*串联系统*"></a><em><strong>*串联系统*</strong></em></h4><p>假设第<em>i</em>个部件的寿命为$X_i$，可靠度为$<em>R_i(t)&#x3D;P{X_i &gt;t}，i&#x3D;1, 2, …,n,</em>$第$<em>i</em>$个部件的失效率为$<em>\lambda_i(t)</em>$$，X_1，X_2 ，…，X_n$相互独立。若</p><p>初始时刻$<em>t&#x3D;0</em>$，所有部件都是新的，且同时开始工作。</p><p>(1) 系统的寿命是： $X&#x3D;min{X_1 ，X_2，…，X_n}$</p><p>(2) 系统的可靠度是：</p><p>$$ R(t)&#x3D;P{min(X_1 ，X_2，…，X_n)&gt;t}&#x3D;\Pi^n_{i&#x3D;1}R_i(t)\ &#x3D;\Pi^n_{i&#x3D;1}exp{-\int^t_0\lambda_i(u)du} $$</p><p>(3) 系统的失效率为：</p><p>$$ \lambda(t)&#x3D;-\frac{R’(t)}{R(t)}&#x3D;\sum^n_{i&#x3D;1}\lambda_i(t) $$</p><p>(4) 系统的平均寿命为:</p><p>$$ MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\int^\infty_0exp{-\int^t_0\lambda(u)du}dt $$</p><p>当$R_i(t)&#x3D;exp{-\lambda_t}，i&#x3D;1, 2, …, n$时（及当第<em>i</em>个部件的命遵从参数为$<em>\lambda_i</em>$的</p><p>指数分布时），系统的可靠度和平均寿命为</p><p>$$ R(t)&#x3D;exp{-\sum^n_{i&#x3D;1}\lambda_it}\ MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i} $$</p><h4 id="并联系统"><a href="#并联系统" class="headerlink" title="*并联系统*"></a><em><strong>*并联系统*</strong></em></h4><p>(1) 系统的寿命是： $X&#x3D;max{X_1，X_2，…，X_n }$</p><p>(2) 系统的可靠度是：</p><p>$$ R(t)&#x3D;P{max(X_1 ，X_2，…，X_n)&gt;t}\ &#x3D;1-P{max(X_1 ，X_2，…，X_n)\le t } \ &#x3D;1-\Pi^n_{i&#x3D;1}[1-R_i(t)] $$</p><p>(3) 系统的平均寿命为：</p><p>$$ MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\sum^n_{i&#x3D;1}\frac{1}{\lambda_i}\ &#x3D;sum_{1\le&lt;i&lt;j\le n}\frac{1}{\lambda_1+\lambda_j}+…+(-1)^{n-1}\frac{1}{\lambda_1+…+\lambda_n} $$</p><h3 id="硬件可靠性和软件可靠性的不同"><a href="#硬件可靠性和软件可靠性的不同" class="headerlink" title="硬件可靠性和软件可靠性的不同"></a>硬件可靠性和软件可靠性的不同</h3><p>硬件可靠性和软件可靠性在概念上有一些基本的差异，这些差异主要反映了它们的固有属性和它们出错的本质。</p><h4 id="硬件可靠性"><a href="#硬件可靠性" class="headerlink" title="硬件可靠性"></a>硬件可靠性</h4><ol><li><strong>物理耗损</strong>：硬件可靠性受到物理组件老化和环境条件（如温度、湿度、机械应力等）的影响，这些因素会导致硬件随时间而退化。</li><li><strong>失效率</strong>：硬件的失效率可以通过“浴盆曲线”来描述，即开始时有较高的初期故障率（新品早期失效），然后进入一段低故障率的稳定期（有用寿命期），最后由于磨损和老化进入失效率上升的磨损期。</li><li><strong>可预测性</strong>：许多硬件故障是可以预测的，通过定期维护和替换部件可以预防。</li><li><strong>冗余设计</strong>：硬件系统经常通过冗余组件来提高可靠性，如RAID系统中的多硬盘冗余，电源和冷却系统的冗余配置等。</li><li><strong>测试与质量控制</strong>：硬件的质量可以在生产时通过物理测试来控制和保证。</li></ol><h4 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h4><ol><li><strong>设计和逻辑错误</strong>：软件故障通常是由设计不当、编程错误、逻辑漏洞等原因引起的，与物理磨损无关。</li><li><strong>失效行为</strong>：软件的失效率不遵循物理磨损的模式，软件不会因为时间推移而衰老，但软件的失效通常是由于不断发现的新错误或者在新环境中的不适应。</li><li><strong>不确定性和复杂性</strong>：软件系统经常涉及复杂的交互和非确定性的行为，这使得确保软件可靠性成为一项挑战。</li><li><strong>更新和补丁</strong>：软件通过更新和补丁程序来修正已知错误，因此，软件的可靠性可以通过软件更新来提高。</li><li><strong>测试的限制</strong>：由于软件的复杂性和使用情境的多样性，不可能测试软件的所有可能路径，因此总有未知错误的可能性。</li></ol><h4 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h4><ul><li><strong>稳态和动态行为</strong>：硬件通常在一定条件下具有稳定的行为，而软件则更多表现出动态和多变的行为。</li><li><strong>故障模式</strong>：硬件故障通常是随机的，而软件故障则是系统性的，一旦触发了软件中的某个错误，通常它总是在相同的条件下发生。</li><li><strong>修复方式</strong>：硬件故障的修复可能包括更换或修理物理组件，而软件故障的修复通常是修改代码或配置。</li></ul><p>总的来说，虽然两者都关注于减少故障并提高系统的整体可靠性，但由于硬件和软件在本质上有所不同，它们的可靠性策略和实施方法也不相同。硬件可靠性更多关注于物理特性和冗余设计，而软件可靠性则更侧重于设计、测试和持续的维护。</p><h3 id="软件的四种常见的可靠性模型及其主要思想"><a href="#软件的四种常见的可靠性模型及其主要思想" class="headerlink" title="软件的四种常见的可靠性模型及其主要思想"></a>软件的四种常见的可靠性模型及其主要思想</h3><p><strong>失效时间间隔模型</strong></p><p>这类模型最常用的方法是假定第i个失效到第i+1个失效间隔时间服从某一分布，而分布的参数依赖于各间隔时间内程序中的残留错误数。通过测试所得到的失效间隔时间数据来估计模型的参数，由获得的模型可以估算软件的可靠度以及各失效间的平均工作时间等；</p><p>另一种方法是把失效间隔时间看作随机过程，然后通过适当的时间序列模型来分析和描述软件的失效过程。这类模型有Jelinski-Moranda的非增长模型 、 Schick-Wolverton 模 型 、 Littlewood-Verrall 的 贝 叶 斯 模 型 和 GoelOkumoto的不完善模型等。</p><p><strong>缺陷计数模型</strong></p><p>这类模型关心的是在特定的时间间隔内软件的错误数或失效数，并假定故障累计数服从某个己知的随机过程，过程强度是时间的离散或连续函数，根据在给定的测试时间间隔发现的错误数或失效数来估计故障强度、均值等参数。随着错误的不断排除，在单位时间内发现的失效数将不断减少。当时间间隔事先确定时，在每个间隔时间内的失效次数就是随机变量。这类模型有Shooman模型、Musa的执行时间模型、Goel-Okumoto的NHPP模型、Goel的NHPP 模型和Musa-Okumoto的对数泊淞执行时间模型等等。</p><p><strong>基于输入域错误</strong></p><p>这类模型的基本思路是通过将一组已知的错误人为地植入到一个固有错误总数尚不清楚的程序中，然后在程序的测试中观察并统计发现的植入错误数和程序总的错误数，通过计数的比值估计程序的固有错误总数，从而得到软件可靠度及其有关指标。这类模型的代表是Mills的超几何分布模型。</p><p><strong>植入模型的模型</strong></p><p>这类模型的基本研究方法是根据程序的使用情况，找出程序可能输入的概率分布，根据这种分布产生一个测试用例的集合。由于得到输入的分布难度较大，一般将输入域划分成等价类，每个等价类与程序的一条执行路径相联。在输入域上随机抽取测试用例，执行相应的程序测试，观测故障，从而推断出各项指标。这类模型以Nelson模型为代表，还有Brown-Lipow的基于输入域模型和Ramamoorthy-Bastani的基于输入域模型。</p><h3 id="冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的-N-Version-Programming-和-Recovery-Block-的对比"><a href="#冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的-N-Version-Programming-和-Recovery-Block-的对比" class="headerlink" title="冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的 N-Version Programming 和 Recovery Block 的对比"></a>冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的 N-Version Programming 和 Recovery Block 的对比</h3><p>冗余是提高可靠性、可用性和系统鲁棒性的一种技术，通常通过在系统中加入额外的信息或组件来实现。不同类型的冗余有着不同的实现原理和相应的优缺点。</p><h4 id="时间冗余（Time-Redundancy）"><a href="#时间冗余（Time-Redundancy）" class="headerlink" title="时间冗余（Time Redundancy）"></a>时间冗余（Time Redundancy）</h4><p><strong>原理：</strong> 时间冗余通过在系统中多次执行同一操作来提高可靠性。如果第一次执行产生了错误，系统可以回滚到一个已知的良好状态，并重新执行该操作。</p><p><strong>优点：</strong></p><ul><li>不需要额外的硬件，节约成本。</li><li>可以动态应对偶发性错误。</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的响应时间，降低了性能。</li><li>对于持续性错误无效，如由设计缺陷引起的软件错误。</li></ul><h4 id="信息冗余（Information-Redundancy）"><a href="#信息冗余（Information-Redundancy）" class="headerlink" title="信息冗余（Information Redundancy）"></a>信息冗余（Information Redundancy）</h4><p><strong>原理：</strong> 信息冗余利用额外的数据位（如校验位、奇偶校验、校验和、Hamming码等）来检测和&#x2F;或纠正错误。这在数据传输和存储系统中非常常见。</p><p><strong>优点：</strong></p><ul><li>能够检测或修正数据中的错误，提高数据完整性。</li><li>适用于数据通信和存储操作。</li></ul><p><strong>缺点：</strong></p><ul><li>需要额外的存储空间或带宽。</li><li>复杂的纠错码可能需要额外的计算资源。</li></ul><h4 id="硬件冗余（Hardware-Redundancy）"><a href="#硬件冗余（Hardware-Redundancy）" class="headerlink" title="硬件冗余（Hardware Redundancy）"></a>硬件冗余（Hardware Redundancy）</h4><p><strong>原理：</strong> 硬件冗余通过增加备用的物理组件（如备用服务器、电源、网络连接等）来提高系统可靠性。当一个组件失败时，备用组件可以接管其功能。</p><p><strong>优点：</strong></p><ul><li>提供即时的故障切换，提高系统的可用性。</li><li>增加的组件可以在检测到故障时即刻接管，减少了系统停机时间。</li></ul><p><strong>缺点：</strong></p><ul><li>成本高昂，因为需要购买额外的硬件设备。</li><li>物理空间要求可能增加。</li></ul><h4 id="软件冗余（Software-Redundancy）"><a href="#软件冗余（Software-Redundancy）" class="headerlink" title="软件冗余（Software Redundancy）"></a>软件冗余（Software Redundancy）</h4><p><strong>原理：</strong> 软件冗余通常指的是运行多个软件副本或使用不同算法实现相同功能，以便在一个副本失败时另一个可以接管。</p><p><strong>优点：</strong></p><ul><li>可以在不更改硬件的情况下增加可靠性。</li><li>能够应对软件缺陷和系统性错误。</li></ul><p><strong>缺点：</strong></p><ul><li>如果所有软件副本含有相同的缺陷，那么冗余可能无效。</li><li>对资源的需求增加（如内存和CPU时间）。</li></ul><h4 id="三模冗余（TMR-Triple-Modular-Redundancy）"><a href="#三模冗余（TMR-Triple-Modular-Redundancy）" class="headerlink" title="三模冗余（TMR, Triple Modular Redundancy）"></a>三模冗余（TMR, Triple Modular Redundancy）</h4><p><strong>原理：</strong> TMR是一种特殊类型的硬件冗余，它涉及三个相同的系统或组件并行工作，并通过表决逻辑来确定最终输出。如果一个组件故障，另外两个正确的输出可以通过多数表决得出正确的结果。</p><p><strong>优点：</strong></p><ul><li>可以容忍单个组件的故障而不影响整体系统。</li><li>提供了自动故障检测和修正能力。</li></ul><p><strong>缺点：</strong></p><ul><li>高昂的成本，因为需要三倍的硬件。</li><li>如果两个组件同时失败，系统可能无法正确决策。</li></ul><p>冗余的应用需根据系统要求、环境、故障模型以及成本效益分析来选择。在实际应用中，经常会组合使用不同类型的冗余策略来达到最佳的可靠性和成本效益平衡。</p><p><strong>“N-Version Programming”（N版本编程）和”Recovery Block”（恢复块）</strong>是两种不同的软件冗余技术，它们的目的都是为了提供容错能力并提高软件的可靠性。尽管目标类似，但它们的设计哲学、实现方式和适用场景有所不同。</p><h4 id="N版本编程（N-Version-Programming）"><a href="#N版本编程（N-Version-Programming）" class="headerlink" title="N版本编程（N-Version Programming）"></a>N版本编程（N-Version Programming）</h4><p><strong>原理：</strong></p><ul><li>N版本编程是通过独立地开发多个软件版本（称为“版本”），这些版本由不同的团队使用不同的工具和技术开发，以实现相同的规格和功能。</li><li>运行时，所有版本并行运行，它们的输出通过一个投票系统来决定最终结果。</li></ul><p><strong>优点：</strong></p><ul><li>提高了可靠性，因为不太可能所有版本都会在相同的输入下失败。</li><li>由于各个版本是独立开发的，它们可能会有不同的错误模式，从而降低全局故障的风险。</li></ul><p><strong>缺点：</strong></p><ul><li>成本高昂，需要多组开发团队和多倍的开发资源。</li><li>如果所有版本遵循相同的错误规格或理解，错误可能会在所有版本中重现。</li><li>投票机制的设计和实施可能复杂且需要精确。</li></ul><h4 id="恢复块（Recovery-Block）"><a href="#恢复块（Recovery-Block）" class="headerlink" title="恢复块（Recovery Block）"></a>恢复块（Recovery Block）</h4><p><strong>原理：</strong></p><ul><li>恢复块在设计上包含了主程序块和一个或多个备用程序块。每个块都试图完成相同的任务，但是如果主程序块失败（通过某种形式的验收测试来判定），控制就会传递到备用块。</li><li>备用块按顺序执行，直到一个块通过验收测试或所有块都失败为止。</li></ul><p><strong>优点：</strong></p><ul><li>实现简单，只有在主块失败时才会尝试执行备用块，从而节约了资源。</li><li>可以在不同级别的粒度上实现，例如，可以在整个程序、单个函数或者代码段的层面上应用恢复块。</li></ul><p><strong>缺点：</strong></p><ul><li>如果验收测试不能准确地检测到所有类型的错误，那么故障可能仍会被传递下去。</li><li>需要额外的时间来执行验收测试以及在块之间切换，可能会导致性能开销。</li><li>可能会增加编程复杂性，特别是在设计验收测试时。</li></ul><p><strong>对比：</strong><br>N版本编程和恢复块两种方法在实践中有不同的适用性和效果。N版本编程更注重在不同版本间提供多样性，从而减少共同故障的可能性，但成本高昂且实现复杂。恢复块则侧重于在一个版本失败时有序地退回到备用方案，通常实现起来更简单，成本较低，但其对验收测试的依赖性较高。</p><p>选择哪种技术取决于特定应用的需求、可用资源、预期的可靠性水平以及对性能的影响。在安全关键和高可靠性需求的系统中，这些技术或它们的组合可能是提高软件容错能力的有效方法。</p><h3 id="RAID5-RAID6-的原理"><a href="#RAID5-RAID6-的原理" class="headerlink" title="RAID5&#x2F;RAID6 的原理"></a>RAID5&#x2F;RAID6 的原理</h3><p>RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列）是一种数据存储虚拟化技术，旨在提高数据存储的可靠性和性能。RAID通过将多块硬盘组合成一个或多个阵列来工作，数据被分散在这些硬盘上，以实现冗余和&#x2F;或提高速度。</p><h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><p><strong>原理：</strong></p><ul><li>RAID 5至少需要三块硬盘。它通过分布式奇偶校验来提供数据冗余。这意味着每个数据块和一个校验块被分布在不同的硬盘上。</li><li>数据和校验信息被分割成等大小的块，在所有驱动器上均匀分布。校验块由当前所有硬盘上的数据块计算得出，使用的是异或（XOR）操作。</li><li>如果一个硬盘出现故障，可以通过剩余硬盘上的数据块和校验块，使用XOR运算来重建丢失的数据。</li></ul><p><strong>优点：</strong></p><ul><li>提供了单块硬盘冗余，任何一块硬盘故障都能重建数据。</li><li>相对于RAID 1，RAID 5在使用更少的额外存储容量提供冗余的同时，还提供了良好的读取性能。</li></ul><p><strong>缺点：</strong></p><ul><li>写入性能由于要更新校验信息而受到影响。</li><li>当硬盘出现故障时，重建过程会占用大量的I&#x2F;O资源，并且在此期间，数据处于无冗余保护的状态，如果再有硬盘失败，数据会丢失。</li></ul><h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p><strong>原理：</strong></p><ul><li>RAID 6类似于RAID 5，但它使用两个独立的奇偶校验块，而不是一个。这样，RAID 6可以容忍两块硬盘同时故障而不丢失数据。</li><li>RAID 6至少需要四块硬盘。它采用了更复杂的校验算法，通常是基于两个不同的异或运算。</li><li>与RAID 5一样，数据和校验块在所有驱动器上分布。但由于有两个校验块，RAID 6在处理校验时需要更多的计算。</li></ul><p><strong>优点：</strong></p><ul><li>相比RAID 5，RAID 6提供了更高的数据冗余，能够容忍两块硬盘同时故障。</li><li>适用于大容量硬盘和大型阵列，因为这些环境中硬盘故障的概率更高。</li></ul><p><strong>缺点：</strong></p><ul><li>写入性能损失比RAID 5更大，因为需要计算和写入两个校验块。</li><li>由于额外的校验块，RAID 6牺牲了更多的存储容量。</li></ul><p><strong>总结：</strong><br>RAID 5和RAID 6都是通过在硬盘之间分配数据和校验信息来提供冗余，但它们的冗余级别和性能特点不同。RAID 5在提供冗余和性能方面做了平衡，而RAID 6则更注重在更高的冗余级别。选择哪种RAID阵列取决于用户对性能、存储效率和数据安全的具体需求。</p><h3 id="Reed-Solomon-纠删码的基本原理及其在通信和大规模数据存储中的应用"><a href="#Reed-Solomon-纠删码的基本原理及其在通信和大规模数据存储中的应用" class="headerlink" title="Reed-Solomon 纠删码的基本原理及其在通信和大规模数据存储中的应用"></a>Reed-Solomon 纠删码的基本原理及其在通信和大规模数据存储中的应用</h3><p>erasure code有很多种，其中RS code是最基本的一种。RS codes是基于 Galois Field 的一种编码算法，在RS codes中使用$$GF(2^w)$$，其中$$2^w&gt;n+m$$.</p><p>因此，对每一段的<em>n</em>份数据，我们都可以通过B * D 得到：</p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220235445622.png" alt="image-20231220235445622"></p><p>假如D1、D4、C2 失效，那么我们可以同时从矩阵B和B*D中，去掉响应的行，得到下面的等式</p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220235501565.png" alt="image-20231220235501565"><img src="D:\my_data\blog\zyhblog-img\image-20231220235507658.png" alt="image-20231220235507658"></p><h2 id="计算机取证-1"><a href="#计算机取证-1" class="headerlink" title="计算机取证"></a>计算机取证</h2><h3 id="取证的范围"><a href="#取证的范围" class="headerlink" title="取证的范围"></a>取证的范围</h3><p>首先依据搜查令或其他授权，根据案件的细节、硬件和软件系统的性质、潜在证据以及整个获取证据现场的环境来确定哪些证据将要进行重点检查。</p><h3 id="取证过程应该遵循的原则"><a href="#取证过程应该遵循的原则" class="headerlink" title="取证过程应该遵循的原则"></a>取证过程应该遵循的原则</h3><ol><li>取证过程中不能对目标设备有任何改动，读取硬盘数据必须用“只读锁”</li><li>所有提取的文件都要经过签名，保证不被篡改</li><li>保存证据的硬盘每次使用前都要“洗盘”——清零操作（Erases）</li><li>尽可能优先提取易失性数据——内存、网络数据包等等</li><li>分析证据的工作应该在工作副本(对目标硬盘逐位、逐字节的镜像）上进行</li></ol><h3 id="取证的一般过程"><a href="#取证的一般过程" class="headerlink" title="取证的一般过程"></a>取证的一般过程</h3><ol><li>记录被检查系统的硬件和软件配置，确认被检查系统所包含的硬件和软件。</li><li>拆开被检查计算机，检查计算机的硬盘。注意：在这个过程中要注意避免静电和强磁场</li><li>确认将要收集的存储设备，这些存储设备既可能是内置的也可能是外置的，有的系统可能同时拥有这两种设备。</li><li>记录内置存储设备和硬件配置，包括：<br>驱动情况(例如，品牌、型号、尺寸、跳线、硬件接口等)<br>内部部件(例如，声卡、显卡、网卡、视频采集卡等。)</li><li>通过受控制的引导程序恢复可疑系统的配置信息</li><li>尽可能地将存储器从可疑计算机中拆卸下来，使用预先准备好的监测系统来进行证据的提取</li></ol><h3 id="常见的取证工具"><a href="#常见的取证工具" class="headerlink" title="常见的取证工具"></a>常见的取证工具</h3><p>确定系统的审核策略auditpol</p><p>转储Windows系统注册表中的特定信息（键）reg</p><p>以文本文件格式转储注册表regdump</p><p>转储SAM数据库，可破解密码pwdump6</p><p>监控成功和失败的系统登录NTLast</p><p>侦测隐藏在NTFS文件流中的文件Sfind</p><p>扫描文件系统找出在某时段内被访问过的文件Afind</p><p>转储Windows系统的事件日志Dumpel</p><h2 id="操作系统安全-1"><a href="#操作系统安全-1" class="headerlink" title="操作系统安全"></a>操作系统安全</h2><h3 id="操作系统的一般性安全机制：隔离，访问控制，审计，加密"><a href="#操作系统的一般性安全机制：隔离，访问控制，审计，加密" class="headerlink" title="操作系统的一般性安全机制：隔离，访问控制，审计，加密"></a>操作系统的一般性安全机制：隔离，访问控制，审计，加密</h3><h4 id="隔离控制"><a href="#隔离控制" class="headerlink" title="隔离控制"></a><strong>隔离控制</strong></h4><p><strong>物理隔离</strong>：例如，把不同的打印机分配给不同安全级别的用户。</p><p><strong>时间隔离：</strong>例如，以不同安全级别的程序在不同的时间使用计算机。</p><p><strong>加密隔离</strong>：例如，把文件、数据加密，使无关人员无法阅读。</p><p><strong>逻辑隔离</strong></p><p>首先要对存储单元的地址进行保护：使非法用户不能访问那些受到保护的存储单元</p><p>其次要对被保护的存储单元提供各种类型的保护：最基本的保护类型是“读&#x2F;写”和“只读”。复杂一些的保护类型还包括“只执行”、“不能存取”等操作。不能存取的存储单元，若被用户存取时，系统要及时发出警报或中断程序执行。</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a><strong>访问控制</strong></h4><p>访问控制是操作系统的安全控制核心。访问控制是确定谁能访问系统，能访问系统何种资源以及在何种程度上使用这些资源。访问控制包括对系统各种资源的存取控制</p><p><strong>身份认证、确定访问权限、实施访问控制的权限</strong></p><h4 id="安全审计"><a href="#安全审计" class="headerlink" title="安全审计"></a><strong>安全审计</strong></h4><p>要求任何影响系统安全性的行为都被跟踪和记录在案，安全系统拥有把用户标识与它被跟踪和记录的行为联系起来的能力。<br>• 审计信息必须有选择性的保留和保护，所有与安全相关的事件记录在审计日志文件中，所有审计数据必须防止受到未授权的访问、修改和破坏，以作为日后对事件调查的依据。<br>• 审计系统能记录以下事件：和标识与鉴别机制相关的事件、将客体导入用户地址空间的操作、删除客体、系统管理员执行的操作及其他与安全相关的事件。</p><h4 id="安全加密"><a href="#安全加密" class="headerlink" title="安全加密"></a>安全加密</h4><p><strong>加密机制用于安全传输</strong></p><p>一个IPSee安全策略由IP筛选器和筛选器操作两部分构成。其中IP筛选器决定哪些报文应当引起IPSee安全策略的关注，筛选器操作是指“允许”还是“拒绝”报文的通过。在Windows 2003Server系统的服务端和客户端都提供了对IPSee的支持，从而增强了安全性。</p><p><strong>加密机制用于文件安全</strong></p><p>EFS加密实际上综合了对称加密和不对称加密</p><h3 id="国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色"><a href="#国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色" class="headerlink" title="国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色"></a>国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色</h3><p>国产操作系统的发展主要是为了满足本国的法律法规要求、信息安全等级保护标准、以及本地化支持的需求。相对于国外的主流操作系统，国产操作系统在安全机制设计方面可能具有以下特色：</p><h4 id="1-符合本地法规"><a href="#1-符合本地法规" class="headerlink" title="1. 符合本地法规"></a>1. 符合本地法规</h4><p>国产操作系统往往更加符合本国的法律法规和政策要求，比如数据保护法、信息内容监管等，以保证操作系统及其应用的合规性。</p><h4 id="2-安全加固"><a href="#2-安全加固" class="headerlink" title="2. 安全加固"></a>2. 安全加固</h4><p>部分国产操作系统可能针对特定的安全威胁进行了加固，以应对国内网络环境中的特定安全挑战，如更高级别的身份验证、加密技术和访问控制等。</p><h4 id="3-可信计算"><a href="#3-可信计算" class="headerlink" title="3. 可信计算"></a>3. 可信计算</h4><p>为了增强系统的信任度，国产操作系统可能内置了支持可信计算的技术，包括硬件身份验证、系统完整性验证等。</p><h4 id="4-可审核性"><a href="#4-可审核性" class="headerlink" title="4. 可审核性"></a>4. 可审核性</h4><p>国产操作系统可能会提供更加透明的审计功能，方便对系统行为和数据流向进行监控、记录和审计，以追踪潜在的安全问题。</p><h4 id="5-私有化定制"><a href="#5-私有化定制" class="headerlink" title="5. 私有化定制"></a>5. 私有化定制</h4><p>国产操作系统可能提供更多的定制服务，以符合国内企业或政府部门的特定需求，包括私有云部署、定制化的安全策略和服务等。</p><h4 id="6-支持国产硬件和加密算法"><a href="#6-支持国产硬件和加密算法" class="headerlink" title="6. 支持国产硬件和加密算法"></a>6. 支持国产硬件和加密算法</h4><p>国产操作系统可能会有更好的支持国产CPU架构（如龙芯、飞腾等）和国产加密算法（如国密SM系列算法）的能力。</p><h4 id="7-系统更新与维护"><a href="#7-系统更新与维护" class="headerlink" title="7. 系统更新与维护"></a>7. 系统更新与维护</h4><p>在维护和系统更新方面，国产操作系统可能会强调更快的本地化响应速度，及时补丁发布和定制化的更新服务。</p><h4 id="8-本地化支持"><a href="#8-本地化支持" class="headerlink" title="8. 本地化支持"></a>8. 本地化支持</h4><p>国产操作系统提供更深层次的本地化支持，不仅限于语言包，还可能包括本地化的用户界面、帮助文档以及用户支持服务。</p><h4 id="9-应对国内网络环境"><a href="#9-应对国内网络环境" class="headerlink" title="9. 应对国内网络环境"></a>9. 应对国内网络环境</h4><p>国产操作系统可能会内置特定的功能和服务，以更好地应对中国特有的网络环境，如对国内常用应用和服务的优化。</p><p>需要指出的是，这些特色并不是说国外的主流操作系统不具备，而是国产操作系统可能会在这些方面做出更多本地化和定制化的设计。另外，不同的国产操作系统，在安全机制上的具体实现和特色会有所不同。</p><h3 id="基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU"><a href="#基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU" class="headerlink" title="基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU"></a>基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU</h3><p>见上</p><h3 id="物联网和虚拟化技术对操作系统带来的安全挑战"><a href="#物联网和虚拟化技术对操作系统带来的安全挑战" class="headerlink" title="物联网和虚拟化技术对操作系统带来的安全挑战"></a>物联网和虚拟化技术对操作系统带来的安全挑战</h3><p>伴随着大数据和云时代的到来，虚拟化技术的应用已经越来越成熟。如何运用虚拟化技术给终端客户提供一个安全、稳定、高效的桌面环境，成为了一个日益热门的话题。</p><p>物联网（IoT）和虚拟化技术是近年来信息技术领域的两个重要趋势，它们对操作系统的安全性提出了新的挑战。</p><h4 id="物联网（IoT）带来的安全挑战："><a href="#物联网（IoT）带来的安全挑战：" class="headerlink" title="物联网（IoT）带来的安全挑战："></a>物联网（IoT）带来的安全挑战：</h4><h5 id="1-设备多样性和管理难度"><a href="#1-设备多样性和管理难度" class="headerlink" title="1. 设备多样性和管理难度"></a>1. 设备多样性和管理难度</h5><p>物联网环境中，设备种类繁多，从传感器到智能家电，再到工业控制系统，这些设备运行的操作系统多样，且往往资源受限，这增加了维护和管理的复杂性。</p><h5 id="2-面向设备的安全攻击"><a href="#2-面向设备的安全攻击" class="headerlink" title="2. 面向设备的安全攻击"></a>2. 面向设备的安全攻击</h5><p>物联网设备由于资源有限，可能无法运行复杂的安全软件，这使得它们更容易受到攻击，如固件劫持、物理篡改等。</p><h5 id="3-数据安全和隐私保护"><a href="#3-数据安全和隐私保护" class="headerlink" title="3. 数据安全和隐私保护"></a>3. 数据安全和隐私保护</h5><p>物联网设备通常会收集大量个人或敏感数据，安全地存储和传输这些数据成为了一大挑战。</p><h5 id="4-网络安全问题"><a href="#4-网络安全问题" class="headerlink" title="4. 网络安全问题"></a>4. 网络安全问题</h5><p>物联网设备通常需要连接到互联网，这可能导致网络层面的安全问题，如DDoS攻击利用了大量未加密的物联网设备。</p><h5 id="5-更新和补丁分发"><a href="#5-更新和补丁分发" class="headerlink" title="5. 更新和补丁分发"></a>5. 更新和补丁分发</h5><p>物联网设备的更新机制往往不如传统 IT 系统那样成熟，这意味着安全漏洞可能长时间得不到修复。</p><h4 id="虚拟化技术带来的安全挑战："><a href="#虚拟化技术带来的安全挑战：" class="headerlink" title="虚拟化技术带来的安全挑战："></a>虚拟化技术带来的安全挑战：</h4><h5 id="1-虚拟化平台的安全"><a href="#1-虚拟化平台的安全" class="headerlink" title="1. 虚拟化平台的安全"></a>1. 虚拟化平台的安全</h5><p>虚拟化平台（如VMware、Xen、KVM等）本身的安全性至关重要，因为它们成为了多个虚拟机共享的基础设施。</p><h5 id="2-虚拟机逃逸攻击"><a href="#2-虚拟机逃逸攻击" class="headerlink" title="2. 虚拟机逃逸攻击"></a>2. 虚拟机逃逸攻击</h5><p>如果攻击者成功实施虚拟机逃逸，他们可以从一个虚拟机访问宿主机或者其他虚拟机，从而破坏整个虚拟化环境的隔离性。</p><h5 id="3-虚拟网络安全"><a href="#3-虚拟网络安全" class="headerlink" title="3. 虚拟网络安全"></a>3. 虚拟网络安全</h5><p>在虚拟化环境中，传统网络安全解决方案可能难以直接应用，因为虚拟机之间的网络交互可能完全在软件定义的网络内部进行。</p><h5 id="4-资源池共享安全问题"><a href="#4-资源池共享安全问题" class="headerlink" title="4. 资源池共享安全问题"></a>4. 资源池共享安全问题</h5><p>虚拟化环境中不同虚拟机共享相同的物理资源，如CPU和内存，这可能导致资源竞争以及隔离性的问题。</p><h5 id="5-快照和移动性带来的数据安全问题"><a href="#5-快照和移动性带来的数据安全问题" class="headerlink" title="5. 快照和移动性带来的数据安全问题"></a>5. 快照和移动性带来的数据安全问题</h5><p>虚拟机的快照和移动性功能，虽然带来了便利，但也带来了数据泄露的风险。</p><h5 id="6-管理和配置的复杂性"><a href="#6-管理和配置的复杂性" class="headerlink" title="6. 管理和配置的复杂性"></a>6. 管理和配置的复杂性</h5><p>虚拟化环境增加了管理和配置的复杂性，不当的配置可能导致安全漏洞。</p><p>为了应对这些挑战，操作系统需要集成更多的安全特性，比如增强的访问控制、隔离机制、加密技术以及实时的监控和响应系统。同时，对于物联网和虚拟化环境中的安全事件，需要有专门的检测和应对策略。此外，开发和维护适用于这些环境的安全准则和最佳实践也同样重要。</p><h3 id="身份认证协议，一次性口令（OTP），Kerberos-协议的原理"><a href="#身份认证协议，一次性口令（OTP），Kerberos-协议的原理" class="headerlink" title="身份认证协议，一次性口令（OTP），Kerberos 协议的原理"></a>身份认证协议，一次性口令（OTP），Kerberos 协议的原理</h3><p><strong>OTP的主要思路是</strong>：在登录过程中加入不确定因素，使每次登录过程中传送的口令信息都不相同，以提高登录过程安全性。</p><p>例如：登录密码&#x3D;MD5(用户名＋密码 ＋时间）系统接收到登录口令后做一个验算即可验证用户的合法性。</p><p><strong>Kerberos认证</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231222205144084.png" alt="image-20231222205144084"></p><p><strong>交换第一轮：获取票据许可票据</strong></p><p>​<strong>Step (1) 用户请求票据许可票据</strong></p><p>➢ 用户请求票据许可票据的工作在登录工作站时进行。<br>➢ 登录时用户被要求输入用户名，输入后系统会向认证服务器AS以明文方式发送一条包含用户和TGS服务两者名字的请求。<br>$$<br>C\to AS:ID_C||ID_{tgs}||TS_1<br>$$<br>​<strong>Step (2) AS发放票据许可票据和会话密钥</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231222213355240.png" alt="image-20231222213355240"></p><p><strong>第二轮：获取访问票据</strong></p><p>​<strong>Step (3) C请求服务器票据</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231222213404437.png" alt="image-20231222213404437"></p><p>​<strong>Step (4) TGS发放服务器票据和会话密钥</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231222213412913.png" alt="image-20231222213412913"></p><p><strong>第三轮：获取服务</strong></p><p>​<strong>Step (5) 工作站将票据和认证符发给服务器</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231222213419461.png" alt="image-20231222213419461"></p><p>​<strong>Step (6) 服务器验证票据TicketS和认证符中的匹配，然后许可访问服务。</strong><br>$$<br>S\to C:E_{Kc,s}[TS_5+1]<br>$$</p><h3 id="组策略的主要优势，组策略和-OU-的关系"><a href="#组策略的主要优势，组策略和-OU-的关系" class="headerlink" title="组策略的主要优势，组策略和 OU 的关系"></a>组策略的主要优势，组策略和 OU 的关系</h3><p><strong>主要优势：</strong></p><p>• <strong>降低管理、支持与培训成本</strong></p><p>• <strong>提升用户工作效率</strong></p><p>• <strong>允许极大量的定制项目</strong> <strong>–</strong> <strong>其扩展性不会牺牲定制的灵活性</strong></p><p>组策略是一种用于中央管理和配置操作系统、应用程序和用户设置的工具，而组织单位（OU）是在Active Directory中用来组织用户、组和设备的容器。通过将组策略应用于特定的OU，管理员能够对网络中的不同用户和计算机群组进行精确和灵活的管理，同时利用OU的层级结构实现策略的继承和覆盖，从而实现高效的策略部署和权限控制。</p><h2 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h2><h3 id="数据库面临的安全威胁"><a href="#数据库面临的安全威胁" class="headerlink" title="数据库面临的安全威胁"></a>数据库面临的安全威胁</h3><p><strong>按照导致的后果分类</strong></p><p>• 信息泄露：未授权的用户有意&#x2F;无意得到的信息。</p><p>• 数据修改：未授权的数据修改，违反信息完整性。</p><p>• 拒绝服务：影响用户访问和数据库资源的使用。</p><p><strong>按照发生的方式分类</strong></p><p>​<strong>偶然的、无意的侵犯或破坏</strong></p><p>​• 自然或意外的灾害</p><p>​• 硬件或软件的故障&#x2F;错误导致的数据丢失和泄露</p><p>​• 人为的失误系和安全机制</p><p>​<strong>蓄意的侵犯或敌意的攻击</strong></p><p>​• 授权用户滥用、误用其权限</p><p>​• 病毒、特洛伊木马、天窗（后门）、隐通道</p><p>​• 绕过DBMS直接对数据进行读写</p><p>​• 为了某种目的，故意把错误数据注入数据库，使之保存错误信息并随着时间的推移扩散</p><p><strong>按照表现形式的分类</strong></p><p>• 滥用过高权限</p><p>• 滥用合法权限</p><p>• 权限提升</p><p>• 平台漏洞</p><p>• SQL注入</p><p>• 审计记录不足</p><p>• 拒绝服务</p><h3 id="数据库的安全防御纵深体"><a href="#数据库的安全防御纵深体" class="headerlink" title="数据库的安全防御纵深体"></a>数据库的安全防御纵深体</h3><p><img src="D:\my_data\blog\zyhblog-img\image-20231222212721493.png" alt="image-20231222212721493"><img src="D:\my_data\blog\zyhblog-img\image-20231222212738244.png" alt="image-20231222212738244"></p><h3 id="数据库的安全漏洞"><a href="#数据库的安全漏洞" class="headerlink" title="数据库的安全漏洞"></a>数据库的安全漏洞</h3><p>数据库安全漏洞通常指的是那些可能被恶意用户利用以非法访问、窃取、损坏或篡改数据的系统弱点。数据库中的安全漏洞可能以不同形式存在，以下是一些常见的数据库安全漏洞类型：</p><ol><li><p><strong>SQL注入</strong>：这是一种常见的攻击手段，攻击者通过在应用程序的输入字段中输入恶意SQL代码，企图对数据库执行未授权的查询或操作。</p></li><li><p><strong>不恰当的权限配置</strong>：如果用户或应用程序被授予过多权限，它们就可能进行不应当的数据库修改，或访问不该访问的数据。</p></li><li><p><strong>敏感数据暴露</strong>：敏感信息未经加密或不正确的加密存储在数据库中，容易被泄漏。</p></li><li><p><strong>配置缺陷</strong>：数据库的默认配置可能不够安全，例如默认账户和密码未更改，导致易于被攻破。</p></li><li><p><strong>未更新的数据库系统</strong>：未及时安装数据库软件的补丁和更新可能会留下安全漏洞，易受已知漏洞的攻击。</p></li><li><p><strong>注入漏洞</strong>：不仅限于SQL注入，还包括其它形式的注入，如LDAP注入、ORM注入等。</p></li><li><p><strong>缓冲区溢出</strong>：当输入数据超出数据库引擎预期的处理能力时，可能会导致执行任意代码。</p></li><li><p><strong>不安全的存储过程和触发器</strong>：如果存储过程或触发器编写不当，它们可能成为执行不受控制的SQL代码的途径。</p></li><li><p><strong>信息泄露</strong>：系统错误信息包含敏感信息，如数据库结构细节、系统路径等，有助于攻击者构造攻击。</p></li><li><p><strong>身份认证绕过</strong>：如果认证机制有漏洞，攻击者可能无需合法凭据就能访问数据库。</p></li><li><p><strong>跨站脚本攻击（XSS）</strong>：如果数据库中存储的数据用于网页内容，未经适当清理就插入HTML页面，可能会执行恶意脚本。</p></li><li><p><strong>未充分保护的备份</strong>：数据库备份如果未加密或存储在不安全的位置，可能被攻击者访问。</p></li></ol><p>为了保护数据库免受安全漏洞的影响，重要的措施包括定期更新和打补丁、实施最小权限原则、加密敏感数据、使用入侵检测系统、进行安全审计以及提供安全意识培训等。</p><h1 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a><strong>3.</strong> <strong>基本操作</strong></h1><h2 id="信息系统概述"><a href="#信息系统概述" class="headerlink" title="信息系统概述"></a>信息系统概述</h2><h3 id="能进行简单的信息系统架构设计，可参考讲义提供的阿里架构"><a href="#能进行简单的信息系统架构设计，可参考讲义提供的阿里架构" class="headerlink" title="能进行简单的信息系统架构设计，可参考讲义提供的阿里架构"></a>能进行简单的信息系统架构设计，可参考讲义提供的阿里架构</h3><p>简单的信息系统架构设计参考阿里巴巴的架构，显然需要考虑到系统的可扩展性、可靠性和高并发处理能力。以下是一个高层次的架构设计概要：</p><h4 id="基础设施层"><a href="#基础设施层" class="headerlink" title="基础设施层"></a>基础设施层</h4><ol><li><p><strong>云服务提供商</strong>：选择云服务，如阿里云，以便利用其弹性计算、存储和网络资源。</p></li><li><p><strong>全球负载均衡</strong>：使用DNS级别的负载均衡或阿里云的全局负载均衡服务确保跨地域的流量分配。</p></li></ol><h4 id="数据持久层"><a href="#数据持久层" class="headerlink" title="数据持久层"></a>数据持久层</h4><ol><li><p><strong>数据库</strong>：采用分布式数据库解决方案，如阿里云的PolarDB或RDS来处理高并发读写操作，实现读写分离和数据分片。</p></li><li><p><strong>缓存</strong>：使用Redis或Memcached作为缓存层减少对数据库的访问频率。</p></li><li><p><strong>存储</strong>：使用对象存储服务（如阿里云OSS）来存储和分发静态内容。</p></li></ol><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ol><li><p><strong>微服务架构</strong>：划分微服务，每个服务负责具体的业务功能，相互独立，通过阿里云的容器服务和Kubernetes进行管理。</p></li><li><p><strong>消息队列</strong>：采用RocketMQ等消息系统处理异步任务和解耦服务间的通信。</p></li><li><p><strong>API网关</strong>：使用API网关管理微服务的入口，提供认证、授权、流量控制等功能。</p></li></ol><h4 id="业务逻辑层"><a href="#业务逻辑层" class="headerlink" title="业务逻辑层"></a>业务逻辑层</h4><ol><li><p><strong>业务微服务</strong>：根据不同的业务功能划分服务，如订单处理、用户管理、产品目录等。</p></li><li><p><strong>定时任务服务</strong>：处理需要周期性执行的业务逻辑。</p></li></ol><h4 id="客户端层"><a href="#客户端层" class="headerlink" title="客户端层"></a>客户端层</h4><ol><li><p><strong>Web前端</strong>：使用现代JavaScript框架（如React或Vue.js）构建用户友好的单页面应用（SPA）。</p></li><li><p><strong>移动端</strong>：开发原生或混合移动应用。</p></li></ol><h4 id="辅助层"><a href="#辅助层" class="headerlink" title="辅助层"></a>辅助层</h4><ol><li><p><strong>CDN</strong>：内容分发网络缓存静态资源，减轻后端服务的压力。</p></li><li><p><strong>监控和日志</strong>：集成监控工具（如Prometheus）和日志服务（如ELK Stack）进行系统监控和日志分析。</p></li><li><p><strong>安全</strong>：实现网络安全策略、数据加密、DDoS防护等。</p></li></ol><h4 id="运维层"><a href="#运维层" class="headerlink" title="运维层"></a>运维层</h4><ol><li><p><strong>自动化部署</strong>：使用CI&#x2F;CD工具（如Jenkins）自动化部署流程。</p></li><li><p><strong>容器编排</strong>：使用Docker和Kubernetes进行容器化部署和管理。</p></li></ol><p>确保在设计时考虑到系统的可观测性、可维护性和灾难恢复能力。此外，对于“秒杀”类型的场景，还需要特别设计限流、熔断机制以及足够的预热和压力测试来确保系统在高负载下的稳定性。</p><h3 id="能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术"><a href="#能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术" class="headerlink" title="能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术"></a>能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术</h3><p><strong>将请求拦截在系统上游，降低下游压力：</strong>秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，甚至导致死锁，最终请求超时。</p><p><strong>充分利用缓存：</strong>利用缓存可极大提高系统读写速度。</p><p><strong>消息中间件：</strong>消息队列可以削峰，将拦截大量并发请求，这是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。</p><h2 id="信息系统安全概论-2"><a href="#信息系统安全概论-2" class="headerlink" title="信息系统安全概论"></a>信息系统安全概论</h2><h3 id="根据业务使命、工作环境进行信息系统安全威胁分析"><a href="#根据业务使命、工作环境进行信息系统安全威胁分析" class="headerlink" title="根据业务使命、工作环境进行信息系统安全威胁分析"></a>根据业务使命、工作环境进行信息系统安全威胁分析</h3><p>进行信息系统安全威胁分析时，考虑业务使命和工作环境是至关重要的。以下是一个分析框架，它考虑了这些因素，并帮助识别和评估潜在的安全威胁。</p><h4 id="1-理解业务使命"><a href="#1-理解业务使命" class="headerlink" title="1. 理解业务使命"></a>1. 理解业务使命</h4><ul><li><strong>业务目标</strong>：确定业务的主要目标和目的，分析哪些信息系统对实现这些目标至关重要。</li><li><strong>关键资产</strong>：识别业务运作的关键资产，包括重要的数据类型、系统、技术和人力资源。</li><li><strong>业务流程</strong>：了解业务流程及其对信息系统的依赖程度，以及流程被破坏时对业务的影响。</li><li><strong>合规要求</strong>：考虑行业标准和法规要求，如GDPR、HIPAA、PCI-DSS等对信息安全管理的影响。</li></ul><h4 id="2-分析工作环境"><a href="#2-分析工作环境" class="headerlink" title="2. 分析工作环境"></a>2. 分析工作环境</h4><ul><li><strong>物理环境</strong>：评估信息系统所在的物理环境，包括访问控制、灾害风险（如洪水、火灾）和其他相关因素。</li><li><strong>网络环境</strong>：理解网络架构，包括互联网接入方式、内部网络隔离以及远程访问的安全性。</li><li><strong>技术栈</strong>：识别使用的所有技术（软件、硬件、云服务等），包括它们的安全状态和历史漏洞。</li><li><strong>操作环境</strong>：涉及日常操作中可能出现的风险，例如员工的安全意识水平、数据处理和存储的安全性等。</li></ul><h4 id="3-安全威胁分析"><a href="#3-安全威胁分析" class="headerlink" title="3. 安全威胁分析"></a>3. 安全威胁分析</h4><ul><li><strong>威胁识别</strong>：列出可能影响信息系统的所有潜在威胁，包括恶意软件、黑客攻击、内部威胁、物理盗窃等。</li><li><strong>威胁评估</strong>：针对每项威胁，评估其可能性和对业务的潜在影响。这通常涉及风险评估矩阵。</li><li><strong>脆弱性评估</strong>：识别系统的脆弱点，包括未打补丁的软件、弱密码政策、员工培训缺失等。</li></ul><h4 id="4-采取防御措施"><a href="#4-采取防御措施" class="headerlink" title="4. 采取防御措施"></a>4. 采取防御措施</h4><ul><li><strong>预防措施</strong>：根据分析结果实施必要的安全措施，如加强访问控制、更新和打补丁、安全配置和加密措施。</li><li><strong>监控和检测</strong>：部署监控系统以检测可疑行为和迹象，确保能够及时响应潜在攻击。</li><li><strong>应急计划</strong>：制定并练习应急响应计划，以便在安全事件发生时能迅速采取行动。</li></ul><h4 id="5-持续改进"><a href="#5-持续改进" class="headerlink" title="5. 持续改进"></a>5. 持续改进</h4><ul><li><strong>审计和复审</strong>：定期进行安全审计，以评估现有措施的有效性，并根据新出现的威胁和漏洞进行调整。</li><li><strong>教育与培训</strong>：定期对员工进行安全培训，提高他们的安全意识和应对安全威胁的能力。</li></ul><h3 id="能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构"><a href="#能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构" class="headerlink" title="能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构"></a>能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构</h3><p><img src="D:\my_data\blog\zyhblog-img\image-20231219230840678.png" alt="image-20231219230840678"></p><h2 id="安全需求和安全策略-2"><a href="#安全需求和安全策略-2" class="headerlink" title="安全需求和安全策略"></a>安全需求和安全策略</h2><h3 id="根据安全威胁分析安全需求"><a href="#根据安全威胁分析安全需求" class="headerlink" title="根据安全威胁分析安全需求"></a>根据安全威胁分析安全需求</h3><p>根据安全威胁分析安全需求是一个重要的步骤，用于确保信息系统的安全性。这个过程涉及识别可能影响系统安全的潜在威胁，并基于这些威胁制定相应的安全需求和措施。以下是这一过程中的关键步骤：</p><h4 id="1-威胁建模"><a href="#1-威胁建模" class="headerlink" title="1. 威胁建模"></a>1. 威胁建模</h4><p>威胁建模通常是分析安全威胁的第一步，旨在识别系统可能面临的安全威胁。它可以帮助确定攻击者可能利用的弱点和系统可能受到的攻击类型。常见的威胁建模方法包括STRIDE模型，它涵盖以下威胁类型：</p><ul><li><strong>Spoofing</strong>（身份冒充）</li><li><strong>Tampering</strong>（数据篡改）</li><li><strong>Repudiation</strong>（否认）</li><li><strong>Information Disclosure</strong>（信息泄露）</li><li><strong>Denial of Service</strong>（服务拒绝）</li><li><strong>Elevation of Privilege</strong>（提权）</li></ul><h4 id="2-风险评估"><a href="#2-风险评估" class="headerlink" title="2. 风险评估"></a>2. 风险评估</h4><p>在威胁建模的基础上，进行风险评估以确定哪些威胁具有最高的风险。风险通常根据两个因素评估：威胁的可能性和威胁的影响。这可以通过不同的风险评估框架进行，如FAIR（Factor Analysis of Information Risk）或传统的风险矩阵。</p><h4 id="3-定义安全需求"><a href="#3-定义安全需求" class="headerlink" title="3. 定义安全需求"></a>3. 定义安全需求</h4><p>通过识别最高风险的威胁，可以定义系统的安全需求。这些需求应该旨在减轻或消除风险。安全需求通常包括以下几个方面：</p><ul><li><strong>保密性</strong>：确保信息不被未授权的个人或系统访问。</li><li><strong>完整性</strong>：保护数据免受未授权的修改。</li><li><strong>可用性</strong>：确保在需要时能够访问信息和资源。</li><li><strong>认证</strong>：确保参与者的身份得到确认。</li><li><strong>授权</strong>：确保只有授权用户才能访问资源。</li><li><strong>审计</strong>：记录和监控系统活动，以便在问题发生时可以进行检查。</li></ul><h4 id="4-实施安全控制"><a href="#4-实施安全控制" class="headerlink" title="4. 实施安全控制"></a>4. 实施安全控制</h4><p>根据定义的安全需求，选择和实施合适的安全控制措施。控制措施可以是技术性的，比如使用防火墙、加密和入侵检测系统；也可以是管理性的，比如制定安全策略、培训和应急计划；还可以是物理性的，比如安全门禁系统和监控摄像头。</p><h4 id="5-验证和测试"><a href="#5-验证和测试" class="headerlink" title="5. 验证和测试"></a>5. 验证和测试</h4><p>实施安全控制后，需要验证和测试它们的有效性。这可以通过安全审计、渗透测试、漏洞扫描等方式进行。</p><h4 id="6-持续监控和评估"><a href="#6-持续监控和评估" class="headerlink" title="6. 持续监控和评估"></a>6. 持续监控和评估</h4><p>安全需求的制定并不是一次性的活动。必须定期监控系统以检测新的安全威胁，并对安全需求进行评估和更新。</p><p>通过这个连续的循环过程，组织可以确保他们的安全措施保持最新，能够应对不断变化的威胁环境。这个过程不仅适用于信息技术系统，还适用于物理安全和组织的各个方面。</p><h3 id="可根据需要编写标准-ACL-或扩展-ACL，特别是通配掩码的使用"><a href="#可根据需要编写标准-ACL-或扩展-ACL，特别是通配掩码的使用" class="headerlink" title="可根据需要编写标准 ACL 或扩展 ACL，特别是通配掩码的使用"></a>可根据需要编写标准 ACL 或扩展 ACL，特别是通配掩码的使用</h3><p><strong>创建标准ACL实例</strong></p><p>Router(config)# access-list 1 permit 192.168.1.0 0.0.0.255</p><p>Router(config)# access-list 1 permit 192.168.2.2 0.0.0.0</p><p>允许192.168.1.0&#x2F;24和主机192.168.2.2的流量通过</p><p><strong>Examples:</strong> <strong>扩展****ACL</strong></p><ol><li><strong>Lab_A(config)#access-list 110 deny tcp any host 172.16.30.2 eq www</strong></li></ol><p>含义：拒绝任何IP地址通过TCP协议访问主机172.16.30.2的www服务。隐含的意思是主机可以访问172.16.30.2的其它服务，限制更为细致。</p><ol start="2"><li><strong>Lab_A(config)#access-list 110 permit tcp 192.168.10.0 0.0.0.255 host</strong></li></ol><p><strong>172.16.30.2 eq 23 log</strong></p><p>含义：允许网段192.168.10.0 255.255.255.0通过TCP协议访问主机172.16.30.2的23端口的服务即Telnet服务，且记录访问日志。</p><ol start="3"><li><strong>Lab_A(config)#access-list 110 permit ip any any</strong></li></ol><p>含义：允许所有使用IP协议的IP访问其它所有IP，即允许所有。</p><h2 id="信息系统的风险评估-2"><a href="#信息系统的风险评估-2" class="headerlink" title="信息系统的风险评估"></a>信息系统的风险评估</h2><h3 id="给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等"><a href="#给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等" class="headerlink" title="给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等"></a>给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等</h3><p>进行安全风险评估是一个系统化的过程，涉及对可能影响信息系统的风险进行识别、评估和优先级排序。这个过程通常包括以下几个关键步骤：</p><h4 id="1-风险分析方法"><a href="#1-风险分析方法" class="headerlink" title="1. 风险分析方法"></a>1. 风险分析方法</h4><p>选择一个适合组织需求的风险分析方法是重要的第一步。常见的方法包括：</p><ul><li><strong>定性分析</strong>：依赖于专业知识和经验来评估风险的概率和影响，结果通常使用诸如”低”、”中”、”高”这样的等级来描述。</li><li><strong>定量分析</strong>：使用数值方法来计算风险概率和影响，通常依赖于历史数据和统计技术。</li><li><strong>半定量分析</strong>：结合定性和定量分析的优点，通过打分系统来量化风险。</li></ul><h4 id="2-资产分类方法及识别模型"><a href="#2-资产分类方法及识别模型" class="headerlink" title="2. 资产分类方法及识别模型"></a>2. 资产分类方法及识别模型</h4><p>对于信息系统来说，资产是指所有的信息资源和相关的组件，如硬件、软件、数据和人力资源。资产分类和识别是风险评估的基础。常用的分类方法包括：</p><ul><li><strong>按照功能</strong>：例如，服务器、用户终端、网络设备等。</li><li><strong>按照数据类型</strong>：如个人身份信息、财务报告、知识产权等。</li><li><strong>按照重要性</strong>：关键资产、重要资产和非关键资产。</li></ul><h4 id="3-威胁赋值"><a href="#3-威胁赋值" class="headerlink" title="3. 威胁赋值"></a>3. 威胁赋值</h4><p>威胁赋值是指识别可能对资产造成损害的所有潜在威胁，并对这些威胁的严重性进行评估。威胁可以来自多个来源，如自然灾害、技术故障、人为错误或恶意攻击。为了评估威胁，组织通常会：</p><ul><li><strong>列出威胁来源</strong>：包括内部和外部来源。</li><li><strong>评估威胁发生的可能性</strong>：通常分为“不太可能”、“可能”、“很可能”等。</li><li><strong>考虑威胁的潜在影响</strong>：对业务的影响，如财务损失、声誉损害等。</li></ul><h4 id="4-脆弱性赋值"><a href="#4-脆弱性赋值" class="headerlink" title="4. 脆弱性赋值"></a>4. 脆弱性赋值</h4><p>脆弱性是指系统、程序或网络中的弱点，可以被威胁所利用。脆弱性赋值包括以下步骤：</p><ul><li><strong>脆弱性扫描</strong>：使用自动工具检测系统的已知脆弱性。</li><li><strong>脆弱性评估</strong>：分析扫描结果，评估每个脆弱性被利用的可能性和潜在的影响。</li><li><strong>脆弱性优先级排序</strong>：确定哪些脆弱性最值得注意。</li></ul><h4 id="5-风险评估"><a href="#5-风险评估" class="headerlink" title="5. 风险评估"></a>5. 风险评估</h4><p>最后，结合威胁赋值和脆弱性赋值的结果来评估风险。风险可以定义为威胁和脆弱性相结合的概率与其潜在影响的乘积。对于每个风险，评估其：</p><ul><li><strong>概率</strong>：风险出现的可能性有多大。</li><li><strong>影响</strong>：如果风险实际发生，会对组织造成多大的损害。</li></ul><p>根据评估的结果，组织可以确定哪些风险需要优先处理，并制定相应的风险缓解措施。这可能包括技术控制（如加密和访问控制）、管理控制（如策略和流程）和物理控制（如安全门和监控相机）。</p><p>风险评估是一个动态的过程，需要定期更新，以反映新的威胁、脆弱性和业务环境的变化。</p><h2 id="信息系统等级保护-2"><a href="#信息系统等级保护-2" class="headerlink" title="信息系统等级保护"></a>信息系统等级保护</h2><h3 id="给定某信息系统的业务使命及操作环境，可进行定级和备案"><a href="#给定某信息系统的业务使命及操作环境，可进行定级和备案" class="headerlink" title="给定某信息系统的业务使命及操作环境，可进行定级和备案"></a>给定某信息系统的业务使命及操作环境，可进行定级和备案</h3><p>北京邮电大学教务系统是一个关键的信息系统，它处理学生的注册、课程分配、成绩记录等重要数据。进行定级和备案操作需遵循以下步骤：</p><h4 id="1-业务使命和操作环境分析"><a href="#1-业务使命和操作环境分析" class="headerlink" title="1. 业务使命和操作环境分析"></a>1. 业务使命和操作环境分析</h4><ul><li><strong>业务使命</strong>：教务系统的业务使命是管理学生的教育相关信息，包括课程注册、成绩管理、学位认证等。</li><li><strong>操作环境</strong>：教务系统在北京邮电大学校园内部署，在校园网络环境下运行，并由学校的IT部门维护。</li></ul><h4 id="2-定级"><a href="#2-定级" class="headerlink" title="2. 定级"></a>2. 定级</h4><h5 id="信息资产识别和价值评估"><a href="#信息资产识别和价值评估" class="headerlink" title="信息资产识别和价值评估"></a>信息资产识别和价值评估</h5><ul><li>确认教务系统中所有的硬件和软件资源，以及它们的配置。</li><li>评估学生和教职工的个人信息、成绩资料、课程信息等数据的价值和敏感性，因为这些信息通常包含个人隐私。</li></ul><h5 id="威胁和脆弱性分析"><a href="#威胁和脆弱性分析" class="headerlink" title="威胁和脆弱性分析"></a>威胁和脆弱性分析</h5><ul><li>确定可能对教务系统构成威胁的各种因素，包括网络攻击、内部数据泄露、自然灾害等。</li><li>分析系统存在的脆弱性，如软件漏洞、硬件故障或人为错误。</li></ul><h5 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h5><ul><li>结合资产价值、威胁和脆弱性来评估风险。</li><li>评估数据泄露、系统中断等对学校运营及声誉可能造成的影响。</li></ul><h5 id="安全等级划分"><a href="#安全等级划分" class="headerlink" title="安全等级划分"></a>安全等级划分</h5><ul><li>根据以上评估的结果，参照国家或行业的标准，给教务系统定一个合适的安全等级。</li><li>根据中国的相关标准，教务系统可能被定为三级或四级信息系统，因为它处理大量的个人敏感数据。</li></ul><h4 id="3-备案"><a href="#3-备案" class="headerlink" title="3. 备案"></a>3. 备案</h4><h5 id="编制备案材料"><a href="#编制备案材料" class="headerlink" title="编制备案材料"></a>编制备案材料</h5><ul><li>准备详细的系统描述，包括它的功能、数据流、用户访问模式等。</li><li>包含定级的相关文档，比如风险评估报告、安全保护措施描述、安全管理制度等。</li></ul><h5 id="提交备案"><a href="#提交备案" class="headerlink" title="提交备案"></a>提交备案</h5><ul><li>将所有准备好的材料提交给北京市海淀区公安局的信息网络安全监管部门。</li><li>包括备案申请表、系统等级评估报告、风险管理方案等。</li></ul><h5 id="后续跟进"><a href="#后续跟进" class="headerlink" title="后续跟进"></a>后续跟进</h5><ul><li>等待海淀区公安局审核并确认备案。</li><li>根据公安局的要求，可能需要提供额外的信息或对系统进行必要的安全改进。</li><li>在备案通过后，定期更新备案信息，如系统升级、安全事件等均可能需要重新评估和备案。</li></ul><p>进行定级和备案操作是为了确保教务系统的安全性，防护措施的适当性，并且遵守中国的法律法规要求，保护学生和教职工的个人信息安全。</p><h2 id="信息系统的物理安全-2"><a href="#信息系统的物理安全-2" class="headerlink" title="信息系统的物理安全"></a>信息系统的物理安全</h2><h3 id="机房设计和建设中应该考虑的安全因素"><a href="#机房设计和建设中应该考虑的安全因素" class="headerlink" title="机房设计和建设中应该考虑的安全因素"></a>机房设计和建设中应该考虑的安全因素</h3><p>在机房设计和建设中考虑的安全因素非常广泛，既包括物理安全措施，也包括环境控制、电源管理等。以下是一些关键的安全因素：</p><h4 id="物理安全"><a href="#物理安全" class="headerlink" title="物理安全"></a>物理安全</h4><ol><li><strong>门禁系统</strong>：确保只有授权人员能够进入机房。门禁系统通常包括卡片读取器、生物识别系统等。</li><li><strong>监控系统</strong>：安装视频监控设备监视机房内外的活动，以防止未授权的访问或其他安全事件。</li><li><strong>安全门和窗户</strong>：使用坚固的材料制作门和窗户，防止非法闯入。</li><li><strong>物理隔离</strong>：机房应与其他非关键区域物理隔离，减少潜在的物理风险。</li></ol><h3 id="火灾防护"><a href="#火灾防护" class="headerlink" title="火灾防护"></a>火灾防护</h3><ol><li><strong>自动喷水灭火系统</strong>：在必要时可采用，但不适用于高端电子设备。</li><li><strong>化学灭火系统</strong>：使用FM200或其他适用于机房的化学灭火剂。</li><li><strong>烟雾探测器和报警系统</strong>：确保一旦发生火情，立即发出警报并启动灭火系统。</li></ol><h4 id="环境控制"><a href="#环境控制" class="headerlink" title="环境控制"></a>环境控制</h4><ol><li><strong>温度和湿度控制</strong>：维持适宜的温度和湿度水平以保护设备免受损害。</li><li><strong>空调系统</strong>：设计高效的空调系统，并具备备用冷却系统以防主系统故障。</li></ol><h4 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h4><ol><li><strong>不间断电源（UPS）</strong>：确保在市电断电的情况下，关键设备能够继续运行。</li><li><strong>备用发电机</strong>：在长时间的电力中断时，能够供应机房所需的电力。</li><li><strong>电源分配单元（PDU）</strong>：合理分配电源，确保电力供应的稳定性与安全性。</li></ol><h4 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h4><ol><li><strong>网络安全设备</strong>：部署适当的防火墙和入侵检测系统来保障网络安全。</li><li><strong>数据备份</strong>：定期备份重要数据，并将备份保存在安全的离线位置。</li></ol><h4 id="管理措施"><a href="#管理措施" class="headerlink" title="管理措施"></a>管理措施</h4><ol><li><strong>访问记录</strong>：记录所有访问机房人员的详情，包括时间和日期。</li><li><strong>维护和操作程序</strong>：建立严格的维护和操作流程，确保每项操作都能追溯并符合安全规范。</li></ol><h4 id="法规遵从"><a href="#法规遵从" class="headerlink" title="法规遵从"></a>法规遵从</h4><ol><li><strong>符合当地法规</strong>：确保机房设计符合当地建筑、电力、消防等相关法规。</li><li><strong>行业标准遵从</strong>：遵循行业标准如TIA-942、ISO&#x2F;IEC 27001等。</li></ol><h4 id="灾害恢复"><a href="#灾害恢复" class="headerlink" title="灾害恢复"></a>灾害恢复</h4><ol><li><strong>灾害恢复计划</strong>：制定并定期测试灾害恢复计划，确保在灾难发生时能够快速恢复操作。</li></ol><p>这些安全因素的考虑能够确保机房免受各种潜在风险的影响，保障信息系统的稳定与数据的安全。在实际应用中，应根据机房的规模、功能和位置，以及所支持的业务的重要性，来确定上述安全措施的具体要求和实施方案。</p><h2 id="计算机取证-2"><a href="#计算机取证-2" class="headerlink" title="计算机取证"></a>计算机取证</h2><h3 id="知道常见的取证工具"><a href="#知道常见的取证工具" class="headerlink" title="知道常见的取证工具"></a>知道常见的取证工具</h3><p>确定系统的审核策略auditpol</p><p>转储Windows系统注册表中的特定信息（键）reg</p><p>以文本文件格式转储注册表regdump</p><p>转储SAM数据库，可破解密码pwdump6</p><p>监控成功和失败的系统登录NTLast</p><p>侦测隐藏在NTFS文件流中的文件Sfind</p><p>扫描文件系统找出在某时段内被访问过的文件Afind</p><p>转储Windows系统的事件日志Dumpel</p><h3 id="制定一个简单的取证方案"><a href="#制定一个简单的取证方案" class="headerlink" title="制定一个简单的取证方案"></a>制定一个简单的取证方案</h3><p>制定一个简单的计算机取证方案包括多个步骤，每个步骤都需要遵循特定的协议和最佳实践。以下是一个基础的计算机取证方案示例：</p><h4 id="1-准备阶段"><a href="#1-准备阶段" class="headerlink" title="1. 准备阶段"></a>1. 准备阶段</h4><ul><li><strong>取证计划：</strong> 制定详细的取证分析计划，包括目标、作业范围、所需工具和资源等。</li><li><strong>法律考虑：</strong> 确保有合法权限进行取证调查，了解相关法律、法规和标准。</li><li><strong>取证工具和软件：</strong> 准备必要的取证工具，如磁盘镜像工具、文件恢复工具、取证分析软件等。</li><li><strong>取证团队：</strong> 确定参与取证分析的团队成员的角色和责任。</li></ul><h4 id="2-采集阶段"><a href="#2-采集阶段" class="headerlink" title="2. 采集阶段"></a>2. 采集阶段</h4><ul><li><strong>现场评估：</strong> 如果是实际现场，首先进行现场评估，记录现场情况，拍照或录像。</li><li><strong>证据保护：</strong> 确保证据不被篡改，避免在取证过程中电磁干扰或物理损坏。</li><li><strong>创建数据镜像：</strong> 对存储设备进行物理或逻辑镜像，并验证镜像的完整性（使用哈希值）。</li><li><strong>文档记录：</strong> 记录详细的证据采集过程，包括时间、日期、位置、人员、操作步骤等。</li></ul><h4 id="3-分析阶段"><a href="#3-分析阶段" class="headerlink" title="3. 分析阶段"></a>3. 分析阶段</h4><ul><li><strong>初步审查：</strong> 初步审查镜像文件以确认潜在的证据文件。</li><li><strong>文件恢复：</strong> 使用恢复工具寻找删除、隐藏或丢失的文件。</li><li><strong>日志文件分析：</strong> 分析系统、网络和应用程序的日志文件。</li><li><strong>关键词搜索：</strong> 执行关键词搜索，以查找相关的文件和通讯记录。</li><li><strong>时间线分析：</strong> 构建时间线，以了解事件发生的顺序。</li><li><strong>数据整理：</strong> 整理和分类发现的证据，准备报告。</li></ul><h4 id="4-文档和报告阶段"><a href="#4-文档和报告阶段" class="headerlink" title="4. 文档和报告阶段"></a>4. 文档和报告阶段</h4><ul><li><strong>报告编写：</strong> 编写详细的取证报告，包括方法、发现、结论和推荐。</li><li><strong>证据保管：</strong> 确保所有证据物品得到妥善保存，避免未授权访问和损坏。</li><li><strong>审阅和分析：</strong> 让同行或法律专家审阅报告，确保报告的准确性和完整性。</li></ul><h4 id="5-呈现阶段"><a href="#5-呈现阶段" class="headerlink" title="5. 呈现阶段"></a>5. 呈现阶段</h4><ul><li><strong>法庭陈述：</strong> 准备在法庭上作为证人陈述的材料，包括可视化展示证据。</li><li><strong>证据链维护：</strong> 在法庭上清晰地展示证据链，确保每一环都能够得到证明。</li></ul><h4 id="6-结束阶段"><a href="#6-结束阶段" class="headerlink" title="6. 结束阶段"></a>6. 结束阶段</h4><ul><li><strong>案件复盘：</strong> 审查整个案件处理过程，总结经验教训。</li><li><strong>数据销毁：</strong> 如果法律要求或客户同意，安全销毁敏感数据。</li></ul><p>在执行上述任何步骤时，都需要遵守诚信、保密和合法性的原则，确保证据的可靠性和法庭的可接受性。此外，整个过程中，团队成员应该接受定期培训，以确保他们的技能和知识与行业标准保持同步。</p>]]></content>
    
    
    <summary type="html">信息系统安全期末考试的初步总结，供学弟学妹参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="复习总结" scheme="https://zhangyuanhe.top/tags/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Latex语法学习</title>
    <link href="https://zhangyuanhe.top/2023/09/19/Software%20and%20App/Latex_study/"/>
    <id>https://zhangyuanhe.top/2023/09/19/Software%20and%20App/Latex_study/</id>
    <published>2023-09-19T01:00:00.000Z</published>
    <updated>2023-10-28T11:12:57.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Latex介绍"><a href="#Latex介绍" class="headerlink" title="Latex介绍"></a>Latex介绍</h1><p>Latex（LATEX，音译“拉泰赫”）是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由 TEX 所提供的强大功能，能在几天、甚至几小时内生成很多具有书籍质量的印刷品。</p><p>它构筑在 TEX 的基础之上，并加进了很多的功能以使得使用者可以更为方便的利用 TEX 的强大功能。使用Latex基本上不需要使用者自己设计命令和宏等，因为Latex已经替你做好了。</p><p>对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。</p><p>这个系统同样适用于生成从简单的信件、精致的简历、优雅的幻灯片到完整书籍的所有其他种类的文档。</p><h1 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/9/1/2/91205e81c98c486418902c88d5c396f5355491f1.png" alt="$\pm$"></td><td>\pm</td><td><img src="https://latex.artofproblemsolving.com/1/9/d/19dcb590e43ac06de8bf64daabdcae351c51ebe6.png" alt="$\mp$"></td><td>\mp</td><td><img src="https://latex.artofproblemsolving.com/b/a/c/bac4dbe1c696d11e8dc43dd7f613199b2120daa1.png" alt="$\times$"></td><td>\times</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/1/c/8/1c81486a525ba08192aab8546dbe9a32bdbe0c07.png" alt="$\div$"></td><td>\div</td><td><img src="https://latex.artofproblemsolving.com/8/f/1/8f1fb66751f2ee2626c75303485dba473c39a2f2.png" alt="$\cdot$"></td><td>\cdot</td><td><img src="https://latex.artofproblemsolving.com/2/7/8/278afa87a7dfa8e2b3f40e608884a690fb1325f6.png" alt="$\ast$"></td><td>\ast</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/d/1/7/d17950ad2ab63c764778b133f95a03dcf2969d57.png" alt="$\star$"></td><td>\star</td><td><img src="https://latex.artofproblemsolving.com/7/5/f/75fbdfd4148a2d76b66583eb07a05c0e1853e5ed.png" alt="$\dagger$"></td><td>\dagger</td><td><img src="https://latex.artofproblemsolving.com/1/e/e/1eee3cf7655b7f97127bfaf93851960caf8aa62f.png" alt="$\ddagger$"></td><td>\ddagger</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/e/4/3/e43da851ce02ac27ab36f6708edf6c313febd609.png" alt="$\amalg$"></td><td>\amalg</td><td><img src="https://latex.artofproblemsolving.com/c/0/f/c0f2b8e02812dd6278501da3698b07563864df3d.png" alt="$\cap$"></td><td>\cap</td><td><img src="https://latex.artofproblemsolving.com/a/6/c/a6cef8fd2bc2c7f9f1e27327b739f2cd7baa31ac.png" alt="$\cup$"></td><td>\cup</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/7/9/0/7909c20a66b5e6fa43a1a26710a8ebcfb82527ff.png" alt="$\uplus$"></td><td>\uplus</td><td><img src="https://latex.artofproblemsolving.com/f/1/7/f17c91e4f44cf3cef16793582abe63eea7b8d0b1.png" alt="$\sqcap$"></td><td>\sqcap</td><td><img src="https://latex.artofproblemsolving.com/1/4/e/14e23edff0ebfb9a1d7976b6d3553ce54c7c413a.png" alt="$\sqcup$"></td><td>\sqcup</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/1/3/f/13f3b223fb942219e3d77d9dfa86ad0933513882.png" alt="$\vee$"></td><td>\vee</td><td><img src="https://latex.artofproblemsolving.com/b/d/8/bd8dcc3cdcaa4d91ba26f8bfb9c339862f7c0047.png" alt="$\wedge$"></td><td>\wedge</td><td><img src="https://latex.artofproblemsolving.com/f/7/c/f7c581af3f7cf7ed3abe62da090534eb4d1bd00f.png" alt="$\oplus$"></td><td>\oplus</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/1/e/b/1eb5abf6a4d5640740fa3b2cd04b4044f2af4447.png" alt="$\ominus$"></td><td>\ominus</td><td><img src="https://latex.artofproblemsolving.com/b/8/8/b88c462e5d9319a7d2181ad94863658fa0a24736.png" alt="$\otimes$"></td><td>\otimes</td><td><img src="https://latex.artofproblemsolving.com/7/f/3/7f3b4ea3b8abe9ced6095c7d75f207a1127ee843.png" alt="$\circ$"></td><td>\circ</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/d/5/3/d534b942086dae501cbdce030206adb87567bb07.png" alt="$\bullet$"></td><td>\bullet</td><td><img src="https://latex.artofproblemsolving.com/a/6/4/a64597fa971a2a89feef230c4a309e18d2bb0c8f.png" alt="$\diamond$"></td><td>\diamond</td><td><img src="https://latex.artofproblemsolving.com/a/1/5/a15fb2b22303748b71b538562bc38cf2f3d9c036.png" alt="$\lhd$"></td><td>\lhd</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/3/7/2/372fab12125c6ece78ebae1fa64389c7bd788166.png" alt="$\rhd$"></td><td>\rhd</td><td><img src="https://latex.artofproblemsolving.com/b/c/4/bc4897ff6faf49b2f2ac26351bca603e931e7ec8.png" alt="$\unlhd$"></td><td>\unlhd</td><td><img src="https://latex.artofproblemsolving.com/b/d/d/bdd81dbaedba0355750058c7c6a2e40a015e28bb.png" alt="$\unrhd$"></td><td>\unrhd</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/f/b/b/fbb803c0fc7f72787184624d4f91e71a171baa1f.png" alt="$\oslash$"></td><td>\oslash</td><td><img src="https://latex.artofproblemsolving.com/9/c/b/9cb84f78e824963c5609a057214128b8c7776183.png" alt="$\odot$"></td><td>\odot</td><td><img src="https://latex.artofproblemsolving.com/b/1/3/b1352e2dc4380ca6efe5d978cb4bfa2745354e11.png" alt="$\bigcirc$"></td><td>\bigcirc</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/a/a/b/aab16e702194ef1900cf09684c138f410ef995e8.png" alt="$\triangleleft$"></td><td>\triangleleft</td><td><img src="https://latex.artofproblemsolving.com/7/6/e/76edde10cd8ffa25ad5bf5689c032fdf78aeef28.png" alt="$\Diamond$"></td><td>\Diamond</td><td><img src="https://latex.artofproblemsolving.com/5/d/0/5d0a21de4d02a9c17e9f716bc93020cb300dc335.png" alt="$\bigtriangleup$"></td><td>\bigtriangleup</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/5/2/a/52a23e3c2f527965b4d5461bf5981ef112d51a2f.png" alt="$\bigtriangledown$"></td><td>\bigtriangledown</td><td><img src="https://latex.artofproblemsolving.com/c/1/2/c12dda010ebddef028cda1ec9d14986f4a26d07e.png" alt="$\Box$"></td><td>\Box</td><td><img src="https://latex.artofproblemsolving.com/c/1/7/c1731dedb14bb1b4781dc9a30b95f58825a50fa9.png" alt="$\triangleright$"></td><td>\triangleright</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/8/a/a/8aa91c965a8fe7e59c49e1e97bc7d5828dc4d120.png" alt="$\setminus$"></td><td>\setminus</td><td><img src="https://latex.artofproblemsolving.com/3/4/1/341afd98eab5dbcdd2128223e84e2d9f1bb63365.png" alt="$\wr$"></td><td>\wr</td><td><img src="https://latex.artofproblemsolving.com/4/8/0/4805dddb4e6911989af8be91da334b5ba2054757.png" alt="$\sqrt{x}$"></td><td>\sqrt{x}</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/d/a/9/da9bb652e84532a7cddad7b633cb769bc6946d4e.png" alt="$x^{\circ}$"></td><td>x^{\circ}</td><td><img src="https://latex.artofproblemsolving.com/8/4/8/848003f6d0389cb141c2bf3b624734556c9f746a.png" alt="$\triangledown$"></td><td>\triangledown</td><td><img src="https://latex.artofproblemsolving.com/0/2/d/02d35112ae0400463779b8c3320f3bc597d81374.png" alt="$\sqrt[n]{x}$"></td><td>\sqrt[n]{x}</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/d/d/e/ddee543f04d6fbac4ab70309ce7aa5b8760aa897.png" alt="$a^x$"></td><td>a^x</td><td><img src="https://latex.artofproblemsolving.com/c/6/9/c690994d239dc33c27fd53c79940a75330eaf41e.png" alt="$a^{xyz}$"></td><td>a^{xyz}</td><td><img src="https://latex.artofproblemsolving.com/9/a/5/9a5af51cfec649afb7d8bf2c8b7080b58ba69830.png" alt="$a_x$"></td><td>a_x</td></tr></tbody></table><h2 id="关系符"><a href="#关系符" class="headerlink" title="关系符"></a>关系符</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/3/b/4/3b4cd01885cb569775f5d1143bc5139fff104bdc.png" alt="$\le$"></td><td>\le</td><td><img src="https://latex.artofproblemsolving.com/0/0/c/00c3863a5ca53a1be38db8921ae7b5bfbfbe1dc6.png" alt="$\ge$"></td><td>\ge</td><td><img src="https://latex.artofproblemsolving.com/e/3/4/e34abf3c7601f491cde20e6c318f54030b0237a2.png" alt="$\neq$"></td><td>\neq</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/e/5/5/e55156a4008b0944ad00d5bc71bc5aa6315aabb7.png" alt="$\sim$"></td><td>\sim</td><td><img src="https://latex.artofproblemsolving.com/1/e/4/1e4d154223e7171ad7ae3b398a849d0152b575ad.png" alt="$\ll$"></td><td>\ll</td><td><img src="https://latex.artofproblemsolving.com/b/5/e/b5e95a72274f434ba9984d67dba7438a286158f3.png" alt="$\gg$"></td><td>\gg</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/a/8/f/a8fa91f83671b6f0f19a4bb1b0839d1fc06ffbf9.png" alt="$\doteq$"></td><td>\doteq</td><td><img src="https://latex.artofproblemsolving.com/5/e/4/5e46ba9c72f86769fb14a32f8eb271bc440e2061.png" alt="$\simeq$"></td><td>\simeq</td><td><img src="https://latex.artofproblemsolving.com/e/6/f/e6ffbe0cb0b8d47bd10eec85fb336adf7694f896.png" alt="$\subset$"></td><td>\subset</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/f/5/4/f5451590e41b731933710d9f34b93b6dd2994139.png" alt="$\supset$"></td><td>\supset</td><td><img src="https://latex.artofproblemsolving.com/a/c/b/acbc54ef8feabfc5d0a2329f0cfbd10af8a6a809.png" alt="$\approx$"></td><td>\approx</td><td><img src="https://latex.artofproblemsolving.com/c/6/d/c6dd6b322a1d042d13b2ceba7a6f45be7eb8de6c.png" alt="$\asymp$"></td><td>\asymp</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/7/a/f/7af4f46fd0cf5cdbed23e67e7896f64cb380ee52.png" alt="$\subseteq$"></td><td>\subseteq</td><td><img src="https://latex.artofproblemsolving.com/a/5/5/a5544786abebf78b0ef72b5241cdb1196effabd2.png" alt="$\supseteq$"></td><td>\supseteq</td><td><img src="https://latex.artofproblemsolving.com/b/9/9/b9904282b277d5afca7b6fb12f3bb7c5ff616510.png" alt="$\cong$"></td><td>\cong</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/b/9/d/b9d7bc7cf4a44200f381f9b8f7f09b27ba728018.png" alt="$\smile$"></td><td>\smile</td><td><img src="https://latex.artofproblemsolving.com/1/2/4/124b77b4b0cc873e5c027a76ab58cd5c7fed0ca1.png" alt="$\sqsubset$"></td><td>\sqsubset</td><td><img src="https://latex.artofproblemsolving.com/2/3/1/231bddf0e59b26209b1b6815d9a41f91d04ea701.png" alt="$\sqsupset$"></td><td>\sqsupset</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/1/1/6/1165e91155febc4bc88785c5504eb52efe4f8c51.png" alt="$\equiv$"></td><td>\equiv</td><td><img src="https://latex.artofproblemsolving.com/c/d/0/cd0780b55db44ebfc68e984c2354c579314de704.png" alt="$\frown$"></td><td>\frown</td><td><img src="https://latex.artofproblemsolving.com/d/6/e/d6ee2b442ac5f3d7940a33c1eba386e93fc3381f.png" alt="$\sqsubseteq$"></td><td>\sqsubseteq</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/6/9/3/693c0332817f1be148c7b691a1d419e0cdc971ed.png" alt="$\sqsupseteq$"></td><td>\sqsupseteq</td><td><img src="https://latex.artofproblemsolving.com/1/1/3/11303cd923877716bbb6fde144d09687260910fb.png" alt="$\propto$"></td><td>\propto</td><td><img src="https://latex.artofproblemsolving.com/c/5/a/c5a172ca1f59801643929daf4b59d0a225604ca7.png" alt="$\bowtie$"></td><td>\bowtie</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/1/3/4/134004c561e4c0cca193dbf5122e5ca963dd5b7f.png" alt="$\in$"></td><td>\in</td><td><img src="https://latex.artofproblemsolving.com/8/9/d/89db07258d2e7a1c9aac138b7c1846645bdf79eb.png" alt="$\ni$"></td><td>\ni</td><td><img src="https://latex.artofproblemsolving.com/c/c/1/cc1075b75dff8acde28b91201acc216d0a343fce.png" alt="$\prec$"></td><td>\prec</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/f/0/d/f0da9cf8e29547352b0d8a30fedb96f71f5def8b.png" alt="$\succ$"></td><td>\succ</td><td><img src="https://latex.artofproblemsolving.com/8/1/2/81226dce386555032afda7e4739639feabbc801a.png" alt="$\vdash$"></td><td>\vdash</td><td><img src="https://latex.artofproblemsolving.com/f/f/d/ffdb8a7364423bb7904d60840d7b7f9047dee450.png" alt="$\dashv$"></td><td>\dashv</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/e/a/c/eac91ff45cea31243210756d0af2ecd0867f9dae.png" alt="$\preceq$"></td><td>\preceq</td><td><img src="https://latex.artofproblemsolving.com/d/b/0/db0f05af17a329d387f5234730350c6227d4ca0d.png" alt="$\succeq$"></td><td>\succeq</td><td><img src="https://latex.artofproblemsolving.com/3/1/a/31a65b06843b33bfe53a87920e8de3a8a40d93e4.png" alt="$\models$"></td><td>\models</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/2/9/5/29501a90018e83d6d3e88b1f83bdfb71e692561e.png" alt="$\perp$"></td><td>\perp</td><td><img src="https://latex.artofproblemsolving.com/7/0/0/700b2122c7a66766d80c3dfe5109de9b58e65a66.png" alt="$\parallel$"></td><td>\parallel</td><td></td><td></td></tr></tbody></table><p>只要将not放在符号前面或者在 \ 和单词之间插入一个 n ，就可以形成许多这些关系的否定形式，这里有一些例子，加上一些其他的否定，它也适用于许多其他的。</p><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/8/3/b/83b17e0f7af5b49594ac16587442fe5f12a475fd.png" alt="$\nmid$"></td><td>\nmid</td><td><img src="https://latex.artofproblemsolving.com/c/6/8/c681d35dfe1a4f53de0ebda66832aa0fc286cbd0.png" alt="$\nleq$"></td><td>\nleq</td><td><img src="https://latex.artofproblemsolving.com/a/5/e/a5ea08782633e9e1db55ada7df9ec3cb1e74e212.png" alt="$\ngeq$"></td><td>\ngeq</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/9/8/e/98e9b5dcdf4cef4c9a6eba2f89b79dbab6589f40.png" alt="$\nsim$"></td><td>\nsim</td><td><img src="https://latex.artofproblemsolving.com/e/f/2/ef2f2d4b87a19a87d9c6aae23f3515c44f49c5e4.png" alt="$\ncong$"></td><td>\ncong</td><td><img src="https://latex.artofproblemsolving.com/6/6/4/66459c2921421baabb23ba674f1c38644bfb94ae.png" alt="$\nparallel$"></td><td>\nparallel</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/b/e/5/be5b21d425b39063889ffc39302122c302187840.png" alt="$\not&lt;$"></td><td>\not&lt;</td><td><img src="https://latex.artofproblemsolving.com/4/1/4/41484799e848722804569891f3c9f8f6ba85be72.png" alt="$\not&gt;$"></td><td>\not&gt;</td><td><img src="https://latex.artofproblemsolving.com/b/5/2/b52e41fffd6f799febf06948db4857add0cafdf5.png" alt="$\not=$"></td><td>\not&#x3D; or \neq or \ne</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/8/8/0/8804323a929802098f7d5135effe13df72f99fe3.png" alt="$\not\le$"></td><td>\not\le</td><td><img src="https://latex.artofproblemsolving.com/c/3/6/c36f3836d4cf8e908a3e63d0640dbe5f3f6b3aac.png" alt="$\not\ge$"></td><td>\not\ge</td><td><img src="https://latex.artofproblemsolving.com/3/2/8/328e7366713d3594c6decd9a16c71d38ff66d24e.png" alt="$\not\sim$"></td><td>\not\sim</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/1/4/c/14cef4209cbb6781580b82fcb49c5cabf42110b5.png" alt="$\not \approx$"></td><td>\not\approx</td><td><img src="https://latex.artofproblemsolving.com/9/d/b/9dba3e1547b02e8cfb16e73174d313ce3c44991d.png" alt="$\not\cong$"></td><td>\not\cong</td><td><img src="https://latex.artofproblemsolving.com/7/5/2/7524371d49900f0a110e8c41a6a626449310999d.png" alt="$\not\equiv$"></td><td>\not\equiv</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/1/0/b/10babfcf66e652715e5ee499b569c4afaff8e347.png" alt="$\not\parallel$"></td><td>\not\parallel</td><td><img src="https://latex.artofproblemsolving.com/1/1/e/11ed3742359426af546f0f2c588934cc3d27d9a7.png" alt="$\nless$"></td><td>\nless</td><td><img src="https://latex.artofproblemsolving.com/8/0/e/80e8acc7c1a52a13f0b46fcdb855501582c1f258.png" alt="$\ngtr$"></td><td>\ngtr</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/0/1/c/01cbbfb6098409250bba1da5cd3702a4f91b1062.png" alt="$\lneq$"></td><td>\lneq</td><td><img src="https://latex.artofproblemsolving.com/5/0/2/502aba7f2ebb4e5b0c07f1fc727f09a20c4b4bc6.png" alt="$\gneq$"></td><td>\gneq</td><td><img src="https://latex.artofproblemsolving.com/2/c/e/2ce172633b8db32cdba9196efe3d5912628e73db.png" alt="$\lnsim$"></td><td>\lnsim</td></tr></tbody></table><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/4/e/a/4eab2b4c3730f6ca28b181105160f87f84c49a08.png" alt="$\sum  \textstyle\sum$"></td><td>\sum</td><td><img src="https://latex.artofproblemsolving.com/6/d/1/6d14592f0872a308caf69a5d695581b8f56adaf4.png" alt="$\int  \textstyle\int$"></td><td>\int</td><td><img src="https://latex.artofproblemsolving.com/b/1/d/b1d46ca41500b244afd17f827dda9a43a1c606c1.png" alt="$\oint  \textstyle\oint$"></td><td>\oint</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/e/8/c/e8cb398f2e1c14f174456af12526d1380de93042.png" alt="$\prod  \textstyle\prod$"></td><td>\prod</td><td><img src="https://latex.artofproblemsolving.com/7/f/f/7ff985aaf9cdb0a46821e8ca45369ea50dab16bf.png" alt="$\coprod  \textstyle\coprod$"></td><td>\coprod</td><td><img src="https://latex.artofproblemsolving.com/0/f/2/0f2b6687b87eba9a1b15c64bf1a510f3d8962533.png" alt="$\bigcap  \textstyle\bigcap$"></td><td>\bigcap</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/d/c/3/dc3622235b09bd67ccd61d51706be0cdba8cde4a.png" alt="$\bigcup  \textstyle\bigcup$"></td><td>\bigcup</td><td><img src="https://latex.artofproblemsolving.com/4/c/1/4c1715b7d4bedcd82804947fff2234e526e67b9a.png" alt="$\bigsqcup  \textstyle\bigsqcup$"></td><td>\bigsqcup</td><td><img src="https://latex.artofproblemsolving.com/f/8/2/f8270dc629acde682ea1e18f9cee677e58c29cbb.png" alt="$\bigvee  \textstyle\bigvee$"></td><td>\bigvee</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/e/b/b/ebb4ab4fbe044c44a446fe1bf274d3a80048284c.png" alt="$\bigwedge  \textstyle\bigwedge$"></td><td>\bigwedge</td><td><img src="https://latex.artofproblemsolving.com/e/3/1/e31ae477e5b4dc90514e2099723ae7faaef6fc3b.png" alt="$\bigodot  \textstyle\bigodot$"></td><td>\bigodot</td><td><img src="https://latex.artofproblemsolving.com/b/1/2/b12e4a1447f71f823eefb562ecac1e11ebd63915.png" alt="$\bigotimes  \textstyle\bigotimes$"></td><td>\bigotimes</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/6/c/1/6c1138601b152c42594b90596c293aee1ee69840.png" alt="$\bigoplus  \textstyle\bigoplus$"></td><td>\bigoplus</td><td><img src="https://latex.artofproblemsolving.com/2/2/0/220392b0536ae9431accdeec479897a2247f4a4d.png" alt="$\biguplus  \textstyle\biguplus$"></td><td>\biguplus</td><td></td><td></td></tr></tbody></table><h2 id="古希腊字母"><a href="#古希腊字母" class="headerlink" title="古希腊字母"></a>古希腊字母</h2><p>小写</p><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/1/0/f/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="$\alpha$"></td><td>\alpha</td><td><img src="https://latex.artofproblemsolving.com/f/d/b/fdb63b9e51abe6bbb16acfb5d7b773ddbb5bf4a8.png" alt="$\beta$"></td><td>\beta</td><td><img src="https://latex.artofproblemsolving.com/6/6/9/66981fa3920210c6ad8dbe5e968783d5dd7520c3.png" alt="$\gamma$"></td><td>\gamma</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/e/a/f/eaf4418fbe935c15a606516d8f55dc380cd8e822.png" alt="$\epsilon$"></td><td>\epsilon</td><td><img src="https://latex.artofproblemsolving.com/e/2/a/e2a63918a6fa75b62ad87ad17aaf65f782d71546.png" alt="$\varepsilon$"></td><td>\varepsilon</td><td><img src="https://latex.artofproblemsolving.com/f/d/a/fda38f45a64bbd4451aedeeb4584e01d91239172.png" alt="$\zeta$"></td><td>\zeta</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/5/2/e/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="$\theta$"></td><td>\theta</td><td><img src="https://latex.artofproblemsolving.com/9/a/3/9a32e414f13071a85f52c90ce88e25332fd2152c.png" alt="$\vartheta$"></td><td>\vartheta</td><td><img src="https://latex.artofproblemsolving.com/e/3/9/e394d1efd05a00d1e561e3dfa8deb80488d8a1a5.png" alt="$\iota$"></td><td>\iota</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/c/e/4/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="$\lambda$"></td><td>\lambda</td><td><img src="https://latex.artofproblemsolving.com/2/d/8/2d8c833ed800824727cd7bd2fb9de1a12ad7e674.png" alt="$\mu$"></td><td>\mu</td><td><img src="https://latex.artofproblemsolving.com/d/6/a/d6a7ccf879c4a4fe694033606332cb83806db296.png" alt="$\nu$"></td><td>\nu</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/f/2/c/f2ca003a7da0de4994b4733e203b74ff52d42553.png" alt="$\pi$"></td><td>\pi</td><td><img src="https://latex.artofproblemsolving.com/0/8/b/08b37549addb92da83c1b842518c22328f331746.png" alt="$\varpi$"></td><td>\varpi</td><td><img src="https://latex.artofproblemsolving.com/0/0/2/0027034d8a10372a06deaf4f4084c01956587479.png" alt="$\rho$"></td><td>\rho</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/f/a/3/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="$\sigma$"></td><td>\sigma</td><td><img src="https://latex.artofproblemsolving.com/4/f/b/4fb382b5e56d61bc1669509bfc060c8deb1d71ef.png" alt="$\varsigma$"></td><td>\varsigma</td><td><img src="https://latex.artofproblemsolving.com/1/d/c/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="$\tau$"></td><td>\tau</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/2/c/1/2c175f60eecef1de7560c3bdea495d69f26f719d.png" alt="$\phi$"></td><td>\phi</td><td><img src="https://latex.artofproblemsolving.com/9/2/1/921aade3100afbc11d0d13f71cdd7e68d83ad52e.png" alt="$\varphi$"></td><td>\varphi</td><td><img src="https://latex.artofproblemsolving.com/6/d/c/6dcb9b88aaa5f14312835145edf06fb2d0823c29.png" alt="$\chi$"></td><td>\chi</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/5/4/d/54d7d48553f4d9e7ab418118607ea324cbfddfda.png" alt="$\omega$"></td><td>\omega</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>大写</p><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/9/1/3/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="$\Gamma$"></td><td>\Gamma</td><td><img src="https://latex.artofproblemsolving.com/0/a/7/0a737670d481129e2ead6d7223437f3cf70ea53f.png" alt="$\Delta$"></td><td>\Delta</td><td><img src="https://latex.artofproblemsolving.com/a/3/2/a321d1b883ba985b1f59ca076beaaf17aa8ab06c.png" alt="$\Theta$"></td><td>\Theta</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/d/0/9/d091cd93291a02d01c92bdc835e0b73f7faed864.png" alt="$\Xi$"></td><td>\Xi</td><td><img src="https://latex.artofproblemsolving.com/c/3/e/c3e77f8dac39bd44cff4ca15469c871bab27c02e.png" alt="$\Pi$"></td><td>\Pi</td><td><img src="https://latex.artofproblemsolving.com/c/8/f/c8f77e3035db5fe9a4975967750ac1a6454bda8c.png" alt="$\Sigma$"></td><td>\Sigma</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/b/8/5/b85bbfb165b853d6f5f9734be4cdabbb453f4e43.png" alt="$\Phi$"></td><td>\Phi</td><td><img src="https://latex.artofproblemsolving.com/8/6/6/866f0204648be9ca6b10e14dd72295295dd53a79.png" alt="$\Psi$"></td><td>\Psi</td><td><img src="https://latex.artofproblemsolving.com/9/e/2/9e2b196e9b7e57d1ec99f6534c581ea9759d2170.png" alt="$\Omega$"></td><td>\Omega</td></tr></tbody></table><h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/7/6/d/76d08618ef0d890aaf8294c65225e6314ef5be97.png" alt="$\gets$"></td><td>\gets</td><td><img src="https://latex.artofproblemsolving.com/b/8/e/b8ea4e52bb41fa9c0a1f8a387ea39b5b9c993b74.png" alt="$\to$"></td><td>\to</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/d/5/f/d5f9d8910bf9b877d37f48c842c045883c51300b.png" alt="$\leftarrow$"></td><td>\leftarrow</td><td><img src="https://latex.artofproblemsolving.com/d/7/7/d773375e7bd7f973b121cd9403ad90d3806d6996.png" alt="$\Leftarrow$"></td><td>\Leftarrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/e/1/2/e12b6767375342ed57d27678e3ea1cdb97f47e15.png" alt="$\rightarrow$"></td><td>\rightarrow</td><td><img src="https://latex.artofproblemsolving.com/8/4/3/843622567e12d686e4e2f94ddfcb444e8ecde0d2.png" alt="$\Rightarrow$"></td><td>\Rightarrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/d/4/5/d4563ad8c3bc2ead402d6ffc50768b0269bf073a.png" alt="$\leftrightarrow$"></td><td>\leftrightarrow</td><td><img src="https://latex.artofproblemsolving.com/a/6/e/a6ec0db174f3b705df19623976bf4b88ff502f3a.png" alt="$\Leftrightarrow$"></td><td>\Leftrightarrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/2/3/5/2353b98d531c2da713a987ce5f2c39c566b621c8.png" alt="$\mapsto$"></td><td>\mapsto</td><td><img src="https://latex.artofproblemsolving.com/d/5/7/d57eef1a90f496dda224bb28c705b4cd6f75f38f.png" alt="$\hookleftarrow$"></td><td>\hookleftarrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/b/3/9/b39c5d94ce0f366d4816ca9e22cdf213306167b4.png" alt="$\leftharpoonup$"></td><td>\leftharpoonup</td><td><img src="https://latex.artofproblemsolving.com/6/c/5/6c5a2cbfcd98ba58231d2cafa9ae6c4ef12fb125.png" alt="$\leftharpoondown$"></td><td>\leftharpoondown</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/f/9/5/f95723e1bf335f9d1cfc3aeba7f8c6dd45a8b6c4.png" alt="$\rightleftharpoons$"></td><td>\rightleftharpoons</td><td><img src="https://latex.artofproblemsolving.com/c/4/0/c405b7ae3c69d93bd1b753f1cd3b49251283bd0f.png" alt="$\longleftarrow$"></td><td>\longleftarrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/f/0/f/f0faeb12503890b80128f8ea8e99eab1ebb0d0b4.png" alt="$\Longleftarrow$"></td><td>\Longleftarrow</td><td><img src="https://latex.artofproblemsolving.com/3/d/6/3d6e222dc751bc632a3e4a0c1a87e7691ec86bba.png" alt="$\longrightarrow$"></td><td>\longrightarrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/9/8/1/981cc6a2adc50878a6da811d05c34e5cfaf6cef7.png" alt="$\Longrightarrow$"></td><td>\Longrightarrow</td><td><img src="https://latex.artofproblemsolving.com/5/b/9/5b925f6b5359af8f3536c2139177aaded2f93757.png" alt="$\longleftrightarrow$"></td><td>\longleftrightarrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/0/3/1/031f544836c18f6f1b3ce1fcab250a2e7b372203.png" alt="$\Longleftrightarrow$"></td><td>\Longleftrightarrow</td><td><img src="https://latex.artofproblemsolving.com/e/4/8/e48117c9370176c975b0cc0f3781ac51fdb420ea.png" alt="$\longmapsto$"></td><td>\longmapsto</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/2/3/c/23c35a20a0d1a302656aaf89da7921f4f58df625.png" alt="$\hookrightarrow$"></td><td>\hookrightarrow</td><td><img src="https://latex.artofproblemsolving.com/b/6/0/b602fa4b55dcf9f3437a9e8fd72152ac371b5bba.png" alt="$\rightharpoonup$"></td><td>\rightharpoonup</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/3/7/0/370fb1af83e5d67016f89663081f0f09eb7d296f.png" alt="$\rightharpoondown$"></td><td>\rightharpoondown</td><td><img src="https://latex.artofproblemsolving.com/5/f/b/5fbd98454ee144f57ef122f596384eaa5bf81fad.png" alt="$\leadsto$"></td><td>\leadsto</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/d/3/9/d39cad522ccbe5a31209793365754665a4d65556.png" alt="$\uparrow$"></td><td>\uparrow</td><td><img src="https://latex.artofproblemsolving.com/1/c/b/1cbe1a0d9a674d0d0bbc0c5572b8e609f9e64437.png" alt="$\Uparrow$"></td><td>\Uparrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/d/9/5/d95bdb4067e8005d19d15bfbd4e83d8980336c65.png" alt="$\downarrow$"></td><td>\downarrow</td><td><img src="https://latex.artofproblemsolving.com/c/d/9/cd90d68c14531a18fb1309c26d5cb62e9216da54.png" alt="$\Downarrow$"></td><td>\Downarrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/c/7/4/c749573a62fd745696f1159c7ba3a9c4ee2b9951.png" alt="$\updownarrow$"></td><td>\updownarrow</td><td><img src="https://latex.artofproblemsolving.com/3/e/d/3edded002dccdd7b08329a57491d4047c8306717.png" alt="$\Updownarrow$"></td><td>\Updownarrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/9/a/c/9ac7c661ed7237c252514b09cd4640d998e37511.png" alt="$\nearrow$"></td><td>\nearrow</td><td><img src="https://latex.artofproblemsolving.com/9/6/1/9619c49478e6be29b664a3b3edb8cf9b6fb9ec70.png" alt="$\searrow$"></td><td>\searrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/a/d/4/ad4d3d05f5a30dc16128c8477a1dc2ff4b259320.png" alt="$\swarrow$"></td><td>\swarrow</td><td><img src="https://latex.artofproblemsolving.com/e/3/9/e399241c1cd2d58d0a397fd94728a5d6f60022d0.png" alt="$\nwarrow$"></td><td>\nwarrow</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/a/8/d/a8dfbb08d2b4dac0825dded0c20a373dd129bd35.png" alt="$\overrightarrow{AB}$"></td><td>\overrightarrow{AB}</td><td><img src="https://latex.artofproblemsolving.com/8/a/0/8a0abef9be73c81cc0d02d1f1a0d4d99dc684fc5.png" alt="$\overleftarrow{AB}$"></td><td>\overleftarrow{AB}</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/8/8/2/8820cdb9ddec09011a25ab50173aa7cd580c8240.png" alt="$\overleftrightarrow{AB}$"></td><td>\overleftrightarrow{AB}</td><td></td><td></td></tr></tbody></table><h2 id="点"><a href="#点" class="headerlink" title="点"></a>点</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/8/f/1/8f1fb66751f2ee2626c75303485dba473c39a2f2.png" alt="$\cdot$"></td><td>\cdot</td><td><img src="https://latex.artofproblemsolving.com/6/9/c/69cdf7ec84ff918cbe7f21acf7543bf1bd243080.png" alt="$\vdots$"></td><td>\vdots</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/6/4/6/64683f315744c851898c8d65dace1a8aa31b93ab.png" alt="$\dots$"></td><td>\dots</td><td><img src="https://latex.artofproblemsolving.com/9/1/b/91bc8b7d1415c5dbd9a3c232b323bde68dd8199c.png" alt="$\ddots$"></td><td>\ddots</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/0/8/7/087594ea26fa196b8e61bc20a36228270dc695f8.png" alt="$\cdots$"></td><td>\cdots</td><td><img src="https://latex.artofproblemsolving.com/e/b/0/eb041173faa89f826c1e6e4a81194e2901ea334e.png" alt="$\iddots$"></td><td>\iddots</td></tr></tbody></table><h2 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/4/7/6/4766b2cc3bd23afdfaa7ab46ebb5f2d0e0fd8b80.png" alt="$\hat{x}$"></td><td>\hat{x}</td><td><img src="https://latex.artofproblemsolving.com/1/9/a/19a5ff1cef4a98be4cbf3fadacd8e1784fa82ce0.png" alt="$\check{x}$"></td><td>\check{x}</td><td><img src="https://latex.artofproblemsolving.com/f/c/a/fcafbe903244d22c4dcd94f46f57e617baf47ad1.png" alt="$\dot{x}$"></td><td>\dot{x}</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/1/7/c/17c5e14151dfe2f18740a32ba63870c7db167368.png" alt="$\breve{x}$"></td><td>\breve{x}</td><td><img src="https://latex.artofproblemsolving.com/a/3/a/a3aa851fec30dc95fc20220ce6e45fc4327d3ab0.png" alt="$\acute{x}$"></td><td>\acute{x}</td><td><img src="https://latex.artofproblemsolving.com/1/4/6/146440b27437438126da946e8e88924762c49b10.png" alt="$\ddot{x}$"></td><td>\ddot{x}</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/0/d/f/0df1054a87870c7611e7a9224a310ab4524bfca6.png" alt="$\grave{x}$"></td><td>\grave{x}</td><td><img src="https://latex.artofproblemsolving.com/c/2/7/c27ef249f820f799c441683c186b5b97b7f93833.png" alt="$\tilde{x}$"></td><td>\tilde{x}</td><td><img src="https://latex.artofproblemsolving.com/c/1/6/c166329f174b82bee3440f1c1473a74f52938572.png" alt="$\mathring{x}$"></td><td>\mathring{x}</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/f/0/6/f06e84fe84a6c63a9c2c392af11652f6e0d72cf4.png" alt="$\bar{x}$"></td><td>\bar{x}</td><td><img src="https://latex.artofproblemsolving.com/f/5/e/f5ec636e755349d4409f910e27d381c6da764230.png" alt="$\vec{x}$"></td><td>\vec{x}</td><td></td><td></td></tr></tbody></table><h2 id="其他符号"><a href="#其他符号" class="headerlink" title="其他符号"></a>其他符号</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/b/6/7/b671f1bb7e4ee86584347d5d22f1dc8abdb5bef2.png" alt="$\infty$"></td><td>\infty</td><td><img src="https://latex.artofproblemsolving.com/0/0/9/009cf3eeb0ff3789cc057632947cadb200ab4663.png" alt="$\triangle$"></td><td>\triangle</td><td><img src="https://latex.artofproblemsolving.com/4/4/b/44b090a5a288a97413c95d2550887b0d15989112.png" alt="$\angle$"></td><td>\angle</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/6/7/c/67c1fbfe4cf9dc91e7ba469a235b0bad54d6a5ab.png" alt="$\aleph$"></td><td>\aleph</td><td><img src="https://latex.artofproblemsolving.com/0/6/7/0678e85c9374aaebeb3099f934cb8a7e452c75da.png" alt="$\hbar$"></td><td>\hbar</td><td><img src="https://latex.artofproblemsolving.com/5/e/9/5e991343f163f34bab751574a500ee9ff3e759e4.png" alt="$\imath$"></td><td>\imath</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/0/0/2/002ca021db0654c4009563a2ce9a16636cfdc1ac.png" alt="$\jmath$"></td><td>\jmath</td><td><img src="https://latex.artofproblemsolving.com/6/3/c/63c17c295325f731666c7d74952b563a01e00fcc.png" alt="$\ell$"></td><td>\ell</td><td><img src="https://latex.artofproblemsolving.com/b/c/f/bcf1dd80910fd624e03574ad36bd73d8f79f65ad.png" alt="$\wp$"></td><td>\wp</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/1/2/e/12e3412ce1c7f9e9be5b98ec0dc7a513787fbbac.png" alt="$\Re$"></td><td>\Re</td><td><img src="https://latex.artofproblemsolving.com/b/1/6/b16edda9eb3f50e6bfcf5dc5fe307789444f321c.png" alt="$\Im$"></td><td>\Im</td><td><img src="https://latex.artofproblemsolving.com/9/c/f/9cfb316b7b1f6a9cf1e42272cd90a4c28bafa543.png" alt="$\mho$"></td><td>\mho</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/c/6/8/c68e6a060376d1105a2fda31e4c447d4a5d7aa66.png" alt="$\prime$"></td><td>\prime</td><td><img src="https://latex.artofproblemsolving.com/8/4/2/84241c448cbf497968ba86136beecf766431a3ff.png" alt="$\emptyset$"></td><td>\emptyset</td><td><img src="https://latex.artofproblemsolving.com/5/3/1/53196dddfbaf8145fd14be11cf568c5154588ed5.png" alt="$\nabla$"></td><td>\nabla</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/b/1/0/b10061a42e5fbda320e5ccef97d80f42166b05dc.png" alt="$\surd$"></td><td>\surd</td><td><img src="https://latex.artofproblemsolving.com/3/4/1/341d567d759ce5d4b0005bca4ce4a0a22c5f0f86.png" alt="$\partial$"></td><td>\partial</td><td><img src="https://latex.artofproblemsolving.com/9/8/9/98908d2f5a52e4be6e2e88e80b92993f42b36973.png" alt="$\top$"></td><td>\top</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/b/f/0/bf09b3494b43408e17d842ee8dcda1edc17cc649.png" alt="$\bot$"></td><td>\bot</td><td><img src="https://latex.artofproblemsolving.com/8/1/2/81226dce386555032afda7e4739639feabbc801a.png" alt="$\vdash$"></td><td>\vdash</td><td><img src="https://latex.artofproblemsolving.com/f/f/d/ffdb8a7364423bb7904d60840d7b7f9047dee450.png" alt="$\dashv$"></td><td>\dashv</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/5/3/6/536ba5a392431e74fec5a8db2257504c85fcc206.png" alt="$\forall$"></td><td>\forall</td><td><img src="https://latex.artofproblemsolving.com/4/e/c/4ecf8666cca5f1d089b9c656be83f9e09d0abd5c.png" alt="$\exists$"></td><td>\exists</td><td><img src="https://latex.artofproblemsolving.com/a/3/a/a3a70722f337e1529068359b303e4f0776ff68de.png" alt="$\neg$"></td><td>\neg</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/d/8/d/d8db7bfbb234b4f05ddfd93d031375cb02a799b4.png" alt="$\flat$"></td><td>\flat</td><td><img src="https://latex.artofproblemsolving.com/3/b/d/3bdea32d3d98eca872e1c4562eac7553ee6a4d34.png" alt="$\natural$"></td><td>\natural</td><td><img src="https://latex.artofproblemsolving.com/9/f/0/9f0f728ec995ff8379cf1a72c0ff1416a2c60177.png" alt="$\sharp$"></td><td>\sharp</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/3/8/5/385adced1eac31db28232371c6e5afb832d82bf7.png" alt="$\backslash$"></td><td>\backslash</td><td><img src="https://latex.artofproblemsolving.com/c/1/2/c12dda010ebddef028cda1ec9d14986f4a26d07e.png" alt="$\Box$"></td><td>\Box</td><td><img src="https://latex.artofproblemsolving.com/7/6/e/76edde10cd8ffa25ad5bf5689c032fdf78aeef28.png" alt="$\Diamond$"></td><td>\Diamond</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/3/9/7/397606372567ab31725033a4d12d00c0276ba086.png" alt="$\clubsuit$"></td><td>\clubsuit</td><td><img src="https://latex.artofproblemsolving.com/c/6/d/c6dda9b4c504bad80fd4308d62fb52fb41f3aefc.png" alt="$\diamondsuit$"></td><td>\diamondsuit</td><td><img src="https://latex.artofproblemsolving.com/3/8/c/38c6b4ac9e30aa1bbcdf4529130bc58e4b392e83.png" alt="$\heartsuit$"></td><td>\heartsuit</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/f/1/0/f10b174b6672f53772ffe28260f4390a3cd405fa.png" alt="$\spadesuit$"></td><td>\spadesuit</td><td><img src="https://latex.artofproblemsolving.com/4/0/2/40268aa589c2ba619a6d521d716bf781a15e4ba8.png" alt="$\Join$"></td><td>\Join</td><td><img src="https://latex.artofproblemsolving.com/3/b/b/3bbb9e25e5be095e317771a9c5d00877ee9c8012.png" alt="$\blacksquare$"></td><td>\blacksquare</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/c/6/d/c6dda9b4c504bad80fd4308d62fb52fb41f3aefc.png" alt="$\diamondsuit$"></td><td>\diamondsuit</td><td><img src="https://latex.artofproblemsolving.com/d/b/d/dbde8771334ba4faa03348ac847c8a22c6a54667.png" alt="$\copyright$"></td><td>\copyright</td><td><img src="https://latex.artofproblemsolving.com/8/3/2/83259bd181bf4d79689381cabcdc71eafbf9baff.png" alt="$\underarc{XYZ}$"></td><td>\underarc{XYZ}</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/3/8/c/38c6b4ac9e30aa1bbcdf4529130bc58e4b392e83.png" alt="$\heartsuit$"></td><td>\heartsuit</td><td><img src="https://latex.artofproblemsolving.com/f/4/8/f482b34d198de478979b7c60c9bf1c8668dd5aa8.png" alt="$\overarc{ABC}$"></td><td>\overarc{ABC}</td><td><img src="https://latex.artofproblemsolving.com/a/6/c/a6cef8fd2bc2c7f9f1e27327b739f2cd7baa31ac.png" alt="$\cup$"></td><td>\cup</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/4/e/0/4e0058658154f5e64eebcb3d40abab723ee34e30.png" alt="$\S$"></td><td>\S</td><td><img src="https://latex.artofproblemsolving.com/a/4/0/a4029f0a93f99c97102b9f06ee47f4a56847bfbf.png" alt="$\P$"></td><td>\P</td><td><img src="https://latex.artofproblemsolving.com/3/2/f/32fc4e30bd315982f54d13b5950a592032632df4.png" alt="$\Vdash$"></td><td>\Vdash</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/7/2/f/72f6e08a2df0af40956a32686a1340a14d9fb98e.png" alt="$\pounds$"></td><td>\pounds</td><td><img src="https://latex.artofproblemsolving.com/1/3/4/134004c561e4c0cca193dbf5122e5ca963dd5b7f.png" alt="$\in$"></td><td>\in</td><td><img src="https://latex.artofproblemsolving.com/7/3/8/7387d7454e276c5802d261da5fc7bb08debcd544.png" alt="$\vDash$"></td><td>\vDash</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/4/3/0/4302e3b4e7057984ac3eb2e9018a9b64002550b8.png" alt="$\bigstar$"></td><td>\bigstar</td><td><img src="https://latex.artofproblemsolving.com/e/f/4/ef48ac956824fcaea163a530a717e6df694aa006.png" alt="$\implies$"></td><td>\implies</td><td></td><td></td></tr><tr><td><img src="https://latex.artofproblemsolving.com/b/6/c/b6cf65b1f2fbdf388e3daeff9b96b34d3399d777.png" alt="$\square$"></td><td>\square</td><td></td><td></td><td></td><td></td></tr><tr><td><img src="https://latex.artofproblemsolving.com/5/4/1/541e9aef85db57b7dbef677e59a04d09b2e8b58a.png" alt="$\smiley$"></td><td>\smiley</td><td></td><td></td><td></td><td></td></tr><tr><td><img src="https://latex.artofproblemsolving.com/9/0/6/906fddead65545297c74bbc2ca83cd01f3f9ecc9.png" alt="$\mathbb{R}$"></td><td>\mathbb{R} (represents all real numbers)</td><td></td><td></td><td></td><td></td></tr><tr><td><img src="https://latex.artofproblemsolving.com/6/0/e/60ed020e037834e10ccbcc412e3386653ec9e847.png" alt="$\checkmark$"></td><td>\checkmark</td><td></td><td></td><td></td><td></td></tr><tr><td><img src="https://latex.artofproblemsolving.com/9/8/9/98943cb2d464a45e72c3a3376e74814399699cb3.png" alt="$\cancer$"></td><td>\cancer</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="命令符"><a href="#命令符" class="headerlink" title="命令符"></a>命令符</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/3/4/7/347d5d8ccef965291225560dfe843b447c59955e.png" alt="$\textdollar$"></td><td>\textdollar or $</td><td><img src="https://latex.artofproblemsolving.com/e/9/d/e9d9da5bde70fea3385da94b7d04efa5b3f963ca.png" alt="$\&amp;$"></td><td>&amp;</td><td><img src="https://latex.artofproblemsolving.com/c/4/3/c4393de50075e05c3363369d39412b341e39cc7d.png" alt="$\%$"></td><td>%</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/0/c/c/0ccb3853aade8501b9dcca60bfbdbb8d9a598aa8.png" alt="$\_$"></td><td>_</td><td><img src="https://latex.artofproblemsolving.com/4/a/1/4a1a0fbdb39b7129d2fc98698c68ff5533405755.png" alt="$\{$"></td><td>{</td><td><img src="https://latex.artofproblemsolving.com/6/5/e/65e2585c1b1cd632b41a41481fd2ad44456aeec4.png" alt="$\}$"></td><td>}</td></tr></tbody></table><h2 id="欧洲符号"><a href="#欧洲符号" class="headerlink" title="欧洲符号"></a>欧洲符号</h2><table><thead><tr><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th><th>Symbol</th><th>Command</th></tr></thead><tbody><tr><td><img src="https://latex.artofproblemsolving.com/3/8/e/38e06a1df4e81b48091aa311d9c0f5cba9432256.png" alt="${\oe}$"></td><td>{\oe}</td><td><img src="https://latex.artofproblemsolving.com/4/5/0/4509653d8d7b806fe06a94dbde93e872f40892ba.png" alt="${\ae}$"></td><td>{\ae}</td><td><img src="https://latex.artofproblemsolving.com/0/6/9/0693f302e79847db7dc8cbe2baf0ab2c7dea2ee3.png" alt="${\o}$"></td><td>{\o}</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/2/d/9/2d90a26f53f0bffc49df20cca0623b183c9b013f.png" alt="${\OE}$"></td><td>{\OE}</td><td><img src="https://latex.artofproblemsolving.com/a/8/4/a84a715a1e45bd844d83b49e076ee5e306a7413a.png" alt="${\AE}$"></td><td>{\AE}</td><td><img src="https://latex.artofproblemsolving.com/d/8/8/d8804db9d6d9d9c54c9dcbbee11d300073f7e471.png" alt="${\AA}$"></td><td>{\AA}</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/8/e/a/8ea86382077c0260f1743eb0b3555370aaa89be0.png" alt="${\l}$"></td><td>{\l}</td><td><img src="https://latex.artofproblemsolving.com/b/a/4/ba40dd86e8e6766c5417744046f0aed2feeb4c6b.png" alt="${\ss}$"></td><td>{\ss}</td><td>![$\text{!&#96;}$](<a href="https://latex.artofproblemsolving.com/0/b/3/0b3e889945a6c124ae6b86f0e764a6741643cec2.png">https://latex.artofproblemsolving.com/0/b/3/0b3e889945a6c124ae6b86f0e764a6741643cec2.png</a>)</td><td>!&#96;</td></tr><tr><td><img src="https://latex.artofproblemsolving.com/3/d/9/3d929efdcf5e4cc9ed64c2e7980dccf4d50d5c24.png" alt="${\L}$"></td><td>{\L}</td><td><img src="https://latex.artofproblemsolving.com/3/3/3/3337194236d3707955d2524f98d806a931b881e9.png" alt="${\SS}$"></td><td>{\SS}</td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">学习使用Latex数学符号相关使用功能</summary>
    
    
    
    <category term="软件学习" scheme="https://zhangyuanhe.top/categories/%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="程序安装" scheme="https://zhangyuanhe.top/tags/%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85/"/>
    
    <category term="软件学习" scheme="https://zhangyuanhe.top/tags/%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Windows下安装Docker</title>
    <link href="https://zhangyuanhe.top/2023/09/14/Software%20and%20App/Windows_docker/"/>
    <id>https://zhangyuanhe.top/2023/09/14/Software%20and%20App/Windows_docker/</id>
    <published>2023-09-14T01:00:00.000Z</published>
    <updated>2023-09-19T15:51:35.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><h2 id="安装WSL2"><a href="#安装WSL2" class="headerlink" title="安装WSL2"></a>安装WSL2</h2><blockquote><p>WSL，即Windows Subsystem on Linux，中文叫“适用于 Linux 的 Windows 子系统”。可以在windows里，直接启动一个linux系统。因为docker依赖linux内核，只能在linux下使用，windows就需要安装linux虚拟机来运行，而微软已经在win10内置了一个轻量级虚拟机，WSL2 便是运行在虚拟机上的一个完整的 linux 内核，所以需要利用WSL2安装docker。</p></blockquote><p>微软要求 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11 </p><p>设置-&gt;更新和安全-&gt;操作系统内部版本信息</p><p>下载wsl2需要的linux内核：</p><blockquote><p>网址： [<a href="https://docs.microsoft.com/zh-cn/windows/wsl/wsl2-kernel]">https://docs.microsoft.com/zh-cn/windows/wsl/wsl2-kernel]</a>(<a href="https://blog.csdn.net/m0_68988603/article/details/123884239?ops_request_misc=%7B%22request_id%22:%22169422368816800226549539%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169422368816800226549539&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123884239-null-null.142%5Ev93%5EchatsearchT3_2&utm_term=docker">https://blog.csdn.net/m0_68988603/article/details/123884239?ops_request_misc={&quot;request_id&quot;%3A&quot;169422368816800226549539&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334..&quot;}&amp;request_id=169422368816800226549539&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123884239-null-null.142^v93^chatsearchT3_2&amp;utm_term=docker</a> Windows&amp;spm&#x3D;1018.2226.3001.4187)</p><p>点击下载最新的更新包，下好后双击运行安装即可。</p></blockquote><p>打开系统虚拟机平台和WSL</p><p>控制面板-&gt;程序-&gt;启用或关闭Windows功能-&gt;</p><p>勾选 适用于Linux的Windows子系统</p><p>勾选 虚拟机平台</p><p>将WSL2设置为默认版本：管理员身份运行Windows PowerShell，运行下面的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/image-20230914170116226.png" alt="image-20230914170116226"></p><h2 id="安装Docker-Desktop-for-Windows"><a href="#安装Docker-Desktop-for-Windows" class="headerlink" title="安装Docker Desktop for Windows"></a>安装Docker Desktop for Windows</h2><p>网上有的教程是先在WSL2里面安装了linux，然后再装docker。我暂时还没有很多实际使用需求，所以我认为应该直接安装windows版就可以了。</p><p>官网下载安装程序：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a></p><p> 下好后直接双击运行安装即可（建议安装时不要使用校园网，不然有可能会出现一些问题，我放在后面解释）。</p><p>设置里勾选基于wsl2的引擎（我的默认勾选了）</p><p>用PowerShell运行 <code>wsl -l -v</code>会发现已经创建了两个发行版了</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/image-20230914171039958.png" alt="image-20230914171039958"></p><h2 id="更改数据存储位置"><a href="#更改数据存储位置" class="headerlink" title="更改数据存储位置"></a>更改数据存储位置</h2><blockquote><p>Windows下的docker默认安装在C盘，所以为了拯救我们可怜的C盘，就需要把数据存储到其他盘。</p></blockquote><h3 id="1-停止docker服务"><a href="#1-停止docker服务" class="headerlink" title="1.停止docker服务"></a>1.停止docker服务</h3><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/image-20230914171749005.png" alt="image-20230914171749005"></p><h3 id="2-备份数据到另一个文件夹"><a href="#2-备份数据到另一个文件夹" class="headerlink" title="2.备份数据到另一个文件夹"></a>2.备份数据到另一个文件夹</h3><p>PowerShell运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export docker-desktop-data &quot;D:\work\study\BUPT\computer\DockerData\docker-desktop-data.tar&quot;</span><br></pre></td></tr></table></figure><h3 id="3-删除原有数据"><a href="#3-删除原有数据" class="headerlink" title="3.删除原有数据"></a>3.删除原有数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister docker-desktop-data</span><br></pre></td></tr></table></figure><h3 id="4-更改数据存储盘并恢复数据"><a href="#4-更改数据存储盘并恢复数据" class="headerlink" title="4.更改数据存储盘并恢复数据"></a>4.更改数据存储盘并恢复数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import docker-desktop-data &quot;D:\work\study\BUPT\computer\DockerData&quot; &quot;D:\work\study\BUPT\computer\DockerData\docker-desktop-data.tar&quot; --version 2</span><br></pre></td></tr></table></figure><p>即将备份数据导入到新的虚拟盘，且指定虚拟盘的存放路径为E:\DockerData，导入完成后在该目录下会存在一个ext4.vhdx的虚拟磁盘路径</p><p>然后启动docker就可以啦</p><h1 id="实验环境配置"><a href="#实验环境配置" class="headerlink" title="实验环境配置"></a><strong>实验环境配置</strong></h1><p>安装docker后，由于国内从官方的dockerHub拉取镜像速度较慢，可以利用国内的镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://1nj0zren.mirror.aliyuncs.com&quot;,</span><br><span class="line">    &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">    &quot;http://f1361db2.m.daocloud.io&quot;,</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;insecure-registries&quot;: [],</span><br><span class="line">  &quot;debug&quot;: true,</span><br><span class="line">  &quot;experimental&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在本机创建一个文件夹专门存放<code>lab</code>及<code>project</code>，路径中不要包含中文</li><li>编辑<code>./docker_script/docker-compose.yml</code>，将替换为第一步中的路径 注意：如假设路径为</li></ol><p><code>E:\buptcompiler</code>，替换的路径应为 <code>/e/buptcompiler</code></p><ol start="3"><li><p>创建<code>image</code>并部署<code>container：</code>进入<code>docker_script</code>目录下，CMD运行 <code>docker-compose up -d</code></p></li><li><p><code>docker desktop</code>中启动部署好的<code>container</code>，该<code>container</code>应该是<code>docker_script</code>下的<code>compiler</code></p></li><li><p>执行<code>container：</code>在CMD运行 <code>docker exec -it compiler /bin/sh</code></p></li><li><p><code>compiler</code>中的<code>/mnt/Workspace</code>即为挂载的共享目录（主机上为<code>E:\buptcompiler</code>）</p></li><li><p><code>lab</code>和<code>project</code>作业下载后放到主机的共享目录中，推荐使用<code>VSCode</code>编写，然后在<code>compiler</code>中编译、运行测试</p></li><li><p>部署好实验环境后，再次进行实验时执行第4、5步即可运行容器，进入实验环境，第5步中不一定在CMD运行命令，可以利用VSCode的终端运行命令。</p></li></ol>]]></content>
    
    
    <summary type="html">Windows下安装Docker详细过程及问题解决</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="网络安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="程序安装" scheme="https://zhangyuanhe.top/tags/%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85/"/>
    
    <category term="软件学习" scheme="https://zhangyuanhe.top/tags/%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>系统快速重装部署网站</title>
    <link href="https://zhangyuanhe.top/2023/08/21/Information_Security_Experiment/network_attack/NA2/"/>
    <id>https://zhangyuanhe.top/2023/08/21/Information_Security_Experiment/network_attack/NA2/</id>
    <published>2023-08-21T04:00:00.000Z</published>
    <updated>2023-08-21T08:32:42.142Z</updated>
    
    <content type="html"><![CDATA[<p>重装系统后：</p><h1 id="开始配置："><a href="#开始配置：" class="headerlink" title="开始配置："></a><strong>开始配置：</strong></h1><ol><li><p>安装依赖库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel </span><br></pre></td></tr></table></figure></li><li><p>安装编译工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel </span><br></pre></td></tr></table></figure></li><li><p>检查是否已安装Git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure><p>返回的结果<code>git version 1.8.3.1</code>即可</p></li><li><p>配置Git环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;export PATH=$PATH:/usr/local/git/bin&#x27; &gt;&gt; /etc/bashrc</span><br></pre></td></tr></table></figure></li><li><p>刷新环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/bashrc</span><br></pre></td></tr></table></figure></li><li><p>创建Git用户并修改权限</p><p>创建后期上传hexo的git指定用户，这里以hyh为例(这个用户名可以自定义，但是要保证后面的需要用户名的地方需要改成自己自定义的用户名即可)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adduser zyh</span><br><span class="line">passwd zyh</span><br></pre></td></tr></table></figure><p>需要注意的便是在设置密码时，设置密码时是没有回显的</p><p>赋予zyh用户相关权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 740 /etc/sudoers   # 设置权限</span><br><span class="line">vim /etc/sudoers # 编辑/etc/sudoers</span><br></pre></td></tr></table></figure><p>使用 set: nu 显示行号，找到100行左右，添加如下信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL)  ALL</span><br><span class="line">zyh  ALL=(ALL)   ALL  #主要添加这句话（这里zyh是你刚才创建的用户名）</span><br></pre></td></tr></table></figure><p>直接:<code>wq!</code>，进行保存，保存后再次修改权限。因为 <code>sudoers</code>是只读文件，所有要使用 <code>!</code>进行保存，否则会失败。</p><p>将&#x2F;etc&#x2F;sudoers 修改成只读类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 /etc/sudoers   //改回权限</span><br></pre></td></tr></table></figure><p>创建hexo文件夹及赋予文件夹权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/hexo  #这个也是自定义的</span><br><span class="line">chown hyh:hyh -R /home/hexo #授予权限</span><br></pre></td></tr></table></figure><p>安装Nginx<br>这里基本没啥好说的，直接运行就可以，然后看到最后一行显示Complete就说明完事了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx  </span><br></pre></td></tr></table></figure><p>这个时候我们可以通过以下命令，启动一下，看看效果，如果没有报错的话就ok</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure><p>配置Nginx文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>在38行进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">listen 80 default_server; </span><br><span class="line">listen [::]:80 default_server; </span><br><span class="line">server_name zhangyuanhe.top; #域名 </span><br><span class="line">root /home/hexo; #网站目录</span><br></pre></td></tr></table></figure><p>保存退出后，重启服务器，<br>修改完配置以后，需要重启一下Nginx服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload nginx.service  </span><br></pre></td></tr></table></figure></li></ol><p>建立git仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/zyh</span><br><span class="line">git init --bare zyh.git</span><br><span class="line">chown zyh:zyh -R zyh.git</span><br></pre></td></tr></table></figure><p>同步网站根目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim zyh.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>向其中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">git --work-tree=/home/hexo --git-dir=/home/zyh/zyh.git checkout -f</span><br></pre></td></tr></table></figure><p>修改权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /home/zyh/zyh.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>在Windows10本地Hexo目录修改_config.yml文件（一般已经修改）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: zyh@62.234.219.169:/home/zyh/zyh.git    #用户名@服务器Ip:git仓库位置</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>然后就可以通过以下命令进行推送了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo -d</span><br></pre></td></tr></table></figure><p><strong>这时候应该可以用http访问了</strong></p><h1 id="部署ssl证书："><a href="#部署ssl证书：" class="headerlink" title="部署ssl证书："></a>部署ssl证书：</h1><h2 id="云服务器安装FTP服务"><a href="#云服务器安装FTP服务" class="headerlink" title="云服务器安装FTP服务"></a>云服务器安装FTP服务</h2><ol><li><p>安装vsftpd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y vsftpd</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure><p>修改第12行，禁止匿名用户登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=No </span><br></pre></td></tr></table></figure></li></ol><h2 id="部署证书"><a href="#部署证书" class="headerlink" title="部署证书"></a>部署证书</h2><ol><li><p>文件默认上传至我们的用户文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/zyh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangyuanhe.top.zip  zhangyuanhe.git</span><br></pre></td></tr></table></figure></li><li><p>解压缩文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangyuanhe.top.zip</span><br></pre></td></tr></table></figure><p>再ls查看目录返回的结果是：</p><p><img src="D:\my_data\blog\zyhblog-img\image-20230729112613573-1692606705013-4.png" alt="image-20230729112613573"></p><p>可以看见有四个文件，这里只需要crt文件和key文件。</p></li><li><p>将Nginx文件夹下的文件复制到新建的文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/nginx/ssl/</span><br><span class="line">cd /home/zhangyuanhe/Nginx</span><br></pre></td></tr></table></figure><p>用ls查看目录返回结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangyuanhe.top_bundle.crt  zhangyuanhe.top.key</span><br></pre></td></tr></table></figure><p>复制到ssl文件夹下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp zhangyuanhe.top_bundle.crt /etc/nginx/ssl/</span><br><span class="line">cp zhangyuanhe.top.key /etc/nginx/ssl/</span><br></pre></td></tr></table></figure></li><li><p>打开nginx.conf 文件夹 修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>删除掉下方最前面注释并进行更改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> server &#123;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        listen       [::]:443 ssl http2 default_server;</span><br><span class="line">        server_name  liuruibin.com; #域名</span><br><span class="line">        root         /home/hexo;    #网站主目录</span><br><span class="line"></span><br><span class="line">        ssl_certificate &quot;/etc/nginx/ssl/zhangyuanhe.top_bundle.crt&quot;; #crt文件路径</span><br><span class="line">        ssl_certificate_key &quot;/etc/nginx/ssl/zhangyuanhe.top.key&quot;;    #key文件路径</span><br><span class="line">        ssl_session_cache shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  10m;</span><br><span class="line">        ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line">        </span><br><span class="line">   #默认请求</span><br><span class="line">        location / &#123;</span><br><span class="line">                root /home/hexo;</span><br><span class="line">  #定义首页索引文件名称</span><br><span class="line">                index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看是否有报错，无报错重启服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">重装网站流程，快速恢复使用</summary>
    
    
    
    <category term="安全实验" scheme="https://zhangyuanhe.top/categories/%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="网络安全实验" scheme="https://zhangyuanhe.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>一次失败的木马攻击防御————系统快速重装部署网站</title>
    <link href="https://zhangyuanhe.top/2023/08/21/Information_Security_Experiment/network_attack/NA1/"/>
    <id>https://zhangyuanhe.top/2023/08/21/Information_Security_Experiment/network_attack/NA1/</id>
    <published>2023-08-21T01:00:00.000Z</published>
    <updated>2023-08-21T08:32:35.845Z</updated>
    
    <content type="html"><![CDATA[<p>前两天收到信息，服务器疑似被人异地登录并植入病毒</p><p>上去一看cpu占用100%，估计是被人挖矿了</p><p>啥也不懂，上网查解决办法</p><p><a href="https://zhuanlan.zhihu.com/p/401296641">了解这几步，教你处理Linux挖矿木马 - 知乎 (zhihu.com)</a></p><p>使用top查看情况，可以看见zyh用户占用大量资源，这是我之前创建上传博客资源的用户</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/image-20230820230030521.png" alt="image-20230820230030521"></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/image-20230820230112690.png" alt="image-20230820230112690"></p><p>根据腾讯云的反馈信息看到了这样一个文件夹。其中DOTA3就是木马的压缩文件</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/image-20230820230633801.png" alt="image-20230820230633801"></p><p>在<code>.rsync</code>中还有<code>a</code> <code>b</code> <code>c</code> 三个文件夹，疑似是木马的三个操作，可以盗用我的系统账户和启用攻击程序</p><p>在<code>b</code>中的<code>run</code>程序里是64位编码格式的代码</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/image-20230820230714421.png" alt="image-20230820230714421"></p><p>具体代码没太看明白，最后在tmp文件夹下找到了这个文本，里面存放的是入侵者爆破出来我的用户和密码</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/image-20230820230650948.png" alt="image-20230820230650948"></p><p>根据网上的说明尝试删除木马文件，但还需要删除zyh这个用户和用户信息。</p><p>由于我的博客都依赖于这个用户，所以想着直接删除木马后改密码，但尝试失败，网站信息页打不开了。</p><p>最后还是用最原始的重装解决问题吧，以后再遇到在尝试别的方法。</p>]]></content>
    
    
    <summary type="html">网站遭受木马攻击，并实现一种效率低下的解决办法</summary>
    
    
    
    <category term="安全实验" scheme="https://zhangyuanhe.top/categories/%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="网络安全实验" scheme="https://zhangyuanhe.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>二进制编辑修改</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL1/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL1/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:16.883Z</updated>
    
    <content type="html"><![CDATA[<ol><li>第一次打开exe文件发现乱码，是因为编辑语言错误。</li><li>打开控制面板，调节语言。</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps1-1691139848774-2.jpg" alt="img"> </p><ol start="3"><li>可以正常打开源文件</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps2-1691139848773-1.jpg" alt="img"> </p><ol start="4"><li>使用010Editir另存源文件</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps3-1691139848774-5.jpg" alt="img"> </p><ol start="5"><li>找到要修改的位置</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps4-1691139848774-3.jpg" alt="img"> </p><ol start="6"><li>找到更改代码</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps5-1691139848774-4.jpg" alt="img"> </p><ol start="7"><li>完成修改</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps6-1691139848774-6.jpg" alt="img"> </p><ol start="8"><li>保存后运行程序，实验成功</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps7-1691139848774-7.jpg" alt="img"> </p>]]></content>
    
    
    <summary type="html">对exe程序文件进行二进制修改，从而改变原文内容</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>MD5加密程序解flag</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL2/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL2/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:27.112Z</updated>
    
    <content type="html"><![CDATA[<p>****问题-1：****找到开头“This program cannot be run …” 这个字符串的内存起始地址（即字符串的指针），并准确计算该字符串的长度；</p><p>1.运行程序寻找字符串位置</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps8-1691140040878-1.jpg" alt="img"> </p><ol start="2"><li>打开IDA寻找字符串</li></ol><p>发现无法找到目标字符串<br><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps9-1691140040878-2.jpg" alt="img"><br>3.通过for fun找到主函数，查看伪代码。</p><p>分析得知各功能实现应%S所实现的内容。</p><p>从而定位其地址<em><strong>*0x40004E*</strong></em></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps10-1691140040878-4.jpg" alt="img"> </p><p>4.将程序放入010Editor找到相应位置，然后数字节。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps11-1691140040878-3.jpg" alt="img"> </p><p>共计****44****个字节</p><p>****问题-2：****需要结合具体的加密操作逻辑，说明所发现的加密算法。</p><ol><li>由第一个子函数可知，输入的字符串长度有固定要求。</li></ol><p>输入内容被保存在byte_407444。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps12-1691140040878-6.jpg" alt="img"> </p><p>且长度必须为9.</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps13-1691140040878-5.jpg" alt="img"> </p><p>2.打开第二个子函数，可以看见其中并无加密转码操作，还是在确认输入内容的范围。</p><p>3.在第三个函数</p><p>首先在18行有一次混淆交换</p><p>随后有sub_40210C(Str1, (int)byte_407444, 5)说明进行了另一种交换</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps14-1691140040878-7.jpg" alt="img"> </p><p>进入发现是将byte_407444的前五个字符进行MD5加密。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps15-1691140040879-9.jpg" alt="img"> </p><p>随后密文Str1与Str2进行比较</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps16-1691140040879-13.jpg" alt="img"> </p><p>4.根据以上推断，可知flag经过一次加密后，前五位经MD5加密后与Str2进行比较，后四位直接进行比较。</p><p>根据MD5要求写出脚本</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps17-1691140040879-10.jpg" alt="img"> </p><p>得到密文为<em><strong>*K502G32Z2*</strong></em></p><p>5.在解密第一层加密方法，这是一个类仿射加密</p><p>范思宇：通过dbg按顺序尝试各个字符的对应关系，从而一一对照找到原flag。</p><p>例如输入123456789，就可得知对应密文为0BEHKNQTW。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps18-1691140040878-8.jpg" alt="img"> </p><p>依次类推，可以推出原文为<em><strong>*5M1LE_L0L*</strong></em></p><p>张原赫：找到初次转码后密文的储存位置</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps19-1691140040879-14.jpg" alt="img"> </p><p>更改存储内容继续运行</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps20-1691140040879-12.jpg" alt="img"> </p><p>得到结果。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps21-1691140040879-11.jpg" alt="img"> </p><p>不足：该方法可以得到结果但是无法拿到flag。</p><p>所以使用脚本进行转换</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps22-1691140040879-15.jpg" alt="img"> </p><p>得到flag。</p>]]></content>
    
    
    <summary type="html">对MD5加密的exe文件进行解密</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>花指令及加密算法程序解flag</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL3/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL3/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:31.804Z</updated>
    
    <content type="html"><![CDATA[<p><strong>实验过程：</strong></p><p>这里0040105E指向转跳到401060+1，而401060又有转跳指令，说明这里指令存在错误，有花指令。并且是<em><strong>*jmp型花指令*</strong></em></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps23-1691140202258-5.jpg" alt="img"> </p><p>更改401060的前两个字符为90。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps24-1691140202258-1.jpg" alt="img"> </p><p>改完后可以按空格查看流程图。说明更改正确。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps25-1691140202258-4.jpg" alt="img"> </p><p>流程图中这里有一个add的单独指令，怀疑存在问题</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps26-1691140202258-2.jpg" alt="img"> </p><p>检查原指令栈情况，发现后续栈有问题</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps27-1691140202258-3.jpg" alt="img"> </p><p>将add esp，30 h  Nop掉</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps28-1691140202258-6.jpg" alt="img"> </p><p>在这里可以看出来将buffer数组每一位都异或1Dh(加密)</p><p>加密后将将command也就是下一层加密代码的地址压入栈</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps29-1691140202258-10.jpg" alt="img"> </p><p>编辑解密脚本</p><p>#include &lt;idc.idc&gt;</p><p>static xor_setp1(){</p><p>  auto addr &#x3D; 0x00403054;  &#x2F;&#x2F;这里填入要解密字节串的起始地址</p><p>  auto i &#x3D; 0;</p><p>  for(i&#x3D;0;addr+i&lt;0x004030DF;i++)  &#x2F;&#x2F;循环结束的条件为字节串的结束地址</p><p>  {</p><p>​    PatchByte(addr+i,Byte(addr+i)^0x1D);  &#x2F;&#x2F;异或的数字根据情况修改</p><p>  }</p><p>}</p><p>static main()</p><p>{</p><p>​xor_setp1();</p><p>}</p><p>进行解密</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps30-1691140202258-7.jpg" alt="img"> </p><p>按快捷键C将字符串转换为汇编语言</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps31-1691140202258-9.jpg" alt="img"> </p><p>保存成新文件后打开，寻找加密模块</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps32-1691140202259-12.jpg" alt="img"> </p><p>其中a1为输入字符串。</p><p>If语句中解出第三位为a，四、七位为i，第八位为n，十一位为o</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps33-1691140202258-8.jpg" alt="img"> </p><p>while函数进行判断</p><p>“,VEJ”和a2^a1[x]做比对</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps34-1691140202259-11.jpg" alt="img"> </p><p>找到a2内容</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps35-1691140202259-14.jpg" alt="img"><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps36-1691140202259-15.jpg" alt="img"> </p><p>追踪到a2就是1D，解出密钥a1[0]&#x3D;1 a1[2]&#x3D;K a1[6]&#x3D;X a1[10]&#x3D;W</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps37-1691140202259-13.jpg" alt="img"> </p><p>在main函数中找到一个异常处理</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps38-1691140202259-17.jpg" alt="img"> </p><p>在except中可以看到转跳函数</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps39-1691140202259-16.jpg" alt="img"> </p><p>因此需要触发异常</p><p>异常为除零异常，当输入为12位时触发</p><p>进入异常后F5查看伪代码</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps40-1691140202259-18.jpg" alt="img"> </p><p>得知byte_4031D5是输入的一部分</p><p>要求输入第二位、第六位、第十位为“_”</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps41-1691140202259-19.jpg" alt="img"> </p><p>byte_4031E1 &#x3D; ‘_’+‘_’+‘_’&#x3D;1D（取低两位）</p><p>这也是之前用1D异或的原因</p><p>解得输入应为1_Kai_Xin_Wo</p><p><em><strong>*问题-1*</strong></em><em><strong>*：程序中一共有2处花指令干扰，分别是哪一种类型的花指令？*</strong></em></p><p><em><strong>*– 提示：结合动态调试，查看出现异常处的实际执行流程&#x2F;跳转情况；判断是不是为”永恒跳转“*</strong></em></p><p>第一处是jmp型花指令</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps42-1691140202259-20.jpg" alt="img">第二处是栈干扰指令</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps43-1691140202259-24.jpg" alt="img"> </p><p><em><strong>*问题-2*</strong></em><em><strong>*：程序中一共有两处异常处理，分别是哪一种？*</strong></em></p><p><em><strong>*– 提示：x32dbg 动态调试除零异常时，可通过在寄存器窗口修改除数对应的寄存器的值为0，来无条件触发*</strong></em></p><p><em><strong>*– 提示：注意审视对 SEH 的潜在 “惯性思维”，认为 它一定是“除零”，以及程序核心功能就一定藏 exception 处理里*</strong></em></p><p>第一处是除零异常</p><p>可以再try块中看到特征idiv语句</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps44-1691140202259-21.jpg" alt="img"> </p><p>第二处是判断输入异常</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps45-1691140202259-22.jpg" alt="img"> </p><p><em><strong>*问题-3*</strong></em><em><strong>*：程序使用了何种加密算法？在程序中总共使用了几次？各自用于实现什么目的？*</strong></em></p><p>使用了异或加密</p><ol><li>在主函数中对buffer加密</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps46-1691140202259-23.jpg" alt="img"> </p><p>实现对反编译的干扰，无法直接读取汇编代码内容</p><ol start="2"><li>在处理输入flag时进行加密</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps47-1691140202259-25.jpg" alt="img"> </p><p><em><strong>*问题-4*</strong></em><em><strong>*：画出程序的算法流程图，给出输入正确f FLAG 时的 CMD 运行窗口截图*</strong></em></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps48-1691140202259-26.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps49-1691140202259-27.jpg" alt="img"> </p>]]></content>
    
    
    <summary type="html">通过源码取消花指令，再进入异常处理破解加密算法</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>23年汇编期末考试答案（个人答案）</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL4/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL4/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:37.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-题目1-本题20"><a href="#一-题目1-本题20" class="headerlink" title="(一) 题目1 (本题20&#96;)"></a><strong>(一)</strong> 题目1 (本题20&#96;)</h1><p>（前3步分析过程不停的掉到坑里，有好多分析是无用的，请简略看）</p><p>1.查看exe文件运行情况</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps50.jpg" alt="img"> </p><p>2.ida分析，查看结构图有无报红花指令报错，找main0，F5看伪代码</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps51.jpg" alt="img"> </p><ol start="3"><li>密钥必须为18位</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps52-1691140441091-1.jpg" alt="img"> </p><ol start="4"><li>发现有一个除零异常，先不管往后看</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps53-1691140441091-3.jpg" alt="img"> </p><ol start="5"><li>看见加密模块，解析加密算法</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps54-1691140441091-2.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps55-1691140441091-5.jpg" alt="img"> </p><p>依照次加密循环，只需将加密后密文加密两次就可以得到明文。</p><p>及efabcdgh-&gt;cdefabgh-&gt;abcdefgh。</p><ol start="6"><li>回头看异常处理部分，动调看一下处理情况</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps56-1691140441091-4.jpg" alt="img"> </p><p>发现处理完后并不会回到程序继续运行，因此加密函数并不会使用主函数的后续功能，说明前面推导错误浪费了时间，真的模块在异常处理当中。</p><ol start="7"><li>找到除零异常位置4012139</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps57-1691140441091-6.jpg" alt="img"> </p><ol start="8"><li>在x32中下断点</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps58-1691140441091-7.jpg" alt="img"> </p><p>随便输入18位输入数据，动调找seh链，转跳到断点后看seh模块</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps59-1691140441091-8.jpg" alt="img"> </p><p>401005为自己设定的异常处理，回到ida找该处理模块。其他的异常不用管</p><ol start="9"><li>追入模块内部</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps60-1691140441091-11.jpg" alt="img"> </p><p>追入sub_401020</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps61-1691140441091-13.jpg" alt="img"> </p><p>发现真正的加密模块。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps62-1691140441091-9.jpg" alt="img"> </p><p>&amp;3是和0011做异或，0x0C&#x3D;0000 1100,0xF0&#x3D;11110000所以有对每位char型的8比特值进行二进制操作</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps63-1691140441091-14.jpg" alt="img"> </p><p>按道理只需要将密文迭代三次可以得到原flag</p><p>10.byte_429A30就是密文信息</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps64-1691140441091-10.jpg" alt="img"> </p><p>复制密文信息  D5 96 C4 F6 07 45 57 77 76 E5 F6 48 47 F7 48 17</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps65-1691140441091-12.jpg" alt="img"> </p><p>11.下断点开始动调</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps66-1691140441091-18.jpg" alt="img"> </p><p>修改输入信息为密文</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps67-1691140441091-15.jpg" alt="img"> </p><p>步进后得到第一次加密结果 密文1：5D D9 9C 6F E0 A4 75 B7 B7 BE 00 C5 C5 10 95 92</p><ol start="12"><li>重复以上步骤2次</li></ol><p>密文2：75 AD B9 87 1E 6A E7 BB FB DC 00 C5 C5 10 95 92</p><p>明文：57 BA EB A8 82 F6 7E 8C C0 5E 00 C5 C5 10 95 92</p><ol start="13"><li>解不出来。原来是落下一步，还要先和序列号相加，前面的计算又浪费了</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps68-1691140441091-17.jpg" alt="img"> </p><p>那就手算吧</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps69-1691140441091-16.jpg" alt="img"> </p><p>根据加密过程可知逆运算需要：</p><p>高两位右移6位，中两位右移2位，低四位左移5位</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps70-1691140441091-19.jpg" alt="img"> </p><p>得到明文 57 65 41 6C 6C 4C 6F 76 65 52 65 76 65 72 73 65</p><p>小工具助我一臂之力：WeAllLoveReverse</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps71-1691140441092-23.jpg" alt="img"> </p><ol start="14"><li>得到flag：WeAllLoveReverseXX，后两位任意</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps72-1691140441092-22.jpg" alt="img"> </p><h1 id="二-题目2-本题20"><a href="#二-题目2-本题20" class="headerlink" title="(二) 题目2 (本题20&#96;)"></a><strong>(二)</strong> 题目2 (本题20&#96;)</h1><p>1.查看exe文件运行情况</p><p>2.ida分析，查看结构图有无报红花指令报错，找main0，F5看伪代码，将比对数按R更改成字符</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps73-1691140441092-25.jpg" alt="img"> </p><p>可以看出来是一个a*x+b的仿射加密，但是区间范围改成了A~Y，是魔改的仿射。</p><p>其中a&#x3D;2,b&#x3D;7</p><ol start="3"><li>找到密文Str2</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps74-1691140441092-20.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps75-1691140441092-21.jpg" alt="img"> </p><p>密文是 HIPHSFUPSU</p><ol start="4"><li>放入破译脚本中进行破解</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps76-1691140441092-28.jpg" alt="img"> </p><p>得到flag：ANEASYTEST</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps77-1691140441092-27.jpg" alt="img"> </p><h1 id="三-题目3-本题20"><a href="#三-题目3-本题20" class="headerlink" title="(三) 题目3 (本题20&#96;)"></a><strong>(三)</strong> 题目3 (本题20&#96;)</h1><p>1.查看exe文件运行情况</p><p>2.ida分析，查看结构图有无报红花指令报错，找main0，F5看伪代码</p><p>看不见输入函数部分，但是有个sub_401005</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps78-1691140441092-24.jpg" alt="img"> </p><p>追入sub_401005查看发生了什么</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps79-1691140441092-26.jpg" alt="img"> </p><p>继续追</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps80-1691140441092-30.jpg" alt="img"> </p><p>可以看出来这是一个文件的hook并不影响代码，因为考试原因不详细分析，知道这个函数实现了字符串输入，并最终把字符串传入了内存Str</p><ol start="3"><li>分析加密部分</li></ol><p>Str为输入内容</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps81-1691140441092-29.jpg" alt="img"> </p><p>实现了两次异或加密。最后与密文相比对，其中输入必须为10字符。</p><p>由于异或的加解密相同，不管异或多少次，都可以用密文通过运行得到明文。</p><ol start="4"><li>抓密文去喽</li></ol><p>格式不对？AU快捷键改一下</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps82-1691140441092-31.jpg" alt="img"> </p><p>抓到密文 RhSrppYzw,</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps83-1691140441092-33.jpg" alt="img"> </p><ol start="5"><li>下断点开始计算明文，上图中断点已下好，断点下载比对加密后明文和密文的位置，运行到这里就已经加好密了</li></ol><p>动调输入密文，断点处查看内存中的加密结果就是明文</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps84-1691140441092-34.jpg" alt="img"> </p><ol start="6"><li>抓到明文 IsHackBad?</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps85-1691140441092-32.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps86-1691140441092-35.jpg" alt="img"> </p><ol start="7"><li>验证</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps87-1691140441092-36.jpg" alt="img"> </p><h1 id="四-题目4-本题20"><a href="#四-题目4-本题20" class="headerlink" title="(四) 题目4 (本题20&#96;)"></a><strong>(四)</strong> 题目4 (本题20&#96;)</h1><p>1.查看exe文件运行情况</p><p>2.ida分析，查看结构图有无报红花指令报错，找main0，F5看伪代码</p><p>很明显的结构，输入固定8位，经算法后比对结果。那么算法就在sub_40100F或sub_401032中</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps88-1691140441092-37.jpg" alt="img"> </p><ol start="3"><li>追入sub_40100F找加密算法</li></ol><p>函数很复杂，一层套一层，感觉不想简单的加密，应该属于DES&#x2F;MD5&#x2F;RC4&#x2F;SHA当中的了</p><p>开始找特征值，看见有48，还有Src[48]，很像DES的加密密钥嗷</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps89-1691140441092-39.jpg" alt="img"> </p><ol start="4"><li>追入sub_401032找加密算法</li></ol><p>都是和48位密钥的操作，判断是des</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps90-1691140441092-41.jpg" alt="img"> </p><ol start="5"><li>尝试动调对密码加密得到flag但是失败了，不过找到了密文</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps91-1691140441092-38.jpg" alt="img"> </p><p>密文为42 AC 43 D3 F1 44 B1 36</p><p>可以看出来V7就是密钥</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps92-1691140441092-40.jpg" alt="img"> </p><ol start="6"><li>不能偷懒，还是用脚本老老实实破解吧</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps93-1691140441092-42.jpg" alt="img"> </p><p>破解flag 1_L0V5_@</p><ol start="7"><li>验证</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps94-1691140441092-43.jpg" alt="img"> </p><h1 id="五-题目5-本题20"><a href="#五-题目5-本题20" class="headerlink" title="(五) 题目5 (本题20&#96;)"></a><strong>(五)</strong> 题目5 (本题20&#96;)</h1><ol><li>查看exe文件运行情况</li></ol><p>这道题还多了个提示，看起来应该很复杂</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps95-1691140441092-45.jpg" alt="img"> </p><ol start="2"><li>ida分析，查看结构图有无报红花指令报错，找main0，F5看伪代码</li></ol><p>都是定义信息，看来加密内容应该在三个sub函数当中</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps96-1691140441092-46.jpg" alt="img"> </p><ol start="3"><li>从sub_401028开始看</li></ol><p>该函数说明输入必须为6位，并返回了一个新函数，输入内容在主函数中为Source，不再是Str</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps97-1691140441092-44.jpg" alt="img"> </p><ol start="4"><li>追入sub_40100A</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps98-1691140441092-48.jpg" alt="img"> </p><p>这一步实现了一个置换，让Str即初始输入变成逆序，返回结果result&#x3D;3</p><ol start="5"><li>看函数sub_40100F</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps99-1691140441092-50.jpg" alt="img"> </p><p>给Str传入输入信息，但是只传了前四位，就是原flag的后四位</p><ol start="6"><li>继续追入</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps100-1691140441092-47.jpg" alt="img"> </p><p>似曾相识的结构，追入函数查看</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps101-1691140441092-49.jpg" alt="img"> </p><p>这不是sha256的密钥输入嘛</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps102-1691140441092-51.jpg" alt="img"> </p><p>可以判定第二个函数是对明文进行加密了</p><ol start="7"><li>继续看第三个函数sub_401014，追入查看</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps103-1691140441092-53.jpg" alt="img"> </p><p>原来就是比对结果</p><p>Big_Numbers3_42AA30是hash的散列密钥 这么长的密钥串，更加确定是sha，md5的128位没有这么长</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps104-1691140441092-52.jpg" alt="img"> </p><ol start="8"><li>破解脚本，启动！</li></ol><p>感谢老师的工具和提示</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps105-1691140441092-54.jpg" alt="img"> </p><ol start="9"><li>分析以上过程，可知flag为6位，后四位是逆序的love，前两为随意小写字母</li></ol><p>得到flag xxevol</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps106.jpg" alt="img"> </p>]]></content>
    
    
    <summary type="html">五道期末考试题作答解析</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>包用包对的汇编破译小脚本</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL5/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL5/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:42.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="放射加密"><a href="#放射加密" class="headerlink" title="放射加密"></a>放射加密</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">affine_decrypt</span>(<span class="params">ciphertext, a, b, dictionary</span>):</span><br><span class="line">    decrypted = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> ciphertext:</span><br><span class="line"></span><br><span class="line">        char_index = dictionary.index(char)</span><br><span class="line">        <span class="comment"># 计算字符的模逆</span></span><br><span class="line">        char_inverse = mod_inverse(a, <span class="built_in">len</span>(dictionary))</span><br><span class="line">        <span class="comment"># 应用仿射解密公式</span></span><br><span class="line">        decrypted_char_index = (char_inverse * (char_index - b)) % <span class="built_in">len</span>(dictionary)</span><br><span class="line">        decrypted += dictionary[decrypted_char_index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decrypted</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a, m</span>):</span><br><span class="line">    <span class="comment"># 扩展欧几里得算法求模逆</span></span><br><span class="line">    g, x, _ = extended_gcd(a, m)</span><br><span class="line">    <span class="keyword">if</span> g == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> x % m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extended_gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> b, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gcd, x, y = extended_gcd(b % a, a)</span><br><span class="line">        <span class="keyword">return</span> gcd, y - (b // a) * x, x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义字典</span></span><br><span class="line">dictionary = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXY&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入密文和仿射加密的参数</span></span><br><span class="line">ciphertext = <span class="string">&quot;HIPHSFUPSU&quot;</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plaintext = affine_decrypt(ciphertext, a, b, dictionary)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;明文:&quot;</span>, plaintext)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ASCII转码"><a href="#ASCII转码" class="headerlink" title="ASCII转码"></a>ASCII转码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hex_values = <span class="string">&quot;0x10, 0x2C, 0x02, 0xFC, 0xFB, 0x3B, 0x0D, 0x73, 0x6E, 0xBC, 0xB9, 0xA7, 0x6F, 0x2F &quot;</span></span><br><span class="line"></span><br><span class="line">hex_values_list = hex_values.split(<span class="string">&quot;, &quot;</span>)</span><br><span class="line"></span><br><span class="line">ascii_values = [<span class="built_in">int</span>(hex_value[:-<span class="number">1</span>], <span class="number">16</span>) <span class="keyword">for</span> hex_value <span class="keyword">in</span> hex_values_list]</span><br><span class="line"></span><br><span class="line">ascii_chars = [<span class="built_in">chr</span>(ascii_value) <span class="keyword">for</span> ascii_value <span class="keyword">in</span> ascii_values]</span><br><span class="line"></span><br><span class="line">ascii_representation = <span class="string">&#x27;&#x27;</span>.join(ascii_chars)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ASCII representation:&quot;</span>, ascii_representation)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">byte_sequence = <span class="string">b&quot;\x10\x2C\x02\xFC\xFB\x3B\x0D\x73\x6E\xBC\xB9\xA7\x6F\x2F&quot;</span></span><br><span class="line">string_representation = byte_sequence.decode(<span class="string">&#x27;ascii&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串表示:&quot;</span>, string_representation)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="des"><a href="#des" class="headerlink" title="des"></a>des</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.ciphers <span class="keyword">import</span> Cipher, algorithms, modes</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.backends <span class="keyword">import</span> default_backend</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hex_to_int</span>(<span class="params">hex_str</span>):</span><br><span class="line">    hex_str = hex_str.replace(<span class="string">&quot;h&quot;</span>, <span class="string">&quot;&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(hex_str, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">des_decrypt</span>(<span class="params">ciphertext, key</span>):</span><br><span class="line">    backend = default_backend()</span><br><span class="line">    cipher = Cipher(algorithms.TripleDES(key), modes.ECB(), backend=backend)</span><br><span class="line">    decryptor = cipher.decryptor()</span><br><span class="line">    plaintext = decryptor.update(ciphertext) + decryptor.finalize()</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line">ciphertext_str = <span class="string">&quot;42h,ACh,43h,D3h,F1h,44h,B1h,36h,&quot;</span></span><br><span class="line">key_str = <span class="string">&quot;23h, 24h, 31h, 32h, 2Ah, 26h, 5Eh, 29h,&quot;</span></span><br><span class="line"></span><br><span class="line">ciphertext_bytes = <span class="built_in">bytearray</span>(hex_to_int(x) <span class="keyword">for</span> x <span class="keyword">in</span> re.findall(<span class="string">r&#x27;[0-9a-fA-F]+&#x27;</span>, ciphertext_str))</span><br><span class="line">key_bytes = <span class="built_in">bytearray</span>(hex_to_int(x) <span class="keyword">for</span> x <span class="keyword">in</span> re.findall(<span class="string">r&#x27;[0-9a-fA-F]+&#x27;</span>, key_str))</span><br><span class="line"></span><br><span class="line">plaintext = des_decrypt(ciphertext_bytes, key_bytes)</span><br><span class="line">plaintext_str = plaintext.decode()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密后的明文:&quot;</span>, plaintext_str)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">md5_hash = <span class="string">&quot;23d4a52c56357cb705137656744dc055&quot;</span>       <span class="comment">#散列值</span></span><br><span class="line">plaintext_length = <span class="number">4</span>                               <span class="comment">#明文长度</span></span><br><span class="line">charset = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>      <span class="comment">#字典 ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 abcdefghijklmnopqrstuvwxyz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成所有可能的明文组合</span></span><br><span class="line">combinations = itertools.product(charset, repeat=plaintext_length)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试每个明文组合并进行MD5散列计算</span></span><br><span class="line"><span class="keyword">for</span> combination <span class="keyword">in</span> combinations:</span><br><span class="line">    plaintext = <span class="string">&quot;&quot;</span>.join(combination)</span><br><span class="line">    md5 = hashlib.md5(plaintext.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查计算的MD5散列值是否与给定的散列值匹配</span></span><br><span class="line">    <span class="keyword">if</span> md5 == md5_hash:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;解密成功！明文为:&quot;</span>, plaintext)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未找到匹配的明文。&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_decrypt</span>(<span class="params">ciphertext, key</span>):</span><br><span class="line">    S = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    decrypted = <span class="built_in">bytearray</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化S盒</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + S[i] + key[i % <span class="built_in">len</span>(key)]) % <span class="number">256</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解密数据</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> ciphertext:</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line">        k = S[(S[i] + S[j]) % <span class="number">256</span>]</span><br><span class="line">        decrypted.append(byte ^ k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decrypted</span><br><span class="line"></span><br><span class="line">ciphertext_str = <span class="string">&quot;1Bh, 0CAh, 0AEh, 0EFh, 1Eh, 95h, 4Bh, 0C2h, 0D5h, 0E3h, 33h, 76h, 4Fh, 0F9h, 4Fh, 0D2h, 0FCh, 60h&quot;</span></span><br><span class="line">ciphertext_bytes = <span class="built_in">bytearray</span>(<span class="built_in">int</span>(<span class="keyword">match</span>.group(<span class="number">1</span>), <span class="number">16</span>) <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> re.finditer(<span class="string">r&quot;([0-9A-Fa-f]+)h&quot;</span>, ciphertext_str))</span><br><span class="line"></span><br><span class="line">key_str = <span class="string">&quot;52h, 43h, 34h, 6Bh, 65h, 79h&quot;</span></span><br><span class="line">key_bytes = <span class="built_in">bytearray</span>(<span class="built_in">int</span>(<span class="keyword">match</span>.group(<span class="number">1</span>), <span class="number">16</span>) <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> re.finditer(<span class="string">r&quot;([0-9A-Fa-f]+)h&quot;</span>, key_str))</span><br><span class="line"></span><br><span class="line">plaintext = rc4_decrypt(ciphertext_bytes, key_bytes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密后的明文:&quot;</span>, plaintext.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="SHA256"><a href="#SHA256" class="headerlink" title="SHA256"></a>SHA256</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">hash_value = <span class="string">&quot;45c6c64ffd31a750bcb2e150519f1963e5424bafd380637cff33075c25d35334&quot;</span></span><br><span class="line">plaintext_length = <span class="number">4</span></span><br><span class="line">charset = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>  <span class="comment">#字典 ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 abcdefghijklmnopqrstuvwxyz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_combinations</span>(<span class="params">length, charset</span>):</span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> charset:</span><br><span class="line">            <span class="keyword">for</span> combination <span class="keyword">in</span> generate_combinations(length - <span class="number">1</span>, charset):</span><br><span class="line">                <span class="keyword">yield</span> char + combination</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> combination <span class="keyword">in</span> generate_combinations(plaintext_length, charset):</span><br><span class="line">    hashed_combination = hashlib.sha256(combination.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">if</span> hashed_combination == hash_value:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Plaintext found:&quot;</span>, combination)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="XOR-异或"><a href="#XOR-异或" class="headerlink" title="XOR 异或"></a>XOR 异或</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">plaintext = <span class="string">&quot;61h, 62h, 63h, 64h, 65h, 66h, 67h, 31h, 32h, 33h&quot;</span></span><br><span class="line">ciphertext = <span class="string">&quot;28h, 3Dh, 24h, 54h, 0Ah, 12h, 38h, 7Ah, 57h, 4Ah&quot;</span></span><br><span class="line"></span><br><span class="line">plaintext = plaintext.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">ciphertext = ciphertext.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext)):</span><br><span class="line">    hex_plain = re.sub(<span class="string">r&#x27;[^0-9a-fA-F]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, plaintext[i])</span><br><span class="line">    hex_cipher = re.sub(<span class="string">r&#x27;[^0-9a-fA-F]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, ciphertext[i])</span><br><span class="line">    decrypted = <span class="built_in">int</span>(hex_plain, <span class="number">16</span>) ^ <span class="built_in">int</span>(hex_cipher, <span class="number">16</span>)</span><br><span class="line">    result.append(<span class="built_in">chr</span>(decrypted))</span><br><span class="line"></span><br><span class="line">output = <span class="string">&quot;&quot;</span>.join(result)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">包括MD5、RC4、des等各种解密手段，并且支持自定义</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言基础代码解读</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL6/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL6/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:47.866Z</updated>
    
    <content type="html"><![CDATA[<p>8080汇编手册数据传输指令</p><p>──────────────────────────────</p><p>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据。</p><h1 id="1。-通用数据传送指令。"><a href="#1。-通用数据传送指令。" class="headerlink" title="1。 通用数据传送指令。"></a><strong>1。 通用数据传送指令。</strong></h1><p>MOV 传送字或字节。</p><p>MOVSX 先符号扩展，再传送。</p><p>MOVZX 先零扩展，再传送。</p><p>PUSH 把字压入堆栈。</p><p>POP 把字弹出堆栈。</p><p>PUSHA 把AX，CX，DX，BX，SP，BP，SI，DI依次压入堆栈。</p><p>POPA 把DI，SI，BP，SP，BX，DX，CX，AX依次弹出堆栈。</p><p>PUSHAD 把EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI依次压入堆栈。</p><p>POPAD 把EDI，ESI，EBP，ESP，EBX，EDX，ECX，EAX依次弹出堆栈。</p><p>BSWAP 交换32位寄存器里字节的顺序</p><p>XCHG 交换字或字节。( 至少有一个操作数为寄存器，段寄存器不可作为操作数)</p><p>CMPXCHG 比较并交换操作数。( 第二个操作数必须为累加器AL&#x2F;AX&#x2F;EAX )</p><p>XADD 先交换再累加。( 结果在第一个操作数里 )</p><p>XLAT 字节查表转换。</p><p>── BX 指向一张 256 字节的表的起点， AL 为表的索引值 (0-255，即</p><p>0-FFH); 返回 AL 为查表结果。 ( [BX+AL]-&gt;AL )</p><p>2。 输入输出端口传送指令。</p><p>IN I&#x2F;O端口输入。 ( 语法: IN 累加器， {端口号│DX} )</p><p>OUT I&#x2F;O端口输出。 ( 语法: OUT {端口号│DX}，累加器 )</p><p>输入输出端口由立即方式指定时， 其范围是 0-255; 由寄存器 DX 指定时，</p><p>其范围是 0-65535。</p><p>3。 目的地址传送指令。</p><p>LEA 装入有效地址。</p><p>例: LEA DX，string ;把偏移地址存到DX。</p><p>LDS 传送目标指针，把指针内容装入DS。</p><p>例: LDS SI，string ;把段地址:偏移地址存到DS:SI。</p><p>LES 传送目标指针，把指针内容装入ES。</p><p>例: LES DI，string ;把段地址:偏移地址存到ES:DI。</p><p>LFS 传送目标指针，把指针内容装入FS。</p><p>例: LFS DI，string ;把段地址:偏移地址存到FS:DI。</p><p>LGS 传送目标指针，把指针内容装入GS。</p><p>例: LGS DI，string ;把段地址:偏移地址存到GS:DI。</p><p>LSS 传送目标指针，把指针内容装入SS。</p><p>例: LSS DI，string ;把段地址:偏移地址存到SS:DI。</p><p>4。 标志传送指令。</p><p>LAHF 标志寄存器传送，把标志装入AH。</p><p>SAHF 标志寄存器传送，把AH内容装入标志寄存器。</p><p>PUSHF 标志入栈。</p><p>POPF 标志出栈。</p><p>PUSHD 32位标志入栈。</p><p>POPD 32位标志出栈。</p><h1 id="二、算术运算指令"><a href="#二、算术运算指令" class="headerlink" title="二、算术运算指令"></a><strong>二、算术运算指令</strong></h1><p>──────────────────────────────</p><p>ADD 加法。</p><p>ADC 带进位加法。</p><p>INC 加 1。</p><p>AAA 加法的ASCII码调整。</p><p>DAA 加法的十进制调整。</p><p>SUB 减法。</p><p>SBB 带借位减法。</p><p>DEC 减 1。</p><p>NEC 求反(以 0 减之)。</p><p>CMP 比较。(两操作数作减法，仅修改标志位，不回送结果)。</p><p>AAS 减法的ASCII码调整。</p><p>DAS 减法的十进制调整。</p><p>MUL 无符号乘法。</p><p>IMUL 整数乘法。</p><p>以上两条，结果回送AH和AL(字节运算)，或DX和AX(字运算)，</p><p>AAM 乘法的ASCII码调整。</p><p>DIV 无符号除法。</p><p>IDIV 整数除法。</p><p>以上两条，结果回送:</p><p>商回送AL，余数回送AH， (字节运算);</p><p>或 商回送AX，余数回送DX， (字运算)。</p><p>AAD 除法的ASCII码调整。</p><p>CBW 字节转换为字。 (把AL中字节的符号扩展到AH中去)</p><p>CWD 字转换为双字。 (把AX中的字的符号扩展到DX中去)</p><p>CWDE 字转换为双字。 (把AX中的字符号扩展到EAX中去)</p><p>CDQ 双字扩展。 (把EAX中的字的符号扩展到EDX中去)</p><h1 id="三、逻辑运算指令"><a href="#三、逻辑运算指令" class="headerlink" title="三、逻辑运算指令"></a><strong>三、逻辑运算指令</strong></h1><p>────────────────────────────</p><p>AND 与运算。</p><p>OR 或运算。</p><p>XOR 异或运算。</p><p>NOT 取反。</p><p>TEST 测试。(两操作数作与运算，仅修改标志位，不回送结果)。</p><p>SHL 逻辑左移。</p><p>SAL 算术左移。(&#x3D;SHL)</p><p>SHR 逻辑右移。</p><p>SAR 算术右移。(&#x3D;SHR)</p><p>ROL 循环左移。</p><p>ROR 循环右移。</p><p>RCL 通过进位的循环左移。</p><p>RCR 通过进位的循环右移。</p><p>以上八种移位指令，其移位次数可达255次。</p><p>移位一次时， 可直接用操作码。 如 SHL AX，1。</p><p>移位&gt;1次时， 则由寄存器CL给出移位次数。</p><p>如 MOV CL，04</p><p>SHL AX，CL</p><h1 id="四、串指令"><a href="#四、串指令" class="headerlink" title="四、串指令"></a><strong>四、串指令</strong></h1><p>───────────────────────────</p><p>DS:SI 源串段寄存器 :源串变址。</p><p>ES:DI 目标串段寄存器:目标串变址。</p><p>CX 重复次数计数器。</p><p>AL&#x2F;AX 扫描值。</p><p>D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量。</p><p>Z标志 用来控制扫描或比较操作的结束。</p><p>MOVS 串传送。</p><p>( MOVSB 传送字符。 MOVSW 传送字。 MOVSD 传送双字。 )</p><p>CMPS 串比较。</p><p>( CMPSB 比较字符。 CMPSW 比较字。 )</p><p>SCAS 串扫描。</p><p>把AL或AX的内容与目标串作比较，比较结果反映在标志位。</p><p>LODS 装入串。</p><p>把源串中的元素(字或字节)逐一装入AL或AX中。</p><p>( LODSB 传送字符。 LODSW 传送字。 LODSD 传送双字。 )</p><p>STOS 保存串。</p><p>是LODS的逆过程。</p><p>REP 当CX&#x2F;ECX&lt;&gt;0时重复。</p><p>REPE&#x2F;REPZ 当ZF&#x3D;1或比较结果相等，且CX&#x2F;ECX&lt;&gt;0时重复。</p><p>REPNE&#x2F;REPNZ 当ZF&#x3D;0或比较结果不相等，且CX&#x2F;ECX&lt;&gt;0时重复。</p><p>REPC 当CF&#x3D;1且CX&#x2F;ECX&lt;&gt;0时重复。</p><p>REPNC 当CF&#x3D;0且CX&#x2F;ECX&lt;&gt;0时重复。</p><h1 id="五、程序转移指令"><a href="#五、程序转移指令" class="headerlink" title="五、程序转移指令"></a><strong>五、程序转移指令</strong></h1><p>──────────────────────────</p><p>1&gt;无条件转移指令 (长转移)</p><p>JMP 无条件转移指令</p><p>CALL 过程调用</p><p>RET&#x2F;RETF过程返回。</p><p>2&gt;条件转移指令 (短转移，-128到+127的距离内)</p><p>( 当且仅当(SF XOR OF)&#x3D;1时，OP1 JA&#x2F;JNBE 不小于或不等于时转移。</p><p>JAE&#x2F;JNB 大于或等于转移。</p><p>JB&#x2F;JNAE 小于转移。</p><p>JBE&#x2F;JNA 小于或等于转移。</p><p>以上四条，测试无符号整数运算的结果(标志C和Z)。</p><p>JG&#x2F;JNLE 大于转移。</p><p>JGE&#x2F;JNL 大于或等于转移。</p><p>JL&#x2F;JNGE 小于转移。</p><p>JLE&#x2F;JNG 小于或等于转移。</p><p>以上四条，测试带符号整数运算的结果(标志S，O和Z)。</p><p>JE&#x2F;JZ 等于转移。</p><p>JNE&#x2F;JNZ 不等于时转移。</p><p>JC 有进位时转移。</p><p>JNC 无进位时转移。</p><p>JNO 不溢出时转移。</p><p>JNP&#x2F;JPO 奇偶性为奇数时转移。</p><p>JNS 符号位为 “0” 时转移。</p><p>JO 溢出转移。</p><p>JP&#x2F;JPE 奇偶性为偶数时转移。</p><p>JS 符号位为 “1” 时转移。</p><p>3&gt;循环控制指令(短转移)</p><p>LOOP CX不为零时循环。</p><p>LOOPE&#x2F;LOOPZ CX不为零且标志Z&#x3D;1时循环。</p><p>LOOPNE&#x2F;LOOPNZ CX不为零且标志Z&#x3D;0时循环。</p><p>JCXZ CX为零时转移。</p><p>JECXZ ECX为零时转移。</p><p>4&gt;中断指令</p><p>INT 中断指令</p><p>INTO 溢出中断</p><p>IRET 中断返回</p><p>5&gt;处理器控制指令</p><p>HLT 处理器暂停， 直到出现中断或复位信号才继续。</p><p>WAIT 当芯片引线TEST为高电平时使CPU进入等待状态。</p><p>ESC 转换到外处理器。</p><p>LOCK 封锁总线。</p><p>NOP 空操作。</p><p>STC 置进位标志位。</p><p>CLC 清进位标志位。</p><p>CMC 进位标志取反。</p><p>STD 置方向标志位。</p><p>CLD 清方向标志位。</p><p>STI 置中断允许位。</p><p>CLI 清中断允许位。</p><h1 id="六、伪指令"><a href="#六、伪指令" class="headerlink" title="六、伪指令"></a><strong>六、伪指令</strong></h1><p>───────────────────────────</p><p>DW 定义字(2字节)。</p><p>PROC 定义过程。</p><p>ENDP 过程结束。</p><p>SEGMENT 定义段。</p><p>ASSUME 建立段寄存器寻址。</p><p>ENDS 段结束。</p><p>END 程序结束。</p><h1 id="一-机械码-又称机器码"><a href="#一-机械码-又称机器码" class="headerlink" title="一.机械码,又称机器码."></a><strong>一.机械码,又称机器码.</strong></h1><p>ultraedit打开,编辑exe文件时你会看到</p><p>许许多多的由0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F组成的数码,这些数码</p><p>就是机器码.</p><p>修改程序时必须通过修改机器码来修改exe文件.</p><h1 id="二-需要熟练掌握的全部汇编知识-只有这么多"><a href="#二-需要熟练掌握的全部汇编知识-只有这么多" class="headerlink" title="二.需要熟练掌握的全部汇编知识(只有这么多)"></a><strong>二.需要熟练掌握的全部汇编知识(只有这么多)</strong></h1><p>不大容易理解,可先强行背住,混个脸儿熟,以后慢慢的就理解了</p><p>cmp a,b 比较a与b</p><p>mov a,b 把b的值送给a</p><p>ret 返回主程序</p><p>nop 无作用,英文“no operation”的简写，意思是“do nothing”(机器码90)***机器码的含义参看上面</p><p>(解释:ultraedit打开编辑exe文件时你看到90,等同于汇编语句nop)</p><p>call 调用子程序</p><p>je 或jz 若相等则跳(机器码74 或0F84)</p><p>jne或jnz 若不相等则跳(机器码75或0F85)</p><p>jmp 无条件跳(机器码EB)</p><p>jb 若小于则跳</p><p>ja 若大于则跳</p><p>jg 若大于则跳</p><p>jge 若大于等于则跳</p><p>jl 若小于则跳</p><p>jle 若小于等于则跳</p><p>pop 出栈</p><p>push 压栈</p><h1 id="三-常见修改-机器码"><a href="#三-常见修改-机器码" class="headerlink" title="三.常见修改(机器码)"></a>三.常见修改(机器码)</h1><p>74&#x3D;&gt;75 74&#x3D;&gt;90 74&#x3D;&gt;EB</p><p>75&#x3D;&gt;74 75&#x3D;&gt;90 75&#x3D;&gt;EB</p><p>jnz-&gt;nop</p><p>75-&gt;90(相应的机器码修改)</p><p>jnz -&gt; jmp</p><p>75 -&gt; EB(相应的机器码修改)</p><p>jnz -&gt; jz</p><p>75-&gt;74 (正常) 0F 85 -&gt; 0F 84(特殊情况下,有时,相应的机器码修改)</p><h1 id="四-两种不同情况的不同修改方法"><a href="#四-两种不同情况的不同修改方法" class="headerlink" title="四.两种不同情况的不同修改方法"></a>四.两种不同情况的不同修改方法</h1><p>1.修改为jmp</p><p>je(jne,jz,jnz) &#x3D;&gt;jmp相应的机器码EB （出错信息向上找到的第一个跳转）jmp的作用是绝对跳，无条件跳，从而跳过下面的出错信息</p><p>xxxxxxxxxxxx 出错信息，例如：注册码不对，sorry,未注册版不能…，”Function Not Avaible in Demo” 或 “Command Not Avaible” 或 “Can’t save in Shareware&#x2F;Demo”等 （我们希望把它跳过，不让它出现）</p><p>。。。</p><p>。。。</p><p>xxxxxxxxxxxx 正确路线所在</p><p>2.修改为nop</p><p>je(jne,jz,jnz) &#x3D;&gt;nop相应的机器码90 （正确信息向上找到的第一个跳转） nop的作用是抹掉这个跳转，使这个跳转无效，失去作用，从而使程序顺利来到紧跟其后的正确信息处</p><p>xxxxxxxxxxxx 正确信息，例如：注册成功，谢谢您的支持等（我们希望它不被跳过，让它出现，程序一定要顺利来到这里）</p><p>。。。</p><p>。。。</p><p>xxxxxxxxxxxx 出错信息（我们希望不要跳到这里，不让它出现）它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据. </p><ol><li>通用数据传送指令.</li></ol><p>MOV 传送字或字节. </p><p>MOVSX 先符号扩展,再传送. </p><p>MOVZX 先零扩展,再传送. </p><p>PUSH 把字压入堆栈. </p><p>POP 把字弹出堆栈. </p><p>PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. </p><p>POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. </p><p>PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. </p><p>POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. </p><p>BSWAP 交换32位寄存器里字节的顺序 </p><p>XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)</p><p>CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL&#x2F;AX&#x2F;EAX )</p><p>XADD 先交换再累加.( 结果在第一个操作数里 )</p><p>XLAT 字节查表转换. </p><p>── BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即 </p><p>0-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL )</p><ol start="2"><li>输入输出端口传送指令.</li></ol><p>IN I&#x2F;O端口输入. ( 语法: IN 累加器, {端口号│DX} )</p><p>OUT I&#x2F;O端口输出. ( 语法: OUT {端口号│DX},累加器 )</p><p>输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,</p><p>其范围是 0-65535.</p><ol start="3"><li>目的地址传送指令.</li></ol><p>LEA 装入有效地址. </p><p>例: LEA DX,string ;把偏移地址存到DX. </p><p>LDS 传送目标指针,把指针内容装入DS. </p><p>例: LDS SI,string ;把段地址:偏移地址存到DS:SI. </p><p>LES 传送目标指针,把指针内容装入ES. </p><p>例: LES DI,string ;把段地址:偏移地址存到ESI. </p><p>LFS 传送目标指针,把指针内容装入FS. </p><p>例: LFS DI,string ;把段地址:偏移地址存到FSI. </p><p>LGS 传送目标指针,把指针内容装入GS. </p><p>例: LGS DI,string ;把段地址:偏移地址存到GSI. </p><p>LSS 传送目标指针,把指针内容装入SS. </p><p>例: LSS DI,string ;把段地址:偏移地址存到SSI. </p><ol start="4"><li>标志传送指令.</li></ol><p>LAHF 标志寄存器传送,把标志装入AH. </p><p>SAHF 标志寄存器传送,把AH内容装入标志寄存器. </p><p>PUSHF 标志入栈. </p><p>POPF 标志出栈. </p><p>PUSHD 32位标志入栈. </p><p>POPD 32位标志出栈. </p><h1 id="二、算术运算指令-1"><a href="#二、算术运算指令-1" class="headerlink" title="二、算术运算指令"></a>二、算术运算指令</h1><p>─────────────────────────────────────── </p><p>ADD 加法. </p><p>ADC 带进位加法. </p><p>INC 加 1.</p><p>AAA 加法的ASCII码调整. </p><p>DAA 加法的十进制调整. </p><p>SUB 减法. </p><p>SBB 带借位减法. </p><p>DEC 减 1.</p><p>NEC 求反(以 0 减之). </p><p>CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). </p><p>AAS 减法的ASCII码调整. </p><p>DAS 减法的十进制调整. </p><p>MUL 无符号乘法. </p><p>IMUL 整数乘法. </p><p>以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算),</p><p>AAM 乘法的ASCII码调整. </p><p>DIV 无符号除法. </p><p>IDIV 整数除法. </p><p>以上两条,结果回送:</p><p>商回送AL,余数回送AH, (字节运算); </p><p>或 商回送AX,余数回送DX, (字运算). </p><p>AAD 除法的ASCII码调整. </p><p>CBW 字节转换为字. (把AL中字节的符号扩展到AH中去)</p><p>CWD 字转换为双字. (把AX中的字的符号扩展到DX中去)</p><p>CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去)</p><p>CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去)</p><h1 id="三、逻辑运算指令-1"><a href="#三、逻辑运算指令-1" class="headerlink" title="三、逻辑运算指令"></a>三、逻辑运算指令</h1><p>─────────────────────────────────────── </p><p>AND 与运算. </p><p>OR 或运算. </p><p>XOR 异或运算. </p><p>NOT 取反. </p><p>TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). </p><p>SHL 逻辑左移. </p><p>SAL 算术左移.(&#x3D;SHL)</p><p>SHR 逻辑右移. </p><p>SAR 算术右移.(&#x3D;SHR)</p><p>ROL 循环左移. </p><p>ROR 循环右移. </p><p>RCL 通过进位的循环左移. </p><p>RCR 通过进位的循环右移. </p><p>以上八种移位指令,其移位次数可达255次. </p><p>移位一次时, 可直接用操作码. 如 SHL AX,1.</p><p>移位&gt;1次时, 则由寄存器CL给出移位次数. </p><p>如 MOV CL,04</p><p>SHL AX,CL </p><h1 id="四、串指令-1"><a href="#四、串指令-1" class="headerlink" title="四、串指令"></a>四、串指令</h1><p>─────────────────────────────────────── </p><p>DS:SI 源串段寄存器 :源串变址. </p><p>ESI 目标串段寄存器:目标串变址. </p><p>CX 重复次数计数器. </p><p>AL&#x2F;AX 扫描值. </p><p>D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. </p><p>Z标志 用来控制扫描或比较操作的结束. </p><p>MOVS 串传送. </p><p>( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )</p><p>CMPS 串比较. </p><p>( CMPSB 比较字符. CMPSW 比较字. )</p><p>SCAS 串扫描. </p><p>把AL或AX的内容与目标串作比较,比较结果反映在标志位. </p><p>LODS 装入串. </p><p>把源串中的元素(字或字节)逐一装入AL或AX中. </p><p>( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )</p><p>STOS 保存串. </p><p>是LODS的逆过程. </p><p>REP 当CX&#x2F;ECX&lt;&gt;0时重复. </p><p>REPE&#x2F;REPZ 当ZF&#x3D;1或比较结果相等,且CX&#x2F;ECX&lt;&gt;0时重复. </p><p>REPNE&#x2F;REPNZ 当ZF&#x3D;0或比较结果不相等,且CX&#x2F;ECX&lt;&gt;0时重复. </p><p>REPC 当CF&#x3D;1且CX&#x2F;ECX&lt;&gt;0时重复. </p><p>REPNC 当CF&#x3D;0且CX&#x2F;ECX&lt;&gt;0时重复. </p><h1 id="五、程序转移指令-1"><a href="#五、程序转移指令-1" class="headerlink" title="五、程序转移指令"></a>五、程序转移指令</h1><p>─────────────────────────────────────── </p><p>1&gt;无条件转移指令 (长转移)</p><p>JMP 无条件转移指令 </p><p>CALL 过程调用 </p><p>RET&#x2F;RETF过程返回. </p><p>2&gt;条件转移指令 (短转移,-128到+127的距离内)</p><p>( 当且仅当(SF XOR OF)&#x3D;1时,OP1&lt;OP2 )</p><p>JA&#x2F;JNBE 不小于或不等于时转移. </p><p>JAE&#x2F;JNB 大于或等于转移. </p><p>JB&#x2F;JNAE 小于转移. </p><p>JBE&#x2F;JNA 小于或等于转移. </p><p>以上四条,测试无符号整数运算的结果(标志C和Z). </p><p>JG&#x2F;JNLE 大于转移. </p><p>JGE&#x2F;JNL 大于或等于转移. </p><p>JL&#x2F;JNGE 小于转移. </p><p>JLE&#x2F;JNG 小于或等于转移. </p><p>以上四条,测试带符号整数运算的结果(标志S,O和Z). </p><p>JE&#x2F;JZ 等于转移. </p><p>JNE&#x2F;JNZ 不等于时转移. </p><p>JC 有进位时转移. </p><p>JNC 无进位时转移. </p><p>JNO 不溢出时转移. </p><p>JNP&#x2F;JPO 奇偶性为奇数时转移. </p><p>JNS 符号位为 “0” 时转移. </p><p>JO 溢出转移. </p><p>JP&#x2F;JPE 奇偶性为偶数时转移. </p><p>JS 符号位为 “1” 时转移. </p><p>3&gt;循环控制指令(短转移)</p><p>LOOP CX不为零时循环. </p><p>LOOPE&#x2F;LOOPZ CX不为零且标志Z&#x3D;1时循环. </p><p>LOOPNE&#x2F;LOOPNZ CX不为零且标志Z&#x3D;0时循环. </p><p>JCXZ CX为零时转移. </p><p>JECXZ ECX为零时转移. </p><p>4&gt;中断指令 </p><p>INT 中断指令 </p><p>INTO 溢出中断 </p><p>IRET 中断返回 </p><p>5&gt;处理器控制指令 </p><p>HLT 处理器暂停, 直到出现中断或复位信号才继续. </p><p>WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. </p><p>ESC 转换到外处理器. </p><p>LOCK 封锁总线. </p><p>NOP 空操作. </p><p>STC 置进位标志位. </p><p>CLC 清进位标志位. </p><p>CMC 进位标志取反. </p><p>STD 置方向标志位. </p><p>CLD 清方向标志位. </p><p>STI 置中断允许位. </p><p>CLI 清中断允许位. </p><h1 id="六、伪指令-1"><a href="#六、伪指令-1" class="headerlink" title="六、伪指令"></a>六、伪指令</h1><p>─────────────────────────────────────── </p><p>DW 定义字(2字节). </p><p>PROC 定义过程. </p><p>ENDP 过程结束. </p><p>SEGMENT 定义段. </p><p>ASSUME 建立段寄存器寻址. </p><p>ENDS 段结束. </p><p>END 程序结束</p>]]></content>
    
    
    <summary type="html">对常见语言进行解释，便于后续阅读源码</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>鲁棒图像感知哈希实验</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS1/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS1/</id>
    <published>2023-08-02T09:00:00.000Z</published>
    <updated>2023-08-02T09:52:10.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 *实验目的*"></a><strong>一、</strong> <em><strong>*实验目的*</strong></em></h1><p>了解鲁棒性内容感知哈希技术的基本特点，设计并实现基于 DCT 的鲁棒性图 </p><p>像感知哈希。了解鲁棒性内容感知哈希技术在数字内容保护中的作用，掌握基于 </p><p>鲁棒性感知哈希的内容保护方法</p><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 *实验内容*"></a><strong>二、</strong> <em><strong>*实验内容*</strong></em></h1><p>本实验实现一种基于视觉特性的图像感知哈希算法，可通过密钥控制哈希序 </p><p>列，保证安全性。</p><h1 id="三、-系统整体描述和分功能描述"><a href="#三、-系统整体描述和分功能描述" class="headerlink" title="三、 *系统整体描述和分功能描述*"></a><strong>三、</strong> <em><strong>*系统整体描述和分功能描述*</strong></em></h1><h2 id="系统整体描述"><a href="#系统整体描述" class="headerlink" title="*系统整体描述*"></a><em><strong>*系统整体描述*</strong></em></h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps23.jpg" alt="img"> </p><p>​    </p><h2 id="分功能描述"><a href="#分功能描述" class="headerlink" title="*分功能描述*"></a><em><strong>*分功能描述*</strong></em></h2><p>1）读入两幅图像，对图像做预处理</p><p>用到的函数rgb2gray()</p><p><a href="#buiz8mj-1-I">I</a> &#x3D; rgb2gray(<a href="#buiz8mj-1-RGB">RGB</a>) 将真彩色图像 RGB 转换为灰度图像 I。rgb2gray 函数通过消除色调和饱和度信息，同时保留亮度，来将 RGB 图像转换为灰度图。</p><p>2） 对标准化图像进行 8*8 子块划分</p><p>用到的函数imresize(Picture1,[64,64])</p><p><a href="#d124e713495">B</a> &#x3D; imresize(<a href="#d124e712839">A</a>,<a href="#d124e712884">scale</a>) 返回图像 B，它是将 A 的长宽大小缩放图像 scale 倍之后的图像。输入图像 A 可以是灰度图像、RGB 图像、二值图像或分类图像。</p><p>3） 依次对各子块进行二维离散余弦变换</p><p>用到的函数(Picture1,[8 8],fun)</p><p>对图像进行分块处理</p><p>4)通过密钥伪随机生成服从标准正态的、的 64*64 矩阵</p><p>用到的函数randn(‘state’,key)</p><p>返回一个从标准正态分布中得到的随机标量。</p><p>5）用高斯低通滤波器进行迭代滤波</p><p>用到的函数 fspecial(‘gaussian’)</p><p>创建具有指定 type 的二维滤波器</p><p>Y &#x3D; cell(1,Hashlen);</p><h1 id="四、-实验步骤、结果及分析"><a href="#四、-实验步骤、结果及分析" class="headerlink" title="四、 *实验步骤、结果及分析*"></a><strong>四、</strong> <em><strong>*实验步骤、结果及分析*</strong></em></h1><ol><li>读入两幅图像，对图像做预处理：如果读入的是彩色图像，将其转换为</li></ol><p>灰度图像（rgb2gray）；在灰度图像中利用差值方式将图像重采样为 64*64 </p><p>的标准化图表示（imresize） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Picture1 = rgb2gray(Picture1);  </span><br><span class="line">Picture2 = rgb2gray(Picture2); </span><br></pre></td></tr></table></figure><ol start="2"><li><p>对标准化图像进行 8<em>8 子块划分，将标准化图像划分为（64</em>64）&#x2F;（8*8）&#x3D;64 个子块，依次对各子块进行二维离散余弦变换1,1）置为 0； </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">% 对标准化图像进行 8*8 子块划分 </span><br><span class="line">Picture1 = imresize(Picture1,[64,64]); </span><br><span class="line">Picture2 = imresize(Picture2,[64,64]); </span><br><span class="line">% 依次对各子块进行二维离散余弦变换 </span><br><span class="line">fun = @dct2; </span><br><span class="line">Picture1 = blkproc(Picture1,[8 8],fun); </span><br><span class="line">Picture2 = blkproc(Picture2,[8 8],fun); </span><br><span class="line">% 并依次将各分块的 DC 系数，即（1,1）置为 0 </span><br><span class="line">Picture1(1,1) = 0; </span><br><span class="line">Picture2(1,1) = 0; </span><br></pre></td></tr></table></figure></li><li><p>生成 N 个 64*64 伪随机矩阵：首先通过密钥伪随机生成服从标准正态的、</p></li></ol><p>的 64*64 矩阵（randn(‘state’,key)，randn），然后用高斯低通滤波器 </p><p>进行迭代滤波（K&#x3D;fspecial(‘gaussian’); Y&#x3D;filter2(K,Y);） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">% 通过密钥伪随机生成服从标准正态的、的 64*64 矩阵 </span><br><span class="line">randn(&#x27;state&#x27;,key); </span><br><span class="line">N = cell(1,Hashlen); </span><br><span class="line">% 用高斯低通滤波器进行迭代滤波 </span><br><span class="line">K = fspecial(&#x27;gaussian&#x27;); </span><br><span class="line">Y = cell(1,Hashlen); </span><br><span class="line">for i = 1:Hashlen </span><br><span class="line"></span><br><span class="line">N&#123;i&#125; = randn(64); </span><br><span class="line">Y&#123;i&#125; = filter2(K,N&#123;i&#125;); </span><br><span class="line">end </span><br></pre></td></tr></table></figure><ol start="4"><li><p>设 DCT 敏感度矩阵 m，对矩阵 m 进行周期延拓得到大小为 64 ×64 的矩阵 M ,并将其每个元素作为 Ic 的对应位置频率系数在特征值计算中的权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% DCT敏感度矩阵m,周期延拓至64*64 </span><br><span class="line">m = [ </span><br><span class="line">71.43 99.01 86.21 60.24 41.67 29.16 20.88 15.24; </span><br><span class="line">99.01 68.97 75.76 65.79 50.00 36.90 27.25 20.28; </span><br><span class="line">86.21 75.76 44.64 38.61 33.56 27.47 21.74 17.01; </span><br><span class="line">60.24 65.79 38.61 26.53 21.98 18.87 15.92 13.16; </span><br><span class="line">41.67 50.00 33.56 21.98 16.26 13.14 11.48 9.83; </span><br><span class="line">29.16 36.90 27.47 18.87 13.14 10.40 8.64 7.40; </span><br><span class="line">20.88 27.25 21.74 15.92 11.48 8.64 6.90 5.78; </span><br><span class="line">15.24 20.28 17.01 13.16 9.83 7.40 5.78 4.73]; </span><br><span class="line">% 矩阵m进行周期延拓得到大小为64 ×64 的矩阵M </span><br><span class="line">M = repmat(m,8,8); </span><br><span class="line">P1_Hash = ones(1,Hashlen); </span><br><span class="line">P2_Hash = ones(1,Hashlen); </span><br></pre></td></tr></table></figure></li><li><p>取第一个伪随机矩阵，计算如果 YN &lt;0，则 H(n)&#x3D;0，反之则 H(n)&#x3D;1； </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">% 对Hashlen个伪随机矩阵遍历计算</span><br><span class="line">for k = 1:Hashlen</span><br><span class="line">    P1_sum = 0;</span><br><span class="line">    P2_sum = 0;</span><br><span class="line">    for i = 1:64</span><br><span class="line">        for j = 1:64</span><br><span class="line">            P1_sum = P1_sum + Picture1(i,j) * Y&#123;k&#125;(i,j) * M(i,j);</span><br><span class="line">            P2_sum = P2_sum + Picture2(i,j) * Y&#123;k&#125;(i,j) * M(i,j);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    if P1_sum &lt; 0</span><br><span class="line">        P1_Hash(k) = 0;</span><br><span class="line">    end</span><br><span class="line">    if P2_sum &lt; 0</span><br><span class="line">        P2_Hash(k) = 0;</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>循环第 5 步，直到将所有的 N 个 64*64 伪随机矩阵都计算完，最终生成</p></li></ol><p>一个 N 比特的 Hash 向量 </p><ol start="7"><li>比较两幅图像 hash 向量的汉明距离 dis，设定一个合适的阈值 tau，如</li></ol><p>果 dis&lt;tau，则两幅图像内容一致；反之则是内容不同的两幅图像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% 汉明距离</span><br><span class="line">dis = norm((P1_Hash-P2_Hash)/2*sqrt(norm(P1_Hash)*norm(P2_Hash)));</span><br></pre></td></tr></table></figure><ol start="8"><li>以 DemoImages 中的图片为测试集，分析实验结果。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% 与阈值比较</span><br><span class="line">if tau &lt; dis</span><br><span class="line">    ds = &#x27;不相似&#x27;;</span><br><span class="line">else</span><br><span class="line">    ds = &#x27;相似&#x27;;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>9.测试Tau和Hashlen的合理值</p><p>Hashlen所影响的是数据的精度，在合理范围内略微降低可以加快运行速率。</p><p>当Hashlen&#x3D;100时跑数据较快，从而固定Hashlen&#x3D;100，调试tau值。</p><p>Tau取值范围为（0,1）从而开始多次测试选取合适数值。</p><p>Tau&#x3D;0.5，结果正确，且多次试验稳定。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps24.jpg" alt="img"> </p><h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a><strong>实验结果及分析</strong></h2><p>运行脚本，对样本库进行比对</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps25.jpg" alt="img"> </p><p>比对结束后输出结果，结果正确</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps26.jpg" alt="img"> </p><h1 id="五、-实验中遇到的问题及改正的方法"><a href="#五、-实验中遇到的问题及改正的方法" class="headerlink" title="五、 *实验中遇到的问题及改正的方法*"></a><strong>五、</strong> <em><strong>*实验中遇到的问题及改正的方法*</strong></em></h1><p>1.不同版本的matlab支持的灰度处理函数不一样，需要选取对应版本的函数。</p>]]></content>
    
    
    <summary type="html">设计并实现基于 DCT 的鲁棒性图像感知哈希。了解鲁棒性内容感知哈希技术在数字内容保护中的作用，掌握基于鲁棒性感知哈希的内容保护方法</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数学建模实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>GAN 的生成器产生图片及换脸检测</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS2/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS2/</id>
    <published>2023-08-02T09:00:00.000Z</published>
    <updated>2023-08-02T09:55:46.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 *实验目的*"></a><strong>一、</strong> <em><strong>*实验目的*</strong></em></h1><p>（1） 掌握在 WINDOWS 下安装和使用 GAN 图片生成系统、换脸检测系统 </p><p>（2） 掌握 GAN 图片生成系统主要功能模块、换脸检测系统主要功能模块 </p><p>（3） GAN 图片生成系统的原理、换脸检测系统的原理</p><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 *实验内容*"></a><strong>二、</strong> <em><strong>*实验内容*</strong></em></h1><p>（1） 分析并调试 GAN 图片生成系统程序主要功能模块、换脸检测系统程序主要功能模块 </p><p>（2） 选取实验数据集 </p><p>（3） 运行 WINDOWS 下的 GAN 图片生成系统、换脸检测系统 </p><p>（4） 用 GAN 图片生成系统对实验数据集进行图片生成实验 </p><p>（5） 用换脸检测系统对实验数据集进行换脸检测实验</p><h1 id="三、-系统整体描述和分功能描述"><a href="#三、-系统整体描述和分功能描述" class="headerlink" title="三、 *系统整体描述和分功能描述*"></a><strong>三、</strong> <em><strong>*系统整体描述和分功能描述*</strong></em></h1><h2 id="系统整体描述"><a href="#系统整体描述" class="headerlink" title="*系统整体描述*"></a><em><strong>*系统整体描述*</strong></em></h2><p>DCGAN系统：</p><p>通过GAN来生成生成图片</p><p>Deepfakes CNN-Detection系统：</p><p>通过CNN算法对图像进行鉴别，辨别是否是伪造信息。</p><p>​    </p><h2 id="分功能描述"><a href="#分功能描述" class="headerlink" title="*分功能描述*"></a><em><strong>*分功能描述*</strong></em></h2><p>1）生成头像算法训练</p><p>建立图像样本库，用Python在动漫素材相关网站爬取或使用网络上已有的数据集，按照固定比例划分训练集和测试集，并对样本进行标准化处理，使图像大小保持，每一张图片拥有唯一ID。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps27.jpg" alt="img"> </p><p>其次，选择深度卷积网络，实现目标特征提取以及图像分类。使用Visdom实现训练过程的可视化，通过控制学习率、迭代次数、训练比例等参数，设置多组对照实验，观察实验结果并利用测试集进行多次测试。</p><p> python main.py train –gpu –vis&#x3D;False</p><p>2）生成动漫头像</p><p>使用训练好的生成模型，进行头像生成（说明文件给出的代码有误）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py generate --nogpu --vis=False --netd-path=checkpoints/netd_200.pth --netg-path=checkpoints/netg_200.pth --gen-img=result.png --gen-num=64</span><br></pre></td></tr></table></figure><p>3）检测功能，检测一张照片真伪</p><p>读取到照片后进行检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python demo.py -f examples/real.png -m weights/blur_jpg_prob0.5.pth</span><br></pre></td></tr></table></figure><p>4）批量检测功能</p><p>读取照片集进行检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py --name blur_jpg_prob0.5 --blur_prob 0.5 --blur_sig 0.0,3.0 --jpg_prob 0.5 --jpg_method cv2,pil --jpg_qual 30,100 --dataroot ./dataset/ --classes airplane,bird,bicycle,boat,bottle,bus,car,cat,cow,chair,diningtable,dog,person,pottedplant,motorbike,tvmonitor,train,sheep,sofa,horse</span><br></pre></td></tr></table></figure><h1 id="四、-实验步骤、结果及分析"><a href="#四、-实验步骤、结果及分析" class="headerlink" title="四、 *实验步骤、结果及分析*"></a><strong>四、</strong> <em><strong>*实验步骤、结果及分析*</strong></em></h1><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="*实验步骤*"></a><em><strong>*实验步骤*</strong></em></h2><p><strong>1.</strong> <em><strong>*安装PYcharm后配置环境*</strong></em></p><p>在命令行安装<a href="https://pytorch.org/">PyTorch</a></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps28.jpg" alt="img"> </p><p>安装其他支持文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps29.jpg" alt="img"> </p><p><strong>2.</strong> <em><strong>*准备数据*</strong></em></p><p>在老师给的压缩包中已经包含了准备好的数据。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps30.jpg" alt="img"> </p><p><strong>3.</strong> <em><strong>*通过已有数据进行训练*</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py train --gpu --vis=False</span><br></pre></td></tr></table></figure><p>这个过程比较慢，可以尝试使用训练好的数据（已在压缩包中给出）</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps31.jpg" alt="img"> </p><p>或者选择自己跑数据训练</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps32.jpg" alt="img"><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps33.jpg" alt="img"> </p><p><strong>4.</strong> <em><strong>*训练完成后即可生成图片*</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py generate --nogpu --vis=False --netd-path=checkpoints/netd_200.pth --netg-path=checkpoints/netg_200.pth --gen-img=result.png --gen-num=64</span><br></pre></td></tr></table></figure><p>生成结果会储存在DCGAN文件夹下，可根据修改日期看出是新生成的图片。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps34.jpg" alt="img"> </p><p>生成结果如下</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps35.jpg" alt="img"> </p><p>第一个实验到此结束。</p><p><strong>5.</strong> <em><strong>*配置Deepfakes CNN-Detection实验环境*</strong></em></p><p>基本不用发生更改，在第一次配置时已经完成</p><p><strong>6.</strong> <em><strong>*尝试运行一张图片，并检测真假*</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python demo.py -f examples/real.png -m weights/blur_jpg_prob0.5.pth</span><br><span class="line"></span><br><span class="line">python demo.py -f examples/fake.png -m weights/blur_jpg_prob0.5.pth</span><br></pre></td></tr></table></figure><p>其中真照片运行结果如下</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps36.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps37.jpg" alt="img"> </p><p>其中假照片运行结果如下</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps38.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps39.jpg" alt="img"> </p><p>尝试运行数据集检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python demo_dir.py -d examples/realfakedir -m weights/blur_jpg_prob0.5.pth</span><br></pre></td></tr></table></figure><p>尝试跑自己的数据集，效果并不好（已在后文中说明）</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps40.jpg" alt="img"> </p><p>跑老师给的数据集（airplane）</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps41.jpg" alt="img"> </p><ol start="7"><li>对数据集进行检测</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python eval.py --no_crop --batch_size 1</span><br></pre></td></tr></table></figure><p>实验二结束。</p><h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a><strong>实验结果及分析</strong></h2><ol><li>在实验一中进行多次实验，可以看出每次生成结果都不同。</li></ol><p>但仿真程度都不是很高</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps42.jpg" alt="img"> <img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps43.jpg" alt="img"> <img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps44.jpg" alt="img"></p><p>2.在实验二的单张检测中可以尝试对实验一的生成图片进行检测。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps45.jpg" alt="img"> </p><p>首先对总生成结果进行检测，由于其中元素较多识别出错，程旭认为其为真实图片。</p><p>但从中截取一幅生成图片进行检测，这次检测结果正确。</p><p>说明可以正确检验真伪。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps46.jpg" alt="img"> </p><p>3.使用另一种权重进行实验</p><p>对比实验可以看出二者之间的差别，0.1版本的准确度更高一些</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps47.jpg" alt="img"> </p><p>4.对数据集进行检验</p><p>老师给的数据集过大，因此在检测时选取了一个比对的数据集。</p><p>对airplane数据集进行测试，测试成功。准确率很高</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps48.jpg" alt="img"> </p><h1 id="五、-实验中遇到的问题及改正的方法"><a href="#五、-实验中遇到的问题及改正的方法" class="headerlink" title="五、 *实验中遇到的问题及改正的方法*"></a><strong>五、</strong> <em><strong>*实验中遇到的问题及改正的方法*</strong></em></h1><ol><li>在安装其他支持文件时经常安装失败，这里可以提供三种安装方法</li></ol><p>首先尝试直接使用命令pip install -r requirements.txt安装，如报连接失败错误可以尝试挂梯子再次链接。</p><p>其次可以尝试在Pycharm中单个添加。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps49.jpg" alt="img"> </p><p>如果上述方法都不可行，只能在官网或镜像站逐一下载，最后将其手动安装。</p><p>2.老师给的数据集过大，因此在检测时选取了一个deepfake人脸生成比对的数据集。</p><p>在测试前准备选取一真一假两张照片进行单张实验观察结果。由于deepfake技术效果比较好，比对结果显示为二者都为真的概率比较高。</p><p>这两张图片为：其中左图为真</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps50.png" alt="img">df0.jpg   <img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps51.png" alt="img">df1.jpg</p><p>进行检测的结果显示</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps52.jpg" alt="img"> </p><p>虽可以看出伪造成分，但无法证明右图为伪造图片。</p><p>其后更改算法权重为另一版本，效果略有升高。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps53.jpg" alt="img"> </p><p>但仍然达到不了50%以上，无法证明图片为伪造。</p>]]></content>
    
    
    <summary type="html">运行 WINDOWS 下的 GAN 图片生成系统、换脸检测系统；用换脸检测系统对实验数据集进行换脸检测实验</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>垃圾邮件过滤系统</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS3/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS3/</id>
    <published>2023-08-02T09:00:00.000Z</published>
    <updated>2023-08-02T09:57:46.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 *实验目的*"></a><strong>一、</strong> <em><strong>*实验目的*</strong></em></h1><p>（1） 掌握在 WINDOWS 下安装和使用垃圾邮件过滤系统 </p><p>（2） 掌握垃圾邮件过滤系统主要功能模块 </p><p>（3） 文本内容过滤的原理</p><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 *实验内容*"></a><strong>二、</strong> <em><strong>*实验内容*</strong></em></h1><p>（1） 分析并调试垃圾邮件过滤系统程序主要功能模块 </p><p>（2） 选取实验数据集 </p><p>（3） 运行 WINDOWS 下的垃圾邮件过滤系统 </p><p>（4） 用垃圾邮件过滤系统对实验数据集进行过滤实验</p><h1 id="三、-系统整体描述和分功能描述"><a href="#三、-系统整体描述和分功能描述" class="headerlink" title="三、 *系统整体描述和分功能描述*"></a><strong>三、</strong> <em><strong>*系统整体描述和分功能描述*</strong></em></h1><h2 id="系统整体描述"><a href="#系统整体描述" class="headerlink" title="*系统整体描述*"></a><em><strong>*系统整体描述*</strong></em></h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps54.jpg" alt="img"> </p><p>​    </p><h2 id="分功能描述"><a href="#分功能描述" class="headerlink" title="*分功能描述*"></a><em><strong>*分功能描述*</strong></em></h2><p>1）预测结果</p><p>首先要获得词典。如果列表中的词已在词典中，则加1，否则添加进去。通过计算每个文件中p(s|w)来得到对分类影响最大的15个词。随后计算贝叶斯概率，再计算预测结果正确率。</p><p>用到自定义函数</p><p>SpamEmailBayes()</p><p>2）计算贝叶斯概率</p><p> 计算在已知词向量$w&#x3D;(w_1,w_2,…,w_n)$的条件下求包含该词向量邮件是否为垃圾邮件的概率</p><p>用到的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calBayes</span>(<span class="params">self, wordList, spamdict, normdict</span>):</span><br><span class="line">  ps_w = <span class="number">1</span></span><br><span class="line">  ps_n = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> word, prob <span class="keyword">in</span> wordList.items():</span><br><span class="line">    <span class="built_in">print</span>(word + <span class="string">&quot;/&quot;</span> + <span class="built_in">str</span>(prob))</span><br><span class="line">    ps_w *= (prob)</span><br><span class="line">    ps_n *= (<span class="number">1</span> - prob)</span><br><span class="line">  p = ps_w / (ps_w + ps_n)</span><br><span class="line">  \<span class="comment">#     print(str(ps_w)+&quot;////&quot;+str(ps_n))</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><p>3）通过计算每个文件中p(s|w)来得到对分类影响最大的15个词</p><p>用到的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getTestWords</span>(<span class="params">self, testDict, spamDict, normDict, normFilelen, spamFilelen</span>):</span><br><span class="line">  wordProbList = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> word, num <span class="keyword">in</span> testDict.items():</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">in</span> spamDict.keys() <span class="keyword">and</span> word <span class="keyword">in</span> normDict.keys():</span><br><span class="line">      \<span class="comment"># 该文件中包含词个数</span></span><br><span class="line">      pw_s = spamDict[word] / spamFilelen</span><br><span class="line">      pw_n = normDict[word] / normFilelen</span><br><span class="line">      ps_w = pw_s / (pw_s + pw_n)</span><br><span class="line">      wordProbList.setdefault(word, ps_w)</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">in</span> spamDict.keys() <span class="keyword">and</span> word <span class="keyword">not</span> <span class="keyword">in</span> normDict.keys():</span><br><span class="line">      pw_s = spamDict[word] / spamFilelen</span><br><span class="line">      pw_n = <span class="number">0.01</span></span><br><span class="line">      ps_w = pw_s / (pw_s + pw_n)</span><br><span class="line">      wordProbList.setdefault(word, ps_w)</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> spamDict.keys() <span class="keyword">and</span> word <span class="keyword">in</span> normDict.keys():</span><br><span class="line">      pw_s = <span class="number">0.01</span></span><br><span class="line">      pw_n = normDict[word] / normFilelen</span><br><span class="line">      ps_w = pw_s / (pw_s + pw_n)</span><br><span class="line">      wordProbList.setdefault(word, ps_w)</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> spamDict.keys() <span class="keyword">and</span> word <span class="keyword">not</span> <span class="keyword">in</span> normDict.keys():</span><br><span class="line">      \<span class="comment"># 若该词不在脏词词典中，概率设为0.4</span></span><br><span class="line">      wordProbList.setdefault(word, <span class="number">0.4</span>)</span><br><span class="line">  <span class="built_in">sorted</span>(wordProbList.items(), key=<span class="keyword">lambda</span> d: d[<span class="number">1</span>], reverse=<span class="literal">True</span>)[<span class="number">0</span>:<span class="number">15</span>]</span><br><span class="line">  <span class="keyword">return</span> (wordProbList)</span><br></pre></td></tr></table></figure><h1 id="四、-实验步骤、结果及分析"><a href="#四、-实验步骤、结果及分析" class="headerlink" title="四、 *实验步骤、结果及分析*"></a><strong>四、</strong> <em><strong>*实验步骤、结果及分析*</strong></em></h1><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="*实验步骤*"></a><em><strong>*实验步骤*</strong></em></h2><p>1.配置相应实验环境</p><p>不报错即可</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps55.jpg" alt="img"> </p><p>2.运行成功</p><p>显示准确度为0.951530612244898</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps56.jpg" alt="img"> </p><p>实验结果及分析</p><p>运行后会返回关键词出现频率等信息</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps57.jpg" alt="img"> </p><p>最后返回本次运行的准确率</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps58.jpg" alt="img"> </p><h1 id="五、-实验中遇到的问题及改正的方法"><a href="#五、-实验中遇到的问题及改正的方法" class="headerlink" title="五、 *实验中遇到的问题及改正的方法*"></a><strong>五、</strong> <em><strong>*实验中遇到的问题及改正的方法*</strong></em></h1><p>本次实验未遇到操作问题</p>]]></content>
    
    
    <summary type="html">了解文本内容过滤的原理，在 WINDOWS 下安装和使用垃圾邮件过滤系统</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>图像差分隐私保护方案实验</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS4/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS4/</id>
    <published>2023-08-02T09:00:00.000Z</published>
    <updated>2023-08-02T10:02:27.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 *实验目的*"></a><strong>一、</strong> <em><strong>*实验目的*</strong></em></h1><p>了解差分隐私技术的基本特点，设计并实现基于离散傅立叶变换（DFT）的图像差分隐私保护算法。了解差分隐私技术在数字内容保护中的作用，掌握基于差分隐私的内容隐私保护方法。</p><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 *实验内容*"></a><strong>二、</strong> <em><strong>*实验内容*</strong></em></h1><p>本实验实现一种基于离散傅立叶变换的图像差分隐私保护算法，可通过隐私预算控制噪声规模，保证隐私安全性，具体过程如下：</p><ol><li>读入一幅图像，对图像做预处理：如果读入的是彩色图像，将其转换为灰度图像（rgb2gray）；在灰度图像中利用差值方式将图像重采样为128*128的标准化图表示（imresize）IM；</li><li>对标准化图像IM进行离散傅立叶变换，得到离散傅立叶变换矩阵FIM；</li><li>对离散傅立叶变换矩阵FIM，选取其前k×k个DFT系数，计算给定隐私预算<code>ε</code>时的拉普拉斯机制的参数<code>λ</code>的最小值，以确定拉普拉斯机制需要添加的噪声；</li><li>对离散傅立叶变换矩阵FIM，采样一组概率p，在参数<code>λ</code>最小时，计算相应的噪声值，以及融合噪声后的FIM’；</li><li>对于FIM和FIM’，分别输入PCA+SVM的人脸识别程序中进行人脸识别分类预测。</li><li>给出整个数据集上，人脸识别分类预测的准确率(Accuracy，测试集中分类器正确分类的样本数与总样本数之比)。</li><li>以LFW中随机80%的图片为训练集，剩余为测试集，分析实验结果。</li><li>关于实验报告</li></ol><p>（1）关于<code>ε</code>的选取，是一个经验值，其选取依据是根据测试集的准确率决定，给出选取过程。</p><p>（2）关于k的选取，k值越大噪声越大,隐私安全性越强，但对人脸识别任务的鲁棒性会降低,因而需设定合适的k值，以满足隐私保护的人脸图像在识别精度和隐私性之间的折衷，给出选取过程。</p><h1 id="三、-系统整体描述和分功能描述"><a href="#三、-系统整体描述和分功能描述" class="headerlink" title="三、 *系统整体描述和分功能描述*"></a><strong>三、</strong> <em><strong>*系统整体描述和分功能描述*</strong></em></h1><h2 id="系统整体描述"><a href="#系统整体描述" class="headerlink" title="*系统整体描述*"></a><em><strong>*系统整体描述*</strong></em></h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps63.jpg" alt="img"> </p><p>​    </p><h2 id="分功能描述"><a href="#分功能描述" class="headerlink" title="*分功能描述*"></a><em><strong>*分功能描述*</strong></em></h2><p>1）图像做预处理</p><p>如果是彩色图像，转换为灰度图像</p><p>将图像重采样为128×128的标准化图像</p><p>用到的函数：def preprocess_image(image)</p><p>2）对图像做离散傅立叶变换</p><p>对图像做离散傅立叶变换，并将结果移动到中心</p><p>选取中心的k×k个系数，并返回它们的幅度和相位</p><p>用到的函数：def dft_image(image)</p><p>3）生成一个服从标准均匀分布的随机数组</p><p>根据拉普拉斯分布的逆变换公式，计算噪声值</p><p>用到的函数：def laplace_noise(shape, b)</p><p>4）对离散傅立叶变换的系数添加拉普拉斯噪声，并还原图像</p><p>根据给定的隐私预算，计算拉普拉斯机制的参数b的最小值</p><p>采样一组概率p，决定是否添加噪声</p><p>计算相应的噪声值，并添加到幅度上</p><p>将幅度和相位合并为复数矩阵</p><p>进行逆离散傅立叶变换</p><p>取实部作为还原后的图像</p><p>用到的函数：def idft_image(magnitude_k, phase_k)</p><p>5）读取数据集中的图像，并返回一个列表和一个标签数组</p><p>遍历数据集中的每个文件夹，每个文件夹代表一个类别</p><p>将文件夹的名字转换为整数作为标签遍历每个文件夹中的每个图像文件</p><p>对图像做预处理</p><p>将图像添加到列表中</p><p>将标签添加到数组中</p><p>用到的函数：def read_dataset(path)</p><p>6）将图像列表转换为特征矩阵，并返回一个训练集和一个测试集</p><p> 将图像列表转换为特征矩阵，每个图像的DFT系数作为一行</p><p>将幅度矩阵展平为一维数组</p><p>利用sklearn的train_test_split函数，按照给定的比例划分训练集和测试集</p><p>用到的函数：def split_dataset(images, labels, test_ratio&#x3D;0.2)</p><p>7）利用PCA和SVM进行人脸识别，并返回准确率</p><p>利用sklearn的PCA模块，对特征矩阵进行降维，保留95%的方差</p><p>利用sklearn的SVM模块，对降维后的特征进行分类，使用线性核函数和默认参数 </p><p>利用sklearn的metrics模块，计算分类的准确率</p><p>用到的函数：def face_recognition(X_train, X_test, y_train, y_test)</p><h1 id="四、-实验步骤、结果及分析"><a href="#四、-实验步骤、结果及分析" class="headerlink" title="四、 *实验步骤、结果及分析*"></a><strong>四、</strong> <em><strong>*实验步骤、结果及分析*</strong></em></h1><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="*实验步骤*"></a><em><strong>*实验步骤*</strong></em></h2><ol><li>下载win10虚拟机</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps64.jpg" alt="img"> </p><ol start="2"><li>开机后安装conda</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps65.jpg" alt="img"> </p><p>Conda安装好后检查版本</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps66.jpg" alt="img"> </p><p>配置好conda和pycharm</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps67.jpg" alt="img"> </p><p>因为环境配置出现了一些问题，没有使用已给的检测模型，自己进行编写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一些常量</span></span><br><span class="line">k = <span class="number">10</span> <span class="comment"># 选取前k×k个DFT系数</span></span><br><span class="line">p = <span class="number">0.5</span> <span class="comment"># 采样概率</span></span><br><span class="line">epsilon = <span class="number">0.1</span> <span class="comment"># 隐私预算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，对图像做预处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess_image</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 如果是彩色图像，转换为灰度图像</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(image.shape) == <span class="number">3</span>:</span><br><span class="line">        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 将图像重采样为128×128的标准化图像</span></span><br><span class="line">    image = cv2.resize(image, (<span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，对图像做离散傅立叶变换，并选取前k×k个系数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dft_image</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 对图像做离散傅立叶变换，并将结果移动到中心</span></span><br><span class="line">    f = np.fft.fft2(image)</span><br><span class="line">    fshift = np.fft.fftshift(f)</span><br><span class="line">    <span class="comment"># 选取中心的k×k个系数，并返回它们的幅度和相位</span></span><br><span class="line">    rows, cols = fshift.shape</span><br><span class="line">    crow, ccol = rows//<span class="number">2</span>, cols//<span class="number">2</span></span><br><span class="line">    fshift_k = fshift[crow-k//<span class="number">2</span>:crow+k//<span class="number">2</span>, ccol-k//<span class="number">2</span>:ccol+k//<span class="number">2</span>]</span><br><span class="line">    magnitude_k = np.<span class="built_in">abs</span>(fshift_k)</span><br><span class="line">    phase_k = np.angle(fshift_k)</span><br><span class="line">    <span class="keyword">return</span> magnitude_k, phase_k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义laplace_noise函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">laplace_noise</span>(<span class="params">shape, b</span>):</span><br><span class="line">    <span class="comment"># 生成一个服从标准均匀分布的随机数组</span></span><br><span class="line">    u = np.random.uniform(-<span class="number">0.5</span>, <span class="number">0.5</span>, size=shape)</span><br><span class="line">    <span class="comment"># 根据拉普拉斯分布的逆变换公式，计算噪声值</span></span><br><span class="line">    noise = -b * np.sign(u) * np.log(<span class="number">1</span> - <span class="number">2</span> * np.<span class="built_in">abs</span>(u))</span><br><span class="line">    <span class="keyword">return</span> noise</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，对离散傅立叶变换的系数添加拉普拉斯噪声，并还原图像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">idft_image</span>(<span class="params">magnitude_k, phase_k</span>):</span><br><span class="line">    <span class="comment"># 根据给定的隐私预算，计算拉普拉斯机制的参数b的最小值</span></span><br><span class="line">    b_min = magnitude_k.size / epsilon</span><br><span class="line">    <span class="comment"># 采样一组概率p，决定是否添加噪声</span></span><br><span class="line">    mask = np.random.binomial(<span class="number">1</span>, p, size=magnitude_k.shape)</span><br><span class="line">    <span class="comment"># 计算相应的噪声值，并添加到幅度上</span></span><br><span class="line">    noise = np.random.laplace(<span class="number">0</span>, b_min, size=magnitude_k.shape)</span><br><span class="line">    magnitude_k_noisy = magnitude_k + mask * noise</span><br><span class="line">    <span class="comment"># 将幅度和相位合并为复数矩阵</span></span><br><span class="line">    complex_k_noisy = magnitude_k_noisy * np.exp(<span class="number">1j</span> * phase_k)</span><br><span class="line">    <span class="comment"># 进行逆离散傅立叶变换</span></span><br><span class="line">    image_noisy = np.fft.ifft2(complex_k_noisy)</span><br><span class="line">    <span class="comment"># 取实部作为还原后的图像</span></span><br><span class="line">    image_noisy = np.real(image_noisy)</span><br><span class="line">    <span class="keyword">return</span> image_noisy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，读取数据集中的图像，并返回一个列表和一个标签数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_dataset</span>(<span class="params">path</span>):</span><br><span class="line">    images = [] <span class="comment"># 存储图像的列表</span></span><br><span class="line">    labels = [] <span class="comment"># 存储标签的数组</span></span><br><span class="line">    <span class="keyword">for</span> folder <span class="keyword">in</span> os.listdir(path): <span class="comment"># 遍历数据集中的每个文件夹，每个文件夹代表一个类别</span></span><br><span class="line">        label = <span class="built_in">int</span>(folder) <span class="comment"># 将文件夹的名字转换为整数作为标签</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(os.path.join(path, folder)): <span class="comment"># 遍历每个文件夹中的每个图像文件</span></span><br><span class="line">            image = cv2.imread(os.path.join(path, folder, file)) <span class="comment"># 读取图像文件</span></span><br><span class="line">            image = preprocess_image(image) <span class="comment"># 对图像做预处理</span></span><br><span class="line">            images.append(image) <span class="comment"># 将图像添加到列表中</span></span><br><span class="line">            labels.append(label) <span class="comment"># 将标签添加到数组中</span></span><br><span class="line">    <span class="keyword">return</span> images, np.array(labels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，将图像列表转换为特征矩阵，并返回一个训练集和一个测试集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_dataset</span>(<span class="params">images, labels, test_ratio=<span class="number">0.2</span></span>):</span><br><span class="line">    <span class="comment"># 将图像列表转换为特征矩阵，每个图像的DFT系数作为一行</span></span><br><span class="line">    features = []</span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> images:</span><br><span class="line">        magnitude_k, phase_k = dft_image(image)</span><br><span class="line">        feature = magnitude_k.flatten() <span class="comment"># 将幅度矩阵展平为一维数组</span></span><br><span class="line">        features.append(feature)</span><br><span class="line">    features = np.array(features)</span><br><span class="line">    <span class="comment"># 利用sklearn的train_test_split函数，按照给定的比例划分训练集和测试集</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=test_ratio, random_state=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, X_test, y_train, y_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，利用PCA和SVM进行人脸识别，并返回准确率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">face_recognition</span>(<span class="params">X_train, X_test, y_train, y_test</span>):</span><br><span class="line">    <span class="comment"># 利用sklearn的PCA模块，对特征矩阵进行降维，保留95%的方差</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">    pca = PCA(n_components=<span class="number">0.95</span>)</span><br><span class="line">    pca.fit(X_train)</span><br><span class="line">    X_train_pca = pca.transform(X_train)</span><br><span class="line">    X_test_pca = pca.transform(X_test)</span><br><span class="line">    <span class="comment"># 利用sklearn的SVM模块，对降维后的特征进行分类，使用线性核函数和默认参数</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">    svm = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">    svm.fit(X_train_pca, y_train)</span><br><span class="line">    y_pred = svm.predict(X_test_pca)</span><br><span class="line">    <span class="comment"># 利用sklearn的metrics模块，计算分类的准确率</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line">    accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line">    <span class="keyword">return</span> accuracy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取数据集中的图像和标签</span></span><br><span class="line">    images = []</span><br><span class="line">    labels = []</span><br><span class="line"></span><br><span class="line">    dataset_path = <span class="string">r&#x27;C:\data\study\second_done\number_safe\exercise4\lfwp\Abel_Pacheco&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(dataset_path):</span><br><span class="line">        image_path = os.path.join(dataset_path, filename)</span><br><span class="line">        label = filename.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 使用文件名作为图像标签</span></span><br><span class="line">        image = cv2.imread(image_path)  <span class="comment"># 读取图像</span></span><br><span class="line">        images.append(image)</span><br><span class="line">        labels.append(label)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分训练集和测试集，按照80%和20%的比例</span></span><br><span class="line">    X_train, X_test, y_train, y_test = split_dataset(images, labels, test_ratio=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对测试集中的每个图像，添加拉普拉斯噪声，并还原为图像</span></span><br><span class="line">    images_noisy = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_test)):</span><br><span class="line">        image = X_test[i]  <span class="comment"># 原始图像</span></span><br><span class="line">        magnitude_k, phase_k = dft_image(image)  <span class="comment"># DFT系数</span></span><br><span class="line">        image_noisy = idft_image(magnitude_k, phase_k)  <span class="comment"># 带噪声的图像</span></span><br><span class="line">        images_noisy.append(image_noisy)</span><br><span class="line">    images_noisy = np.array(images_noisy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分训练集和测试集，使用带噪声的图像作为测试集，按照80%和20%的比例</span></span><br><span class="line">    X_train_noisy, X_test_noisy, y_train_noisy, y_test_noisy = split_dataset(images_noisy, labels, test_ratio=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行人脸识别，分别使用原始图像和带噪声的图像，并打印准确率</span></span><br><span class="line">    accuracy_original = face_recognition(X_train, X_test, y_train, y_test)</span><br><span class="line">    accuracy_noisy = face_recognition(X_train_noisy, X_test_noisy, y_train_noisy, y_test_noisy)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;人脸识别分类预测的准确率为:&#123;:.2f&#125;%&#x27;</span>.<span class="built_in">format</span>(accuracy_original * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 读取数据集中的图像和标签</span></span><br><span class="line">    <span class="comment"># images, labels = read_dataset(&#x27;dataset&#x27;)</span></span><br><span class="line">    <span class="comment"># # 划分训练集和测试集，按照80%和20%的比例</span></span><br><span class="line">    <span class="comment"># X_train, X_test, y_train, y_test = split_dataset(images, labels, test_ratio=0.2)</span></span><br><span class="line">    <span class="comment"># # 对测试集中的每个图像，添加拉普拉斯噪声，并还原为图像</span></span><br><span class="line">    <span class="comment"># images_noisy = []</span></span><br><span class="line">    <span class="comment"># for i in range(len(X_test)):</span></span><br><span class="line">    <span class="comment">#     image = images[i] # 原始图像</span></span><br><span class="line">    <span class="comment">#     magnitude_k, phase_k = dft_image(image) # DFT系数</span></span><br><span class="line">    <span class="comment">#     image_noisy = idft_image(magnitude_k, phase_k) # 带噪声的图像</span></span><br><span class="line">    <span class="comment">#     images_noisy.append(image_noisy)</span></span><br><span class="line">    <span class="comment"># images_noisy = np.array(images_noisy)</span></span><br><span class="line">    <span class="comment"># # 划分训练集和测试集，使用带噪声的图像作为测试集，按照80%和20%的比例</span></span><br><span class="line">    <span class="comment"># X_train_noisy, X_test_noisy, y_train_noisy, y_test_noisy = split_dataset(images_noisy, labels, test_ratio=0.2)</span></span><br><span class="line">    <span class="comment"># # 进行人脸识别，分别使用原始图像和带噪声的图像，并打印准确率</span></span><br><span class="line">    <span class="comment"># accuracy_original = face_recognition(X_train, X_test, y_train, y_test)</span></span><br><span class="line">    <span class="comment"># accuracy_noisy = face_recognition(X_train_noisy, X_test_noisy, y_train_noisy, y_test_noisy)</span></span><br><span class="line">    <span class="comment"># print(&#x27;原始图像的人脸识别准确率为：&#123;:.2f&#125;%&#x27;.format)</span></span><br></pre></td></tr></table></figure><h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a><strong>实验结果及分析</strong></h2><p>对检测图片集进行运行</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps68.jpg" alt="img"> </p><p>运行一段时间后反馈运行结果</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps69.jpg" alt="img"> </p><p>可以看见反馈结果精准</p>]]></content>
    
    
    <summary type="html">设计并实现基于离散傅立叶变换（DFT）的图像差分隐私保护算法。</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>面向内容保护的区块链系统实验</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS5/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS5/</id>
    <published>2023-08-02T09:00:00.000Z</published>
    <updated>2023-08-02T10:50:35.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 *实验目的*"></a><strong>一、</strong> <em><strong>*实验目的*</strong></em></h1><p>（1） 掌握在Linux下安装和使用版权保护区块链系统</p><p>（2） 掌握版权保护区块链系统主要功能模块</p><p>（3） 区块链的原理</p><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 *实验内容*"></a><strong>二、</strong> <em><strong>*实验内容*</strong></em></h1><p>（1） 分析并调试版权保护区块链系统程序主要功能模块</p><p>（2） 选取测试实验数据（txt文本、mp3音频、jpg图像）</p><p>（3） 运行Linux下的版权保护区块链系统</p><p>（4） 用版权保护区块链系统对实验测试数据提取版权信息进行不重复的上链。</p><h1 id="三、-系统整体描述和分功能描述"><a href="#三、-系统整体描述和分功能描述" class="headerlink" title="三、 *系统整体描述和分功能描述*"></a><strong>三、</strong> <em><strong>*系统整体描述和分功能描述*</strong></em></h1><h2 id="系统整体描述"><a href="#系统整体描述" class="headerlink" title="*系统整体描述*"></a><em><strong>*系统整体描述*</strong></em></h2><p>BitRights系统实现了基于区块链的数字版权保护概念验证。用户上传媒体文件，并永久声明其作品的所有权。网络上的任何人都可以查看已发表的作品并验证作者的正确性。此外，系统会检测上传作品与已发表作品是否过于相似，并进行禁止。目前支持音频、图像和文本文件。</p><p>每当用户上传文件时，一个新的区块就会被添加到区块链中。该块包含作品的标题、作者、下载文件的路径&#x2F;链接、文件的哈希值、作者的公钥、时间戳和前一个块的哈希值。其中使用文件的散列而不是原始数据来保持块大小较小。同时其中包含的公钥可以使作者知道相应的密钥，从而证明所有权。与任何区块链一样，前一个区块的哈希值允许用户验证该链是否未被篡改。</p><p>​    </p><h2 id="分功能描述"><a href="#分功能描述" class="headerlink" title="*分功能描述*"></a><em><strong>*分功能描述*</strong></em></h2><p>1）Blockchain上链</p><p>用来实现整个系统中所有交易数据的网络的概念。包含了一系列方法和属性，用于管理和操作区块链。该类可以包括创建新的区块、添加交易数据到区块链、验证区块的有效性、搜索特定的交易等功能。</p><p>2）verify_block(self, block)</p><p>这段代码通过迭代self.chain中的每个块来验证新块block的原创性。它首先检查新块和每个先前块的genre是否相同。然后，根据genre的类型执行相应的检查。</p><p>如果genre为Audio，则调用ac.calc_accuracy函数计算新块和先前块音频文件的相似度得分score。如果相似度得分大于0.9，表示新块的音频文件与先前块的音频文件相似度过高，返回0表示验证失败。</p><p>如果genre为Text，则调用tc.check_text_similarity函数检查新块和先前块文本文件的相似度得分score。如果相似度得分小于100，表示新块的文本文件与先前块的文本文件相似度过低，返回0表示验证失败。</p><p>如果genre为Image，则调用ic.calc_accuracy函数计算新块和先前块图像文件的相似度得分score。如果相似度得分小于0.4，表示新块的图像文件与先前块的图像文件相似度过低，返回0表示验证失败。</p><p>3）lookup(self, transaction)</p><p>这段代码通过迭代 self.chain 中的每个块来查找与给定交易数据 transaction 相关的先前块。它首先检查每个先前块的 genre 是否与给定交易的 genre 相同。然后，根据 genre 的类型执行相应的检查。</p><p>如果 genre 为 Audio，则调用 ac.calc_accuracy 函数计算给定交易的音频文件与先前块音频文件之间的相似度得分 score。如果相似度得分大于0.9，表示给定交易的音频文件与先前块的音频文件相似度过高，直接返回该先前块。</p><p>如果 genre 为 Text，则调用 tc.check_text_similarity 函数检查给定交易的文本文件与先前块文本文件之间的相似度得分 score。如果相似度得分小于100，表示给定交易的文本文件与先前块的文本文件相似度过低，直接返回该先前块。</p><p>如果 genre 为 Image，则调用 ic.calc_accuracy 函数计算给定交易的图像文件与先前块图像文件之间的相似度得分 score。如果相似度得分小于0.4，表示给定交易的图像文件与先前块的图像文件相似度过低，直接返回该先前块。</p><p>4）upload()</p><p>检查请求中是否包含名为 contentFile 的文件。如果没有该文件，返回一个带有错误信息的 JSON 响应。</p><p>接下来从请求中获取 contentFile 文件，并将其存储在变量 file 中。</p><p>根据请求中的 action 值进行不同的操作。如果 action 是 “lookup”，表示进行查找操作。它将上传的文件保存在临时文件夹中，并构建一个包含了文件的信息的字典 lookup_media。然后，调用 blockchain.lookup 方法来查找与该文件相关的先前块。如果找不到匹配的先前块，响应中的 unique 属性将为 True，表示该文件是唯一的。如果找到了匹配的先前块，响应中的 unique 属性将为 False，同时返回匹配的块信息和一条附加消息。</p><p>如果 action 是 “publish”，表示进行发布操作，即将文件添加到区块链中。</p><p>如果 action 不是 “lookup” 也不是 “publish”，则默认将文件保存到上传文件夹中。</p><p>最后，根据不同的响应结果，使用 jsonify 方法将响应转换为 JSON 格式，并返回 HTTP 状态码 200 表示成功。</p><h1 id="四、-实验步骤、结果及分析"><a href="#四、-实验步骤、结果及分析" class="headerlink" title="四、 *实验步骤、结果及分析*"></a><strong>四、</strong> <em><strong>*实验步骤、结果及分析*</strong></em></h1><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="*实验步骤*"></a><em><strong>*实验步骤*</strong></em></h2><ol><li>打开kali虚拟机</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps70.jpg" alt="img"> </p><ol start="2"><li>检查python版本号</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps71.jpg" alt="img"> </p><ol start="3"><li>sh文件内容运行失败，选择手动运行</li></ol><p>下载virtualenv</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps72.jpg" alt="img"> </p><p>再次运行install.sh</p><p>下载还是失败，挂一下清华源</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps73.jpg" alt="img"> </p><p>再次尝试，下载的很快</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps74.jpg" alt="img"> </p><p>但python版本不对，和软件包不兼容。</p><p>改用Anaconda，放弃编译环境了。</p><p>安装Anaconda</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps75.jpg" alt="img"> </p><p>安装完成</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps76.jpg" alt="img"> </p><p>随后再环境中安装软件包。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps77.jpg" alt="img"> </p><p>4.安装差不多了，仍然有安不上的</p><p>先运行一下程序试试</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps78.jpg" alt="img"><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps79.jpg" alt="img"> </p><p>安装报错所需要的文件包</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps80.jpg" alt="img"><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps81.jpg" alt="img"> </p><p>对于较为麻烦的image-match选择直接从github下载源文件安装</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps82.jpg" alt="img"> </p><p>5.程序运行成功</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps83.jpg" alt="img"> </p><p>可以打开网页界面</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps84.jpg" alt="img"> </p><p>但后续发现需要使用gpg生成密钥</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps85.jpg" alt="img"> </p><p>6.再去安装gpg</p><p>升级apt</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps86.jpg" alt="img"> </p><p>安装gog后生成密钥</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps87.jpg" alt="img"> </p><p>设置密码12345678</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps88.jpg" alt="img"> </p><p>证书生成完毕</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps89.jpg" alt="img"> </p><p>输入密钥</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps90.jpg" alt="img"> </p><p>上传成功</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps91.jpg" alt="img"> </p><h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a><strong>实验结果及分析</strong></h2><p>1.在实验过程基础上又上传了一个mp3文件</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps92.jpg" alt="img"> </p><p>此时可以在uploads文件夹下看见上传的文件</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps93.jpg" alt="img"> </p><p>通过view Blochain也可以看见上传的文件</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps94.jpg" alt="img"> </p><p>2.此时在上传一张蒙娜丽莎</p><p>先通过lookup检测，可以看见没有相似文件</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps95.jpg" alt="img"> </p><p>在进行上传</p><p>3.在尝试上传蒙娜丽莎2</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps96.jpg" alt="img"> </p><p>检测会报错，说已有相似图片。说明功能成功</p><p>（显示有点问题）已有功能图片显示在这里</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps97.jpg" alt="img"> </p><p>4.以上过程说明实验成功</p><p>证明了用版权保护区块链系统可以对实验测试数据实现提取版权信息进行不重复的上链。</p><h1 id="五、-实验中遇到的问题及改正的方法"><a href="#五、-实验中遇到的问题及改正的方法" class="headerlink" title="五、 *实验中遇到的问题及改正的方法*"></a><strong>五、</strong> <em><strong>*实验中遇到的问题及改正的方法*</strong></em></h1><ol><li>下载sh中文件会出错</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps98.jpg" alt="img"> </p><p>可以手动运行一步步下载。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps99.jpg" alt="img"> </p><p>2.安装时报错</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps100.jpg" alt="img"> </p><p>读代码知道要先按numpy 1.16.3,直接上清华源</p><p>pip install -U numpy&#x3D;&#x3D;1.16.3 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps101.jpg" alt="img"> </p><p>还是报错，选择用pycharm解决</p><p>安装pycharm</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps102.jpg" alt="img"> </p><p>重新配置了一下环境，再安装软件包</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps103.jpg" alt="img"> </p><ol start="2"><li>配置环境需要python3.6的版本</li></ol><p>需要重新安装python再配置环境</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps104.jpg" alt="img"> </p><p>3.升级apt的时候报错</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps105.jpg" alt="img"> </p><p>需要安装</p><p>apt install binutils</p>]]></content>
    
    
    <summary type="html">掌握在Linux下安装和使用版权保护区块链系统,并调用版权保护区块链系统主要功能模块</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
</feed>
