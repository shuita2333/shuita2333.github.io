<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZYH&#39;s blog</title>
  
  
  <link href="https://zhangyuanhe.top/atom.xml" rel="self"/>
  
  <link href="https://zhangyuanhe.top/"/>
  <updated>2024-01-17T12:52:36.357Z</updated>
  <id>https://zhangyuanhe.top/</id>
  
  <author>
    <name>Charmes</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件安全课程笔记</title>
    <link href="https://zhangyuanhe.top/2024/01/15/BUPT_note/Notes%20on%20software%20security/"/>
    <id>https://zhangyuanhe.top/2024/01/15/BUPT_note/Notes%20on%20software%20security/</id>
    <published>2024-01-15T13:00:00.000Z</published>
    <updated>2024-01-17T12:52:36.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件安全-张淼"><a href="#软件安全-张淼" class="headerlink" title="软件安全 张淼"></a>软件安全 张淼</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h3 id="信息安全现状"><a href="#信息安全现状" class="headerlink" title="信息安全现状"></a>信息安全现状</h3><p><strong>信息安全现象</strong></p><p>➔ <strong>病毒、黑客攻击的泛滥</strong></p><p>➢数量规模大、智能程度高（技术含量）、组织方式多样化（个人、组织和集团等）</p><p>➢危害程度严重</p><p>➔ <strong>信息安全成为国家安全的重要内容</strong></p><p>➢国家领导层的意识</p><p>➢信息化建设的经验、伊战的教训</p><p>➔ <strong>关键技术受制于人</strong></p><p>➢CPU、OS</p><p>➢专利、标准</p><h3 id="信息安全威胁"><a href="#信息安全威胁" class="headerlink" title="信息安全威胁"></a><strong><strong>信息安全威胁</strong></strong></h3><p>信息安全威胁的表现：</p><p>➔ 网络协议的弱点</p><p>➔ 网络操作系统的漏洞</p><p>➔ 应用系统设计的漏洞</p><p>➔ 网络系统设计的缺陷</p><p>➔ 恶意攻击</p><p>➔ 来自合法用户的攻击</p><p>➔ 互联网的开放性</p><p>➔ 物理安全</p><p>➔ 管理安全</p><p>威胁的根源</p><p>➔ <strong>信息系统的复杂性：</strong></p><p>➢系统软硬件缺陷，网络协议的缺陷</p><p>➔ <strong>信息系统的开放性：</strong></p><p>➢系统开放：计算机及计算机通信系统是根据行业标准规定的接口建立起来的。</p><p>➢标准开放：网络运行的各层协议是开放的，并且标准的制定也是开放的。</p><p>➢业务开放：用户可以根据需要开发新的业务。</p><h2 id="问题的原因和根源"><a href="#问题的原因和根源" class="headerlink" title="问题的原因和根源"></a><strong><strong>问题的原因和根源</strong></strong></h2><h3 id="软件问题的原因"><a href="#软件问题的原因" class="headerlink" title="软件问题的原因"></a><strong><strong>软件问题的原因</strong></strong></h3><p>⚫<strong>Connectivity（互联性）</strong></p><ul><li>终端设备的互联给了攻击者有更多的机会</li><li>攻击者利用系统弱点不再需要进行物理访问</li><li>平台设计缺陷</li></ul><p>⚫<strong>Extensibility（扩展性）</strong></p><ul><li>目前很多软件技术都支持扩展技术</li><li>优点在于可以很方便的加载以及扩展新的功能与组件</li><li>问题在于扩展的功能与组件不可控，会带来未知的安全风险</li></ul><p>⚫<strong>Complexity（复杂性</strong>）</p><ul><li>软件系统代码增长速度惊人</li></ul><p>系统越复杂，Bug越难避免，质量越难保证，可能发生的安全风险越多。</p><h3 id="新的需求与传统安全技术的不足"><a href="#新的需求与传统安全技术的不足" class="headerlink" title="新的需求与传统安全技术的不足"></a><strong><strong>新的需求与传统安全技术的不足</strong></strong></h3><p>传统网络安全技术只能对网络层进行防护</p><p>无法分辨与正常应用数据混杂在一起的攻击</p><p>➔<strong>XSS</strong></p><p>➔<strong>SQL注入</strong></p><p>➔<strong>未校验参数</strong></p><p>➔<strong>etc.</strong></p><table><thead><tr><th>传统的安全模式</th><th>新的安全模式</th></tr></thead><tbody><tr><td>保护”边界”</td><td>构建安全的系统</td></tr><tr><td>网络安全</td><td>设计安全的软件</td></tr><tr><td>安全负责的人是 IT&#x2F;MIS&#x2F;CISSP等部门</td><td>软件开发人员和设计人员对安全负责</td></tr><tr><td>被动式</td><td>主动式</td></tr></tbody></table><h1 id="缓冲区溢出基础"><a href="#缓冲区溢出基础" class="headerlink" title="缓冲区溢出基础"></a>缓冲区溢出基础</h1><h2 id="缓冲区溢出概述－缓冲区溢出原理简介"><a href="#缓冲区溢出概述－缓冲区溢出原理简介" class="headerlink" title="缓冲区溢出概述－缓冲区溢出原理简介"></a>缓冲区溢出概述－缓冲区溢出原理简介</h2><p>缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量溢出的数据覆盖在合法数据上。</p><p>在初始化、拷贝或移动数据时，C语言并不自动地支持内在的数组边界检查。</p><p><strong>目前对于缓冲区溢出,主要分为静态保护和动态保护:</strong></p><p>⚫**静态保护:**不执行代码,通过静态分析来发现代码中可能存在的漏洞.静态的保护技术包括编译时加入限制条件,返回地址保护,二进制改写技术,基于源码的代码审计等.</p><p>⚫**动态保护:**通过执行代码分析程序的特性,测试是否存在漏洞,或者是保护主机上运行的程序来防止来自外部的缓冲区溢出攻击</p><h2 id="PE文件格式简介"><a href="#PE文件格式简介" class="headerlink" title="PE文件格式简介"></a>PE文件格式简介</h2><p>PE(Portable Executable)是Win32平台下可执行文件遵守的数据格式。常见的可执行文件(如“*.exe”文件和“*.dll”文件)都是典型的PE文件。</p><p>PE 文 件 格 式 把 可 执 行 文 件 分 成 若 干 个 数 据 节(section)，不通的资源被存放在不同的节中。一个典型的PE文件包含的节如下：</p><p>➔ .text 由编译器产生，存放着二进制的机器代码，也是我们反汇编和调试的对象。<br>➔ .data 初始化的数据块，如宏定义、全局变量、静态变量等。<br>➔ .idata 可执行文件所使用的动态链接库等外来函数与文件的信息。<br>➔ .rsrc 存放程序的资源，如图标、菜单等。<br>➔ 除此之外 ， 还 可 能 出 现 的 节 包 括 “.reloc” 、“.edata”、 “.tls”、 “.rdata”等。</p><p><strong>PE文件简单构成</strong></p><table><thead><tr><th>其他</th></tr></thead><tbody><tr><td>.data节</td></tr><tr><td>.rdata节</td></tr><tr><td>.text节</td></tr><tr><td>文件头、节</td></tr><tr><td>表等</td></tr></tbody></table><h2 id="虚拟内存相关知识—虚拟内存简介"><a href="#虚拟内存相关知识—虚拟内存简介" class="headerlink" title="虚拟内存相关知识—虚拟内存简介"></a>虚拟内存相关知识—虚拟内存简介</h2><p>Windows的内存可以被分为两个层面：物理内存和虚拟内存 。 其 中 ， 物理内存比较复杂 ， 需要进入Windows内核级别ring0才能看到。通常，在用户模式下，我们用调试器看到的地址都是虚拟内存。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled.png" alt="Untitled"></p><p>虽然每个进程都“相信”自己拥有4GB的空间，但实际上它们运行时真正能用到的空间根本没有那么多。</p><p>内存管理器只是分给进程一片“假地址”，或者说是“虚拟地址”，它们对进程来说只是一笔“无形的数字财富”；</p><p>当需要实际的内存操作时，内存管理器才会把“虚拟地址”和“物理地址”联系起来。</p><h2 id="PE文件与虚拟内存之间的映射"><a href="#PE文件与虚拟内存之间的映射" class="headerlink" title="PE文件与虚拟内存之间的映射"></a><strong>PE文件与虚拟内存之间的映射</strong></h2><p>静态反汇编工具看到的PE文件中某条指令的位置是相对于磁盘文件而言的，即所谓的文件偏移，我们可能还需要知道这条指令在内存中所处的位置，即虚拟内存的位置</p><p>反之，在调试时看到的某条指令的地址是虚拟内存地址，我们也经常需要回到PE文件中找到这条指令对应的机器码</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>⚫ <strong>文件偏移地址(File Offset)</strong></p><p>➢数据在PE文件中的地址叫做文件偏移地址。这是文件在磁盘上存放时相对于文件开头的偏移。</p><p>⚫ <strong>装载基址(Image Base)</strong></p><p>➢PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址是0x00400000,DLL文件是0x10000000。这些位置可以通过修改编译选项更改。</p><p>⚫ <strong>虚拟内存地址(Virtual Address,VA)</strong></p><p>➢PE文件中的指令被装入内存后的地址。</p><p>⚫ <strong>相对虚拟地址(Relative Virtual Address,RVA)</strong></p><p>➢相对虚拟地址是内存地址相对于映射基址的偏移量。</p><h2 id="系统栈的工作原理—内存的不同用途"><a href="#系统栈的工作原理—内存的不同用途" class="headerlink" title="系统栈的工作原理—内存的不同用途"></a><strong><strong>系统栈的工作原理—内存的不同用途</strong></strong></h2><p>成功地利用缓冲区溢出漏洞可以修改内存中的变量的值，甚至可以劫持进程，执行恶意代码，最终获得主机的控制权。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h3><p>⚫ 通用寄存器</p><p>➔ 32位的通用寄存器有<em>EAX</em>、<em>EBX</em>、<em>ECX</em>、<em>EDX</em>、<em>ESP</em>、<em>EBP</em>、<em>ESI</em>和<em>EDL</em>，它们的使用方法不总是相同的。一些指令赋予它们特殊的功能。</p><p>⚫ 段寄存器</p><p>➔ 段寄存器被用于指向进程地址空间不同的段。</p><p>➔ <em>CS</em>指向一个代码段的开始；</p><p>➔ <em>SS</em>是一个堆栈段；</p><p>➔ <em>DS</em>、<em>ES</em>、<em>FS</em>、<em>GS</em>和各种其他数据段，例如存储静态数据的段。</p><p>⚫ 程序流控制寄存器</p><p>⚫ 其他寄存器</p><p>程序员习惯中已经默认的给每个寄存器赋上了特殊的含义，比如：</p><p>➔ EAX一般用来做返回值<br>➔ ECX用于记数<br>➔ EIP：扩展指令指针。在调用一个函数时，这个指针被存储在堆栈中，用于后面的使用。在函数返回时，这个被存储的地址被用于决定下一个将被执行的指令的地址。<br>➔ ESP：扩展堆栈指针。这个寄存器指向堆栈的当前位置，并允许通过使用push和pop操作或者直接的指针操作来对堆栈中的内容进行添加和移除。<br>➔ EBP：扩展基指针。主要用与存放在进入call以后的ESP的值，便于退出的时候回复ESP的值，达到堆栈平衡的目的</p><p>内存的4个部分和相关用途:</p><table><thead><tr><th>名称</th><th>用途</th></tr></thead><tbody><tr><td>代码区</td><td>这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指并执行。</td></tr><tr><td>数据区</td><td>用于存储全局变量等。</td></tr><tr><td>堆区</td><td>进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。</td></tr><tr><td>栈区</td><td>用于动态地存储函数之间的调用关系，以保证被调用函数在返回时恢复到父函数中继续执行。</td></tr></tbody></table><h3 id="栈与系统栈"><a href="#栈与系统栈" class="headerlink" title="栈与系统栈"></a><strong><strong>栈与系统栈</strong></strong></h3><p>从计算机科学的角度来看，栈指的是一种数据结构，是一种先进后出的数据表。栈的最常见操作有两种：压栈(PUSH)、弹栈(POP)；用于标识栈的属性也有两个：栈顶(TOP)、栈底(BASE)。</p><p>内存的栈区实际上指的就是系统栈。系统栈由系统自动维护，它用于实现高级语言中函数的调用。对 于 类 似 C 语 言 这 样 的 高 级 语 言 ， 系 统 栈 的PUSH&#x2F;POP等堆栈平衡细节是透明的。</p><table><thead><tr><th>代码空间</th><th>系统栈空间</th></tr></thead><tbody><tr><td>程序被装入，由main函数代码空间依次取指执行</td><td>系统栈 栈顶为当前正在执行的main函数栈帧</td></tr><tr><td>执行到main代码区的call指令时，跳转到funca的代码区继续执行</td><td>为配合funca的执行，在系统栈中为其开辟新的栈帧并压入</td></tr><tr><td>执行到funca代码区的call指令时，跳转到funcb的代码区继续执行</td><td></td></tr><tr><td>为配合funcb的执行，在系统栈中为其开辟新的栈帧并压入</td><td></td></tr><tr><td>funcb代码执行完毕，弹出自己的栈帧并从中获得返回地址，跳回funca代码区继续执行</td><td>弹出funcb的栈帧。对应于当前正在执行的函数，当前栈顶栈帧重新恢复成funca函数栈帧</td></tr><tr><td>funca代码执行完毕，弹出自己的栈帧并从中获得返回地址，跳回main代码区继续执行</td><td>弹出funca的栈帧。对应于当前正在执行的函数，当前栈顶栈帧重新恢复成main函数栈帧</td></tr></tbody></table><h2 id="寄存器与函数栈帧"><a href="#寄存器与函数栈帧" class="headerlink" title="寄存器与函数栈帧"></a><strong><strong>寄存器与函数栈帧</strong></strong></h2><p>（1）ESP：栈指针寄存器(extended stackpointer),其内存放着一个指针，该指针永远指向系统栈最上面的一个栈帧的栈顶。</p><p>（2）EBP：基址指针寄存器(extended basepointer),其内存放着一个指针，该指针永远指向系统栈最上面的一个栈帧的底部。</p><p>（3）EIP ：指令寄存器 (Extended InstructionPointer),其内存放着一个指针，该指针永远指向一条等待执行的指令地址。</p><p><strong>在函数栈帧中，一般包含以下几类重要信息。</strong></p><p>（1）局部变量：为函数局部变量开辟的内存空间。</p><p>（2）栈帧状态值：保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡计算得到），用于在本帧被弹出后恢复出上一个栈帧。</p><p>（3）函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令</p><p><strong>函数调用步骤</strong></p><p>（1）参数入栈：将参数从右向左一次压入系统栈中。</p><p>（2）返回地址入栈：将当前代码区调用指令的下一跳指令地址压入栈中，<br>供函数返回时继续执行。</p><p>（3）代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。</p><p>（4）栈帧调整</p><ul><li>保存当前栈帧的状态值，以备后面恢复本栈帧时使用（EBP入栈）；</li><li>将当前栈帧切换到新栈帧（将ESP值装入EBP，更新栈帧底部）；</li><li>给新栈帧分配空间（把ESP减去所需空间的大小，抬高栈帧）；</li></ul><h2 id="函数调用约定与相关指令"><a href="#函数调用约定与相关指令" class="headerlink" title="函数调用约定与相关指令"></a><strong>函数调用约定与相关指令</strong></h2><p>入栈</p><table><thead><tr><th>序列</th><th>备注</th></tr></thead><tbody><tr><td>push 参数 3</td><td>假设该函数有3个参数，将从右向左依次入栈</td></tr><tr><td>push 参数 2</td><td></td></tr><tr><td>push 参数 1</td><td></td></tr><tr><td>call 函数地址</td><td>call指令将同时完成两项工作:a)向栈中压入当前指令在内存中的位置，即保存返回地址。</td></tr><tr><td>b)跳转到所调用函数的入口地址函数入口处</td><td></td></tr><tr><td>push ebp</td><td>保存旧栈帧的底部</td></tr><tr><td>mov ebp,esp</td><td>设置新栈帧的底部(栈帧切换)</td></tr><tr><td>sub esp,xxx</td><td>sub esp,xxx 设置新栈帧的顶部(抬高栈顶，为新栈帧开辟空间）</td></tr></tbody></table><p>类似的，函数返回的步骤如下。<br>（1）保存返回值：通常将函数的返回值保存在寄存器EAX中。<br>（2）弹出当前栈帧，恢复上一个栈帧，具体包括：</p><p>在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间。</p><p>将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复上一个栈帧。</p><p>将函数返回地址弹给EIP寄存器。</p><p>（3）跳转：按照函数返回地址跳回母函数中继续执行。</p><table><thead><tr><th>指令</th><th>备注</th></tr></thead><tbody><tr><td>add esp,xxx</td><td>降低栈顶，回收当前的栈帧</td></tr><tr><td>pop ebp</td><td>将上一个栈帧底部位置恢复到ebp</td></tr><tr><td>retn</td><td>这条指令有两个功能:</td></tr><tr><td>a)弹出当前栈顶元素，即弹出栈帧中的返回地址。至此，栈帧恢复工作完成。</td><td></td></tr><tr><td>b)让处理器跳转到弹出的返回地址，恢复调用前的代码区</td><td></td></tr></tbody></table><h1 id="第三讲-字符串安全"><a href="#第三讲-字符串安全" class="headerlink" title="第三讲 字符串安全"></a><strong><strong>第三讲 字符串安全</strong></strong></h1><h2 id="C-风格的字符串"><a href="#C-风格的字符串" class="headerlink" title="C-风格的字符串"></a><strong><strong>C-风格的字符串</strong></strong></h2><p>c风格的字符串由一个连续的字符序列组成，并以一个空字符（null ）作为结束。</p><p>➔ 一个指向字符串的指针实际上就是指向该字符串的起始字符。</p><p>➔ 字符串长度指空字符之前的字节数</p><p>➔ 字符串的值则是它所包含的按顺序排列的字符序列。</p><p>➔ 存储一个字符串所需要的字节数是字符串的字符数加1。 (x 是每个字符的大小)</p><h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a><strong><strong>C++ 字符串</strong></strong></h2><p>C++的标准化促进了：</p><p>➔ <strong>标准的类模板std::basic_string</strong></p><p>➔ 及它的<strong>char</strong> 实例化 <strong>std::string</strong></p><p>➔ 相对于C风格的字符串，<strong>basic_string</strong> 类更不容易出现安全漏洞 。</p><h2 id="常见的字符串操作错误"><a href="#常见的字符串操作错误" class="headerlink" title="常见的字符串操作错误"></a><strong><strong>常见的字符串操作错误</strong></strong></h2><p>最常见的错误有<br>➢ 无界字符串复制<br>➢ 空结尾错误<br>➢ 截断<br>➢ 差－错误<br>➢ 数组写入越界<br>➢ 不恰当的数据处理</p><h2 id="无边界字符串复制"><a href="#无边界字符串复制" class="headerlink" title="无边界字符串复制"></a><strong><strong>无边界字符串复制</strong></strong></h2><p>无边界字符串复制发生于从一个无边界数据源复制数据到一个定长的字符数组时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> Password[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter 8 character password:&quot;</span>);</span><br><span class="line"><span class="built_in">gets</span>(Password);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制和连接字符串时也容易出现错误，因为标准strcpy() 和strcat() 函数执行的都是无边界复制操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> name[<span class="number">2048</span>];</span><br><span class="line"><span class="number">3.</span> <span class="built_in">strcpy</span>(name, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="number">4.</span> <span class="built_in">strcat</span>(name, <span class="string">&quot; = &quot;</span>);</span><br><span class="line"><span class="number">5.</span> <span class="built_in">strcat</span>(name, argv[<span class="number">2</span>]);</span><br><span class="line">...</span><br><span class="line"><span class="number">6.</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="简单的解决方案"><a href="#简单的解决方案" class="headerlink" title="简单的解决方案"></a><strong><strong>简单的解决方案</strong></strong></h3><p>利用strlen() 测试输入字符串的长度然后动态分配内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> *buff = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>])+<span class="number">1</span>);</span><br><span class="line"><span class="number">3.</span> <span class="keyword">if</span> (buff != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">4.</span> <span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="number">5.</span> <span class="built_in">printf</span>(<span class="string">&quot;argv[1] = %s.\n&quot;</span>, buff);</span><br><span class="line"><span class="number">6.</span> &#125;</span><br><span class="line"><span class="number">7.</span> <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Couldn&#x27;t get the memory - recover*/</span></span><br><span class="line"><span class="number">8.</span> &#125;</span><br><span class="line"><span class="number">9.</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">10.</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="C-无界字符串复制"><a href="#C-无界字符串复制" class="headerlink" title="C++无界字符串复制"></a><strong><strong>C++无界字符串复制</strong></strong></h2><p>对于下列的C＋＋程序，如果用户输入多于11个字符，也会导<br>致越界写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">3.</span> <span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line"><span class="number">4.</span> cin &gt;&gt; buf;</span><br><span class="line"><span class="number">5.</span> cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line"><span class="number">6.</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="简单的解决方案-1"><a href="#简单的解决方案-1" class="headerlink" title="简单的解决方案"></a><strong><strong>简单的解决方案</strong></strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">3.</span> <span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line"><span class="number">3.</span> cin.<span class="built_in">width</span>(<span class="number">12</span>);</span><br><span class="line"><span class="number">4.</span> cin &gt;&gt; buf;</span><br><span class="line"><span class="number">5.</span> cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line"><span class="number">6.</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="空结尾错误"><a href="#空结尾错误" class="headerlink" title="空结尾错误"></a><strong><strong>空结尾错误</strong></strong></h2><p>当使用C风格字符时，另一个常见的问题是字符串末尾没有正确的空字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> a[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> b[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> c[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(a, <span class="string">&quot;0123456789abcdef&quot;</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="built_in">strncpy</span>(b, <span class="string">&quot;0123456789abcdef&quot;</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line"><span class="built_in">strncpy</span>(c, a, <span class="built_in">sizeof</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strncpy-函数"><a href="#strncpy-函数" class="headerlink" title="strncpy 函数"></a><strong><strong>strncpy 函数</strong></strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncpy</span><span class="params">(<span class="type">char</span> * restrict s1,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">char</span> * restrict s2,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>从数组S2中复制不超过 <strong>n</strong> 个字符串 (空字符后的字符不会被复制) 到目标数组S1 *****中。</p><p>➔ *因此，如果第一个数组S2中的前n个字符中不存在空字符，那么其结果字符串将不会是以空字符结尾的。</p><h2 id="字符串截断"><a href="#字符串截断" class="headerlink" title="字符串截断"></a><strong><strong>字符串截断</strong></strong></h2><p>⚫<strong>一些限制字节数的函数通常用来防止缓冲区溢出漏洞</strong></p><p>➔ <strong>strncpy() 代替 strcpy()</strong></p><p>➔ <strong>fgets()代替 gets()</strong></p><p>➔ <strong>snprintf()代替 sprintf()</strong></p><p>⚫当目标字符数组的长度不足以容纳一个字符串的内容时，就会发生字符串截断</p><p>⚫字符串截断会丢失数据，有时也会导致软件漏洞</p><h2 id="数组写入越界"><a href="#数组写入越界" class="headerlink" title="数组写入越界"></a><strong><strong>数组写入越界</strong></strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">2.</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="number">3.</span> <span class="type">char</span> buff[<span class="number">128</span>];</span><br><span class="line"><span class="number">4.</span> <span class="type">char</span> *arg1 = argv[<span class="number">1</span>];</span><br><span class="line"><span class="number">5.</span> <span class="keyword">while</span> (arg1[i] != <span class="string">&#x27;\0&#x27;</span> ) &#123;</span><br><span class="line"><span class="number">6.</span> buff[i] = arg1[i];</span><br><span class="line"><span class="number">7.</span> i++;</span><br><span class="line"><span class="number">8.</span> &#125;</span><br><span class="line"><span class="number">9.</span> buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="number">10.</span> <span class="built_in">printf</span>(<span class="string">&quot;buff = %s\n&quot;</span>, buff);</span><br><span class="line"><span class="number">11.</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="程序栈"><a href="#程序栈" class="headerlink" title="程序栈"></a><strong><strong>程序栈</strong></strong></h2><p>⚫栈（ 栈 ）通过存储下列内容来追踪程序的执行和状态。<br>➢ 调用函数的返回地址<br>➢ 函数参数<br>➢ 局部 (临时）变量<br>⚫在下列情况下栈需要被修改<br>➢ 在函数调用期间<br>➢ 函数初始化期间<br>➢ 从子例程返回时</p><h3 id="栈粉碎"><a href="#栈粉碎" class="headerlink" title="栈粉碎"></a><strong><strong>栈粉碎</strong></strong></h3><p>⚫堆栈支持嵌套调用</p><p>⚫帧指由函数调用引发的压入栈的数据。</p><p>⚫栈用于存储</p><p>➔ 调用函数的返回地址</p><p>➔ 子例程的实际参数</p><p>➔ 局部（自动）变量</p><p>⚫当前帧的地址被存储到帧或者基址寄存器中(英特尔架构中的EBP)</p><p>⚫帧指针在栈中是一个定点的引用。</p><p>⚫下列情况出现时，栈要要被修改</p><p>➔ 子例程调用</p><p>➔ 子例程初始化</p><p>➔ 从子例程返回</p><p><strong>EIP：扩展指令指针  ESP: 扩展栈指针  EBP:扩展基指针</strong></p><h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a><strong><strong>缓冲区溢出</strong></strong></h2><p>当向为某特定数据结构分配的内存空间边界之外写入数据时， 就会发生缓冲区溢出。</p><p>➔当缓冲区溢出覆写分配给执行栈内存中的数据时，就会导致栈粉碎</p><p>➔成功的利用这个漏洞能够覆写栈返回地址，从而在目标机器中执行任意代码。</p><h2 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a><strong><strong>代码注入</strong></strong></h2><p>⚫攻击者创建一个恶意参数</p><p>➔一个蓄意构造的字符串，其中包含一个指向某些恶意代码的指针，该代码也由攻击者提供。</p><p>⚫当函数返回时，控制就被转移到了那段恶意代码。</p><p>➔注入的代码就会以与该有漏洞的程序相同的权限运行</p><p>➔攻击者通常都以“以root或其他较高权限运行”的程序为目标</p><p>⚫恶意参数的目的是把控制权转移给恶意代码</p><p>➔ 可能包含在恶意参数 (如本实例)中</p><p>➔ 可能在一个有效的输入操作期间注入恶意代码</p><p>➔ 恶意代码可以执行以其他任何形式编程所能执行的功能，</p><p>不过它们通常只是简单地在受害机器上开一个远程<strong>。</strong></p><h2 id="弧注入-return-into-libc"><a href="#弧注入-return-into-libc" class="headerlink" title="弧注入 (return-into-libc)"></a><strong><strong>弧注入 (return-into-libc)</strong></strong></h2><p>弧注入将控制转移到已经存在于程序内存空间中的代码中</p><p>➔ 弧注入的利用方式是在程序的控制流“团”中插入一段新的“弧’（表示控制流转移），而不是进行代码注入。</p><p>➔ 可以安装一个已有函数的地址（如system() 或exec ()，用于执行已存在于本地系统上的程序</p><p>➔ 更复杂的攻击可能会使用这种技术</p><h3 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a><strong><strong>缓解措施</strong></strong></h3><p>⚫缓解措施包括：</p><p>➔预防缓冲区溢出</p><p>➔侦测缓冲区溢出并安全地恢复，使得漏洞利用的企图无法得逞。</p><p>⚫防范策略</p><p>➔静态分配空间</p><p>➔动态分配空间</p><h3 id="静态方法-静态分配缓冲区"><a href="#静态方法-静态分配缓冲区" class="headerlink" title="静态方法  静态分配缓冲区"></a><strong>静态方法  静态分配缓冲区</strong></h3><p>假设一个固定大小的缓冲区</p><p>➔在缓冲区满了以后，不可能添加再数据</p><p>➔因为静态的方法丢弃了超出的数据，所以实际的程序数据会丢失。</p><p>➔因此，生成的字符串必须被充分验证</p><p><strong>输入验证</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> buff[<span class="number">100</span>];</span><br><span class="line"><span class="number">3.</span> <span class="keyword">if</span> (<span class="built_in">strlen</span>(arg) &gt;= <span class="built_in">sizeof</span>(buff)) &#123;</span><br><span class="line"><span class="number">4.</span> <span class="built_in">abort</span>();</span><br><span class="line"><span class="number">5.</span> &#125;</span><br><span class="line"><span class="number">6.</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>strlcpy() 和 strlcat()</strong></p><p>采用一个更不容易出错的方式来复制和链接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlcpy</span><span class="params">(<span class="type">char</span> *dst,<span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlcat</span><span class="params">(<span class="type">char</span> *dst,<span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>strlcpy()</strong> 从<strong>src</strong>复制空结尾的字符串到<strong>dst</strong> (直到<strong>size</strong> 大小的字符)。</p><p><strong>strlcat()</strong> 函数把非空结尾的字符串<strong>src</strong> 连接到<strong>dst</strong>末尾 (不超过<strong>size</strong> 的字符都能够连接到dst末尾)</p><p>两个函数都确保目标字符串对所有非零长度的缓冲区来说都是<br>非空结尾的。</p><p><strong><strong>ISO&#x2F;IEC “Security” TR 24731</strong></strong></p><p>➔strcpy_s() 代替strcpy()</p><p>➔strcat_s()代替strcat()</p><p>➔strncpy_s()代替strncpy()</p><p>➔strncat_s()代替strncat()</p><h3 id="strcpy-s-函数"><a href="#strcpy-s-函数" class="headerlink" title="strcpy_s() 函数"></a><strong><strong>strcpy_s() 函数</strong></strong></h3><p>把字符从源字符串复制到目标字符数组，直到并包括终止null字<br>符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">errno_t</span> <span class="title">strcpy_s</span><span class="params">(<span class="type">char</span> * restrict s1,<span class="type">rsize_t</span> s1max,<span class="type">const</span> <span class="type">char</span> * restrict s2)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="动态方法-动态地分配缓冲区"><a href="#动态方法-动态地分配缓冲区" class="headerlink" title="动态方法  动态地分配缓冲区"></a><strong>动态方法  动态地分配缓冲区</strong></h2><p>⚫动态分配的缓冲区需要动态调整额外的内存。</p><p>⚫动态方法更好，而且不丢弃多余的数据。</p><p>⚫主要缺点是,如果输入被限制，则可能</p><p>➔耗尽机器内存</p><p>➔结果导致拒绝服务攻击</p><h3 id="防范策略"><a href="#防范策略" class="headerlink" title="防范策略"></a><strong><strong>防范策略</strong></strong></h3><p>为C提供丰富的字符串操作库，</p><p>➔ 拥有安全的语义</p><p>➔ 与遗留的库代码互操作</p><p>➔ 使用一种动态分配的方式，可以在需要时自动调整字符串的大小。</p><h3 id="safestr-t-类型"><a href="#safestr-t-类型" class="headerlink" title="safestr_t 类型"></a><strong><strong>safestr_t 类型</strong></strong></h3><p>safestr_t类型与char<em>是兼容的，并且可以将safestr_t转型为char</em>当作<br>C风格字符使用。<br> safestr_t类型保存了由该指针所引用的内存部分的说明信息（例如，<br>实际长度和分配的长度），保存子指针所指向的内存之前</p><p>⚫管理动态字符串</p><p>➔ 分配缓冲区</p><p>➔ 如果需要额外的内存，则重新调整内存大小</p><p>⚫管理字符串操作，以确保</p><p>➔ 字符串操作没有导致缓冲区溢出</p><p>➔ 数据没有丢失</p><p>➔ 字符串正常终止(字符串可能是也可能不是内部空结尾)</p><p>⚫缺点</p><p>➔ 无限制地消耗内存，可能导致拒绝服务攻击</p><p>➔ 性能开销</p><h1 id="第四讲-软件安全漏洞基础"><a href="#第四讲-软件安全漏洞基础" class="headerlink" title="第四讲 软件安全漏洞基础"></a><strong><strong>第四讲 软件安全漏洞基础</strong></strong></h1><h2 id="软件漏洞简介"><a href="#软件漏洞简介" class="headerlink" title="软件漏洞简介"></a><strong><strong>软件漏洞简介</strong></strong></h2><p>在形形色色的软件逻辑缺陷中，有一部分如果被利用能够引起非常严重的后果。</p><p>例如:SQL注入,跨站脚本,缓冲区溢出</p><p>我们通常把这类能够引起软件做一些“超出设计范围的事情”的bug称为漏洞</p><table><thead><tr><th></th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>BUG</td><td>功能性逻辑缺陷，影响软件的正常功能</td><td>执行结果错误、图标显示错误等</td></tr><tr><td>漏洞</td><td>安全性逻辑缺陷，通常情况下不影响软件的正常功能，但被攻击者成功利用后，有可能引起软件去执行额外的恶意代码</td><td>软件缓冲区溢出漏洞、网站的跨站脚本漏洞(XSS)、SQL注入漏洞等</td></tr></tbody></table><h3 id="典型的软件漏洞"><a href="#典型的软件漏洞" class="headerlink" title="典型的软件漏洞"></a><strong><strong>典型的软件漏洞</strong></strong></h3><p>缓冲区溢出漏洞：它发生的原理是，由于用户处理用户数据时使用了不限边界的拷贝，导致程序内部一些关键数据被覆盖，引发了安全问题，严重的缓冲区溢出漏洞会使得程序被利用而安装上木马或病毒</p><p>整数溢出漏洞：对于有符号的16位整数来说，它的最大值就是0x7fff，也就是十进制的32767，当赋值给一个整数的值为其最大值时，如果此时再加上1，就会发生整数型的溢出。</p><p>格式化字符串漏洞：格式化字符串漏洞是由于程序的数据输出函数中对输出数据的格式解析不当而发生的。</p><p><strong>SQL注入漏洞：</strong>通过控制传递给软件数据库操作语句 的关键变量来获得恶意控制软件数据库、获取有用信息或者制造恶意破坏的，甚至是控制用户计算机系统的漏洞，就成为”SQL注入漏洞”。</p><h3 id="软件漏洞的危害"><a href="#软件漏洞的危害" class="headerlink" title="软件漏洞的危害"></a><strong><strong>软件漏洞的危害</strong></strong></h3><p>无法正常使用,引发恶性事件,关键数据丢失,秘密信息泄漏,被安装木马病毒</p><h3 id="安全漏洞出现的原因"><a href="#安全漏洞出现的原因" class="headerlink" title="安全漏洞出现的原因"></a><strong><strong>安全漏洞出现的原因</strong></strong></h3><p>小作坊式的软件开发、赶进度带来的弊端、被轻视的软件安全测试、淡薄的安全思想、不完善的安全维护、</p><h2 id="漏洞挖掘、分析、利用简介"><a href="#漏洞挖掘、分析、利用简介" class="headerlink" title="漏洞挖掘、分析、利用简介"></a><strong><strong>漏洞挖掘、分析、利用简介</strong></strong></h2><p>⚫从技术角度讲，漏洞挖掘实际上是一种高级的测试(QA)。</p><p>⚫学术界一直热衷于使用静态分析的方法寻找源代码中的漏洞；</p><p>⚫而在工程界，不管是安全专家还是攻击者，普遍采用的漏洞挖掘方法是Fuzz，这实际是一种“灰”盒测试。</p><p>⚫当fuzz捕捉到软件一个严重的异常时，当你想透过厂商公布的简单描述了解漏洞细节的时候，我们就需要具备一定的漏洞分析能力。一般情况下，我们需要调试二进制级别的程序。</p><h2 id="PE文件格式简介-1"><a href="#PE文件格式简介-1" class="headerlink" title="PE文件格式简介"></a><strong><strong>PE文件格式简介</strong></strong></h2><p>PE(Portable Executable)是Win32平台下可执行文件遵守的数据格式。常见的可执行文件(如“*.exe”文件和“*.dll”文件)都是典型的PE文件。</p><p>PE 文 件 格 式 把 可 执 行 文 件 分 成 若 干 个 数 据 节(section)，不通的资源被存放在不同的节中。一个典型的PE文件包含的节如下：</p><table><thead><tr><th>DOS头</th></tr></thead><tbody><tr><td>PE签名</td></tr><tr><td>PE头文件</td></tr><tr><td>PE可选头</td></tr><tr><td>节表</td></tr><tr><td>.idata节</td></tr><tr><td>.text节</td></tr><tr><td>.data节</td></tr></tbody></table><h2 id="虚拟内存相关知识"><a href="#虚拟内存相关知识" class="headerlink" title="虚拟内存相关知识"></a><strong>虚拟内存相关知识</strong></h2><h3 id="PE文件与虚拟内存之间的映射-1"><a href="#PE文件与虚拟内存之间的映射-1" class="headerlink" title="PE文件与虚拟内存之间的映射"></a><strong>PE文件与虚拟内存之间的映射</strong></h3><p>⚫ <strong>文件偏移地址(File Offset)</strong></p><p>➢数据在PE文件中的地址叫做文件偏移地址。这是文件在磁盘上存放时相对于文件开头的偏移。</p><p>⚫ <strong>装载基址(Image Base)</strong></p><p>➢PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址是0x00400000,DLL文件是0x10000000。这些位置可以通过修改编译选项更改</p><p>⚫ <strong>虚拟内存地址(Virtual Address,VA)</strong></p><p>➢PE文件中的指令被装入内存后的地址。</p><p>⚫ <strong>相对虚拟地址(Relative Virtual Address,RVA)</strong></p><p>➢相对虚拟地址是内存地址相对于映射基址的偏移量。</p><p>➔ <strong>虚拟内存地址、映射基址、相对虚拟内存地址三</strong>者有如下关系 VA&#x3D;Image Base + RVA</p><h1 id="第五讲-漏洞利用技术"><a href="#第五讲-漏洞利用技术" class="headerlink" title="第五讲 漏洞利用技术"></a><strong><strong>第五讲 漏洞利用技术</strong></strong></h1><h2 id="shellcode概述"><a href="#shellcode概述" class="headerlink" title="shellcode概述"></a><strong><strong>shellcode概述</strong></strong></h2><h3 id="淹没返回地址"><a href="#淹没返回地址" class="headerlink" title="淹没返回地址"></a><strong><strong>淹没返回地址</strong></strong></h3><p>buffer[0-3]<br>buffer[4-7]<br>authenticated          左侧是变量的 排列顺序图<br>EBP<br>返回地址<br>观察一下我们发现我们只需要先放置16个字符串，然后接下来<br>的4个字节就能够淹没返回地址，达到控制返回地址的目的</p><h3 id="栈帧移位与jmp-esp"><a href="#栈帧移位与jmp-esp" class="headerlink" title="栈帧移位与jmp esp"></a><strong><strong>栈帧移位与jmp esp</strong></strong></h3><p>一般情况下，ESP寄存器中的地址总是指向系统栈中，且不会被溢出的数据破坏。函数返回时，ESP所指的位置恰好是我们所淹没的返回地址的下一个位置</p><h3 id="获取“跳板”的地址"><a href="#获取“跳板”的地址" class="headerlink" title="获取“跳板”的地址"></a><strong><strong>获取“跳板”的地址</strong></strong></h3><p>在利用跳板之前，我们必须在进程空间中找到一条jmp esp指令的地址作为“跳板”。除了PE文件的代码被读入内存空间，一些经常被用到的动态链接库也将会一同被映射到内存 。 其 中 ， 注 入kernel32.dll,user32.dll之类的动态链接库几乎会被所有的进程加载，且加载基址始终相同。</p><h2 id="缓冲区的组织"><a href="#缓冲区的组织" class="headerlink" title="缓冲区的组织"></a><strong><strong>缓冲区的组织</strong></strong></h2><p>填充物:可以是任何值，但是一般用NOP指令对应的0x90来进行填充，这样只要能跳进填充区，处理器最终也能顺序执行到shellcode。</p><p>淹没返回地址的数据：可以是跳转指令的地址，shellcode的起始地址，或者近似的shellcode地址（跳转进NOP填充区）</p><p>shellcode:可执行的机器代码。</p><h1 id="第六讲-漏洞挖掘与模糊测试"><a href="#第六讲-漏洞挖掘与模糊测试" class="headerlink" title="第六讲 漏洞挖掘与模糊测试"></a><strong><strong>第六讲 漏洞挖掘与模糊测试</strong></strong></h1><h2 id="漏洞挖掘技术简介"><a href="#漏洞挖掘技术简介" class="headerlink" title="漏洞挖掘技术简介"></a><strong><strong>漏洞挖掘技术简介</strong></strong></h2><p>工业界目前普遍采用的是进行Fuzz测试，与基于功能性的测试有所不同，Fuzz的主要目的是”崩溃crash”,”中断break”,”销毁destroy”。</p><p>Fuzz的测试用例往往是带有攻击性的畸形数据，用以触发各种类型的漏洞。<br>我们可以把Fuzz理解成为一种能自动进行”rough attack”尝试的工具。之所以说它是”rough attack”,是因为Fuzz往往可以触发一个缓冲区溢出的漏洞，但却不能实现有效的exploit。<br>测试人员需要实时地捕捉目标程序抛出的异常、发生的崩溃和寄存器等信息，综合判断这些错误是不是真正的可利用漏洞</p><h3 id="动态测试技术与静态代码审计的对比"><a href="#动态测试技术与静态代码审计的对比" class="headerlink" title="动态测试技术与静态代码审计的对比"></a><strong>动态测试技术与静态代码审计的对比</strong></h3><table><thead><tr><th></th><th>动态测试技术</th><th>静态代码审计</th></tr></thead><tbody><tr><td>主要技术</td><td>Fuzz等黑盒测试</td><td>数据流分析、类型验证系统、边界检验系统、状态机系统等</td></tr><tr><td>主要应用人群</td><td>攻击者</td><td>学者、QA工程师</td></tr><tr><td>优点</td><td>快捷，准确</td><td>检测出的漏洞数量多</td></tr><tr><td>缺点</td><td>不能发现系统里全部（或者大部分）漏洞</td><td>实现静态代码分析工具相当困难</td></tr></tbody></table><h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h3><p>Fuzz的测试用例往往是带有攻击性的畸形数据，用以触发各种类型的漏洞。<br>我们可以把Fuzz理解成为一种能自动进行”rough attack”尝试的工具。之所以说它是”rough attack”,是因为Fuzz往往可以触发一个缓冲区溢出的漏洞，但却不能实现有效的exploit。</p><p>Fuzz的测试优点是很少出现误报，能够迅速地找到真正的漏洞；缺点是Fuzz永远不能保证系统里已经没漏洞。</p><h2 id="文件类型漏洞挖掘—文件格式Fuzz的基本方法"><a href="#文件类型漏洞挖掘—文件格式Fuzz的基本方法" class="headerlink" title="文件类型漏洞挖掘—文件格式Fuzz的基本方法"></a><strong>文件类型漏洞挖掘—文件格式Fuzz的基本方法</strong></h2><p>不管IE还是OFFICE，它们都有一个共同点，那就是用文件作为程序的主要输入。从本质上来说，这些软件都是按照事先约定好的数据结构对文件中不同的数据域进行解析，以决定用什么颜色、在什么位置显示这些数据。<br>假如我们习惯了这样的思维，也就是假设他们所使用的文件是严格遵守软件规定的数据格式的。因为用Word生成的doc文件一般不会存在什么非法数据。<br>文件格式Fuzz就是利用这种“畸形文件”测试软件的方法。我们可以在网上找到很多FileFuzz的工具。</p><p><strong>一个File Fuzz工具通常包括以下几个步骤：</strong></p><p>(1)以一个正常的文件模板作为基础，按照一定规则产生一批畸形文件。<br>(2)将畸形文件逐一送入软件进行解析，并监视软件是否会抛出异常<br>(3)记录软件产生的错误信息，如寄存器状态、栈状态等。<br>(4)用日志或其他UI形式向测试人员展示异常信息，以进一步鉴定这些错误是否能被利用</p><blockquote><p><strong>Blind Fuzz</strong>即通常所说的“盲测”，就是在随机位置插入随机的数据以生成畸形文件。然而现代软件往往使用非常复杂的私有数据结构。</p></blockquote><blockquote><p>针对Blind Fuzz的不足，<strong>Smart Fuzz</strong>被越来越多地提出和应用。通常Smart Fuzz包括三方面的特征：<br>面向逻辑(Logic Oriented Fuzzing)<br>面向数据类型(Data Type Oriented Fuzzing)<br>基于样本(Sample Based Fuzzing)</p></blockquote><p><strong>面向数据类型测试：</strong>测试中可以生成的数据通常包括以下几种类型。</p><p>1）算术型：包括以HEX、ASCII、Unicode、Raw格式存在的各种数值。</p><p>2）指针型：包括Null指针、合法&#x2F;非法的内存指针等。</p><p>3）字符串型：包括超长字符串、缺少终止符(0x00)的字符串等。</p><p>4）特殊字符：包括#，@，’，&lt;,&gt;,&#x2F;,,..&#x2F;等等。</p><h1 id="第七讲-指针安全"><a href="#第七讲-指针安全" class="headerlink" title="第七讲 指针安全"></a><strong><strong>第七讲 指针安全</strong></strong></h1><h2 id="缓冲区溢出覆写指针条件："><a href="#缓冲区溢出覆写指针条件：" class="headerlink" title="缓冲区溢出覆写指针条件："></a>缓冲区溢出覆写指针条件：</h2><p>➔ 缓冲区与目标指针必须分配在同一个段内</p><p>➔ 缓冲区必须位于比目标指针更低的内存地址处</p><p>➔ 该缓冲区必须是界限不充分的，因此容易被缓冲区溢出利用</p><h2 id="虚函数攻击"><a href="#虚函数攻击" class="headerlink" title="虚函数攻击"></a><strong><strong>虚函数攻击</strong></strong></h2><p>多态是面向对象的一个重要特性，在C++中，这个特性主要靠对虚函数的动态调用来实现。</p><p>在仅仅关注漏洞利用的前提下，我们可以简单地把虚函数和虚表理解为一下几个要点。</p><p>1）C++类的成员函数在声明时，若使用关键字virtual进行修饰，则被称为虚函数</p><p>2）一个类中可能有很多个虚函数。</p><p>3）虚函数的入口地址被统一保存在虚表(Vtable)中。</p><p>4）对象在使用虚函数时，先通过虚表指针找到虚表，然后从虚表中取出最终的函数入口地址进行调用。</p><p>5）虚表指针保存在对象的内存空间中，紧接着虚表指针的是其他成员变量。</p><p>6）虚函数只有通过对象指针的引用才能显示出其动态调用的特性</p><h2 id="SEH攻击"><a href="#SEH攻击" class="headerlink" title="SEH攻击"></a><strong>SEH攻击</strong></h2><p>1）S.E.H结构体存放在系统栈中。</p><p>2）当线程初始化时，会自动向栈中安装一个S.E.H，作为线程默认的异常处理。</p><p>3）如果程序源代码中使用了__try{}__except{}或者Assert宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个S.E.H来实现异常处理。</p><p>4）栈中一般会同时存在多个S.E.H</p><p>5）栈中的多个S.E.H通过链表指针在栈内由栈顶向栈底串成单向链表，位于链表最顶端的S.E.H通过T.E.B(线程环境块)0字节偏移处的指针标识。</p><p>6）当异常发生时，操作系统会中断程序，并首先从T.E.B的0字节偏移处取出距离栈顶最近的S.E.H，使用异常处理函数句柄所指向的代码来处理异常。</p><p>7）当离“事故现场”最近的异常处理函数运行失败时，将顺着S.E.H链表依次尝试其他的异常处理函数。</p><p>8）如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通常，这个函数会弹出一个对话框，然后强制关闭程序</p><blockquote><p>首先，S.E.H存放在栈内，我们学过的栈溢出漏洞可能会派上用场。<br>其次，我们可以精心制造出溢出数据来把S.E.H的异常处理的函数地址替换为shellcode的起始地址。<br>再次，溢出后错误的栈帧或堆块数据往往会触发异常，或者我们能查到哪些能触发异常的片段。<br>最后，当Windows开始处理溢出后的异常时，会把hellcode当作异常函数来处理异常。</p></blockquote><h1 id="第八讲-格式化输出"><a href="#第八讲-格式化输出" class="headerlink" title="第八讲 格式化输出"></a><strong>第八讲 格式化输出</strong></h1><p><strong>格式化输出函数参数由一个格式字符串和可变数目的参数构成</strong></p><p>➔格式化字符串提供了一组可以由格式化输出函数解释执行的指令<br>➔用户可以通过控制格式字符串的内容来控制格式化输出函数的执行</p><p><strong>变参函数在C语言中实现的局限性导致格式化输出函数的使用中容易产生漏洞！</strong></p>]]></content>
    
    
    <summary type="html">软件安全的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://zhangyuanhe.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>信息系统安全课程笔记</title>
    <link href="https://zhangyuanhe.top/2024/01/14/BUPT_note/Notes%20on%20Information%20System%20Security/"/>
    <id>https://zhangyuanhe.top/2024/01/14/BUPT_note/Notes%20on%20Information%20System%20Security/</id>
    <published>2024-01-14T13:00:00.000Z</published>
    <updated>2024-01-17T12:51:36.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息系统安全"><a href="#信息系统安全" class="headerlink" title="信息系统安全"></a>信息系统安全</h1><h1 id="信息系统发展趋势（自学）"><a href="#信息系统发展趋势（自学）" class="headerlink" title="信息系统发展趋势（自学）"></a>信息系统发展趋势（自学）</h1><h1 id="第一讲-信息系统概述"><a href="#第一讲-信息系统概述" class="headerlink" title="第一讲  信息系统概述"></a>第一讲  信息系统概述</h1><h2 id="信息系统架构"><a href="#信息系统架构" class="headerlink" title="信息系统架构"></a>信息系统架构</h2><h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a><strong><strong>单机架构</strong></strong></h3><p>在网站开设初期，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。</p><h3 id="第一次演进：Tomcat与数据库分开部署"><a href="#第一次演进：Tomcat与数据库分开部署" class="headerlink" title="第一次演进：Tomcat与数据库分开部署"></a><strong><strong>第一次演进：Tomcat与数据库分开部署</strong></strong></h3><p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能</p><h3 id="第二次演进：引入本地缓存和分布式缓存"><a href="#第二次演进：引入本地缓存和分布式缓存" class="headerlink" title="第二次演进：引入本地缓存和分布式缓存"></a><strong><strong>第二次演进：引入本地缓存和分布式缓存</strong></strong></h3><p>在Tomcat服务器增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的HTML页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力</p><h3 id="第三次演进：引入反向代理实现负载均衡"><a href="#第三次演进：引入反向代理实现负载均衡" class="headerlink" title="第三次演进：引入反向代理实现负载均衡"></a><strong><strong>第三次演进：引入反向代理实现负载均衡</strong></strong></h3><p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发</p><h3 id="第四次演进：数据库读、写分离"><a href="#第四次演进：数据库读、写分离" class="headerlink" title="第四次演进：数据库读、写分离"></a><strong><strong>第四次演进：数据库读、写分离</strong></strong></h3><p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据</p><h3 id="第五次演进：数据库按业务分库"><a href="#第五次演进：数据库按业务分库" class="headerlink" title="第五次演进：数据库按业务分库"></a><strong><strong>第五次演进：数据库按业务分库</strong></strong></h3><p>把不同业务的数据保存到不同的数据库中，降低业务之间的资源竞争，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决</p><h3 id="第六次演进：把大表拆分为小表"><a href="#第六次演进：把大表拆分为小表" class="headerlink" title="第六次演进：把大表拆分为小表"></a><strong><strong>第六次演进：把大表拆分为小表</strong></strong></h3><p>这种做法显著增加了数据库运维的难度，对DBA的要求较高!!!</p><p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀地分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能</p><h3 id="第七次演进：使用LVS或F5使多个Nginx负载均衡"><a href="#第七次演进：使用LVS或F5使多个Nginx负载均衡" class="headerlink" title="第七次演进：使用LVS或F5使多个Nginx负载均衡"></a><strong><strong>第七次演进：使用LVS或F5使多个Nginx负载均衡</strong></strong></h3><p>LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。</p><h3 id="第八次演进：通过DNS轮询实现机房间的负载均衡"><a href="#第八次演进：通过DNS轮询实现机房间的负载均衡" class="headerlink" title="第八次演进：通过DNS轮询实现机房间的负载均衡"></a><strong><strong>第八次演进：通过DNS轮询实现机房间的负载均衡</strong></strong></h3><p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href="http://www.taobao.com时,dns服务器会使用轮询策略或其他策略,来选择某个ip供用户访问/">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问</a></p><h3 id="第九次演进：引入NoSQL数据库和搜索引擎等技术"><a href="#第九次演进：引入NoSQL数据库和搜索引擎等技术" class="headerlink" title="第九次演进：引入NoSQL数据库和搜索引擎等技术"></a><strong><strong>第九次演进：引入NoSQL数据库和搜索引擎等技术</strong></strong></h3><p>针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key&#x2F;value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决</p><h3 id="第十次演进：大应用拆分为小应用"><a href="#第十次演进：大应用拆分为小应用" class="headerlink" title="第十次演进：大应用拆分为小应用"></a><strong><strong>第十次演进：大应用拆分为小应用</strong></strong></h3><p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决</p><h3 id="第十一次演进：复用的功能抽离成微服务"><a href="#第十一次演进：复用的功能抽离成微服务" class="headerlink" title="第十一次演进：复用的功能抽离成微服务"></a><strong><strong>第十一次演进：复用的功能抽离成微服务</strong></strong></h3><p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理</p><h3 id="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"><a href="#第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异" class="headerlink" title="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"></a><strong><strong>第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异</strong></strong></h3><p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong><strong>架构</strong></strong></h2><p>架构（architecture）是针对某种特定目标系统的普遍性</p><p>问题而提供的具有体系性质的、通用的解决方案，是对复</p><p>杂系统的一种共性的体系抽象，目的是帮助人们能够正确、</p><p>合理地理解、设计和最终构建复杂的系统。</p><h3 id="信息系统体系架构分析的必要性：系统的复杂度"><a href="#信息系统体系架构分析的必要性：系统的复杂度" class="headerlink" title="信息系统体系架构分析的必要性：系统的复杂度"></a><strong><strong>信息系统体系架构分析的必要性：系统的复杂度</strong></strong></h3><p>从系统分析方法论的角度看，如果一个系统过于复杂，则对其进行分析的最好方法就是按照某种角度对整个系统进行<strong>解构</strong>。</p><h1 id="第二讲-信息系统安全概述"><a href="#第二讲-信息系统安全概述" class="headerlink" title="第二讲 信息系统安全概述"></a>第二讲 信息系统安全概述</h1><p>攻击致命度：攻击所具有的固话危害程度</p><p>描述网络威胁信息的结构化语言：STIX（结构化威胁信息表达式）</p><h2 id="信息系统的脆弱性"><a href="#信息系统的脆弱性" class="headerlink" title="信息系统的脆弱性"></a>信息系统的脆弱性</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>硬件电路也可以设计后门（在电容器累计电荷，触发操作）</p><p><strong>Intel AMT存在高危漏洞</strong></p><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>软件问题漏洞来自于软件的复杂性</p><h3 id="攻防不对称性"><a href="#攻防不对称性" class="headerlink" title="攻防不对称性"></a><strong><strong>攻防不对称性</strong></strong></h3><table><thead><tr><th>攻击可以在任意时刻发起</th><th>防御必须随时警惕</th></tr></thead><tbody><tr><td>攻击可以选择一个薄弱点进行</td><td>防御必须全线设防</td></tr><tr><td>攻击包含了对未知缺陷的探测</td><td>防御只能对已知的攻击防御</td></tr><tr><td>攻击常在暗处，具隐蔽性</td><td>防御常在明处，表面看起来完美，使人容易疏忽，丧失警惕</td></tr><tr><td>攻击可以肆意进行</td><td>防御必须遵循一定的规则</td></tr></tbody></table><ul><li>网络是个整体，攻击可以从任何一个薄弱点发起</li><li>网络攻击已自动化和智能化</li><li>安全响应速度要求越来越快，但面对海量安全事件，人力无法及时有效地分析处理</li></ul><h2 id="网络切片带来的安全挑战"><a href="#网络切片带来的安全挑战" class="headerlink" title="网络切片带来的安全挑战"></a><strong><strong>网络切片带来的安全挑战</strong></strong></h2><p>网络切片对网络构建带来了一定的挑战，需要考虑以下安全需求：</p><ul><li>切片授权与接入控制</li><li>切片间的资源冲突</li><li>切片间的安全隔离</li><li>切片用户的隐私保护</li><li>以切片方式隔离故障网元</li></ul><h2 id="信息系统安全实现"><a href="#信息系统安全实现" class="headerlink" title="信息系统安全实现"></a><strong><strong>信息系统安全实现</strong></strong></h2><p>信息系统安全保障是在信息系统的整个生命周期中，通过对信息系统的风险分析，制定并执行相应的安全保障策略，从技术、管理、工程和人员等方面提出安全保障要求，确保信息系统的保密性、完整性和可用性，降低安全风险到可接受的程度，从而保障系统实现组织机构的使命</p><h2 id="信息系统安全保障模型⎯⎯CMM框架"><a href="#信息系统安全保障模型⎯⎯CMM框架" class="headerlink" title="信息系统安全保障模型⎯⎯CMM框架"></a><strong><strong>信息系统安全保障模型⎯⎯CMM框架</strong></strong></h2><p>第一能力级别0：未实施<br>第二能力级别1：基本执行<br>第三能力级别2：计划跟踪<br>第四能力级别3：充分定义<br>第五能力级别4：量化控制<br>第六能力级别5：持续改进</p><h2 id="信息系统安全的理解"><a href="#信息系统安全的理解" class="headerlink" title="信息系统安全的理解"></a><strong><strong>信息系统安全的理解</strong></strong></h2><p>信息网络的硬件、软件及其系统中的数据受到保护，不受偶然的或者恶意的原因而遭到破坏、更改、泄露，系统连续可靠正常地运行，信息服务不中断。</p><h3 id="信息系统安全的实质"><a href="#信息系统安全的实质" class="headerlink" title="信息系统安全的实质"></a><strong><strong>信息系统安全的实质</strong></strong></h3><p><strong><strong>安全＝及时的检测和处理</strong></strong></p><p>$$<br>P_t&gt;Dt+R_t<br>$$</p><p>防护时间<em>Pt</em>：黑客在到达攻击目标之前需要攻破很多的设备（路由器，交换机）、系统（NT，UNIX）和防火墙等障碍，在黑客达到目标之前的时间</p><p>在黑客攻击过程中，我们检测到他的活动的所用时间称之为<em>Dt</em>，检测到黑客的行为后，我们需要作出响应，这段时间称之为<em>Rt</em>.</p><h2 id="应对威胁的方式——拟态主动防御"><a href="#应对威胁的方式——拟态主动防御" class="headerlink" title="应对威胁的方式——拟态主动防御"></a><strong><strong>应对威胁的方式——拟态主动防御</strong></strong></h2><h3 id="拟态路由器"><a href="#拟态路由器" class="headerlink" title="拟态路由器"></a><strong><strong>拟态路由器</strong></strong></h3><p>拟态路由器在其架构中引入多个异构冗余的路由执行体，通过对各个执行体维护的路由表项进行共识裁决，生成拟态路由器的路由表；通过对执行体的策略调度，可以实现拟态路由器对外呈现特征的不确定变化。在满足一定差异化设计的前提下，不同的执行体存在完全相同漏洞或后门的概率极低，攻击者即使控制了部分执行体，其恶意行为也很容易被拟态裁决机制所阻断，从而极大地提高路由器应对网络攻击的能力。</p><h3 id="拟态域名服务器"><a href="#拟态域名服务器" class="headerlink" title="拟态域名服务器"></a><strong>拟态域名服务器</strong></h3><p>拟态域名服务器以遏制域名解析服务漏洞后门的可利用性、建立内生安全防御机制、大幅提高攻击者的攻击难度和代价为出发点，可以在不改变现有域名协议和地址解析设施的基础上，通过拟态防御设备的增量部署，能够有效防御针对域名系统的域名投毒、域名劫持攻击等各种已知和未知域名攻击，能够提供安全可靠的域名解析服务。</p><h3 id="拟态Web虚拟机"><a href="#拟态Web虚拟机" class="headerlink" title="拟态Web虚拟机"></a><strong>拟态Web虚拟机</strong></h3><p>拟态Web虚拟机利用云平台部署空间上的优势，构建功能等价、多样化、动态化的异构虚拟web服务器池，采用动态执行体调度、数据库指令异构化、多余度（共识）表决等技术，建立多维动态变换的运行空间，阻断攻击链，大幅增加传统web服务和虚拟环境中的漏洞及后门利用难度，在不影响web服务性能的前提下，保证服务功能的安全可信</p><h3 id="拟态云服务器"><a href="#拟态云服务器" class="headerlink" title="拟态云服务器"></a><strong>拟态云服务器</strong></h3><p>拟态化的云服务器通过构建功能等价的异构云服务器池的方法，采用动态执行体调度、多余度（共识）表决、异常发现、线上（下）清洗等技术，及时阻断基于执行体软硬件漏洞后门等的“差模”攻击，使得蓄意攻击难以奏效。</p><h3 id="拟态防火墙"><a href="#拟态防火墙" class="headerlink" title="拟态防火墙"></a><strong>拟态防火墙</strong></h3><p>拟态化的云服务器通过构建功能等价的异构云服务器池的方法，采用动态执行体调度、多余度（共识）表决、异常发现、线上（下）清洗等技术，及时阻断基于执行体软硬件漏洞后门等的“差模”攻击，使得蓄意攻击难以奏效</p><h1 id="第三讲-安全需求及安全策略"><a href="#第三讲-安全需求及安全策略" class="headerlink" title="第三讲 安全需求及安全策略"></a><strong>第三讲 安全需求及安全策略</strong></h1><h2 id="安全需求的定义"><a href="#安全需求的定义" class="headerlink" title="安全需求的定义"></a><strong><strong>安全需求的定义</strong></strong></h2><p><strong>安全需求</strong>就是在设计一个安全系统时<strong>期望得到的安全保障</strong></p><h3 id="一般性的安全需求"><a href="#一般性的安全需求" class="headerlink" title="一般性的安全需求"></a><strong><strong>一般性的安全需求</strong></strong></h3><ul><li><strong>机密性需求</strong>，防止信息被泄漏给未授权的用户</li><li><strong>完整性需求，</strong>防止未授权用户对信息的修改</li><li><strong>可用性需求，</strong>保证授权用户对系统信息的可访问性</li><li><strong>可记账性需求，</strong>防止用户对访问过某信息或执行过某一操作以否认</li></ul><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a><strong><strong>安全策略</strong></strong></h2><p>针对面临的威胁决定采用何种对策的方法</p><ul><li>安全策略为针对威胁而选择和实行对策提供了框架</li></ul><h2 id="最常用的安全策略"><a href="#最常用的安全策略" class="headerlink" title="最常用的安全策略"></a><strong><strong>最常用的安全策略</strong></strong></h2><p><strong><strong>访问控制策略</strong></strong></p><p>系统必须选择下列三类相关属性制定访问控制策略</p><p>➢<strong>主体属性</strong></p><p>主体是系统内行为的发起者，通常是用户发起的进程</p><ul><li>信息的访问者（用户）</li><li>信息的拥有者</li><li>系统管理员</li></ul><p>➢<strong>客体属性</strong></p><p>➢<strong>系统环境（上下文）</strong></p><h2 id="自主访问控制策略"><a href="#自主访问控制策略" class="headerlink" title="自主访问控制策略"></a><strong><strong>自主访问控制策略</strong></strong></h2><p>❖ 自主访问控制的优点</p><p>➢ 访问模式设定灵活。</p><ul><li>读；写；执行；“每隔一周的周五可以读”；“读完文件x后才能</li></ul><p>读此文件”等等</p><p>➢ 具有较好的适应性，常用与商用OS和应用中</p><p>❖ 自主访问控制的缺点</p><p>➢ 不能防范木马和某些形式的恶意代码。</p><h2 id="强制访问控制策略"><a href="#强制访问控制策略" class="headerlink" title="强制访问控制策略"></a><strong><strong>强制访问控制策略</strong></strong></h2><h3 id="Bell-LaPadula模型"><a href="#Bell-LaPadula模型" class="headerlink" title="Bell-LaPadula模型"></a><strong><strong>Bell-LaPadula模型</strong></strong></h3><p><strong>公开 受限 秘密 机密 高密</strong></p><p>BLP 保密模型基于两种规则来保障数据的机密度与敏感度：</p><p>➢ 不上读（NRU）⎯⎯主体不可读安全级别高于它的数据</p><p>➢ 不下写（NWD）⎯⎯主体不可写安全级别低于它的数据</p><p><strong>BLP</strong>模型允许用户读取安全级别比他低的资源；相反地，写入对象的安全级别只能高于用户级别。</p><h3 id="防火墙所实现的单向访问机制"><a href="#防火墙所实现的单向访问机制" class="headerlink" title="防火墙所实现的单向访问机制"></a><strong>防火墙所实现的单向访问机制</strong></h3><p>防火墙所实现的单向访问机制不允许敏感数据从内部网络（例：其安全级别为“机密”）流向Internet（安全级别为“公开”）。</p><p>➢ 防火墙提供“不上读”功能来阻止Internet对内部网络的访问；</p><p>➢ 提供“不下写”功能来限制进入内部的数据流只能经由由内向外发起的连接流入（例如，允许HTTP的“GET”操作而拒绝“POST”操作，或阻止任何外发的邮件）。</p><h3 id="BIBA完整性模型"><a href="#BIBA完整性模型" class="headerlink" title="BIBA完整性模型"></a><strong>BIBA完整性模型</strong></h3><p>BIBA模型基于两种规则来保障数据的完整性的保密性：</p><p>➢ <strong>不下读（NRU）属性主体不能读取安全级别低于它的数据</strong></p><p>➢ <strong>不上写（NWD）属性主体不能写入安全级别高于它的数据</strong></p><h2 id="强制访问控制策略-1"><a href="#强制访问控制策略-1" class="headerlink" title="强制访问控制策略"></a><strong>强制访问控制策略</strong></h2><p>❖ <strong>最显著的特征</strong>：全局性和永久性</p><p>➢ 无论何时何地，主体和客体的标签是不会改变的。</p><p>➢ <strong>全局性</strong>：对特定的信息，从任何地方访问，它的敏感级别相同</p><p>➢ <strong>永久性</strong>：对特定的信息，在任何时间访问，它的敏感级别相同</p><p>➢ 上述特征在多级安全体系中称为“<strong>宁静性原则</strong>”（tranquility）</p><p>❖ 一旦不满足该原则，无法从根本上防备木马和恶意代码</p><h2 id="SSR安全模型"><a href="#SSR安全模型" class="headerlink" title="SSR安全模型"></a><strong><strong>SSR安全模型</strong></strong></h2><ol><li>当标签级别为“中级别”的主体访问标签级别为“高级别”的客体时，主体对客体无任何访问权限(no read up, no write up）。</li><li>当标签级别为“中级别”的主体访问标签级别为“中级别”的客体时，主体对客体持所有权限。</li><li>当标签级别为“中级别”的主体访问标签级别为“低级别”的客体时，主体对客体拥有只读权限（nowrite down）。</li></ol><p><strong>SSR安全模型的主要特点</strong></p><ol><li><p>信息流只能从低级别流向高级，确保的信息的保密性。</p></li><li><p>高级别主体对低级别客体的访问只能进行读取，确保了低级别资源的完整性</p></li></ol><h3 id="主体颗粒度扩充"><a href="#主体颗粒度扩充" class="headerlink" title="主体颗粒度扩充"></a><strong>主体颗粒度扩充</strong></h3><p>主体颗粒度扩充主要是把主体的颗粒度从用户级别扩充到进程级别，扩充的目的是为了实现更加细化的安全策略以保证信息系统的安全。</p><h3 id="SSR安全模型的应用"><a href="#SSR安全模型的应用" class="headerlink" title="SSR安全模型的应用"></a><strong><strong>SSR安全模型的应用</strong></strong></h3><p><strong>涉密系统方案</strong></p><p>通过应用SSR安全模型，信息流只能从低级别流向高级别，而不能往下，即使某一级别的用户受到病毒感染或者黑客渗透，其也只能感染和阅读自己的信息与读取下级的信息，确保了保密性。高权限用户无法篡改低权限用户的文件，保证了文件的完整性，避免了官大压人的现象，可以保证递交文件的真实可靠。</p><p><strong>病毒防治方案</strong></p><p>信息的访问需要程序，因此程序往往是被攻击对象，攻击了程序就可以访问其对应的文件甚至其他程序的文件。应用SSR安全模型以后，把主体颗粒度扩充到进程，让程序与程序需要文件进行绑定，然后再将程序本身进行只读保护，既能保证程序不被感染，又能防止对象被非法程序访问，从而保证了应用系统的安全性</p><h2 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a><strong><strong>访问控制列表</strong></strong></h2><p><strong>访问控制列表（ACL）</strong></p><p>访问控制列表是一系列允许或拒绝数据的指令的集合。</p><p><strong>读取第三层、第四层包头信息</strong></p><p><strong>根据预先定义好的规则对包进行过滤</strong></p><ul><li><p>**标准ACL:**只使用数据包的源地址作为测试条件。所有决定是基于源IP地址的。</p><p>  标准访问列表的创建根据 “动作”＋“源地址”，即允许谁、拒绝谁的方法来创建</p></li><li><p>**扩展ACL:**可以测试IP包的第3层和第4层报头中的字段。包括源IP地址、目的IP地址、网络层报头中的协议字段（如，TCP、UDP、ICMP等）以及位于传输层报头中的端口号。<br>扩展列表的放置——靠近源地址</p></li><li><p>**命名ACL:**命名ACL以列表名代替列表编号来定义IP访问控制列表，同样包括标准和扩展两种列表，定义过滤的语句与编号方式中相似。</p></li></ul><h3 id="通配掩码"><a href="#通配掩码" class="headerlink" title="通配掩码"></a><strong>通配掩码</strong></h3><p>路由器使用<strong>IP地址和通配掩码</strong>（wildcard-mask）一起来分辨匹配的地址范围，它跟子网掩码刚好相反。</p><p>它不像子网掩码告诉路由器IP地址的哪一位属于网络号一样，通配符掩码告诉路由器为了判断出匹配，它需要检查IP地址中的多少位。</p><p>有了通配掩码，可以只使用两个32位的号码来确定IP地址的范围，<strong>这是十分方便的</strong></p><ul><li>通配掩码（wildcard mask）是分成4字节的32bit数</li><li>通配掩码与IP地址位位配对，相应位为0&#x2F;1，用于表示如何对待IP地址中的相应位</li></ul><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled.png" alt="Untitled"></p><p>IP地址的第三个字节为16（00010000）。通配掩码中的前四位为0，告诉路由器要匹配IP地址的前四位（0000）。由于最后的四位被忽略，则所有的在范围16（00010000）到31（00011111）的都将被允许，相应的通配掩码位是1。</p><h1 id="第四讲安全风险评估"><a href="#第四讲安全风险评估" class="headerlink" title="第四讲安全风险评估"></a><strong>第四讲安全风险评估</strong></h1><h2 id="风险评估涉及标准"><a href="#风险评估涉及标准" class="headerlink" title="风险评估涉及标准"></a><strong><strong>风险评估涉及标准</strong></strong></h2><p>ISO&#x2F;IEA</p><h2 id="风险（Risk）的概念"><a href="#风险（Risk）的概念" class="headerlink" title="风险（Risk）的概念"></a><strong><strong>风险（Risk）的概念</strong></strong></h2><p>风险指在某一特定环境下，在某一特定时间段内，特定的威胁利用资产的一种或一组薄弱点，导致资产的丢失或损害的潜在可能性，即特定威胁事件发生的可能性与后果的结合</p><p><strong>安全风险组成的四要素：</strong>信息系统资产（Asset）、信息系统脆弱性（Vulnerability）、信息安全威胁（Threat）、信息系统安全保护措施（Safeguard）。</p><h2 id="风险处置策略"><a href="#风险处置策略" class="headerlink" title="风险处置策略"></a><strong><strong>风险处置策略</strong></strong></h2><p><strong>降低风险（Reduce Risk）</strong>采取适当的控制措施来降低风险，包括技术手段和管理手段，如安装防火墙，</p><p>杀毒软件，或是改善不规范的工作流程、制定业务连续性计划，等等。</p><p><strong>避免风险（Avoid Risk）</strong>通过消除可能导致风险发生的条件来避免风险的发生，如将公司内外网隔离</p><p>以避免来自互联网的攻击，或是将机房安置在不可能造成水患的位置，等等。</p><p>**转移风险（Transfer Risk)**将风险全部或者部分地转移到其他责任方，例如购买商业保险。</p><p><strong>接受风险（Accept Risk）</strong>在实施了其他风险应对措施之后，对于残留的风险，可以有意识地选择接受。</p><h2 id="风险评估的要素"><a href="#风险评估的要素" class="headerlink" title="风险评估的要素"></a><strong><strong>风险评估的要素</strong></strong></h2><p><strong>风险评估围绕着资产、威胁、脆弱性和安全措施这些基本要素展开。</strong></p><p>需要充分考虑业务战略、资产价值、安全需求、安全事件、残余风险等与这些基本要素相关的各类属性。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%201.png" alt="Untitled"></p><h3 id="信息系统安全风险计算模型（GB-T20984-2007）"><a href="#信息系统安全风险计算模型（GB-T20984-2007）" class="headerlink" title="信息系统安全风险计算模型（GB&#x2F;T20984-2007）"></a><strong><strong>信息系统安全风险计算模型（GB&#x2F;T20984-2007）</strong></strong></h3><p>风险计算模型是对通过风险分析计算风险值过程的抽象，它主要包括资产评估、威胁评估、脆弱性评估。</p><h3 id="安全风险评估的框架及流程（GB-T20984-2007）"><a href="#安全风险评估的框架及流程（GB-T20984-2007）" class="headerlink" title="安全风险评估的框架及流程（GB&#x2F;T20984-2007）"></a><strong><strong>安全风险评估的框架及流程（GB&#x2F;T20984-2007）</strong></strong></h3><p>① 对资产进行识别，并对资产的重要性进行赋值；<br>② 对威胁进行识别，描述威胁的属性，并对威胁出现的频率赋值；<br>③ 对资产的脆弱性进行识别，并对具体资产的脆弱性的严重程度赋值；<br>④ 根据威胁和脆弱性的识别结果判断安全事件发生的可能性；<br>⑤ 根据脆弱性的严重程度及安全事件所作用资产的重要性计算安全事件的损失；<br>⑥ 根据安全事件发生的可能性以及安全事件的损失，计算安全事件一旦发生对组织的影响，即风险值。</p><h2 id="资产分类方法"><a href="#资产分类方法" class="headerlink" title="资产分类方法"></a><strong><strong>资产分类方法</strong></strong></h2><table><thead><tr><th>分类</th><th>示例</th></tr></thead><tbody><tr><td>数据</td><td>保存在信息媒介上的各种数据资料，包括源代码、数据库数据、系统文档、运行管理规程、计划、报告、用户手册、各类纸质的文档等</td></tr><tr><td>软件</td><td>系统软件：操作系统、数据库管理系统、语句包、开发系统等</td></tr><tr><td>应用软件：办公软件、数据库软件、各类工具软件等</td><td></td></tr><tr><td>源程序：各种共享源代码、自行或合作开发的各种代码等</td><td></td></tr><tr><td>硬件</td><td>网络设备：路由器、网关、交换机等</td></tr><tr><td>计算机设备：大型机、小型机、服务器、工作站、台式计算机、便携计算机等</td><td></td></tr><tr><td>存储设备：磁带机、磁盘阵列、磁带、光盘、软盘、移动硬盘等</td><td></td></tr><tr><td>传输线路：光纤、双绞线等</td><td></td></tr><tr><td>保障设备：UPS、变电设备等、空调、保险柜、文件柜、门禁、消防设施等</td><td></td></tr><tr><td>安全保障：防火墙、入侵检测系统、身份鉴别等</td><td></td></tr><tr><td>其他：打印机、复印机、扫描仪、传真机等</td><td></td></tr><tr><td>服务</td><td>信息服务：对外依赖该系统开展的各类服务</td></tr><tr><td>网络服务：各种网络设备、设施提供的网络连接服务</td><td></td></tr><tr><td>办公服务：为提高效率而开发的管理信息系统，包括各种内部配置管理、文件流转管理等服务</td><td></td></tr><tr><td>人员</td><td>掌握重要信息和核心业务的人员，如主机维护主管、网络维护主管及应用项目经理等</td></tr><tr><td>其他</td><td>企业形象、客户关系等</td></tr></tbody></table><h3 id="资产等级计算公式"><a href="#资产等级计算公式" class="headerlink" title="资产等级计算公式"></a><strong><strong>资产等级计算公式</strong></strong></h3><p>AV&#x3D;F(AC, AI, AA)</p><p>Asset Value 资产价值</p><p>Asset Confidentiality 资产保密性赋值</p><p>Asset Integrity 资产完整性赋值</p><p>Asset Availability 资产可用性赋值</p><p>例1：AV&#x3D;MAX(AC, AI, AA)</p><p>例2：AV&#x3D;AC+AI+AA</p><p>例3：AV&#x3D;AC×AI×AA</p><h2 id="威胁来源列表"><a href="#威胁来源列表" class="headerlink" title="威胁来源列表"></a><strong><strong>威胁来源列表</strong></strong></h2><table><thead><tr><th>来源</th><th></th><th>描述</th></tr></thead><tbody><tr><td>环境因素</td><td></td><td>断电、静电、灰尘、潮湿、温度、鼠蚁虫害、电磁干扰、洪灾、火灾、地震、意外 事故等环境危害或自然灾害，以及软件、硬件、数据、通信线路等方面的故障</td></tr><tr><td>人为因素</td><td>恶意人员</td><td>不满的或有预谋的内部人员对信息系统进行恶意破坏；</td></tr><tr><td>采用自主或内外勾结的方式盗窃机密信息或进行篡改，获取利益外部人员利用信息系统的脆弱性,对网络或系统的机密性、完整性和可用性进行破坏，以获取利益或炫耀能力</td><td></td><td></td></tr><tr><td>人为因素</td><td>非恶意人员</td><td>内部人员由于缺乏责任心，或者由于不关心和不专注，或者没有遵循规章制度和操作流程而导致故障或信息损坏；</td></tr><tr><td>内部人员由于缺乏培训、专业技能不足、不具备岗 位技能要求而导致信息系统故障或被攻击</td><td></td><td></td></tr></tbody></table><h2 id="风险计算方法"><a href="#风险计算方法" class="headerlink" title="风险计算方法"></a><strong>风险计算方法</strong></h2><p><strong>风险值&#x3D;<em>R</em>(A, T, V) &#x3D; <em>R</em>(<em>L</em>(T, V), <em>F</em>(Ia,Va))</strong></p><p><strong>R</strong>安全风险计算函数</p><p><strong>A</strong>资产</p><p><strong>T</strong>威胁</p><p><strong>V</strong>脆弱性</p><p><strong>Ia</strong>安全事件所作用的资产价值</p><p><strong>Va</strong> 脆弱性严重程度</p><p><strong>L</strong>威胁利用资产的脆弱性导致安全事件发生的可能性</p><p><strong>F</strong>安全事件发生后产生的损失</p><h2 id="残留风险评价"><a href="#残留风险评价" class="headerlink" title="残留风险评价"></a><strong>残留风险评价</strong></h2><ul><li>绝对安全（即零风险）是不可能的</li><li>实施安全控制后会有残留风险或残存风险（Residual Risk）</li><li>为了确保信息安全，应该确保残留风险在可接受的范围内：</li></ul><p>➢ 残留风险Rr ＝ 原有的风险R0 － 控制ΔR</p><p>➢ 残留风险Rr ≤ 可接受的风险Rt</p><p><strong><strong>风险评估应贯穿于信息系统生命周期的各阶段</strong></strong></p><p><strong><strong>规划阶段的风险评估</strong></strong></p><p>规划阶段的评估结果应体现在信息系统整体规划或项目建议书中。</p><p><strong><strong>设计阶段的风险评估</strong></strong></p><p>设计阶段的评估可以以安全建设方案评审的方式进行，判定方案所提供的安全功能与信息技术安全技术标准的符合性。评估结果应体现在信息系统需求分析报告或建设实施方案中。</p><p><strong><strong>实施阶段的风险评估</strong></strong></p><p>本阶段风险评估可以采取对照实施方案和标准要求的方式，对实际建设结果进行测试、分析。</p><p><strong><strong>运行维护阶段的风险评估</strong></strong></p><p>运行维护阶段的风险评估应定期执行；当组织的业务流程、系统状况发生重大变更时，也应进行风险评估。</p><p><strong><strong>废弃阶段的风险评估</strong></strong></p><p>信息系统的维护技术人员和管理人员均应该参与此阶段的评估</p><p><strong><strong>一种新的风险评估⎯⎯数据风险评估</strong></strong></p><h2 id="风险评估项目实施过程"><a href="#风险评估项目实施过程" class="headerlink" title="风险评估项目实施过程"></a><strong><strong>风险评估项目实施过程</strong></strong></h2><p><strong>策划 准备 实施 报告 跟踪</strong></p><h1 id="第五讲-信息系统等级保护"><a href="#第五讲-信息系统等级保护" class="headerlink" title="第五讲  信息系统等级保护"></a><strong>第五讲  信息系统等级保护</strong></h1><h3 id="什么是等级保护"><a href="#什么是等级保护" class="headerlink" title="什么是等级保护"></a><strong>什么是等级保护</strong></h3><p>网络安全等级保护是指对国家重要信息、法人和其他组织及公民的专有信息以及公开信息和存储、传输、处理这些信息的信息系统分等级实行安全保护，对信息系统中使用的信息安全产品实行按等级管理，对信息系统中发生的信息安全事件分等级响应、处置</p><p><strong><strong>定级对象</strong></strong></p><p>也称等级保护对象、网络安全等级保护工作的作用对象</p><p>包括网络基础设施（广电网、电信网、专用通信网络等）、云计算平台系统、大数据平台系统、物联网、工业控制系统、采用移动互联技术的系统等</p><h2 id="等级保护有“五个规定动作”"><a href="#等级保护有“五个规定动作”" class="headerlink" title="等级保护有“五个规定动作”"></a><strong><strong>等级保护有“五个规定动作”</strong></strong></h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%202.png" alt="Untitled"></p><h2 id="等级保护主要工作流程"><a href="#等级保护主要工作流程" class="headerlink" title="等级保护主要工作流程"></a><strong><strong>等级保护主要工作流程</strong></strong></h2><p>1 <strong>定级  定级是等级保护的首要环节</strong></p><p>2 <strong>备案 备案是等级保护的核心</strong></p><p>3 <strong>建设整改 建设整改是等级保护工作落实的关键</strong></p><p>4 <strong>等级测评 等级测评是评价安全保护状况的方法</strong></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%203.png" alt="Untitled"></p><h1 id="第六讲-物理安全"><a href="#第六讲-物理安全" class="headerlink" title="第六讲 物理安全"></a><strong>第六讲 物理安全</strong></h1><h2 id="环境安全"><a href="#环境安全" class="headerlink" title="环境安全"></a><strong><strong>环境安全</strong></strong></h2><ul><li>安防技术</li><li>计算机机房的温度、湿度、洁净度</li><li>计算机机房的用电安全技术</li><li>计算机机房安全管理制度</li></ul><h3 id="机房三度要求"><a href="#机房三度要求" class="headerlink" title="机房三度要求"></a><strong><strong>机房三度要求</strong></strong></h3><blockquote><p>温度：机房温度一般应控制在18～22℃</p><p>湿度：相对湿度一般控制在40％～60％为宜</p><p>洁净度：尘埃颗粒直径&lt;0.5<em>m</em>，含尘量&lt;1万颗&#x2F;升</p></blockquote><p>GB50174-2008 电子信息系统机房设计规范</p><h3 id="防火与防水要求"><a href="#防火与防水要求" class="headerlink" title="防火与防水要求"></a><strong><strong>防火与防水要求</strong></strong></h3><p>为避免火灾、水灾，应采取如下具体措施:<br>（1）隔离<br>（2）火灾报警系统<br>（3）灭火设施<br>（4）管理措施</p><h3 id="机房防盗要求"><a href="#机房防盗要求" class="headerlink" title="机房防盗要求"></a><strong><strong>机房防盗要求</strong></strong></h3><h3 id="机房防鼠"><a href="#机房防鼠" class="headerlink" title="机房防鼠"></a><strong><strong>机房防鼠</strong></strong></h3><h3 id="防静电措施"><a href="#防静电措施" class="headerlink" title="防静电措施"></a><strong>防静电措施</strong></h3><blockquote><p> 机房的内装修材料一般应避免使用挂毯、地毯等吸尘、容易产生静电的材料，而应采用乙烯材料。</p><p>为了防静电，机房一般要安装防静电地板。</p><p> 机房内应保持一定湿度，特别是在干燥季节应适当增加空气湿度，以免因干燥而产生静电。</p></blockquote><h3 id="接地要求"><a href="#接地要求" class="headerlink" title="接地要求"></a><strong>接地要求</strong></h3><p>接地可以为计算机系统的数字电路提供一个稳定的0V参考电位</p><h1 id="第七讲-可靠性的基本概念"><a href="#第七讲-可靠性的基本概念" class="headerlink" title="第七讲 可靠性的基本概念"></a><strong>第七讲 可靠性的基本概念</strong></h1><h3 id="可靠性的定义"><a href="#可靠性的定义" class="headerlink" title="可靠性的定义"></a><strong><strong>可靠性的定义</strong></strong></h3><p>在规定的条件下、在给定的时间内，系统能实施应有功能的能力。</p><h3 id="可靠性参数"><a href="#可靠性参数" class="headerlink" title="可靠性参数"></a><strong><strong>可靠性参数</strong></strong></h3><p>$T_{MTTF}：$平均失效前时间</p><p>$T_{MTBF}：$平均故障间隔时间</p><p>$R：$<strong><strong>可靠度</strong></strong></p><p>$λ：$<strong><strong>失效率</strong></strong></p><h3 id="寿命"><a href="#寿命" class="headerlink" title="寿命"></a><strong><strong>寿命</strong></strong></h3><p>通常用一个非负随机变量$<em><strong>X</strong></em>$来描述产品的寿命。</p><p>$<em><strong>X</strong></em>$的分布函数为</p><p>$<em>F(t) &#x3D; P{X \le t}，t\ge0</em>$</p><p>有了寿命分布<em>F</em>(<em>t</em>) ，就知道产品的平均寿命</p><p>$EX&#x3D;\int_0^\infty tdF(t)$</p><h3 id="可靠度R"><a href="#可靠度R" class="headerlink" title="可靠度R"></a><em><strong><em>可靠度</em>R</strong></em></h3><p>产品在时刻 <em>t</em> 之前都正常工作（不失效）的概率，即产品在时刻 <em>t</em>的生存概率，称为无故障工作概率（可靠度函数）</p><p>$$<br>R(t)&#x3D;P{X&gt;t}&#x3D;\int_0^\infty dF(t)&#x3D;\int_0^\infty f(t)dt \<br>𝑹(t) +F(t)&#x3D;1<br>$$</p><blockquote><p>假设 C 是一个具有 <em>N</em> 个元器件的数字系统，在一定的条件和环境（如温度、湿度、电压等）下运行，并且随着时间 <em>t</em> 的推移质量逐步下降</p></blockquote><p>系统<strong>C</strong>在时刻 <em>t</em> 能正常工作的概率 $<em><strong>R(t)&#x3D;S(t)&#x2F;N</strong></em>$</p><p>**<em>R</em>(<em>t</em>)**称为系统 <strong>C</strong> 在时刻 <em>t</em> 的可靠度。</p><h3 id="失效率λ"><a href="#失效率λ" class="headerlink" title="失效率λ"></a><strong><strong>失效率λ</strong></strong></h3><p>假设<em>F</em>(<em>t</em>)是绝对连续的，即存在分布密度函数$<em>f(t)&#x3D;F’(t)</em>$且$F(t)&#x3D;\int_0^tf(x)dx$</p><blockquote><p>将发生故障的条件概率密度叫做失效率。<br>$λ(t)&#x3D;f(t)&#x2F;R(t)&#x3D;-R’(t)&#x2F;R(t)$<br>失效率**λ(<em>t</em>)**表示系统中元器件失效的速率。</p></blockquote><h3 id="λ-t-的浴缸形曲线（Bathtub-curve）"><a href="#λ-t-的浴缸形曲线（Bathtub-curve）" class="headerlink" title="**λ(t)的浴缸形曲线（Bathtub-curve）"></a>**<strong>λ(<em>t</em>)的浴缸形曲线（Bathtub-curve）</strong></h3><p><strong>第一阶段 早期失效期（Infant Mortality）</strong></p><p>器件在开始使用时失效率很高，但随着产品工作时间的增加，失效率迅速降低。这一阶段失效的原因大多是由于设计、原材料和制造过程中的缺陷造成的。为了缩短这一阶段的时间，产品应在投入运行前进行试运转，以便及早发现、修正和排除故障；或通过试验进行筛选，剔除不合格品。</p><p><strong>第二阶段 偶然失效期，也称随机失效期（Random Failures）</strong></p><p>这一阶段的特点是失效率较低，且较稳定，往往可近似看作常数。这一时期是产品的良好使用阶段。由于在这一阶段中，产品失效率近似为一常数，故设<em></em>(<em>t</em>)&#x3D;<em>λ</em>（常数）由可靠度计算公式得$R(t)&#x3D;e^{-λt}$ 这一式表明<strong>设备的可靠性与失效率成指数关系</strong>。</p><p><strong>第三阶段 耗损失效期（Wearout）</strong></p><p>该阶段的失效率随时间的延长而急速增加，主要原因是器件的损失己非常的严重，寿命快到尽头了，可适当的维修或直接更换。</p><p>**<strong><em>R</em>(<em>t</em>)和λ的关系</strong></p><p>可靠性不仅是时间<em>t</em>的函数，而且与失效率<strong><strong>λ</strong></strong>有着密切的关联。</p><p>$$<br>R(t)&#x3D;e^{\int^t_0\lambda(t)dt }<br>$$</p><h3 id="可维修产品的平均维修时间"><a href="#可维修产品的平均维修时间" class="headerlink" title="可维修产品的平均维修时间"></a><strong><strong>可维修产品的平均维修时间</strong></strong></h3><p>可维修产品的可维护性平均维修时间（MTTR，Mean Time To Repair）来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间（即设备处于故障状态时间的平均值，或设备修复时间的平均值）。系统的可维护性越好，平均维修时间越短</p><p>$$<br>MTTR&#x3D;\int^\infty _0t\mu(t)dt<br>$$</p><blockquote><p>$<em>\mu(t)</em>$是维修时间的概率密度函数</p></blockquote><h3 id="可维修产品的维修性指标：可用性"><a href="#可维修产品的维修性指标：可用性" class="headerlink" title="可维修产品的维修性指标：可用性"></a><strong><strong>可维修产品的维修性指标：可用性</strong></strong></h3><p>可维修产品的可用性定义为：</p><p>$$<br>\frac{MTBF}{MTBF+MTTR}*100%<br>$$</p><p><strong>计算机系统可靠性举例</strong></p><p>已知世界上第一代电子管计算机ENIAC有20000个电子管，假<br>设每个电子管的失效率为&#x3D;0.5%&#x2F;kh（千小时），试求：<br>（1）该计算机的MTTF；<br>（2）若要求计算机的可靠性在95%以上，则至多可以工作多久？</p><p>$$<br>MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i}&#x3D;\frac{1}{\frac{0.05}{100}*\frac{1}{1000}*20000}&#x3D;\frac{1}{0.01}&#x3D;100H\ R(t)&#x3D;e^{-\frac{t}{MTTF}}\ t&#x3D;5H<br>$$</p><h2 id="系统可靠性模型"><a href="#系统可靠性模型" class="headerlink" title="系统可靠性模型"></a><strong><strong>系统可靠性模型</strong></strong></h2><p><strong>可靠性模型：描述了系统及其组成单元之间的故障逻辑关系</strong></p><h3 id="串联系统"><a href="#串联系统" class="headerlink" title="串联系统"></a><strong><strong>串联系统</strong></strong></h3><p>假设第<em>i</em>个部件的寿命为$<em><strong>X_i</strong></em>$，可靠度为$<em>R_i(t)&#x3D;P{X_i &gt;t}，i&#x3D;1, 2, …,n,</em>$第$<em>i</em>$个部件的失效率为$<em>\lambda_i(t)</em>$$，X_1，X_2 ，…，X_n$相互独立。若</p><p>初始时刻$<em>t&#x3D;0</em>$，所有部件都是新的，且同时开始工作。</p><p>(1) 系统的寿命是： $X&#x3D;min{X_1 ，X_2，…，X_n}$</p><p>(2) 系统的可靠度是：</p><p>$$<br>R(t)&#x3D;P{min(X_1 ，X_2，…，X_n)&gt;t}&#x3D;\Pi^n_{i&#x3D;1}R_i(t)\ &#x3D;\Pi^n_{i&#x3D;1}exp{-\int^t_0\lambda_i(u)du}<br>$$</p><p>(3) 系统的失效率为：</p><p>$$<br>\lambda(t)&#x3D;-\frac{R’(t)}{R(t)}&#x3D;\sum^n_{i&#x3D;1}\lambda_i(t)<br>$$</p><p>(4) 系统的平均寿命为:</p><p>$$<br>MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\int^\infty_0exp{-\int^t_0\lambda(u)du}dt<br>$$</p><p>当$R_i(t)&#x3D;exp{-\lambda_t}，i&#x3D;1, 2, …, n$时（及当第<em>i</em>个部件的命遵从参数为$<em>\lambda_i</em>$的</p><p>指数分布时），系统的可靠度和平均寿命为</p><p>$$<br>R(t)&#x3D;exp{-\sum^n_{i&#x3D;1}\lambda_it}\ MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i}<br>$$</p><h3 id="并联系统"><a href="#并联系统" class="headerlink" title="并联系统"></a><strong><strong>并联系统</strong></strong></h3><p>(1) 系统的寿命是： $X&#x3D;max{X_1，X_2，…，X_n<br>}$</p><p>(2) 系统的可靠度是：</p><p>$$<br>R(t)&#x3D;P{max(X_1 ，X_2，…，X_n)&gt;t}\ &#x3D;1-P{max(X_1 ，X_2，…，X_n)\le t } \ &#x3D;1-\Pi^n_{i&#x3D;1}[1-R_i(t)]<br>$$</p><p>(3) 系统的平均寿命为：</p><p>$$<br>MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\sum^n_{i&#x3D;1}\frac{1}{\lambda_i}\ &#x3D;sum_{1\le&lt;i&lt;j\le n}\frac{1}{\lambda_1+\lambda_j}+…+(-1)^{n-1}\frac{1}{\lambda_1+…+\lambda_n}<br>$$</p><h1 id="第八讲-信息系统的可靠性"><a href="#第八讲-信息系统的可靠性" class="headerlink" title="第八讲 信息系统的可靠性"></a><strong>第八讲 信息系统的可靠性</strong></h1><h3 id="计算机系统可靠性"><a href="#计算机系统可靠性" class="headerlink" title="计算机系统可靠性"></a><strong>计算机系统可靠性</strong></h3><p><strong>硬件可靠性</strong></p><p>硬件在使用过程中有磨损、材料的老化、变质和使用环境等多种因素</p><p><strong>软件可靠性</strong></p><p>软件使用期间无磨损;存在物质老化和变质</p><h2 id="提高信息系统可靠性的途径"><a href="#提高信息系统可靠性的途径" class="headerlink" title="提高信息系统可靠性的途径"></a><strong><strong>提高信息系统可靠性的途径</strong></strong></h2><p><strong>提高可靠性有两个方面：一是尽量使系统在规定时间内少发生故障和错误；二是发生了故障能迅速排除。</strong></p><h3 id="提高硬件可靠性"><a href="#提高硬件可靠性" class="headerlink" title="提高硬件可靠性"></a><strong><strong>提高硬件可靠性</strong></strong></h3><p><strong>设计</strong></p><p>结构优化<br>功能合理</p><p><strong>环境</strong></p><p>符合相关的标准和要求</p><p><strong>使用</strong></p><p>符合操作规程<br>减少人为失误</p><blockquote><p><strong>冗余设计</strong></p><p>故障容错是利用冗余的元部件来屏蔽已发生的故障对系统的影响。</p><p>三模冗余（TMR，Triple Modular Redundancy）的基本原理是：系统输入通过3个功能相同的模块，产生的3个结果送到多数表决器进行表决，即三中取二的原则，如果模块中有一个出错，而另外两个模块正常，则表决器的输出正确，从而可以屏蔽一个故障。</p><p><strong>TMR的缺点是：如果3个模块的输出各不相同，则无法进行多数表决；若有两个模块出现一致的故障，则表决的结果会出现错误。</strong></p></blockquote><h2 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h2><p><strong><strong>程序运行监视系统</strong></strong></p><p>程序运行监视系统WTD（“看门狗”），是一种软硬件结合的抗程序“跑飞”的措施。其硬件是一个用于产生定时 <em>T</em> 的计数器或单稳触发器。其定时输出端接至CPU 的复位线，而其定时清零则由CPU 控制。</p><p>在正常情况下，程序启动WTD 后，即以小于<em>T</em> 的间隔 <em>t</em> 将其清零一次，这样WTD 的定时溢出就不会发生。在受到干扰的异常情况下，程序的正常执行顺序被破坏，不可能周期性地将WTD清零，导致WTD定时溢出，使系统复位，CPU 摆脱因程序“跑飞”造成的瘫痪状态</p><h3 id="软件可靠性模型"><a href="#软件可靠性模型" class="headerlink" title="软件可靠性模型"></a><strong><strong>软件可靠性模型</strong></strong></h3><p><strong><strong>失效时间间隔模型</strong></strong></p><p>这类模型最常用的方法是假定第<em>i</em>个失效到第<em>i</em>+1个失效间隔时间服从某一分布，而分布的参数依赖于各间隔时间内程序中的残留错误数。通过测试所得到的失效间隔时间数据来估计模型的参数，由获得的模型可以估算软件的可靠度以及各失效间的平均工作时间等</p><p><strong><strong>Jelinski-Moranda模型</strong></strong></p><p>系统基本假设如下：<br>（1）软件中的固有错误数<em>N</em>是一个未知的常数；<br>（2）软件中的各个错误是相互独立的，每个错误导致系统发生失效的可能性大致相同,各次失效间隔时间也相互独立；<br>（3）软件错误被发现后立即排除，每次排除一个错误且不引入新的错误，排除错误的时间忽略不计；<br>（4）软件的失效率在每个失效间隔时间内是常数，其数值正比于程序中残留的错误数，在第$<em>i</em>$个测试区间$<em>t_i</em>$，其失效率函数为:$\lambda(t_i)&#x3D;\phi(N-i+1)$,$\phi$为比例常数 。</p><p><strong><strong>缺陷计数模型</strong></strong></p><p>这类模型关心的是在<strong>特定的时间间隔内软件的错误数或失效数</strong>，并假定故障累计数服从某个己知的随机过程，过程强度是时间的离散或连续函数，根据在给定的测试时间间隔发现的错误数或失效数来估计故障强度、均值等参数。</p><p><strong><strong>错误植入模型</strong></strong></p><p>这类模型的基本思路是通过将一组已知的错误人为地植入到一个固有错误总数尚不清楚的程序中，然后在程序的测试中观察并统计发现的植入错误数和程序总的错误数，通过计数的比值估计程序的固有错误总数，从而得到软件可靠度及其有关指标。这类模型的代表是Mills的超几何分布模型。</p><p><strong><strong>基于输入域的模型</strong></strong></p><p>这类模型的基本研究方法是根据程序的使用情况，找出程序可能输入的概率分布，根据这种分布产生一个测试用例的集合。由于得到输入的分布难度较大，一般将输入域划分成等价类，每个等价类与程序的一条执行路径相联。在输入域上随机抽取测试用例，执行相应的程序测试，观测故障，从而推断出各项指标。这类模型以Nelson模型为代表，还有Brown-Lipow的基于输入域模型和Ramamoorthy-Bastani的基于输入域模型</p><h2 id="网络可靠性"><a href="#网络可靠性" class="headerlink" title="网络可靠性"></a><strong><strong>网络可靠性</strong></strong></h2><p><strong>故障定义</strong>– <strong>网络不能在用户期望的时间范围内将物质、信息、能量按用户需求完整、正确地在网络中传输的状态或事件</strong></p><p><strong><strong>计算机网络可靠性定义</strong></strong></p><p>在人为或自然的破坏作用下，网络在特定环境和规定时间内，充分完成规定的通信功能的能力。<strong>环境、时间和充分完成功能是这一定义的三要素。</strong></p><p>当传输设备和交换设备发生故障时网络可以维持正常业务的程度</p><h1 id="第九讲-信息系统的容错技术"><a href="#第九讲-信息系统的容错技术" class="headerlink" title="第九讲 信息系统的容错技术"></a><strong>第九讲 信息系统的容错技术</strong></h1><h2 id="容错的概念"><a href="#容错的概念" class="headerlink" title="容错的概念"></a><strong><strong>容错的概念</strong></strong></h2><p>容忍故障，即故障一旦发生时能够<strong>自动检测</strong>出来并使系统能够<strong>自动恢复正常运行</strong></p><p><strong>容错设计的软件可以有某些规定数目的故障但不导致失效，但对无容错的软件而言，故障即失效。</strong></p><h2 id="容错的主要内容"><a href="#容错的主要内容" class="headerlink" title="容错的主要内容"></a><strong><strong>容错的主要内容</strong></strong></h2><p><strong>故障检测和诊断</strong></p><p>故障检测（Fault Detection）：判断系统是否存在故障的过程<br><strong>故障检测的作用是确认系统是否发生了故障，指示故障的状态，即查找故障源和故障性质。一般来说，故障检测只能找到错误点（错误单元），不能准确找到故障点。</strong></p><p>故障诊断（Fault Diagnosis）：检测出系统存在故障后要进行故障的定位，找出故障所在的位置</p><p><strong>故障屏蔽技术</strong></p><p>故障屏蔽技术是防止系统中的故障在该系统的信息结构中产生差错的各种措施的总称，其实质是在故障效应达到模块的输出以前，利用冗余资源将故障影响掩盖起来，达到容错目的</p><p><strong>冗余技术</strong></p><p>三模冗余可以由用户手动完成，也可以依靠工具完成。Xilinx推出了XIlInXtMrtool ，可以方便地实现三模冗余设计，并且可以方便地配置被冗余项，大大方便了用户</p><p><strong>时间冗余技术</strong></p><p><strong>基本思想：</strong>重复执行指令或者一段程序来消除故障的影响，以达到容错的效果，它是用消耗时间来换取容错的目的。</p><p><strong>信息冗余技术</strong></p><p>信息容错技术是通过在数据中附加冗余的信息位来达到故障检测和容错的目的</p><p><strong>软件冗余技术</strong></p><p>软件容错是指在出现有限数目的软件故障的情况下，系统仍可提供连续正确执行的内在能力。其目的是屏蔽软件故障，恢复因出故障而影响的运行进程。</p><p>实现软件容错的基本方法，是将若干个根据同一需求说明编写的不同程序（即多版本程序），在不同空间同时运行，然后在每一个设置点通过表决或接收测试进行表决。</p><h2 id="典型的容错应用"><a href="#典型的容错应用" class="headerlink" title="典型的容错应用"></a><strong><strong>典型的容错应用</strong></strong></h2><p><strong><strong>热备份（Hot-Standby）</strong></strong></p><p>M运行，S后备；</p><p>M故障，S接管作M；</p><p>原M修复，S归还M。</p><h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a><strong><strong>RAID</strong></strong></h3><p>廉价磁盘冗余阵列（Redundant Arrays of Inexpensive Disks），以多个低成本磁盘构成磁盘子系统，提供比单一硬盘更完备的可靠性和高性能</p><p><strong>数据基带条阵列（RAID0）</strong></p><p>分块无校验型，无冗余存储。简单将数据分配到各个磁盘上，不提供真正容错性。带区化至少需要2个硬盘，可支持8&#x2F;16&#x2F;32个磁盘</p><p> <strong>优点</strong></p><p>➢允许多个小区组合成一个大分</p><p>➢更好地利用磁盘空间，延长磁盘寿命</p><p>➢多个硬盘并行工作，提高了读写性能</p><p> <strong>缺点</strong></p><p>➢不提供数据保护，任一磁盘失效，数据可能丢失，且不能自动恢复。</p><p><strong>磁盘镜象（RAID1）</strong></p><p>每一组盘至少两台，数据同时以同样的方式写到两个盘上，两个盘互为镜象。磁盘镜象可以是分区镜象、全盘镜象。容错方式以空间换取，实施可以采用镜象或者双工技术。</p><p> <strong>优点</strong></p><p>➢ 可靠性高，策略简单，恢复数据时不必停机。</p><p> <strong>缺点</strong></p><p>➢ 有效容量只有总容量的1&#x2F;2，利用率50%。由于磁盘冗余，硬件</p><p>开销较大，成本较高</p><p><strong>循环奇偶校验阵列（RAID5）</strong></p><p>与RAID4类似，但校验数据不固定在一个磁盘上，而是循环地依次分布在不同的磁盘上，也称块间插入分布校验。它是目前采用最多、最流行的方式，至少需要3个硬盘。</p><p> 优点</p><p>➢ 校验分布在多个磁盘中，写操作可以同时处理；</p><p>➢ 为读操作提供了最优的性能；</p><p>➢ 一个磁盘失效，分布在其他盘上的信息足够完成数据重建 。</p><p> 缺点</p><p>➢ 数据重建会降低读性能；</p><p>➢ 每次计算校验信息，写操作开销会增大，是一般存储操作时间的3倍</p>]]></content>
    
    
    <summary type="html">信息系统安全的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://zhangyuanhe.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编译原理与技术课程笔记</title>
    <link href="https://zhangyuanhe.top/2024/01/11/BUPT_note/Notes%20on%20Compilation%20principle/"/>
    <id>https://zhangyuanhe.top/2024/01/11/BUPT_note/Notes%20on%20Compilation%20principle/</id>
    <published>2024-01-11T13:00:00.000Z</published>
    <updated>2024-01-17T12:52:44.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译原理与技术-郭燕慧"><a href="#编译原理与技术-郭燕慧" class="headerlink" title="编译原理与技术 郭燕慧"></a>编译原理与技术 郭燕慧</h1><h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><table><thead><tr><th>Lexical Analyzer</th><th>词法分析</th></tr></thead><tbody><tr><td>Syntax Analyzer</td><td>语法分析</td></tr><tr><td>Semantic Analyzer</td><td>语义分析</td></tr><tr><td>Intermediate Code Generator</td><td>中间代码生成</td></tr><tr><td>Machine-Independent Code Optimizer</td><td>机器无关的代码优化</td></tr><tr><td>Code Generator</td><td>代码生成</td></tr><tr><td>Machine-Dependent Code Optimizer</td><td></td></tr></tbody></table><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>将源程序分解为多个组成部分，并对其施加语法结构</li><li>使用语法结构创建一个中间表示intermediate representation(IR)的源程序</li><li>收集有关源程序的信息，并将其存储在称为符号表的数据结构中(将通过IR传递给后端)</li></ul><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul><li>根据IR和符号表中的信息构造目标程序(通常用机器语言)</li><li>在此过程中执行代码优化</li></ul><h3 id="词法分析-Lexical-Analyzer"><a href="#词法分析-Lexical-Analyzer" class="headerlink" title="词法分析 Lexical Analyzer"></a>词法分析 Lexical Analyzer</h3><p>&lt;token-name, attribute-value&gt;</p><aside>💡 token-name 在语法分析中使用的抽象符号</aside><aside>💡 attribute-value 指向符号表中的一个项。表项中的信息用于语义分析和代码生成</aside><p>position &#x3D; initial + rate * 60</p><p>Lexical Analyzer</p><p>&lt;id, 1&gt;<br>&lt;&#x3D;&gt;<br>&lt;id, 2&gt;<br>&lt;+&gt;<br>&lt;id, 3&gt;<br>&lt;*&gt;<br>&lt;60&gt;</p><h3 id="语法分析-Syntax-Analyzer"><a href="#语法分析-Syntax-Analyzer" class="headerlink" title="语法分析 Syntax Analyzer"></a>语法分析 Syntax Analyzer</h3><p>语法分析器(解析器)使用词法分析器生成的令牌名称来创建描述令牌流语法结构的中间表示，通常是语法树</p><p>每个内部节点表示一个操作，该节点的子节点表示该操作的参数</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled.png" alt="Untitled"></p><h3 id="语义分析-Semantic-Analysis"><a href="#语义分析-Semantic-Analysis" class="headerlink" title="语义分析 Semantic Analysis"></a>语义分析 Semantic Analysis</h3><p>语义分析器使用语法树和符号表中的信息来检查源程序与语言定义的语义一致性</p><p>还收集用于类型检查、类型转换和中间代码生成的类型信息</p><p>编程语言的语法描述了其程序的适当形式</p><p>编程语言的语义描述了其程序的含义，即每个程序在执行时所做的事情</p><h3 id="类型检查-Type-Checking"><a href="#类型检查-Type-Checking" class="headerlink" title="类型检查 Type Checking"></a>类型检查 Type Checking</h3><p>语义分析的一个重要部分是类型检查编译器检查每个操作符是否有匹配的操作数(类型正确)</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%201.png" alt="Untitled"></p><h3 id="中间代码生成-Machine-Independent-Code-Optimizer"><a href="#中间代码生成-Machine-Independent-Code-Optimizer" class="headerlink" title="中间代码生成 Machine-Independent Code Optimizer"></a>中间代码生成 Machine-Independent Code Optimizer</h3><ul><li>经过语义分析后，编译器生成一个中间值representation, typically three-address code (Three-address code)</li><li>类汇编指令，每条指令有三个操作数，每个操作数就像一个寄存器</li><li>每个赋值指令在RHS上最多有一个操作符</li><li>易于翻译成目标机器的机器指令</li></ul><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%202.png" alt="Untitled"></p><h3 id="机器无关的代码优化-Machine-Independent-Code-Optimization"><a href="#机器无关的代码优化-Machine-Independent-Code-Optimization" class="headerlink" title="机器无关的代码优化 Machine-Independent Code Optimization"></a>机器无关的代码优化 Machine-Independent Code Optimization</h3><p>类似于英文的文章编辑&#x2F;修改，改进中间代码以获得更好的目标代码</p><p>t1 &#x3D; inttofloat(60) </p><p>t2 &#x3D; id3 * t1<br>t3 &#x3D; id2 + t2</p><p>id1 &#x3D; t3</p><p>—&gt;</p><p>t1 &#x3D; id3 * 60.0 </p><p>id1 &#x3D; id2 + t1</p><h3 id="代码生成-Code-Generator"><a href="#代码生成-Code-Generator" class="headerlink" title="代码生成 Code Generator"></a>代码生成 Code Generator</h3><p>t1 &#x3D; id3 * 60.0 </p><p>id1 &#x3D; id2 + t1</p><p>Code<br>Generation</p><p>LDF R2, id3<br>MULF R2, R2, #60.0 </p><p>LDF R1, id2<br>ADDF R1, R1, R2</p><p> STF id1, R1</p><h3 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h3><ul><li>由前端执行，符号表与中间代码一起传递到后端</li><li>记录变量名称和存储分配的各种属性、类型、作用域</li><li>记录过程名称和各种属性<ul><li>参数的数量和类型</li><li>传递参数的方式(通过值或引用)</li><li>返回类型</li></ul></li></ul><h3 id="中间语言（Intermediate-Language）IL"><a href="#中间语言（Intermediate-Language）IL" class="headerlink" title="中间语言（Intermediate Language）IL"></a><strong><strong>中间语言（Intermediate Language）IL</strong></strong></h3><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%203.png" alt="Untitled"></p><h3 id="编译器与解释器的区别"><a href="#编译器与解释器的区别" class="headerlink" title="编译器与解释器的区别"></a>编译器与解释器的区别</h3><ul><li><p>1</p><p>  编译器将用高级语言编写的源程序翻译成可以直接在目标计算机上运行的机器码。</p><p>  解释器直接执行源代码中的每条语句，而不需要将程序编译成机器码。</p></li><li><p>2</p><p>  解释器通常花费较少的时间来分析源代码:他们只是解析每个语句并执行它(例如，Python代码)。</p><p>  相比之下，编译器通常会分析语句之间的关系(例如，控制流和数据流)以实现优化。</p></li><li><p>3</p><p>  解释器继续执行程序，直到遇到第一个错误，在这种情况下它们停止。</p><p>  对于编译语言，程序只有在编译成功后才可执行。</p></li></ul><h2 id="编译器的结构-1"><a href="#编译器的结构-1" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><table><thead><tr><th>Lexical Analyzer</th><th>词法分析</th></tr></thead><tbody><tr><td>Syntax Analyzer</td><td>语法分析</td></tr><tr><td>Semantic Analyzer</td><td>语义分析</td></tr><tr><td>Intermediate Code Generator</td><td>中间代码生成</td></tr><tr><td>Machine-Independent Code Optimizer</td><td>机器无关的代码优化</td></tr><tr><td>Code Generator</td><td>代码生成</td></tr><tr><td>Machine-Dependent Code Optimizer</td><td></td></tr></tbody></table><h3 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h3><ul><li>将源程序分解为多个组成部分，并对其施加语法结构</li><li>使用语法结构创建一个中间表示intermediate representation(IR)的源程序</li><li>收集有关源程序的信息，并将其存储在称为符号表的数据结构中(将通过IR传递给后端)</li></ul><h3 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h3><ul><li>根据IR和符号表中的信息构造目标程序(通常用机器语言)</li><li>在此过程中执行代码优化</li></ul><h3 id="词法分析-Lexical-Analyzer-1"><a href="#词法分析-Lexical-Analyzer-1" class="headerlink" title="词法分析 Lexical Analyzer"></a>词法分析 Lexical Analyzer</h3><p>&lt;token-name, attribute-value&gt;</p><aside>💡 token-name 在语法分析中使用的抽象符号</aside><aside>💡 attribute-value 指向符号表中的一个项。表项中的信息用于语义分析和代码生成</aside><p>position &#x3D; initial + rate * 60</p><p>Lexical Analyzer</p><p>&lt;id, 1&gt;<br>&lt;&#x3D;&gt;<br>&lt;id, 2&gt;<br>&lt;+&gt;<br>&lt;id, 3&gt;<br>&lt;*&gt;<br>&lt;60&gt;</p><h3 id="语法分析-Syntax-Analyzer-1"><a href="#语法分析-Syntax-Analyzer-1" class="headerlink" title="语法分析 Syntax Analyzer"></a>语法分析 Syntax Analyzer</h3><p>语法分析器(解析器)使用词法分析器生成的令牌名称来创建描述令牌流语法结构的中间表示，通常是语法树</p><p>每个内部节点表示一个操作，该节点的子节点表示该操作的参数</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled.png" alt="Untitled"></p><h3 id="语义分析-Semantic-Analysis-1"><a href="#语义分析-Semantic-Analysis-1" class="headerlink" title="语义分析 Semantic Analysis"></a>语义分析 Semantic Analysis</h3><p>语义分析器使用语法树和符号表中的信息来检查源程序与语言定义的语义一致性</p><p>还收集用于类型检查、类型转换和中间代码生成的类型信息</p><p>编程语言的语法描述了其程序的适当形式</p><p>编程语言的语义描述了其程序的含义，即每个程序在执行时所做的事情</p><h3 id="类型检查-Type-Checking-1"><a href="#类型检查-Type-Checking-1" class="headerlink" title="类型检查 Type Checking"></a>类型检查 Type Checking</h3><p>语义分析的一个重要部分是类型检查编译器检查每个操作符是否有匹配的操作数(类型正确)</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%201.png" alt="Untitled"></p><h3 id="中间代码生成-Machine-Independent-Code-Optimizer-1"><a href="#中间代码生成-Machine-Independent-Code-Optimizer-1" class="headerlink" title="中间代码生成 Machine-Independent Code Optimizer"></a>中间代码生成 Machine-Independent Code Optimizer</h3><ul><li>经过语义分析后，编译器生成一个中间值representation, typically three-address code (Three-address code)</li><li>类汇编指令，每条指令有三个操作数，每个操作数就像一个寄存器</li><li>每个赋值指令在RHS上最多有一个操作符</li><li>易于翻译成目标机器的机器指令</li></ul><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%202.png" alt="Untitled"></p><h3 id="机器无关的代码优化-Machine-Independent-Code-Optimization-1"><a href="#机器无关的代码优化-Machine-Independent-Code-Optimization-1" class="headerlink" title="机器无关的代码优化 Machine-Independent Code Optimization"></a>机器无关的代码优化 Machine-Independent Code Optimization</h3><p>类似于英文的文章编辑&#x2F;修改，改进中间代码以获得更好的目标代码</p><p>t1 &#x3D; inttofloat(60) </p><p>t2 &#x3D; id3 * t1<br>t3 &#x3D; id2 + t2</p><p>id1 &#x3D; t3</p><p>—&gt;</p><p>t1 &#x3D; id3 * 60.0 </p><p>id1 &#x3D; id2 + t1</p><h3 id="代码生成-Code-Generator-1"><a href="#代码生成-Code-Generator-1" class="headerlink" title="代码生成 Code Generator"></a>代码生成 Code Generator</h3><p>t1 &#x3D; id3 * 60.0 </p><p>id1 &#x3D; id2 + t1</p><p>Code<br>Generation</p><p>LDF R2, id3<br>MULF R2, R2, #60.0 </p><p>LDF R1, id2<br>ADDF R1, R1, R2</p><p> STF id1, R1</p><h3 id="符号表管理-1"><a href="#符号表管理-1" class="headerlink" title="符号表管理"></a>符号表管理</h3><ul><li>由前端执行，符号表与中间代码一起传递到后端</li><li>记录变量名称和存储分配的各种属性、类型、作用域</li><li>记录过程名称和各种属性<ul><li>参数的数量和类型</li><li>传递参数的方式(通过值或引用)</li><li>返回类型</li></ul></li></ul><h3 id="中间语言（Intermediate-Language）IL-1"><a href="#中间语言（Intermediate-Language）IL-1" class="headerlink" title="中间语言（Intermediate Language）IL"></a><strong><strong>中间语言（Intermediate Language）IL</strong></strong></h3><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%203.png" alt="Untitled"></p><h3 id="编译器与解释器的区别-1"><a href="#编译器与解释器的区别-1" class="headerlink" title="编译器与解释器的区别"></a>编译器与解释器的区别</h3><ul><li><p>1</p><p>  编译器将用高级语言编写的源程序翻译成可以直接在目标计算机上运行的机器码。</p><p>  解释器直接执行源代码中的每条语句，而不需要将程序编译成机器码。</p></li><li><p>2</p><p>  解释器通常花费较少的时间来分析源代码:他们只是解析每个语句并执行它(例如，Python代码)。</p><p>  相比之下，编译器通常会分析语句之间的关系(例如，控制流和数据流)以实现优化。</p></li><li><p>3</p><p>  解释器继续执行程序，直到遇到第一个错误，在这种情况下它们停止。</p><p>  对于编译语言，程序只有在编译成功后才可执行。</p></li></ul><h1 id="第二章词法分析器"><a href="#第二章词法分析器" class="headerlink" title="第二章词法分析器"></a>第二章词法分析器</h1><h2 id="词法分析器的作用"><a href="#词法分析器的作用" class="headerlink" title="词法分析器的作用"></a>词法分析器的作用</h2><ul><li>读取输入字符的源程序，将它们转换为词素，并生成一个标记序列</li><li>必要时向符号表中添加词素去掉注释和空白(空白、换行、制表符等)。</li><li>将错误消息与行号关联(跟踪换行)</li></ul><p>有效执行简单任务、提高编译器效率（比语法分析简单的多）、提高编译器可移植性</p><h3 id="Tokens-Patterns-and-Lexemes"><a href="#Tokens-Patterns-and-Lexemes" class="headerlink" title="Tokens, Patterns, and Lexemes"></a>Tokens, Patterns, and Lexemes</h3><p>token由一对&lt;token name, attribute value&gt;组成，&lt;抽象符号，字符表内容&gt;</p><p>patterns是对tokens的词素可能采取的形式的描述。</p><p>lexeme就是所表示的实例</p><p>例子：printf(“Total &#x3D;%d\n”, score)</p><table><thead><tr><th>Lexeme</th><th>printf</th><th>scorce</th><th>“Total &#x3D;%d\n”</th><th>(</th><th>…</th></tr></thead><tbody><tr><td>Token</td><td>id</td><td>id</td><td>literal</td><td>left_parenthesis</td><td>…</td></tr></tbody></table><h3 id="token属性"><a href="#token属性" class="headerlink" title="token属性"></a>token属性</h3><p>token name：影响属性决策</p><p>attribute value：影响代码分析生成</p><h2 id="令牌规范-正则表达式"><a href="#令牌规范-正则表达式" class="headerlink" title="令牌规范(正则表达式)"></a>令牌规范(正则表达式)</h2><p>Regular expression (正则表达式,regexp)指词素模式的重要符号</p><ul><li>Strings and Languages (串和语言)</li><li>Operations on Languages (语言上的运算)</li><li>Regular Expressions</li><li>Regular Definitions (正则定义)</li><li>Extensions of Regular Expressions</li></ul><h3 id="字符串和语言"><a href="#字符串和语言" class="headerlink" title="字符串和语言"></a>字符串和语言</h3><p>Alphabet(字母表):任何有限的符号集合</p><p>符号的例子:字母、数字和标点符号</p><p>字母的例子:(1,0)，ASCII, Unicode</p><p>string（串)是从字母表中抽取的符号的有限序列</p><p>字符串s的长度，记为Isl，是数符号在s中的出现次数(即基数)</p><p>Empty string（空字符串）:长度为0，ε</p><p><strong>与字符串相关的术语</strong></p><p>Prefix 前缀:从的末尾删除0个或多个符号获得的任何字符串。</p><p>Proper prefix 真前缀:不是ε也不等于s本身的前缀。</p><p>Suffix 后缀:从s 的开头删除0个或多个符号后获得的任何字符串。</p><p>Proper suffix 真后缀:非ε且不等于s的后缀本身</p><p>Substring (子串):从s中删除任何前缀和后缀而得到的任何字符串。</p><p>Proper substring (真子串):不是ε且不等于s本身的子字符串。</p><p>Subsequence (子序列):从s中去掉0个或多个不一定连续的符号而形成的字符串</p><p>Concatenation (连接)：x &#x3D; dog, y &#x3D; house, xy &#x3D; doghouse</p><p>Exponentiation (幂&#x2F;指数运算)：</p><p>$$<br>x &#x3D; dog, x^0 &#x3D; ε,x^1 &#x3D; dog,x^3 &#x3D; dogdogdog<br>$$</p><p>language (语言):任何可数集合的一些固定字母</p><h3 id="Operations-on-Languages-语言的运算"><a href="#Operations-on-Languages-语言的运算" class="headerlink" title="Operations on Languages (语言的运算)"></a>Operations on Languages (语言的运算)</h3><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%204.png" alt="Untitled"></p><p>优先级:closure*&gt; concatenation &gt; union</p><h2 id="令牌识别-转换图"><a href="#令牌识别-转换图" class="headerlink" title="令牌识别(转换图)"></a>令牌识别(转换图)</h2><p>词法分析器检查输入字符串并找到一个前缀匹配其中一个标记</p><p>构建词法分析器的第一件事是使用常规定义定义令牌的模式</p><p>一个特殊的token: ws→(blank I tab I newline)*</p><h2 id="Transition-Diagrams-状态转换图"><a href="#Transition-Diagrams-状态转换图" class="headerlink" title="Transition Diagrams (状态转换图)"></a>Transition Diagrams (状态转换图)</h2><p>构造词法分析器的一个重要步骤是将模式转换为“转换图”。</p><p>转换图有一组节点，称为状态(state)和边缘(edge)，从一个节点指向另一个节点</p><p><strong>States</strong></p><p>起始状态由标记为“start”的边表示，它从任何地方进入</p><p>接受状态，或者是最终的，表明已经找到了一个词素</p><p><strong>States Cont</strong></p><p>在某些接受状态下，找到的词素可能不包含我们从开始状态看到的所有字符</p><p>这样的状态用*来注释当进入状态时，需要收回指向输入字符串中下一个字符的前向指针。</p><p><strong>Edges</strong></p><p>边从一种状态指向另一种状态</p><p>每条边都用一个或一组符号来标记</p><p><strong>Recognition of Reserved Words and Identifiers (保留字和标识符的识别)</strong></p><p>在许多语言中，保留词或关键字(例如，then)还要匹配标识符的模式</p><h2 id="构建整个词法分析器"><a href="#构建整个词法分析器" class="headerlink" title="构建整个词法分析器"></a>构建整个词法分析器</h2><p>策略1:依次尝试每个令牌的转换图</p><p>Fail()向前重置指针并开始下一个图表</p><p>策略2:并行运行转换图</p><p>需要解决一个图找到一个词素，而其他图仍然能够处理输入的情况。</p><p>解决方案:使用与任何模式匹配的最长的输入前缀</p><p>策略3:将所有转换图组合为一个(首选)</p><p>允许转换图读取输入，直到没有可能下一个状态取与任何模式匹配的最长词素</p><h2 id="词法分析器生成器"><a href="#词法分析器生成器" class="headerlink" title="词法分析器生成器"></a>词法分析器生成器</h2><p>Lex程序有三个部分，用%%分隔</p><ul><li>Declaration (声明)</li><li>Translation rules (转换规则)</li><li>Auxiliary functions section (辅助函数)</li></ul><h2 id="Finite-Automata-有穷自动机"><a href="#Finite-Automata-有穷自动机" class="headerlink" title="Finite Automata (有穷自动机)"></a>Finite Automata (有穷自动机)</h2><h3 id="Nondeterministic-finite-automata-NFA-非确定有穷自动机"><a href="#Nondeterministic-finite-automata-NFA-非确定有穷自动机" class="headerlink" title="Nondeterministic finite automata (NFA, 非确定有穷自动机)"></a>Nondeterministic finite automata (NFA, 非确定有穷自动机)</h3><p>当一个状态面对一个输入符号的时候，所转换到的是一个唯一确定的状态。</p><p>S &#x3D; {0, 1, 2, 3}<br>Start state: 0<br>Accepting states: {3}<br>Transition function<br>▪ (0, a) → {0, 1} (0, b) → {0}<br>▪ (1, b) → {2} (2, b) → {3}</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%205.png" alt="Untitled"></p><h3 id="Transition-Table-转换表"><a href="#Transition-Table-转换表" class="headerlink" title="Transition Table 转换表"></a>Transition Table 转换表</h3><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%206.png" alt="Untitled"></p><h3 id="Deterministic-finite-automata-DFA-确定有穷自动机"><a href="#Deterministic-finite-automata-DFA-确定有穷自动机" class="headerlink" title="Deterministic finite automata (DFA, 确定有穷自动机)"></a>Deterministic finite automata (DFA, 确定有穷自动机)</h3><p>当一个状态面对一个输入符号的时候，它所转换到的可能不只一个状态，可以是一个状态集合。</p><h1 id="第三章-语法分析"><a href="#第三章-语法分析" class="headerlink" title="第三章:语法分析"></a>第三章:语法分析</h1><h2 id="描述语法"><a href="#描述语法" class="headerlink" title="描述语法"></a>描述语法</h2><blockquote><p>编程语言结构的语法可以通过上下文无关语法或BNF（Backus Naur Form）表示法指定<br>语法为编程语言提供了精确但易于理解的语法规范<br>对于某些语法，我们可以自动构建一个高效的解析器<br>设计得当的语法定义了一种语言的结构，有助于将源程序翻译成正确的目标代码并检测错误<br>语法允许通过添加新的结构来执行新的任务来迭代地进化或开发一种语言</p></blockquote><h3 id="语法分析器的角色"><a href="#语法分析器的角色" class="headerlink" title="语法分析器的角色"></a>语法分析器的角色</h3><ul><li>语法分析器从词法分析器获得token串，并验证token名称是否可以由源语言的语法生成</li><li>以智能的方式报告语法错误</li><li>对于格式良好的程序，语法分析器构建一个语法分析树<br>语法分析树无需显式构建</li></ul><h2 id="语法分析器的分类"><a href="#语法分析器的分类" class="headerlink" title="语法分析器的分类"></a>语法分析器的分类</h2><p>· 通用语法分析器</p><p>· 一些方法（例如，Earley算法1）可以解析任何语法<br>· 然而，它们效率太低，无法在实践中使用</p><p>· 自顶向下语法分析器</p><p>· 构建从顶部（根）到底部（叶）的语法分析树</p><p>· 自底向上语法分析器</p><p>·从底部（叶子）到顶部（根）构建语法分析树</p><p>注意：自上而下和自下而上的解析都从左到右扫描输入，一次扫描一个符号。它们只适用于某些语法，这些语法具有足够的表达能力。</p><h3 id="Context-Free-Grammar-上下文无关文法"><a href="#Context-Free-Grammar-上下文无关文法" class="headerlink" title="Context-Free Grammar (上下文无关文法)"></a>Context-Free Grammar (上下文无关文法)</h3><p>上下文无关语法（CFG）由四个部分组成：<br>· Terminals终结符号: 形成字符串的基本符号（token名称）<br>· Nonterminals非终结符号: 表示字符串集的语法变量 通常对应于一个语言结构，如stmt（statements）      一个非终结符被区分为开始符号 由开始符号表示的字符串集是CFG生成的语言<br>·Productions 产生式: 指定终结符号和非终结符号组合形成字符串的方式<br>     格式：head（左侧）-&gt; body（右侧）<br>     head是非终结符号；body由零个或多个终结符号或非终结符号组成<br>     例如：expression -&gt; expression + term</p><p>下面的语法定义了简单的算术表达式</p><p>Terminal symbols: id, +, -, *, &#x2F;, (, )<br>Nonterminals: expression, term, factor<br>Start symbol: expression<br>Productions:</p><p>expression → expression + term<br>expression → expression – term<br>expression → term<br>term → term * factor<br>term → term &#x2F; factor<br>term → factor<br>factor → ( expression )<br>factor → id</p><blockquote><p>符号简化<br>E → E + T | E – T | T<br>T → T * F | T &#x2F; F | F<br>F → ( E ) | id</p></blockquote><p>“|”是指定备选方案的元符号<br>“(”和”)”不是元符号，而是终结符号</p><h3 id="Derivation-推导"><a href="#Derivation-推导" class="headerlink" title="Derivation (推导)"></a>Derivation (推导)</h3><p>推导: 从开始符号开始，使用产生式重写非终结符，直到只剩下终结符为止</p><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>⇒ 意思是“一步到位”<br>⇒ ∗ 意思是“以零个或多个步骤推导”𝛼 ⇒∗ 𝛼 适用于任何字符串𝛼<br>⇒ “ 意思是“以一个或多个步骤推导”</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>• 如果S⇒ ∗ α, 其中S是语法G的开始符号，我们说α是G文法的句型<br>· 文法的句型可以同时包含终结符号和非终结符号，并且可以为空<br>· 示例𝐸 ⇒ −𝐸 ⇒ −(𝐸)⇒ −(𝐸+𝐸) ⇒ −(𝐢𝐝+𝐸) ⇒ −(𝐢𝐝 + 𝐢𝐝) 这里所有的语法符号串都是文法的句型<br>• 一个G的句子是一个没有非终结符的文法句型<br>· 在上面的例子中，只有最后一个字符串−(𝐢𝐝 + 𝐢𝐝)是一个句子<br>•语法产生的语言是它的一组句子</p><h3 id="最左-最右推导"><a href="#最左-最右推导" class="headerlink" title="最左&#x2F;最右推导"></a>最左&#x2F;最右推导</h3><p>在推导的每一步，我们都需要选择要替换的非终结符<br>在最左推导中,总是选择每个句型中最左边的非终结符来替换<br>在最右推导中, 总是选择最右边的非终结符来替换</p><h3 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h3><p>语法分析树是一种推导的图形表示，它过滤掉了产生式应用的顺序<br>· 根结点是文法的开始符号<br>· 每个叶子结点由终结符或𝜖标记<br>· 每个内部结点由非终结符标记<br>· 每个内部结点代表产生式的应用<br>· 内部节点用产生式的头部中的非终结符进行标记；<br>· 子节点由产生式主体中的符号从左到右进行标记</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%207.png" alt="Untitled"></p><h2 id="Ambiguity-二义性"><a href="#Ambiguity-二义性" class="headerlink" title="Ambiguity (二义性)"></a>Ambiguity (二义性)</h2><p>如果一个语法为某个句子生成了多个语法分析树，则它具有二义性<br>示例：该文法为id+id*id生成了两种语法分析树。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%208.png" alt="Untitled"></p><p>程序设计语言的语法通常需要明确<br>· 否则，将有多种方法来解释程序<br>· 问题：给定𝐸 → 𝐸 + 𝐸 | 𝐸 ∗ 𝐸 | (𝐸) | 𝐢𝐝, 如何解读 𝑎 + 𝑏 ∗ 𝑐?<br>· 答案：该文法是上一张PPT的示例，根据两种语法分析树，第一种解释：应先处理b*c，然后与a相加；第二种解释：应先处理a+b，然后与c相乘<br>在某些情况下，使用精心选择的歧义语法以及消歧规则来丢弃不需要的语法分析树是很方便的 </p><h2 id="CFG与正则表达式比较-CFG-vs-Regular-Expressions"><a href="#CFG与正则表达式比较-CFG-vs-Regular-Expressions" class="headerlink" title="CFG与正则表达式比较 CFG vs. Regular Expressions"></a>CFG与正则表达式比较 CFG vs. Regular Expressions</h2><p>CFG比正则表达式更具表达能力<br>· 可以用正则表达式描述的每个构造都可以用语法描述，但反之不成立<br>· 每个正则语言都是上下文无关的语言，但反之不成立<br>示例：$𝐿 &#x3D;{𝑎^𝑛𝑏^𝑛 | 𝑛&gt; 0}$<br>语言L可以用CFG：𝑆 → 𝑎𝑆𝑏 | 𝑎𝑏 来描述<br>L不能用正则表达式来描述。换句话说，我们不能构造一个DFA来接受L</p><h3 id="任何正则语言都可以用CFG描述"><a href="#任何正则语言都可以用CFG描述" class="headerlink" title="任何正则语言都可以用CFG描述"></a>任何正则语言都可以用CFG描述</h3><p>（结构证明）NFA可以接受每种常规语言。我们可以构造一个CFG来描述语言：<br>· 对于每个在NFA中的状态 𝑖 ，创建一个非终结符𝐴𝑖<br>· 如果状态𝑖 在碰到输入a转为状态j 时, 添加产生式$𝐴_𝑖→ 𝐴_j$<br>· 如果状态𝑖 是一个接受状态，添加产生式𝐴𝑖→𝜖<br>· 如果状态𝑖 是开始状态，将𝐴𝑖作为文法的开始符号</p><h2 id="语法设计"><a href="#语法设计" class="headerlink" title="语法设计"></a>语法设计</h2><p>CFG能够描述编程语言的大部分（但不是全部）语法<br>· CFG不能描述“使用前应声明标识符”<br>· 后续阶段必须分析解析器的输出，以确保符合此类规则<br>在解析之前，我们通常对语法进行几种转换，使其更适合解析<br>· 消除二义性<br>· 消除左递归<br>· 提取左公因子</p><h3 id="消除二义性"><a href="#消除二义性" class="headerlink" title="消除二义性"></a>消除二义性</h3><p>接近原则：用最接近的未匹配的then匹配else<br>· 重写的想法：出现在then和else之间的语句必须匹配（不能以不匹配的the结束）<br>重写语法以消除歧义是困难的。没有指导这一过程的一般规则。</p><h3 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h3><p>如果语法中存在一个非终结符A，使得某个字符𝛼有相关的产生式𝐴 ⇒+ 𝐴𝛼 ，则该语法为左递归语法<br>立即左递归: 语法有产生式𝐴 -&gt; 𝐴𝛼<br>自顶向下分析方法无法处理左递归语法（自底向上的分析方法可以处理…）</p><p><strong>消除立即左递归</strong><br>简单语法：𝐴 → 𝐴𝛼 | 𝛽 它生成以符号𝛽开头的句子，后面跟零个或更多的𝛼’s<br>将语法替换为：<br>𝐴 → 𝛽A’<br>A’ → 𝛼A’ | 𝜖<br>它现在是右递归了</p><blockquote><p>𝐴 → 𝐴𝛼1|…|𝐴𝛼𝑚|𝛽1|… | 𝛽𝑛<br>将语法替换为：<br>𝐴 →𝛽1A’ | … |𝛽nA’<br>A’ → 𝛼1A’ | … | 𝛼mA’ |𝜖</p></blockquote><p>例子：</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%209.png" alt="Untitled"></p><p>消除左递归<br>消除立即左递归的技术不适用于非立即左递归<br>通用左递归消除算法（迭代）<br>· 输入：没有循环或𝜖-产生式<br>· 输出：没有左递归的等价语法</p><h2 id="Left-Factoring-提取左公因子"><a href="#Left-Factoring-提取左公因子" class="headerlink" title="Left Factoring (提取左公因子)"></a>Left Factoring (提取左公因子)</h2><p>如果我们有以下两个产生式</p><p>𝑠𝑡𝑚𝑡 → 𝐢𝐟 𝑒𝑥𝑝𝑟 𝐭𝐡𝐞𝐧 𝑠𝑡𝑚𝑡 𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡  |𝐢𝐟 𝑒𝑥𝑝𝑟 𝐭𝐡𝐞𝐧 𝑠𝑡𝑚𝑡<br>看到输入时𝐢𝐟, 我们无法立即决定选择哪个产生式<br>一般来说，如果𝐴 → 𝛼𝛽1 | 𝛼𝛽2是两个产生式，并且输入以从𝛼派生的非空字符串开始. 我们可以通过扩大𝐴 到𝛼𝐴‘来推迟选择产生式</p><h2 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h2><p>问题定义：为输入字符串构建一个语法分析树，从根开始，按预序创建语法分析树的节点（深度优先）<br>· 相当于为输入字符串找到最左推导<br>基本思想（两个步骤）：<br>· 预测：在解析的每一步，确定最左边非终结符所用的生产式<br>· 匹配：将所选产生式主体中的终结符与输入字符串相匹配</p><h2 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h2><p>问题定义：为输入字符串构建一个从叶子（终结符）开始并向上延伸到根（语法的开始符号）的语法分析树<br>· 相当于为输入字符串找到最右推导（相反）<br>移入-归约分析技术是自底向上语法分析的通用方式（使用栈来保存语法符号）</p><p>自底向上语法分析可以看作是一个将字符串𝜔“归约”到开始符号的过程<br>在每一个归约步骤中，与产生式主体匹配的特定子串（位于堆栈顶部）都会被产生式的头部替换（与推导步骤相反）</p><h2 id="递归下降的语法分析"><a href="#递归下降的语法分析" class="headerlink" title="递归下降的语法分析"></a>递归下降的语法分析</h2><p>递归下降的语法分析程序对于每个非终结符都有一套程序<br>· 该程序会扫描与非终结符对应的结构（输入的子字符串）<br>从开始符号的程序开始执行<br>· 如果程序扫描整个输入字符串，则宣布成功</p><h2 id="Backtracking-回溯"><a href="#Backtracking-回溯" class="headerlink" title="Backtracking (回溯)"></a>Backtracking (回溯)</h2><p>一般的递归下降语法分析可能需要对输入进行重复扫描（回溯）</p><blockquote><p>算法流程更改：<br>与考察A-产生式不同，我们必须按照一定的顺序尝试每一种可能的产生式。<br>当第7行出现故障时，返回第1行并尝试另一个A产生式<br>为了尝试另一个A-产生式时，我们必须重置指向下一个要扫描的符号的输入指针（失败尝试的消耗符号）</p></blockquote><p>左递归带来的问题<br>如果CFG中有左递归，递归下降的语法分析器可能会进入无限循环，所以需要解析前修改CFG</p><h3 id="𝐹𝐼𝑅𝑆𝑇"><a href="#𝐹𝐼𝑅𝑆𝑇" class="headerlink" title="𝐹𝐼𝑅𝑆𝑇()"></a>𝐹𝐼𝑅𝑆𝑇()</h3><blockquote><p>假设输入字符串为𝒙𝒂<br>假设当前的句型是𝒙𝑨β<br>· 𝑨 是非终结符；β可以同时包含终结符和非终结符<br>如果我们知道产生式𝑨 → 𝑎 | 𝜸的以下事实:<br>·𝑎 ∈ 𝐹𝐼𝑅𝑆𝑇(𝛼) ：𝛼 可以推导以a开头的字符串<br>·𝑎 ∉ 𝐹𝐼𝑅𝑆𝑇(𝛾)：𝛾 不可以推导出以a开头的字符串<br>*𝐹𝐼𝑅𝑆𝑇(𝛼) 表示可从α推导得到的串的首符号的集合</p></blockquote><p>计算FIRST(𝑿) 𝑋 是语法符号<br>· 如果𝑋 是一个终结符，那么FIRST(𝑋) &#x3D; {𝑋}<br>· 如果X是一个非终结符，且𝑋 → 𝑌1𝑌2 … 𝑌𝑘 (𝑘 ≥ 1) 是一个产生式<br>    · 如果对于某个𝑖，𝑎在FIRST(𝑌i)中且𝜖在所有的FIRST(𝑌1), …, FIRST(𝑌i-1)中，就把𝑎加入到FIRST(𝑋)中<br>    · 如果对于所有的FIRST(𝑌1), …, FIRST(𝑌𝑘)，𝜖在其中，那么将𝜖加入到FIRST(𝑋)中<br>· 如果X是一个非终结符，并且存在产生式𝑋 → 𝜖，那么将𝜖加入到FIRST(𝑋)中</p><p>计算FIRST(𝑿𝟏𝑿𝟐 … 𝑿𝒏) 𝑿𝟏𝑿𝟐 … 𝑿𝒏是语法符号的串<br>· 向FIRST(𝑋1𝑋2 … 𝑋𝑛)加入FIRST(𝑋1)中所有的非𝜖符号<br>· 如果𝜖在FIRST(𝑋1)中，再加入FIRST(𝑋2)中所有的非𝜖符号；如果𝜖在FIRST(𝑋1)和FIRST(𝑋2)中，加入FIRST(𝑋3)中的所有非𝜖符号，以此类推。<br>· 最后，如果对于所有的i，𝜖都在FIRST(𝑋i)中，那么将加入到FIRST(𝑋1𝑋2 … 𝑋𝑛)中。</p><blockquote><p>假设输入字符串为𝒙𝒂<br>假设当前的句型是𝒙𝑨β<br>· 𝑨 是非终结符；β可以同时包含终结符和非终结符<br>如果我们知道生产𝑨 →𝛼, 𝜖 ∈ 𝐹𝐼𝑅𝑆𝑇(𝛼), 我们能选择重写A的产生式吗?<br>可以，只有在𝛽 可以推导以𝑎开头的字符串, 即，在一些句型中𝐴 后面可以跟着𝑎 （即，𝒂 ∈ 𝑭𝑶𝑳𝑳𝑶𝑾(𝑨))</p></blockquote><p>计算FOLLOW集<br>计算所有非终结符A的FOLLOW(A)集合<br>· 将$反复到中，其中S是开始符号，二是输入右端的结束标记<br>· 不断应用下面的规则，直到所有FOLLOW集不再改变<br>    · 如果存在一个产生式𝐴 → 𝛼𝐵𝛽，那么FIRST(𝛽)中除𝜖之外的所有符号都在FOLLOW(𝐵)<br>中<br>     · 如果存在一个产生式𝐴 → 𝛼𝐵 ，或存在产生式𝐴 → 𝛼𝐵𝛽且FIRST(𝛽)包含𝜖，那么FOLLOW(𝐴)中的所有符号都在FOLLOW(𝐵)<br>中<br>𝜖不会在任何FOLLOW集中</p><h2 id="LL-1-Grammars"><a href="#LL-1-Grammars" class="headerlink" title="LL(1) Grammars"></a>LL(1) Grammars</h2><p>我们可以为一类称为LL(1)的语法构造不需要回溯的递归下降语法分析器<br>从左到右扫描输入<br>产生最左推导<br>在每一步使用一个前瞻输入符号来作出分析决策</p><blockquote><p>语法𝑮 是LL(1)当且仅当对于任意两个不同的产生式𝐴 → 𝛼 | 𝛽, 以下条件成立：<br>1.不存在终结符𝑎 使得𝛼 和𝛽 都可以推导以𝑎开头的字符串<br>2.𝛼 和𝛽 中最多只有一个可以推导空字符串<br>3.如果𝛽 ⇒* 𝜖, 那么𝛼 不能推导出任何以FOLLOW(𝐴)中某个终结符开头的字符串，反之亦然<br>*这三个条件基本上排除了应用两个产生式的可能性<br>更正式地说：</p></blockquote><ol><li>FIRST(𝛼)∩ FIRST(𝛽)&#x3D; ∅ （上述条件1-2）<br>如果𝜖 ∈ FIRST(𝛽)，那么 FIRST(𝛼)∩ FOLLOW(𝐴)&#x3D; ∅ ，反之亦然<blockquote></blockquote></li></ol><p>对于LL(1)语法，在递归下降语法分析过程中，只需查看当前输入符号，就可以选择应用于非终结符的正确产生式：<br>给定文法<br>给出输入的分析步骤：<br>1.用产生式①重写开始符号stmt： 𝐢𝐟(𝐞𝐱𝐩𝐫)𝑠𝑡𝑚𝑡 𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡<br>2.用产生式②重写最左边的stmt：𝐢𝐟(𝐞𝐱𝐩𝐫)𝐰𝐡𝐢𝐥𝐞(𝐞𝐱𝐩𝐫) 𝑠𝑡𝑚𝑡  𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡<br>3.用产生式③重写最左边的stmt：𝐢𝐟(𝐞𝐱𝐩𝐫)𝐰𝐡𝐢𝐥𝐞(𝐞𝐱𝐩𝐫) 𝐚 𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡<br>4.用产生式③重写最左边的stmt：𝐢𝐟(𝐞𝐱𝐩𝐫)𝐰𝐡𝐢𝐥𝐞(𝐞𝐱𝐩𝐫) 𝐚 𝐞𝐥𝐬𝐞 a</p><h2 id="Parsing-Table-预测分析表"><a href="#Parsing-Table-预测分析表" class="headerlink" title="Parsing Table (预测分析表)"></a>Parsing Table (预测分析表)</h2><p>递归下降语法分析器（或LL分析器）是基于表的解析器<br>预测分析表是一个二维数组，用于确定解析器在看到非终结符A和符号a时应该选择哪个产生式<br>LL(1)解析器的预测分析表没有包含多个产生式的条目</p><h3 id="构造预测分析表"><a href="#构造预测分析表" class="headerlink" title="构造预测分析表"></a>构造预测分析表</h3><p>以下算法可以应用于任何CFG<br>输入：文法G<br>输出：预测分析表M<br>方法：对于每个产生式𝐴 → 𝛼 ，进行以下处理：<br>执行以下操作：<br>    ·对于FIRST(𝛼)中每个终结符𝑎，将𝐴 → 𝛼加入到𝑀[𝐴, 𝑎]<br>    · 如果𝜖在FIRST(𝛼)中，对于FOLLOW(𝐴)中每个终结符b，包括$，将𝐴 → 𝛼加入到𝑀[𝐴, b]<br>将表中的所有空条目设置为错误</p><h2 id="非递归的预测分析"><a href="#非递归的预测分析" class="headerlink" title="非递归的预测分析"></a>非递归的预测分析</h2><p>非递归的预测分析器可以通过显式维护堆栈（而不是通过递归调用隐式维护）来构建<br>· 输入缓冲区包含要解析的字符串，以$结尾<br>· 堆栈包含底部为$的语法符号序列。<br>最初，堆栈只包含$和在$顶部的开始符号𝑆</p><h3 id="表驱动的预测语法分析"><a href="#表驱动的预测语法分析" class="headerlink" title="表驱动的预测语法分析"></a>表驱动的预测语法分析</h3><p>输入：字符串𝜔 和文法G的预测分析表M<br>输出：如果𝜔 在𝐿(𝐺)中, 输出𝜔的一个最左边推导; 否则，给出一个错误指示<br>最初，输入缓冲区包含𝜔$<br>开始符号𝑆 位于堆栈顶部，在$上方。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%2010.png" alt="Untitled"></p><h2 id="自底向上分析"><a href="#自底向上分析" class="headerlink" title="自底向上分析"></a>自底向上分析</h2><p>自底向上的语法分析<br>问题定义：为输入字符串构建一个从叶子（终结符）开始并向上延伸到根（语法的开始符号）的语法分析树<br>· 相当于为输入字符串找到最右边的推导（相反）<br>移入-归约分析技术是一种自底向上语法分析的通用方式（使用栈来保存语法符号）</p><h3 id="Reductions-归约"><a href="#Reductions-归约" class="headerlink" title="Reductions (归约)"></a>Reductions (归约)</h3><p>自底向上语法分析可以看作是一个将字符串𝜔“归约”到开始符号的过程<br>在每一个归约步骤中，与产生式体匹配的特定子串（位于栈顶部）会被产生式的头部替换（与推导步骤相反）</p><h3 id="Handles-句柄"><a href="#Handles-句柄" class="headerlink" title="Handles (句柄)"></a>Handles (句柄)</h3><p>非正式地讲，句柄是和某个产生式体匹配的子串，对它的归约代表了相应的最右推导中的一个反向步骤<br>正式地讲，如果$S \Rightarrow^*_{rm} \alpha A<br>\omega\Rightarrow^*_{rm} \alpha \beta<br>\omega$，那么紧跟𝛼的产生式𝐴 → 𝛽 （或者简单地𝛽) 是句型𝛼𝛽𝜔的一个句柄</p><h3 id="Handle-Pruning-句柄剪枝"><a href="#Handle-Pruning-句柄剪枝" class="headerlink" title="Handle Pruning (句柄剪枝)"></a>Handle Pruning (句柄剪枝)</h3><p>在最右句型中， 句柄右侧的字符串必须仅包含终结符号<br>如果一个文法是无二义性的，那么该文法的每个右句型都有且只有一个句柄<br>通过句柄剪枝可以得到一个反向的最右推导</p><p>移入-归约语法分析技术是自底向上语法分析的一种通用方式，其中：</p><p>· 使用栈保存文法符号<br>· 使用输入缓冲区保存要进行语法分析的字符串的其余部分<br>· 栈内容（从底部到顶部）和输入缓冲区内容形成最右句型（假设没有错误）</p><p><strong>初始状态：</strong><br>移入-归约过程：<br>· 语法分析器将零个或多个输入符号转移到栈顶上，直到它可以对栈顶的一个文法符号串𝛽进行归约为止<br>· 将𝛽归约为某个产生式的头<br>语法分析器重复上述循环，直到检测到错误或栈包含开始符号且输入为空<br>*在移入-归约解析过程中，句柄最终总是出现在栈的顶部</p><h2 id="简单LR"><a href="#简单LR" class="headerlink" title="简单LR"></a>简单LR</h2><p>LR(k)语法分析器：最流行的自底向上的语法分析器类型<br>   · L： 从左到右扫描输入<br>   · R： 反向构造最右推导<br>   · k： 在做出解析决策时使用k个前瞻性输入符号<br>LR(0)和LR(1)语法分析器具有实际意义<br>当𝑘 ≥ 2时，语法分析器变得太复杂，无法构建（解析表太大，无法管理）</p><p>LR语法分析器的优势<br>· 表驱动（类似于非递归LL语法分析器）、强大<br>    · 尽管手工构建LR语法分析器工作量太大，但也有一些语法分析器生成器可以自动构建语法分析表<br>    · 相比之下，LL语法分析器往往更容易手工编写，但功能较弱（处理的语法较少）<br>· LR语法分析技术是已知的最通用的非回溯移入-归约语法分析方法<br>· LR语法分析器可以被构造为识别几乎所有可以为其编写CFG的编程语言结构<br>· LR语法比LL语法可以描述更多的语言<br>    · 回想文法成为LL(1)的严格条件</p><h2 id="LR-0-Items-LR-0-项"><a href="#LR-0-Items-LR-0-项" class="headerlink" title="LR(0) Items (LR(0)项)"></a>LR(0) Items (LR(0)项)</h2><p>一个LR语法分析器通过维护一些状态来跟踪在语法分析中所处的位置，从而来做出移入-归约的决策。<br>LR(0)项（简称item）是产生式再加上一个位于它的体中某处的点，表示在语法分析过程中的给定点上，我们已经看到了一个产生式的哪些部分。<br>𝐴 →} 𝑋𝑌𝑍        𝐴 → 𝑋 } 𝑌𝑍        𝐴 → 𝑋𝑌 } 𝑍         𝐴 → 𝑋𝑌𝑍 }<br>𝐴 → 𝑋 } 𝑌𝑍: 我们刚刚在输入中看到了一个可以由X推导得到的字符串，我们希望接下来看到一个能从YZ推导得到的字符串<br>状态：LR(0)项集<br>产生式𝐴 → 𝜖 仅生成一个item 𝐴 → ·</p><h3 id="规范LR-0-项集族"><a href="#规范LR-0-项集族" class="headerlink" title="规范LR(0)项集族"></a>规范LR(0)项集族</h3><p>LR(0)项集合的一个集合，称为规范LR(0)项集族, 为构建用于做出语法分析决定的DFA提供了基础<br>为了构造文法的LR(0)项集规范族，我们需要定义：<br>· 增广文法<br>· 两个函数：（1）项集闭包的CLOSURE 和（2）GOTO</p><h3 id="增广文法"><a href="#增广文法" class="headerlink" title="增广文法"></a>增广文法</h3><p>增广一个以S为开始符号的文法G：<br>· 引入一个新开始符号S‘代替S<br>· 增加产生式S‘ -&gt; S<br>明显地𝐿(𝐺)&#x3D;𝐿(𝐺’)<br>优点：通过增广，只有当语法分析器使用𝑆’ → 𝑆进行归约时输入符号串被接受。否则，输入符号串可能在多处被接受，因为可能存在多个𝑆-产生式</p><h3 id="项集闭包"><a href="#项集闭包" class="headerlink" title="项集闭包"></a>项集闭包</h3><p>如果𝐼 是文法𝐺的一组项集, 那么CLOSURE(𝐼)就是按照下面两条规则构造的项集：</p><ol><li>一开始，将𝐼中的各个项加入到CLOSURE(𝐼)</li><li>如果𝐴 → 𝛼 · 𝐵𝛽在CLOSURE(𝐼)中，𝐵 → 𝛾是一个产生式，并且𝐵 → ·𝛾不在CLOSURE(𝐼)中，那么将𝐵 → ·𝛾加入CLOSURE(𝐼)中。不断应用这条规则，直到没有新项可以加入到<br>直观地讲：𝐴 → 𝛼 · 𝐵𝛽 表示我们希望看到从一个能够从𝐵𝛽推导得到的子串。这个子串的某个前缀可以从B推导得到。因此，我们将所有𝐵-产生式加入到项集。</li></ol><h3 id="GOTO函数"><a href="#GOTO函数" class="headerlink" title="GOTO函数"></a>GOTO函数</h3><p>𝐆𝐎𝐓𝐎(𝑰, 𝑿) 其中𝑰是一个项集而𝑿是一个文法符号，被定义为𝑰中所有形如的项所对应的项的集合的闭包。</p><h3 id="LR-0-自动机"><a href="#LR-0-自动机" class="headerlink" title="LR(0)自动机"></a>LR(0)自动机</h3><p>“简单LR语法分析技术”（即SLR分析技术）的中心思想是根据文法构造出LR(0)自动机。<br>· 这个自动机的状态是规范LR(0)项集族<br>· 它的转换由GOTO函数给出<br>· 开始状态是CLOSURE({𝑆’ →· 𝑆})</p><h3 id="LR-0-自动机的使用"><a href="#LR-0-自动机的使用" class="headerlink" title="LR(0)自动机的使用"></a>LR(0)自动机的使用</h3><p>帮助做出移入-归约决定：<br>· 假设文法符号𝛾 使自动机从开始状态0运行到某个状态𝑗<br>· 如果下一个输入符号为𝑎且状态𝑗有一个在𝑎上的转换，那就移入𝑎<br>· 否则，归约；状态𝑗的项将会告诉我们使用哪个产生式进行归约</p><p>栈只保存状态，文法符号可以从相应状态中获取</p><h3 id="LR语法分析器结构"><a href="#LR语法分析器结构" class="headerlink" title="LR语法分析器结构"></a>LR语法分析器结构</h3><p>LR语法分析器由一个输入、一个输出、一个栈、一个驱动程序和一个语法分析表（ACTION+GOTO）组成<br>所有LR语法分析器的驱动程序都是相同的；只有语法分析表随语法分析器的不同而变化<br>栈保存一个状态序列<br>在SLR中，栈保存来自LR(0)自动机的状态<br>语法分析器根据（1）栈顶部的状态和（2）从输入缓冲区读取的终结符来决定下一个动作</p><h3 id="LR语法分析表：ACTION-GOTO"><a href="#LR语法分析表：ACTION-GOTO" class="headerlink" title="LR语法分析表：ACTION + GOTO"></a>LR语法分析表：ACTION + GOTO</h3><p>ACTION函数接受两个参数：（1）状态𝑖 和（2）终结符𝑎 （或$）<br>ACTION[𝒊, 𝒂] 可以具有以下四种形式的值之一：<br>· 移入𝒋: 其中𝑗是一个状态，把输入符号𝑎移入栈中，但使用状态𝑗 代表𝑎<br>· 归约𝑨 →𝛽: 将栈顶的𝛽归约为产生式头A<br>· 接受：语法分析器接受输入并完成语法分析过程<br>· 报错：存在语法错误<br>将定义在项集上的GOTO函数扩展为定义在状态集上的函数：如果GOTO(𝐼𝑖, 𝐴) &#x3D; 𝐼𝑗，那么GOTO也把状态𝑖和一个非终结符A映射到状态𝑗</p><h3 id="LR语法分析器的态势"><a href="#LR语法分析器的态势" class="headerlink" title="LR语法分析器的态势"></a>LR语法分析器的态势</h3><p>“态势”是表示语法分析器完整状态的符号。态势是一个形如：(𝑠0𝑠1 … 𝑠𝑚, 𝑎i𝑎i+1 … 𝑎𝑛$)的对<br>第一个分量是栈中的内容，第二个分量是余下的输入。<br>根据结构，每个状态（除𝑠0）对应于一组项和文法符号（导致状态转换的符号，即传入边上的符号）<br>· 假设𝑋i是状态𝑠i的文法符号<br>· 那么𝑋0𝑋1 … 𝑋𝑚𝑎i𝑎i+1 … 𝑎𝑛是最右句型（假设没有错误）</p><h3 id="构造SLR语法分析表"><a href="#构造SLR语法分析表" class="headerlink" title="构造SLR语法分析表"></a>构造SLR语法分析表</h3><p>SLR语法分析表𝐺以LR(0)项和LR(0)自动机为基础。</p><ol><li>构造增广文法G‘的规范LR(0)项集族{𝐼0, 𝐼1, … , 𝐼𝑛}</li><li>根据𝐼i构造得到状态i，状态i的语法分析动作按照下面的方法决定：<br>· 如果[𝐴 → 𝛼 · 𝑎𝛽]在𝐼𝑖中并且GOTO [𝐼𝑖, 𝑎 ]&#x3D; 𝐼j，那么将ACTION[ 𝑖, 𝑎]设置为“移入j”<br>· 如果[𝐴 → 𝛼·]在𝐼𝑖中，那么对于𝐅𝐎𝐋𝐋𝐎𝐖(𝑨)中的所有𝑎，将设置ACTION[ 𝑖, 𝑎]为“归约𝐴 → 𝛼”。这里𝐴不等于S’<br>· 如果[𝑆’ → 𝑆·]在𝐼𝑖中，那么将设置ACTION[𝑖, $]为“接受”</li><li>状态i对于各个非终结符号A的转换使用下面的规则构造得到：如果GOTO [𝐼i, 𝐴]&#x3D; 𝐼𝑗，那么GOTO[𝑖, 𝐴]&#x3D; 𝑗</li><li>规则2、3没有定义的所有条目都设置为“报错”</li><li>语法分析器的初始状态就是根据[𝑆′ → · 𝑆]所在项集构造得到的状态<br>如果在语法分析构造过程中没有冲突（即，一个表项的多个条目），则语法为SLR（1）</li></ol><p>在SLR中，状态𝑖 要求归约𝐴 → 𝛼，如果项集$𝐼_𝑖$包含项[𝐴 → 𝛼 · ] ，同时输入符号𝑎 在FOLLOW(𝐴)中<br>在某些情况下，归约后𝛽𝛼 在栈顶上会变成𝛽𝐴， 后面跟着的不是𝑎的任何最右句型</p><h2 id="规范LR"><a href="#规范LR" class="headerlink" title="规范LR"></a>规范LR</h2><h3 id="规范LR-1-项"><a href="#规范LR-1-项" class="headerlink" title="规范LR(1)项"></a>规范LR(1)项</h3><p>在状态中携带更多信息以排除一些无效的归约（通过分裂LR（0）状态）<br>LR(1)项的一般形式：[𝐴 → 𝛼 · 𝛽, 𝑎]<br>· 𝐴 → 𝛼𝛽是一个产生式，𝑎是一个终结符或右端结束标记<br>· 1指的是第二个分量𝑎的长度，第二个分量𝑎叫做向前看字符<br>· 当𝛽不为空时，向前看字符没有任何作用因为它决定是否归约<br>· 一个形如[𝐴 → 𝛼· , 𝑎]的项只有在下一个输入符号等于𝑎时，才会按照𝐴 → 𝛼进行归约。这样的𝑎的集合总是的FOLLOW(𝐴)子集<br>𝐴 → 𝛼𝛽 是一个生产和𝑎 是终端还是$“1”是指第二个组成部分的长度：展望(向前看字符)*如果𝛽 不是𝜖 因为它只帮助确定是否减少(𝑎 将在状态转换期间继承）表单中的一项𝐴 → 𝛼· , 𝑎要求减少𝐴 → 𝛼 仅当下一个输入符号𝑎 （𝑎’s是FOLLOW的子集(𝐴))*：LR（0）项没有先行符号，因此它们被称为LR（0</p><blockquote><p>构造LR（1）项集族本质上与构造规范LR（0）项集族相同。唯一的区别在于CLOSURE和GOTO函数。</p></blockquote><p>构造LR（1）项集族本质上与构造规范LR（0）项集族相同。唯一的区别在于CLOSURE和GOTO函数。<br>向前看符号从现有项传递到新项</p><h3 id="构造规范LR-1-语法分析表"><a href="#构造规范LR-1-语法分析表" class="headerlink" title="构造规范LR(1)语法分析表"></a>构造规范LR(1)语法分析表</h3><ol><li>构造增广文法G‘的规范LR(1)项集族{𝐼0, 𝐼1, … , 𝐼𝑛}</li><li>根据𝐼i构造得到状态i，状态i的语法分析动作按照下面的方法决定：<br>· 如果[𝐴 → 𝛼 · 𝑎𝛽, 𝑏 ]在𝐼𝑖中并且GOTO [𝐼𝑖, 𝑎 ]&#x3D; 𝐼j，那么将ACTION[ 𝑖, 𝑎]设置为“移入j”<br>· 如果[𝐴 → 𝛼·, 𝑎 ]在𝐼𝑖中，设置ACTION[ 𝑖, 𝑎]为“归约𝐴 → 𝛼”。这里𝐴不等于S’<br>· 如果[𝑆’ → 𝑆·, $ ]在𝐼𝑖中，那么将设置ACTION[𝑖, $]为“接受”<br>如果以上规则导致任何冲突的动作，我们就说这个文法不是LR(1)的。</li><li>状态i对于各个非终结符号A的转换使用下面的规则构造得到：如果GOTO [𝐼i, 𝐴]&#x3D; 𝐼𝑗，那么GOTO[𝑖, 𝐴]&#x3D; 𝑗</li><li>规则2、3没有定义的所有条目都设置为“报错”</li><li>语法分析器的初始状态就是根据[𝑆′ → · 𝑆, $]所在项集构造得到的状态</li></ol><h2 id="Lookahead-LR-LALR"><a href="#Lookahead-LR-LALR" class="headerlink" title="Lookahead LR (LALR)"></a>Lookahead LR (LALR)</h2><p>SLR(1)的功能不足以处理大量语法（回想一下以前的明确语法）<br>LR(1)在语法分析表中有一组庞大的状态（状态过于细粒度）<br>LALR(1)在实践中经常使用<br>· 在项中保留向前看符号<br>· 它的状态数与SLR(1)的状态数相同<br>· 可以处理现代程序设计语言中最常见的句法结构</p><p>寻找具有相同核心的LR(1)项集<br>LR(1)项集的核心是第一个分量的集合<br>· 𝐼4和𝐼7的核心是{𝐶 → 𝑑 ·}<br>· 𝐼3和𝐼6的核心是{𝐶 → 𝑐·𝐶,𝐶 → ·𝑐𝐶,𝐶 → ·𝑑}</p><blockquote><p>一般而言，一个核心就是LR(0)项集<br>我们可以将具有共同核心的LR(1)项集合并为一组项目<br>由于GOTO的核心(𝐼, 𝑋) 仅取决于𝐼, 合并项集的GOTO目标也具有相同的核心，因此可以合并</p></blockquote><h3 id="状态合并引发的冲突"><a href="#状态合并引发的冲突" class="headerlink" title="状态合并引发的冲突"></a>状态合并引发的冲突</h3><p>合并LR(1)语法分析表中的状态可能会导致冲突<br>合并不会导致移入&#x2F;归约冲突<br>· 假设合并后在向前看符号𝑎上存在移入&#x2F;归约冲突<br>· 有一个项[𝐴 → 𝛼·, 𝑎] 要求归约𝐴 → 𝛼<br>· 有其他项[𝐵 → 𝛽· 𝑎𝛾, ?]要求移入<br>· 由于要合并的集合的核心是相同的，因此合并前必须有一个集合同时包含[𝐴 → 𝛼· , 𝑎] 以及[𝐵 → 𝛽· 𝑎𝛾, ?]<br>· 那么根据LR(1)语法分析表构造算法，在合并之前，已经在𝑎上存在移入&#x2F;归约冲突 。该文法不是LR（1）。<br>合并状态可能导致归约&#x2F;归约冲突</p><p>构造LR(1)项集族$𝐶 &#x3D; {𝐼_0，𝐼_1，𝐼_𝑛}$<br>对于LR(1)项集中的每个核心，找出所有具有这个核心的项集，并将这些项集替换为它们的并集<br>令$𝐶’ &#x3D; {J_0，J_1，J_𝑛}$是合并后得到的项集族。<br>· 状态$𝑖$的语法分析动作是按照LR(1)语法分析表构造算法中的方法根据$𝐽_i$构造得到的<br>· 如果存在一个分析动作冲突，这个算法就不能生成语法分析器，这个文法不是LALR(1)的</p><p><strong>GOTO表构造方法如下：</strong></p><p>· 如果𝐽是一个或多个LR(1)项集的并集。也就是说 𝐽 &#x3D; 𝐼1 𝖴 𝐼2 𝖴 ⋯ 𝖴 𝐼𝑘，那么GOTO(𝐼1, 𝑋), GOTO(𝐼2, 𝑋), …, GOTO(𝐼𝑘, 𝑋)的核心是相同的，因为𝐼1, 𝐼2, … , 𝐼𝑘具有相同的核心<br>· 令𝐾是所有和GOTO(𝐼1, 𝑋)具有相同核心的项集的并集<br>· 那么GOTO(𝐽, 𝑋)&#x3D; 𝐾</p><h2 id="错误恢复"><a href="#错误恢复" class="headerlink" title="错误恢复"></a>错误恢复</h2><p><strong>LR语法分析中的错误恢复</strong></p><p>LR语法分析器应该能够处理错误：<br>· 报告错误的精确位置<br>· 从错误中恢复并继续分析<br>两种典型的错误<br>· 恐慌模式<br>· 短语层次的恢复</p><p><strong>恐慌模式</strong><br>基本思想：丢弃零个或多个输入符号，直到同步词法单元已找到<br>原理：<br>· 语法分析器总是查找可以从非终结符𝐴推导的输入的前缀<br>· 当出现错误时，意味着无法找到这样的前缀<br>· 如果错误仅发生在与𝐴相关的部分, 我们可以通过寻找一个可以合法跟随的符号来跳过这一部分<br>· 示例：如果𝐴 是𝑠𝑡𝑚𝑡, 则同步词法单元可以是分号</p><p><strong>短语层次的恢复</strong><br>基本思路：<br>· 检查语法分析表中的每个错误条目，并确定最有可能导致错误的程序员错误<br>· 修改栈顶部或第一个输入符号，并向程序员发出消息<br>短语层次的恢复示例：<br>· 删除右侧的）<br>· 提示“不匹配的右括号”。</p><h2 id="语法分析器生成工具"><a href="#语法分析器生成工具" class="headerlink" title="语法分析器生成工具"></a><strong>语法分析器生成工具</strong></h2><p>本节将介绍如何使用语法分析器生成工具来帮助构造一个编译器的前端，我们将使用LALR语法分析生成工具Yacc作为讨论的基础。Yacc，又一个编译器的编译器<br>Yacc在UNIX系统中是以命令的方式出现的，它已经用于实现多个编译器产品。Bison 是GNU项目的一部分，是对Yacc的扩展和改进。</p><p><strong>声明</strong><br>· 通常的C声明<br>· 对词法单元的声明<br><strong>翻译规则</strong><br>· 翻译规则 &#x3D; 产生式 + 语义动作<br><strong>辅助性C语言例程</strong><br>· 将会被直接拷贝至y.tab.c<br>· 可以在语义动作中调用<br>· 必须提供yylex()这一词法分析器，它将返回一个由词法单元和相关属性组成的词法单元<br>· 可以添加错误恢复例程等其他过程</p><blockquote><p><strong>翻译规则</strong><br>第一个产生式头符号被视为开始符号<br>一个语义动作是一个C语句的序列<br>· $$表示和相应产生时头部的非终结符关联的属性值<br>· $i表示和相应产生式体中第i个文法符号关联的属性值<br>当我们按照一个产生式归约时就会执行盒盖产生式相关联的语义动作<br>· 我们通常根据$i的值来计算$$的值</p></blockquote><h3 id="Yacc的冲突解决"><a href="#Yacc的冲突解决" class="headerlink" title="Yacc的冲突解决"></a>Yacc的冲突解决</h3><p>默认策略：<br>· 移入&#x2F;归约冲突：始终移入<br>· 归约&#x2F;归约冲突：归约第一个列出的产生式<br>指定终结符的优先级和结合性：<br>· 结核性：%left、%right、%nonassoc<br>· 移入𝒂&#x2F;归约𝑨 → 𝑎 冲突：比较的优先级𝑎 和𝐴 →𝛼 （优先级不够时使用结合性）<br>· 终结符的声明顺序决定了它们的优先级<br>· 一个产生式的优先级等于它最右边终结符的优先级。也可以使用%prec<terminal>指定，它将产生式的优先级定义为与终结符相同</p><h3 id="Yacc的错误恢复"><a href="#Yacc的错误恢复" class="headerlink" title="Yacc的错误恢复"></a>Yacc的错误恢复</h3><p>在Yacc中，错误恢复使用一种错误产生式的形式：<br>· 一般形式：𝐴 → 𝐞𝐫𝐫𝐨𝐫 𝛼<br>· 用户可以决定哪些非终结符（例如，生成表达式、语句、块等的非终结符）将具有错误产生式<br>错误示例：𝒔𝒕𝒎𝒕 → 𝐞𝐫𝐫𝐨𝐫 ;<br>· 该错误产生式规定当语法分析器遇到错误时，它要跳到下一个分号之后，并假设已经找到一条语句<br>· 将调用错误产生式的语义动作不需要处理输入，只需生成诊断消息</p><h1 id="Chapter-4-Syntax-Directed-Translation"><a href="#Chapter-4-Syntax-Directed-Translation" class="headerlink" title="Chapter 4:  Syntax-Directed Translation"></a>Chapter 4:  Syntax-Directed Translation</h1><h3 id="语法制导的翻译"><a href="#语法制导的翻译" class="headerlink" title="语法制导的翻译"></a><strong>语法制导的翻译</strong></h3><p>• 读取源程序的输入字符，将其归类为词素，并生成词素序列<br>• 必要时将词目添加到符号表中<br>• 删除注释和空白（空格、换行符、制表符等）<br>• 将错误信息与行号关联起来（跟踪换行符）</p><p>语法制导定义（SDD）是一种无上下文语法，同时包含属性和规则。<br>  一组属性（attributes）与每个语法符号相关联*。<br>    可以是任何属性，例如表达式的数据类型，# 生成代码中的指令<br>  语义规则（semantic rule）与语法生成相关联，描述如何计算属性<br>  属性代码表示结构体的后缀符号<br>  || 是字符串连接操作符</p><h3 id="合成属性"><a href="#合成属性" class="headerlink" title="合成属性"></a><strong>合成属性</strong></h3><p>如果一个属性在解析树节点 N 上的值仅由 N 的子节点和 N 本身的属性值决定，则称该属性为合成属性；</p><h3 id="SDD-不指定解析树上属性的计算顺序"><a href="#SDD-不指定解析树上属性的计算顺序" class="headerlink" title="SDD 不指定解析树上属性的计算顺序"></a><strong>SDD 不指定解析树上属性的计算顺序</strong></h3><p>任何顺序，只要能在依赖的所有其他属性之后计算一个属性就可以了合成属性有一个很好的特性，<br>即它们可以在解析树的一次自下而上的遍历中进行评估（通常不需要显式创建解析树）。</p><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a><strong>继承属性</strong></h3><p>继承属性在解析树节点上的值由该节点本身、其父节点和解析树中同级节点的属性值决定<br>回答：继承属性在处理与上下文相关的问题时仍然是非常有用的。它为我们提供了一种在语法树中考虑外部信息的方法，从而使得我们可以更为精确和灵活地描述语法制导定义的属性</p><p>给定解析树节点 $N,M_1,M_2,M_3,…,M_k，$如果 N 的属性 a 定义为 $N.a &#x3D; f(M_1,a_1,M_2,a_2,…,M_k,a_k)$，那么为了计算 N.a，我们必须先计算 $M_1. a_1$。<br>依赖图 (依赖图) 是确定评估顺序的有用工具<br>    描述特定解析树中属性实例之间的信息流<br>    为属性实例之间的部分顺序建模</p><p>从一个属性实例$（a_1）$到另一个属性实例$（a_2）$的边表示计算 $a_2$ 的值需要 $a_1$ 的值。<br>如果依赖关系图中存在循环，我们就无法找到计算所有属性实例值的顺序ε</p><h3 id="S-属性定义"><a href="#S-属性定义" class="headerlink" title="S 属性定义"></a>S 属性定义</h3><p>如果每个属性都是合成的，那么语法制导定义就是 S 属性的<br>直观地说，任何解析树的依赖关系图中都不可能存在循环，因为边总是从子节点到父节点，而不是相反。</p><p>当 SDD 具有 S 属性时，我们可以按照解析树节点的任何自下而上的顺序评估其属性。<br>例如，解析树的后序遍历（postorder traversal)<br>S 属性定义可以在自下而上的解析过程中轻松实现（相当于后序遍历）</p><h3 id="L-属性定义"><a href="#L-属性定义" class="headerlink" title="L 属性定义"></a>L 属性定义</h3><p>如果对于每个产品 $A → X_1X_2…X_n$，对于每个 J &#x3D; 1 … n，$x_j$ 的每个继承属性仅取决于以下属性，则 SDD 是 L 属性 SDD：<br>$x_1,…x_{j-1}$ 的属性（合成的或继承的），<br>或 A 的继承属性<br>依赖关系图的边可以从左到右（对于解析树而言），但不能从右到左（因此称为 “L-属性”）。</p><h3 id="L-属性定义的属性评估"><a href="#L-属性定义的属性评估" class="headerlink" title="L 属性定义的属性评估"></a>L 属性定义的属性评估</h3><p>输入: 解析树 T 中的节点 n<br>输出: 以 n 为根的子树属性的评估顺序<br>程序 depth_first(n)*<br>开始<br>      对于 n 的每个子节点 m，从左到右依次执行 开始<br>      评估 m 的继承属性；<br>      depth_first(m); &#x2F;&#x2F; 这里将评估 m 的合成属性<br>      结束<br>      评估 n 的合成属性；<br>      保证：在评估节点的继承属性时，已评估了其左侧节点的属性<br>end</p><h2 id="构建语法树"><a href="#构建语法树" class="headerlink" title="构建语法树"></a>构建语法树</h2><p><strong>抽象语法树</strong></p><p>每个内部节点 N 代表一个结构体（对应一个运算符）<br>N 的子节点代表 N 所代表结构的有意义成分（相当于操作数）</p><p><strong>语法树与解析树</strong></p><p>在语法树中，内部节点代表编程结构，而在解析树中，内部节点代表非终结符*。<br>解析树也称为具体语法树，其底层语法称为语言的具体语法</p><p>为简单表达式构建语法树的 S 属性 SDD<br>语法树的每个节点都是一个对象，其中有一个字段 op（代表节点的标签）和一些附加字段<br>叶节点：一个包含词法值的附加字段<br>内部节点：额外的字段数量等于子节点的数量</p><h2 id="计算类型的结构"><a href="#计算类型的结构" class="headerlink" title="计算类型的结构"></a>计算类型的结构</h2><p>• 正则语言（regular language）是一种可由 regexp<br>• 如果两个 regexps r 和 s 表示相同的语言，那么它们是等价的，写成 r &#x3D; s</p><p><strong>合成属性</strong>：这种属性通常用于将信息从叶子节点向上传递到父节点。在这里，合成属性t代表一个类型，这意味着某个节点（可能是一个变量或表达式）的类型可以通过计算其子节点的属性来确定，并将这个类型作为其自己的t属性。<br><strong>继承属性</strong>：这种属性是从父节点传递给子节点的。在这个描述中，继承属性t在解析树中向下传递一个基本类型。这通常意味着上层节点（例如，声明或类型定义的上下文）已经确定了某种基本类型，这个类型需要向下传递给子节点，以确保子节点可以根据这个类型进行相应的操作或检查。</p><h2 id="Syntax-Directed-Translation-Schemes"><a href="#Syntax-Directed-Translation-Schemes" class="headerlink" title="Syntax-Directed Translation Schemes"></a>Syntax-Directed Translation Schemes</h2><p>SDD 告诉我们在翻译中要做什么（高级规范），但不告诉我们如何做<br>语法制导的翻译方案（SDT’s，Syntax-directed translation schemes）规定了如何进行翻译的更多细节。<br>SDT 是一种无上下文语法，其语义动作（程序片段）嵌入在生产体中 ：<br>与 SDD 的语义规则不同<br>语义动作可以出现在制作体的任何地方</p><p>任何 SDT 都可以通过以下方式实现：</p><p>首先构建一棵解析树<br>将语义操作视为 “虚拟 “解析树节点<br>执行从左到右的深度优先（即预排序）树遍历，并在访问相应节点时触发操作</p><p><strong>SDD（Syntax Directed Definition）</strong>：<br>SDD定义了与语法产生式关联的属性和规则。它为每个语法产生式指定一个或多个属性计算或语义动作。<br>SDD关注于如何为语法树中的节点计算属性值，但不一定涉及产生中间代码或目标代码的具体操作。<br>它可以有合成属性和继承属性，因此可以描述为S属性的（只有合成属性）或L属性的（允许继承属性但有限制）。<br><strong>SDT（Syntax Directed Translation）</strong>：<br>SDT是SDD的一个特例，它专门用于生成中间代码或目标代码。换句话说，SDT的目的是翻译，它定义了与语法产生式关联的动作，这些动作通常在解析时执行。<br>当解析器在处理产生式时，与该产生式关联的SDT动作被执行，从而生成代码或进行其他翻译工作。<br>动作可以嵌入到产生式中，例如，在YACC或Bison这样的工具中，可以直接在语法规则中插入C代码作为动作。<br><strong>总结差异</strong>：<br>SDD更为通用，关注于为语法树的节点计算属性。这些属性可以用于多种目的，如类型检查、变量绑定等。<br>SDT特化于翻译任务，即将源代码转换为中间代码或目标代码。它通常涉及在解析过程中执行特定的动作。<br>尽管有这些区别，但在实际应用中，SDD和SDT的界限可能会模糊，因为编译器的语义分析和翻译阶段通常是交织在一起的</p><p>$$<br>B-&gt;X{a}Y<br>$$</p><p>动作 a 应在我们识别完 X（如果 X 是终端）或由 X 派生的所有终端（如果 X 是非终端）后执行<br>如果解析是自下而上的，那么一旦 X 出现在解析栈顶端，我们就执行操作 a<br>如果解析是自上而下的，我们在尝试扩展 Y（如果 Y 是非终端）或检查输入中的 Y（如果 Y 是终端）之前执行操作 a</p><blockquote><p><strong>底层语法是LR，而SDD是S属性的</strong>：<br><strong>LR语法</strong>：这是一种可以用自底向上的方式进行解析的语法。LR解析器从左到右读取输入，但决策是基于右侧的上下文进行的。它使用一个堆栈来存储已经读取的符号，并在适当的时候进行规约。<br><strong>S属性的SDD</strong>：这意味着所有属性都是合成属性，它们只从子节点传递给父节点，没有从父节点传递给子节点的继承属性。这对于自底向上的LR解析是非常合适的，因为我们从叶子节点开始构建并向上移动，因此只需要合成属性即可。<br>底层语法是LL，而SDD是L属性的：<br><strong>LL语法</strong>：这是一种可以用自顶向下的方式进行解析的语法。LL解析器从左到右读取输入，并基于左侧的上下文来进行决策。它通常使用递归下降的方法，直接从起始符号开始，并尝试应用各种产生式。</p></blockquote><p>如果 SDD 的语法是 LR，而且 SDD 是 S 属性的，那么我们就可以构造一个后缀 SDT（后缀 SDT），在自下而上的解析中实现 SDD 语义动作总是出现在制作的末尾（因此称为 “后缀”）。</p><h3 id="SDT’s-for-L-Attributed-SDD’s"><a href="#SDT’s-for-L-Attributed-SDD’s" class="headerlink" title="SDT’s for L-Attributed SDD’s"></a>SDT’s for L-Attributed SDD’s</h3><p>如果基础语法是 LL，那么 L 归因 SDD 可以在自上而下的解析过程中实现。<br>将 L 属性 SDD 转化为 SDT 的方法是将语义动作放在相关语篇 A → X1X2…Xn 的适当位置上。<br>将计算非终端 Xi 的继承属性的动作紧接在生产体中 Xi 的前面<br>将为语篇头部计算合成属性的操作放在语篇主体的末尾</p><h3 id="构建整个词法分析器-1"><a href="#构建整个词法分析器-1" class="headerlink" title="构建整个词法分析器"></a>构建整个词法分析器</h3><p>• 策略 1：依次尝试每个标记的过渡图<br>fail() 重置指针并开始下一个图表<br>• 策略 2：并行运行过渡图<br>需要解决一个图找到一个词素，而其他图仍能处理输入的情况。<br>▪ 解决方法：取输入中与任何模式匹配的最长前缀<br>• 策略 3：将所有过渡图合并为一张图（首选）<br>允许过渡图读取输入，直到没有可能的下一个状态为止<br>取与任何模式匹配的最长词素<br>语义操作：<br>a) L1 &#x3D; new()；L2 &#x3D; new()；<br>b) C.false &#x3D; S.next; C.true &#x3D; L2；<br>c) S1.next &#x3D; L1；<br>d) S.code &#x3D; ⋯ ；<br>根据动作位置规则，<br>b) 应放在制作体之前，c) 应放在制作体之前，d) 应放在制作体末尾<br>a) 可以放在开头；没有限制条件</p><h2 id="Implementing-L-Attributed-SDD’s"><a href="#Implementing-L-Attributed-SDD’s" class="headerlink" title="Implementing L-Attributed SDD’s"></a>Implementing L-Attributed SDD’s</h2><p>许多翻译应用都可以使用 L 归因 SDD 来解决。如下所示，我们可以扩展递归-后裔解析器来实现 L 归因 SDD：<br>递归-迭代解析器为每个非终端 A 都有一个函数 A<br>使用函数 A 的参数传递 A 的继承属性<br>当函数 A 完成时，返回 A 的合成属性<br>通过上述扩展，在函数 A 的主体中，我们需要同时解析和处理属性</p><h1 id="Chapter-5-Intermediate-Code-Generation"><a href="#Chapter-5-Intermediate-Code-Generation" class="headerlink" title="Chapter 5: Intermediate-Code Generation"></a>Chapter 5: Intermediate-Code Generation</h1><h2 id="中间表示法"><a href="#中间表示法" class="headerlink" title="中间表示法"></a>中间表示法</h2><p>编译器的前端分析源程序并创建中间表示（IR，intermediate representation），后端据此生成目标代码。<br>理想情况下，源语言的细节仅限于前端，目标机的细节仅限于后端</p><h2 id="编译器可构建-IR-序列"><a href="#编译器可构建-IR-序列" class="headerlink" title="编译器可构建 IR 序列"></a>编译器可构建 IR 序列</h2><p>语法树等高级 IR 接近源语言。它们描述了源程序的结构，适用于静态类型检查等任务<br>低级 IR 接近目标机器，适用于寄存器分配和指令选择等与机器相关的任务。<br>三地址代码可以是高级或低级的，取决于运算符的选择</p><p>有趣的事实：C 经常被用作中间形式。第一个 C++ 编译器的前端生成 C，后端是 C 编译器</p><h2 id="DAG’s-for-Expressions"><a href="#DAG’s-for-Expressions" class="headerlink" title="DAG’s for Expressions"></a>DAG’s for Expressions</h2><p>在语法树中，一个普通子表达式的语法树将按该子表达式出现的次数复制</p><p>Example: $𝑎+𝑎∗(𝑏−𝑐)+(𝑏−c)∗𝑑$会重复两次，而$（b-c）$也重复了两次</p><p>有向无环图 (DAG, 有向无环图) 识别共同的子表达式，并简洁地表示表达式</p><p>蓝圈节点有两个父节点</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%2011.png" alt="Untitled"></p><p>DAG 可以用构造语法树的 SDD 来构造<br>区别：在构建 DAG 时，只有当且仅当没有现存的相同节点时，才会创建新节点</p><h2 id="Three-Address-Code-三地址代码"><a href="#Three-Address-Code-三地址代码" class="headerlink" title="Three-Address Code (三地址代码)"></a>Three-Address Code (三地址代码)</h2><p>在三地址代码中，指令右侧最多只有一个运算符<br>指令的形式通常是 $𝑥 &#x3D; 𝑦\ 𝑜𝑝\ 𝑧$<br>运算符（或地址）可以是：</p><p>源程序中的名称<br>常量：编译器必须处理多种类型的常量<br>编译器生成的临时名称</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>赋值指令：</strong><br>𝑥 &#x3D; 𝑦 op 𝑧，其中 op 是二进制算术&#x2F;逻辑运算<br>𝑥&#x3D; op 𝑦，其中 op 是一元运算<br><strong>复制指令：</strong> 𝑥 &#x3D; 𝑦<br><strong>无条件跳转指令：</strong>goto 𝐿，其中 𝐿 是跳转目标的标记<br><strong>有条件跳转指令：</strong><br>if 𝑥 goto 𝐿<br>if Flase 𝑥 goto 𝐿<br>if 𝑥 relop 𝑦 goto 𝐿</p><p><strong>程序调用和返回：</strong></p><p>param 𝑥1<br>…<br>param 𝑥𝑛<br>call 𝑝, 𝑛 (procedure call)<br>y &#x3D; call p, n (function call)<br>return y<br><strong>索引复制指令：</strong> 𝑥 &#x3D; 𝑦[𝑖] 𝑥[𝑖] &#x3D; 𝑦<br>这里，𝑦[𝑖] 表示位置 𝑖 存储单元中超出位置 𝑦 的值。这里，𝑦[𝑖] 表示位置 𝑖存储单元中超出位置 𝑦 的值。<br><strong>地址和指针赋值指令：</strong><br>𝑥 &#x3D; &amp;𝑦 ，𝑥 &#x3D;∗ 𝑦， ∗ 𝑥 &#x3D; 𝑦</p><blockquote><p>对三地址指令的描述说明了每种指令的组成部分，但没有说明指令的表示方法。<br>在编译器中，这些指令可以作为对象&#x2F;记录来实现，并为运算符和操作数设置字段<br>三种典型的表示法:</p><p>四元式表示方法<br>三元式表示方法<br>间接三元式表示方法</p></blockquote><h3 id="Quadruples-四元式"><a href="#Quadruples-四元式" class="headerlink" title="Quadruples (四元式)"></a>Quadruples (四元式)</h3><p>一个四元组（或 “四元组”）有四个字段<br>    一般形式： op arg1 arg2 result<br>    op 包含运算符的内部代码<br>    arg1、arg2、result 是地址（操作数）<br>一元运算符（如 x &#x3D; 减 y 或 x &#x3D; y）不使用 arg2<br>参数运算符既不使用 arg2 也不使用 result<br>条件&#x2F;非条件跳转将目标标签放在 result 中</p><h3 id="Triples-三元式"><a href="#Triples-三元式" class="headerlink" title="Triples (三元式)"></a>Triples (三元式)</h3><p>三元组只有三个字段：操作、参数 1、参数 2。<br>我们用操作 x 操作 y 的位置来表示操作结果，而无需生成临时名称（这是对四元组的优化）</p><h3 id="Indirect-Triples-间接三元式"><a href="#Indirect-Triples-间接三元式" class="headerlink" title="Indirect Triples (间接三元式)"></a>Indirect Triples (间接三元式)</h3><p>间接三元组由一个指向三元组的指针列表（下面的指令数组）<br>优化可以通过重新排序指令列表来移动指令（无需修改三元组）<br>交换后，列表中的第一条和第二条指令仍然指向正确的指令</p><p>静态单赋值形式静态单赋值形式（SSA，Static Single-Assignment ForStatic single-assignment form）是一种 IR，有助于某些代码优化。<br>在 SSA 中，每个名称只接受一次赋值</p><p>SSA 使用一种称为 𝜙 函数的符号惯例来合并 x 的两个定义</p><h2 id="Types-and-Type-Checking"><a href="#Types-and-Type-Checking" class="headerlink" title="Types and Type Checking"></a>Types and Type Checking</h2><p>数据类型或简单的类型告诉编译器或解释器程序员打算如何使用数据<br>类型信息的作用<br>    查找源代码中的错误<br>    在运行时确定名称所需的存储空间<br>    计算数组元素的地址<br>    插入类型转换<br>选择算术运算符的正确版本（如 fadd、iadd）<br>类型检查(类型检查) 使用逻辑规则确保操作数的类型与运算符所期望的类型匹配</p><h2 id="Type-Expressions-类型表达式"><a href="#Type-Expressions-类型表达式" class="headerlink" title="Type Expressions (类型表达式)"></a>Type Expressions (类型表达式)</h2><p>类型具有结构，可以用类型表达式来表示<br>    类型表达式要么是基本类型，要么是通过对类型表达式应用类型构造算子而形成<br>array(2, array (3, integer ))是 int[2][3] 的类型表达式<br>    array 是一个类型构造函数，有两个参数：一个数字，一个类型表达式</p><h2 id="Name-Equivalence-名等价"><a href="#Name-Equivalence-名等价" class="headerlink" title="Name Equivalence (名等价)"></a>Name Equivalence (名等价)</h2><p>将命名的类型视为基本类型；类型表达式中的名称不会被其定义的类型表达式所替换<br>当且仅当两个类型表达式完全相同时，它们的名称才是等价的(由相同的语法树表示，具有相同的标签）</p><h2 id="Structural-Equivalence-结构等价"><a href="#Structural-Equivalence-结构等价" class="headerlink" title="Structural Equivalence (结构等价)"></a>Structural Equivalence (结构等价)</h2><p>对于已命名的类型，用其类型表达式替换类型名，并递归检查替换后的树</p><h2 id="Declarations-类型的声明"><a href="#Declarations-类型的声明" class="headerlink" title="Declarations (类型的声明)"></a>Declarations (类型的声明)</h2><p>下面的语法涉及基本类型、数组类型和记录类型</p><p>非终端 𝐷生成声明序列<br>𝑇 生成基本类型、数组类型或记录类型，记录类型是记录字段的声明序列，由大括号包围<br>𝐵 生成基本类型之一：int 和 float<br>𝐶 生成一个或多个整数的序列，每个整数都由大括号包围</p><h2 id="Storage-Layout-for-Local-Names-局部变量的存储布局"><a href="#Storage-Layout-for-Local-Names-局部变量的存储布局" class="headerlink" title="Storage Layout for Local Names (局部变量的存储布局)"></a>Storage Layout for Local Names (局部变量的存储布局)</h2><p>根据名称的类型，我们可以决定运行时名称所需的内存量。运行时名称所需的内存量<br>    类型的宽度（宽度）： 该类型对象所需的 # 内存单位<br>    对于长度不等的数据（如字符串），或在运行前无法确定大小的数据（如动态数组），我们只为数据指针预留固定的内存量。<br>    对于函数的局部名称，我们总是分配连续的字节*。<br>    对于每个这样的名称，我们可以在编译时计算出一个相对地址<br>类型信息和相对地址存储在符号表中</p><h2 id="表达式的翻译"><a href="#表达式的翻译" class="headerlink" title="表达式的翻译"></a>表达式的翻译</h2><p>包含多个运算符的表达式：𝑎 + 𝑏 ∗ 𝑐<br>转换为多条指令，每条指令最多使用一个运算符𝑡1 &#x3D; 𝑏 ∗ 𝑐,𝑡2 &#x3D; 𝑎 + 𝑡1<br>数组引用𝐴[𝑖][𝑗] 将扩展为一系列三地址指令，用于计算引用的地址</p>]]></content>
    
    
    <summary type="html">编译原理与技术的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://zhangyuanhe.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>复杂网络课程笔记</title>
    <link href="https://zhangyuanhe.top/2024/01/10/BUPT_note/Notes%20on%20Complex%20network/"/>
    <id>https://zhangyuanhe.top/2024/01/10/BUPT_note/Notes%20on%20Complex%20network/</id>
    <published>2024-01-10T13:00:00.000Z</published>
    <updated>2024-01-17T12:48:12.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复杂网络-彭海朋"><a href="#复杂网络-彭海朋" class="headerlink" title="复杂网络 彭海朋"></a>复杂网络 彭海朋</h1><h2 id="虫口方程"><a href="#虫口方程" class="headerlink" title="虫口方程"></a>虫口方程</h2><h1 id="第零讲"><a href="#第零讲" class="headerlink" title="第零讲"></a>第零讲</h1><p>$$<br>x_{n+1}&#x3D;\gamma x_n(1-x_n)<br>$$</p><p>在不控制的条件下，人口每25年增加一倍，即按几何级数增长。<em>xn</em>+1 &#x3D; <em>𝛾xn</em>。修正就是计入限制虫口增长的负因素。虫口数目太多时，由于争夺有限的食物和生存空间发生咬斗，由于接触传染而导致疾病蔓延，争斗使虫口数目减少的事件，这些事件的数目比例于<em>xn^</em>2。</p><h2 id="Logistic映射（Logistic-Map）"><a href="#Logistic映射（Logistic-Map）" class="headerlink" title="Logistic映射（Logistic Map）"></a>Logistic映射（Logistic Map）</h2><p>$$<br>x_{n+1}&#x3D;rx_n(1-x_n)<br>$$</p><p>分叉与周期倍增（Bifurcation &amp; Period Doubling）</p><p>對初始值的敏感性</p><p>混沌内部的自相似结构</p><h1 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h1><h2 id="复杂网络的数学描述"><a href="#复杂网络的数学描述" class="headerlink" title="复杂网络的数学描述"></a>复杂网络的数学描述</h2><p>网络G&#x3D;（V, E），由点集V（G）和边集E（G）组成的一个图，可分为无向、有向和加权网络<br>令ei∈ E（G），每条边ei有V（G）中的一对点(u,v)与之对应；如果任意(u,v)与(v,u)对应同一条边，则称为无向网络，否则为有向网络；如果任意∣ei ∣ &#x3D;1，则称为无权网络，否则为加权网络。</p><p>——复杂网络是对复杂系统的一种抽象</p><h2 id="对网络拓扑结构的描述"><a href="#对网络拓扑结构的描述" class="headerlink" title="对网络拓扑结构的描述"></a>对网络拓扑结构的描述</h2><p><strong>几何量及其分布</strong></p><p>度（Degree）：朋友的个数<br>集聚系数（群系数）（Clustering coefficient）：朋友的朋友还是不是朋友的情况<br>最短路径（Shortest path）：两个顶点之间边数最少的路径<br>介数（Betweenness）：经过我的最短路径的条数</p><h2 id="网络的基本模型"><a href="#网络的基本模型" class="headerlink" title="网络的基本模型"></a>网络的基本模型</h2><ul><li>规则网<br>(a) 完全连接; (b) 最近邻居连接; (c) 星形连接; (d) Lattice; … (z) Layers</li><li>随机图</li><li>小世界网络</li><li>Scale-Free 网络</li></ul><h3 id="ER-随机图模型"><a href="#ER-随机图模型" class="headerlink" title="ER 随机图模型"></a>ER 随机图模型</h3><p>特征:<br>连通性:Poisson 分布<br>齐次特征:每个节点大约有相同的<br>连接数:节点数不增加</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled.png" alt="Untitled"></p><h3 id="小世界网络"><a href="#小世界网络" class="headerlink" title="小世界网络"></a>小世界网络</h3><p>特征:<br>齐次性:每个节点有大约相同的连接数<br>节点不增加</p><h3 id="Scale-Free网络的基本特征"><a href="#Scale-Free网络的基本特征" class="headerlink" title="Scale Free网络的基本特征"></a>Scale Free网络的基本特征</h3><p>Power Law Degree Distribution（幂律度分布）</p><p>$$<br>P(k)\propto k^{-\gamma} \ \ \ \ \ln P(k)\propto -\gamma\ln k\P(\lambda k)\propto(\lambda k)^{-\gamma}&#x3D;\lambda^{-\gamma}k^{-\gamma}&#x3D;\lambda^{-\gamma}P(k)<br>$$</p><p>1、自相似结构<br>2、两极分化，高度弥散</p><p><strong>六度分隔（Six Degrees of Separation）理论</strong>。简单地说：“你和任何一个陌生人之间所间隔的人不会超六个，也就是说，最多通过六个人你就能够认识任何一个陌生人。”</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table><thead><tr><th></th><th>E&#x2F;R随机图模型</th><th>现实生活的复杂网络</th></tr></thead><tbody><tr><td>平均距离</td><td>小&#x2F;大</td><td>小</td></tr><tr><td>聚类系数</td><td>大&#x2F;小</td><td>大(Small-world feature)</td></tr><tr><td>度分布</td><td>二项式&#x2F;Poisson</td><td>幂指数(Scale-free feature)</td></tr></tbody></table><p>直径：两点间最短距离的最大值</p><h2 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h2><p>分形和不规则形状的几何有关。</p><p>分形（Fractal)：局部与整体具有相似性，或者说在标度变换下具有相似性的几何形体。</p><p>曼德勃鲁集</p><p>分形音乐</p><h3 id="分维"><a href="#分维" class="headerlink" title="分维"></a>分维</h3><p>假设ε是小立方体一边的长度， N （ε）是用此小立方体覆盖被测形体所得的数目，维数公式意味着通过用边长为ε的小立方体覆盖被测形体来确定形体的维数。对于通常的规则物体 ，覆盖一根单位 长度的线 段所需 的数目要 N （ε）＝1／ε，覆盖一个单位边长的正方形，N(ε)＝（1／ε）2 ，覆盖单位边 长的立方体，N （ε）＝（1／ε）3。从这三个式子可见维数公式也适用于通常的维数含义。</p><h1 id="复杂网络病毒的行为分析"><a href="#复杂网络病毒的行为分析" class="headerlink" title="复杂网络病毒的行为分析"></a>复杂网络病毒的行为分析</h1><h3 id="恶意代码的基础知识"><a href="#恶意代码的基础知识" class="headerlink" title="恶意代码的基础知识"></a>恶意代码的基础知识</h3><p>恶意代码是最头痛的安全问题之一，它甚至是整个软件安全的核心。虽然单独对付某台设备上的指定恶意代码并不难，但是，网上各种各样的海量恶意代码，却像癌细胞一样，危害着安全，而且，既杀之不绝，又严重消耗正常体能。</p><blockquote><p>狭义上说，恶意代码是指故意编制或设置的、会产生威胁或潜在威胁的计算机代码（软件）。最常见的恶意代码有计算机病毒、特洛伊木马、计算机蠕虫、后门、逻辑炸弹等。<br>广义上说，恶意代码还指那些没有作用却会带来危险的代码，比如，流氓软件和广告推送等。</p></blockquote><p>恶意代码的入侵手段主要有三类：利用软件漏洞、利用用户的误操作、前两者的混合。</p><p>恶意代码的主要传播方式是病毒式传播</p><h2 id="死亡型病毒的动力学分析"><a href="#死亡型病毒的动力学分析" class="headerlink" title="死亡型病毒的动力学分析"></a>死亡型病毒的动力学分析</h2><blockquote><p>设网络的用户数为N，在t时刻，已经受害的用户数为T(t)，暂未受害的用户数为S(t)，那么，有恒等式S(t)+T(t)&#x3D;N。<br>再令f(S,T)为在“已有T人受害，S人暂未受害”条件下，受害事件发生率，于是，有下面两个微分方程<br>dT(t)&#x2F;dt&#x3D;f(S,T) 和 dS(t)&#x2F;dt&#x3D;-f(S,T)</p></blockquote><p>在生物医学的流行病学中，有一个可借鉴的概念是传染力λ(T)，它表示在已有T台设备中毒的情况下，暂未中毒的设备与中毒者相连接的概率，所以，f(S,T)&#x3D;λ(T)S；<br>另一个概念是传染率β，它表示一个未中毒设备在连接到中毒者后，被传染的概率；所以，λ(T)&#x3D;βT。于是，f(S,T)&#x3D;λ(T)S&#x3D;βTS，即，它是一个双线性函数。</p><h2 id="康复型病毒的动力学分析"><a href="#康复型病毒的动力学分析" class="headerlink" title="康复型病毒的动力学分析"></a>康复型病毒的动力学分析</h2><blockquote><p>与死亡型模型不同，在康复型模型中，受害用户在经过救治后，又可以康复成为暂未受害的用户，当然，该用户也可能再次受害。<br>其实，绝大部分恶意代码，特别是诱骗类恶意代码，都是这种康复型的。</p></blockquote><p>在此，除了10.2节中的S、T、F(S,T)和N等概念外，我们再引入另一个概念，即g(T)，它表示在T个受害者中，有g(T)个用户被康复成正常健康用户，从而，变成暂未受害用户。<br>若用γ表示康复率（生物医学经验告诉我们：每个受害者，在下一小段时间δt内，被康复的概率为γδt+0(δt)2。并且受害者被康复的时间，服从均值为1&#x2F;γ的指数分布。）那么：g(T)&#x3D;γT</p><p>由此，我们可以得到微分方程组：<br>dT(t)&#x2F;dt&#x3D;f(S,T)-g(T)&#x3D;βTS-γT和 dS(t)&#x2F;dt&#x3D;-f(S,T)+g(T)&#x3D;-βTS+γT<br>若令u(t)&#x3D;S(t)&#x2F;N， v(t)&#x3D;T(t)&#x2F;N， t’&#x3D;γt和R0&#x3D;βN&#x2F;γ，那么，上面的两个微分方程就变为：<br>du&#x2F;dt&#x3D;-(R0u-1)v 和dv&#x2F;dt&#x3D;(R0u-1)v<br>其定义域为：D&#x3D;{0≤u≤1,0≤v≤1,u+v&#x3D;1}</p><p><strong>定理10.1：针对康复型恶意代码，如果R0&lt;1，那么，康复型恶意代码就会最终被消灭，即，无人受害；反过来，如果R0&gt;1，那么，康复型恶意代码就会在一定范围内长期为害，具体地说，受害者人数将长期徘徊在N(1-1&#x2F;R0)附近。</strong></p><h2 id="免疫型病毒的动力学分析"><a href="#免疫型病毒的动力学分析" class="headerlink" title="免疫型病毒的动力学分析"></a>免疫型病毒的动力学分析</h2><p>设S、T、γ、β和N等概念与10.3节相同，又记R(t)为t时刻被康复（具有了免疫力）的用户数。于是，在任何一个时刻，都恒有N&#x3D;S(t)+T(t)+R(t)<br>为了使相关公式看起来简单一些，分别用S(t)&#x2F;N、T(t)&#x2F;N和R(t)&#x2F;N去代替S(t)、T(t)和R(t)并且仍然采用原来的记号来表示S(t)、T(t)和R(t)，此时便有S(t)+T(t)+R(t)&#x3D;1<br>简单来说，S(t)、T(t)和R(t)分别代表暂未受害、正受害和受害康复且具有免疫力的用户，各占总用户数的比例。</p><p><strong>定理10.2：针对免疫型恶意代码，当F0&lt;1时，此恶意代码不会爆发，并随着时间的推移，会自动消灭；当F0&gt;1时，该恶意代码会在一定的时段内爆发，受害者人数达到一个最大值Tmax后，才开始递减，并最终消灭。更深入地，Tmax在总人数中所占的比例为1-ρ+ρln(ρ&#x2F;S0)<br>在这里S0表示刚开始时，暂未受害的人数比例。</strong></p><h2 id="开机和关机对免疫型病毒的影响"><a href="#开机和关机对免疫型病毒的影响" class="headerlink" title="开机和关机对免疫型病毒的影响"></a>开机和关机对免疫型病毒的影响</h2><blockquote><p>以上所有小节的分析，都假定活跃用户数固定为N。但是，在实际情况下，当然有例外。比如，某用户主动关机后，任何恶意代码对他都不构成威胁，此时活跃用户就减少一个；当某用户终端中毒后被宕（dang）机，这里活跃用户数也减少一个；当新用户开机（或进入网络）后，他又可能成为恶意代码的攻击对象，这时，活跃用户数又增加一个等。</p></blockquote><p><strong>定理10.3：记P0&#x3D;β&#x2F;(γ+μ)，那么，在情况1之下，<br>当P0≤1时，该免疫型恶意代码一定会随着时间的推移，最终自动消灭；<br>当P0≥1时，该免疫型恶意代码一定会随着时间的推移，最终在$S&#x3D;1&#x2F;P_0、T&#x3D;μ(P_0-1)&#x2F;β、R&#x3D;1-1&#x2F;P_0-μ(P_0-1)&#x2F;β$点处达到全局渐近稳定，即，最终健康终端的比例为$S&#x3D;1&#x2F;P_0$，受害终端的比例为$T&#x3D;μ(P_0-1)&#x2F;β$，获得免疫力的终端比例为$R&#x3D;1-1&#x2F;P_0-μ(P_0-1)&#x2F;β$。</strong></p><h2 id="预防措施的效果分析"><a href="#预防措施的效果分析" class="headerlink" title="预防措施的效果分析"></a>预防措施的效果分析</h2><p>我们虽然不能强求全体用户都采取预防措施，但是，如果有比例为p的用户采取了预防措施（比例为q的用户偷了懒，此处，p+q&#x3D;1），那么，我们发现：只要当p足够大时，仍然能够消灭该恶意代码。</p><p><strong>定理10.5：在10.5节的情况1中，如果在暂未受害的终端中，采取了预防措施终端数的比例p≥1-1&#x2F;P0，这里P0&#x3D;β&#x2F;(γ+μ)，那么，该免疫型恶意代码一定会随着时间的推移，最终自动消灭。</strong><br>此定理告诉我们：对付恶意代码，虽然不能指望全体人员都及时采取预防措施，但是，只要有足够多的人（占总人数比例超过P0&#x3D;β&#x2F;(γ+μ)）重视安全，并及时采取了预防措施，那么，该恶意代码就一定是可控的，甚至会最终被消灭。</p><h1 id="回声状态网络"><a href="#回声状态网络" class="headerlink" title="回声状态网络"></a>回声状态网络</h1><p>人工神经网络（Artificial Neural Network）是由大量处理单元互联组成的非线性、自适应信息处理系统 。</p><p>人工神经网络按照性能分为两类：<br>（1）静态神经网络 Static Neural Network<br>（2）动态神经网络 Recurrent Neural Network<br>其中，动态神经网络又称为递归神经网络</p><p>两种网络对比：</p><p>静态网络数学表达式：</p><p>$$<br>y&#x3D;\sigma(\sum^n_{i&#x3D;1}\omega_1x_1+\sigma_1)<br>$$</p><p>静态网络数学表达式：</p><p>$$<br>y&#x3D;\sigma(\sum^n_{i&#x3D;1}\omega_1x_1(t-\tau_i)+\sigma_1)<br>$$</p><p>对比表达式，我们可以看出：动态网络内部存在带延迟因子的反馈连接，可以更好的反映动态系统的特性和演化行为 。而静态网络没有这种能力。</p><p>回声状态状态网络作为一种新型的递归神经网络，无论是建模还是学习算法，都已经与传统的递归神经网络差别很大。<br>ESN网络特点：<br>（1） 它的核心结构是一个随机生成、且保持不 变的储备池（Reservoir）<br>（2）其输出权值是唯一需要调整的部分<br>（3）简单的线性回归就可完成网络的训练</p><h2 id="ESN的结构和运行机理"><a href="#ESN的结构和运行机理" class="headerlink" title="ESN的结构和运行机理"></a>ESN的结构和运行机理</h2><p>ESN网络的核心结构是一个“储备池”。所谓的储备池就是随机生成的、大规模的、稀疏连接（SD通常保持1%~5%连接 ）的递归结构。<br>注：SD是储备池中相互连接的神经元占总的神经元N的百分比</p><p>从结构上讲，ESN是一种特殊类型的递归神经网络，其基本思想:使用大规模随机连接的递归网络，取代经典神经网络中的中间层，从而简化网络的训练过程。<br>我们假设系统具有M个输入单元，N个内部处理单元（Processing Elements，PE），即N个内部神经元，同时具有L个输出单元。</p><p>那么输入单元u（n）内部状态x（n）以及输出单元y（n）在n时刻值分别为：</p><p>$$<br>u(n)&#x3D;[u_1(n),u_2(n),\dots,u_M(n)]^T\ x(n)&#x3D;[x_1(n),x_2(n),\dots,x_N(n)]^T\ y(n)&#x3D;[y_1(n),y_2(n),\dots,y_L(n)]^T<br>$$</p><p>则回声状态网络状态方程为：</p><p>$$<br>x(n+1)&#x3D;f(Wx(n)+W_{in}u(n)+W_{back})y(n)\ y(n+1)&#x3D;f_{out}(W_{out}[x(n+1),u(n+1),y(n)]+W_{bias}^{out})<br>$$</p><h2 id="ESN的储备池"><a href="#ESN的储备池" class="headerlink" title="ESN的储备池"></a>ESN的储备池</h2><p>虽然有大量的研究是关于如何获得与具体问题相关的“好”的储备池，但是并没有形成一个系统的方法，多数研究是从实验的角度进行的。这也是目前ESN方法遇到的最大的挑战。<br>ESN的最终性能是由储备池的各个参数决定的，下面首先简要介绍储备池的四个关键参数。</p><p><strong>储备池内部连接权谱半径SR</strong></p><p><strong>储备池规模N</strong></p><p><strong>储备池输入单元尺度IS</strong></p><p><strong>储备池稀疏程度SD</strong></p><p>关于IS的规则：<br>如果需要处理的任务的非线性越强，那么输人单元尺度越大。<br>该原则的本质是通过输入单元尺度IS，将输入变换到神经元激活函数funtion相应的范围。<br>注：神经元激活函数的不同输入范围，其非线性程度不同。</p><h1 id="智能优化算法"><a href="#智能优化算法" class="headerlink" title="智能优化算法"></a>智能优化算法</h1><p>牛顿迭代法、共轭梯度法、单纯形法、黄金分割</p><h2 id="课上重点"><a href="#课上重点" class="headerlink" title="课上重点"></a>课上重点</h2><p>求</p><p>$$<br>\min(x_1^2+2x_2^2)&#x3D;E<br>$$</p>]]></content>
    
    
    <summary type="html">复杂网络的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://zhangyuanhe.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>信息论与编码课程笔记</title>
    <link href="https://zhangyuanhe.top/2024/01/10/BUPT_note/Notes%20on%20Information%20Theory%20and%20Coding/"/>
    <id>https://zhangyuanhe.top/2024/01/10/BUPT_note/Notes%20on%20Information%20Theory%20and%20Coding/</id>
    <published>2024-01-10T13:00:00.000Z</published>
    <updated>2024-01-17T12:37:33.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息论与编码"><a href="#信息论与编码" class="headerlink" title="信息论与编码"></a>信息论与编码</h1><h1 id="第一章-信息论与编码理论概述"><a href="#第一章-信息论与编码理论概述" class="headerlink" title="第一章 信息论与编码理论概述"></a>第一章 信息论与编码理论概述</h1><h2 id="信息论与编码理论概述"><a href="#信息论与编码理论概述" class="headerlink" title="信息论与编码理论概述"></a>信息论与编码理论概述</h2><p>自从汉明码开始，各种信道编码获得了长足的发展，如</p><ul><li>格雷码，Reed-Muller码，循环码，Reed-Solomon码,BCH码</li><li>卷积码，Turbo码，LDPC码，Polar码</li><li>级联码，网格编码调制，代数几何码</li><li>编织卷积码，纠删码，空时码</li><li>网络编码，量子纠错码，二维码</li><li>基于信息论与编码理论的安全技术</li></ul><h3 id="编码机制"><a href="#编码机制" class="headerlink" title="编码机制"></a>编码机制</h3><ul><li>编码：信息从一种形式或格式转换为另一种形式的过程。</li><li>编码机制：用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。</li></ul><h3 id="信源编码"><a href="#信源编码" class="headerlink" title="信源编码"></a>信源编码</h3><p>目的：提高通信的有效性，即以更少的符号来表示原始消息</p><p>通过减少消息符号序列中的冗余度，提高平均信息量</p><h3 id="随机错误"><a href="#随机错误" class="headerlink" title="随机错误"></a>随机错误</h3><ul><li>随机错误：接收序列中的传输错误是随机出现的。</li><li>随机错误信道：这样的信道称为随机错误信道。</li></ul><h3 id="突发错误"><a href="#突发错误" class="headerlink" title="突发错误"></a>突发错误</h3><p>突发错误：不同状态特性下，错误出现的概率不一样，这种错误为突发错误。</p><h3 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h3><p>目的：检测和纠正由于非人为(自然)因素引起的传输错误</p><p>设计机制：通过对消息符号序列加入冗余信息，使得接收方收到信号后，可以通过这些冗余信息进行检错和纠错</p><h2 id="数字通信系统的组成及各种信道"><a href="#数字通信系统的组成及各种信道" class="headerlink" title="数字通信系统的组成及各种信道"></a>数字通信系统的组成及各种信道</h2><h3 id="数字通信系统模型"><a href="#数字通信系统模型" class="headerlink" title="数字通信系统模型"></a>数字通信系统模型</h3><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled.png" alt="Untitled"></p><h3 id="无记忆信道和有记忆信道"><a href="#无记忆信道和有记忆信道" class="headerlink" title="无记忆信道和有记忆信道"></a>无记忆信道和有记忆信道</h3><p>无记忆信道：如果在给定时间间隔上，检测器的输出只与在该时间间隔上传送的信号有关，而与任何前面时间的传送的信号无关，称此信道为无记忆信道。该信道可以用如下公式表示：</p><p>$$<br>P(Y&#x2F;X)&#x3D; \prod_n p(y_n&#x2F;x_n)<br>$$</p><p>有记忆信道：一种M元输入、Q元输出的信道模型。该信道可以用如下公式表示：</p><p>$$<br>P(y_n&#x2F;x_{n-k+1},…,x_{n-1},x_n)<br>$$</p><h3 id="离散无记忆-DMC-信道"><a href="#离散无记忆-DMC-信道" class="headerlink" title="离散无记忆(DMC)信道"></a>离散无记忆(DMC)信道</h3><p>是一种M元输入、Q元输出的信道模型。</p><p>条件概率P(Y&#x2F;X)是描述该信道的最好方式，也叫做转移概率，其中X表示调制器输入符号，Y表示解调器输出符号，P(Y&#x2F;X)表示发送为X接收为Y的概率。</p><h3 id="二元对称-BSC-信道"><a href="#二元对称-BSC-信道" class="headerlink" title="二元对称(BSC)信道"></a>二元对称(BSC)信道</h3><p>信道矩阵：一个信道也可由它的转移概率组成的矩阵来表示。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%201.png" alt="Untitled"></p><h3 id="信道矩阵"><a href="#信道矩阵" class="headerlink" title="信道矩阵"></a>信道矩阵</h3><p>一般离散单符号信道的信道矩阵为：</p><p>$$<br>\begin{bmatrix} P(b_1|a_1) &amp; P(b_2|a_1) &amp; \dots &amp; P(b_s|a_1) \ P(b_1|a_2) &amp; P(b_2|a_2) &amp; \dots &amp; P(b_s|a_2) \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \P(b_1|a_r) &amp; P(b_2|a_r) &amp; \dots &amp; P(b_s|a_r)  \end{bmatrix}<br>$$</p><h3 id="加性高斯白噪声-AWGN-信道"><a href="#加性高斯白噪声-AWGN-信道" class="headerlink" title="加性高斯白噪声(AWGN)信道"></a>加性高斯白噪声(AWGN)信道</h3><ul><li>加性噪声：叠加在信号上的一种噪声。</li><li>白噪声：噪声的功率谱密度在所有的频率上均为一常数。</li><li>高斯白噪声：白噪声取值的概率分布服从高斯分布，其自相关系数为无延时的冲击函数。</li></ul><h2 id="通信系统涉及的一些基本概念"><a href="#通信系统涉及的一些基本概念" class="headerlink" title="通信系统涉及的一些基本概念"></a>通信系统涉及的一些基本概念</h2><h3 id="信息传输率"><a href="#信息传输率" class="headerlink" title="信息传输率"></a>信息传输率</h3><ul><li>符号传输率：为1&#x2F;T，每T秒传输一个编码符号，即单位时间内传输的符号个数。</li><li>码速率：编码后的数据流中有用部分的比例，对于(n,k)线性分组码，码速率为R&#x3D;k&#x2F;n，即k个信息比特对应于传送n个符号。</li><li>信息传输率(数据率)：在编码系统中，若码速率是R&#x3D;k&#x2F;n，则信息传输率(数据率)为R&#x2F;T(bit&#x2F;s)。</li></ul><h3 id="信道带宽"><a href="#信道带宽" class="headerlink" title="信道带宽"></a>信道带宽</h3><p>除了噪声的作用造成信号改变外，所有的通信系统都会因为带宽有限而造成信号失真。</p><ul><li>最小信道带宽：为基本保证信号不因带宽原因而失真，粗略估计等于W&#x3D;1&#x2F;(2T)(Hz)。</li><li>未编码系统：数据率1&#x2F;T&#x3D;2W，受到带宽影响。</li><li>二元编码系统：数据率R&#x2F;T&#x3D;2RW。同未编码系统相比，若要保持数据率不变，则要求带宽扩展1&#x2F;R倍。</li></ul><h3 id="AWGN信道的分组编码系统"><a href="#AWGN信道的分组编码系统" class="headerlink" title="AWGN信道的分组编码系统"></a>AWGN信道的分组编码系统</h3><p>译码器的条件错误概率：已知接收序列Y时</p><p>$$<br>P_e(H_m&#x2F;Y),P_e(X_m&#x2F;Y)<br>$$</p><p>译码器的错误概率：</p><p>$$<br>P_e(H_m)&#x3D;P_e(X_m)&#x3D;\sum_Y P_e(X_m&#x2F;Y)P(Y)<br>$$</p><h3 id="最佳译码规则和最大后验概率译码"><a href="#最佳译码规则和最大后验概率译码" class="headerlink" title="最佳译码规则和最大后验概率译码"></a>最佳译码规则和最大后验概率译码</h3><ul><li><p><strong>最佳译码规则</strong>：能够使译码错误概率P(E)达到最小的译码规则</p></li><li><p>由于接收序列Y是译码前产生的，所以P(Y)与译码规则无关</p></li><li><p>最佳译码规则必须对所有Y，使得</p><p>  $$<br>  P(E&#x2F;Y)\cong P(Y \neq X&#x2F;Y)<br>  $$</p><p>  &#96;最小，即 P(Y&#x3D;X&#x2F;Y) 最大。</p></li><li><p><strong>最大后验概率译码</strong>：对于每个输入Y，如果译码器能在码字集合中选择一个码字，作为发送码字的估值，并且使P(X&#x2F;Y)最大，则这种译码规则一定能使译码器输出的错误概率最小。</p></li></ul><h3 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h3><p>Bayes公式：</p><p>$$<br>\uparrow P(X&#x2F;Y)&#x3D;\frac{P(Y&#x2F;X)P(X)}{P(Y)} \公式(1)<br>$$</p><ul><li>对于给定的Y，可选择能使公式(1)右边最大的向量作为X的估计值。</li><li>如果所有码字都是等可能的，即P(X)是常数，那么公式(1)左边最大，就推导出P(Y&#x2F;X)最大。</li><li>P(Y&#x2F;X)：叫做似然函数、信道转移概率。</li></ul><h3 id="最大似然译码"><a href="#最大似然译码" class="headerlink" title="最大似然译码"></a>最大似然译码</h3><ul><li><p>定义：若能在码字集合选择合适的码字X，使得P(Y&#x2F;X)最大，则这种译码规则被称为最大似然译码。</p></li><li><p>对数似然函数：由于lnx与x是单调关系，故有lnP(Y&#x2F;X)。</p></li><li><p>对于离散无记忆信道，由于</p><p>  $$<br>  P(Y&#x2F;X)&#x3D;\sum_n P(y_i&#x2F;x_i)<br>  $$</p><p>  所以</p><p>  $$<br>  \ln P(Y&#x2F;X)&#x3D;\sum_n \ln P(y_i&#x2F;x_i)<br>  $$</p></li><li><p>MLD：对应的译码器称为最大似然译码器。</p></li><li><p>MLD规则：是最为可行的一种译码规则。</p></li><li><p>对于DMC和BSC信道是一种最佳译码准则。但是在某些情况下并不是最佳的译码规则，如当发送端不是以等概率发送码字的时候。</p></li></ul><h3 id="BSC信道的最大似然译码"><a href="#BSC信道的最大似然译码" class="headerlink" title="BSC信道的最大似然译码"></a>BSC信道的最大似然译码</h3><p>$$<br>P(y_i&#x2F;x_i)&#x3D;\begin{cases} 1-p&amp;  y_i&#x3D;x_i\p&amp; y_i\neq x_i \end{cases}<br>$$</p><p>Y为二元序列，用d(Y, X)表示Y和X之间的距离，即不同位数的个数</p><p>$$<br>\ln P(Y&#x2F;X)&#x3D;d(y,X)\ln p+(n-d(Y,X))\ln (1-p) &#x3D;\ d(Y,X)\ln \frac {p}{1-p} +n\ln(1-p)<br>$$</p><p>即想要P(Y&#x2F;X)最大，则需要d(Y, X)最小</p><p>最小距离译码器：在BSC中，MLD规则变成了选择能使Y和X之间的汉明距离为最小的向量，作为码字X的估计值</p><h1 id="数据安全中的数学问题"><a href="#数据安全中的数学问题" class="headerlink" title="数据安全中的数学问题"></a>数据安全中的数学问题</h1><p>语义</p><p>语法：01比特</p><p>语用</p><h2 id="信道编码"><a href="#信道编码" class="headerlink" title="信道编码"></a>信道编码</h2><p>y&#x3D;Ax+b mod  q</p><p>分组码</p><p>循环码</p><p>卷积码</p><h2 id="LDPC码"><a href="#LDPC码" class="headerlink" title="LDPC码"></a>LDPC码</h2><p>有低密度的稀疏矩阵，就表示是LDPC码</p><h2 id="压缩感知"><a href="#压缩感知" class="headerlink" title="压缩感知"></a>压缩感知</h2><p>y&#x3D;Ax+b</p><p>如果x稀疏，A满足一定的条件，通过y A可以找到x</p><p>由于A不可逆，无法通过求找到x</p><p>现实中的x一般并不稀疏，进过一个变化之后，再一组正交基上可以进行稀疏表示</p><h3 id="矩阵A与x维数不匹配"><a href="#矩阵A与x维数不匹配" class="headerlink" title="矩阵A与x维数不匹配"></a>矩阵A与x维数不匹配</h3><p>格密码，编码，压缩感知都有对测量矩阵尺寸多样性的需求</p><h3 id="半张量积压缩感知"><a href="#半张量积压缩感知" class="headerlink" title="半张量积压缩感知"></a>半张量积压缩感知</h3><p>$$<br>y&#x3D;a\ltimes x+b<br>$$</p><h1 id="第二章-信息论基础与信源编码理论"><a href="#第二章-信息论基础与信源编码理论" class="headerlink" title="第二章 信息论基础与信源编码理论"></a>第二章 信息论基础与信源编码理论</h1><p>信息的定义：信息是事物运动状态或存在方式不确定性的描述</p><h2 id="自信息"><a href="#自信息" class="headerlink" title="自信息"></a>自信息</h2><p>定义：考虑离散随机变量X，其样本空间为{xi, i&#x3D;1, 2,…,n}，则事件X&#x3D;xi的自信息的定义为</p><p>$$<br>I(x_i)&#x3D;log(\frac{1}{P(x_i)})&#x3D;-logP(x_i)<br>$$</p><blockquote><p>自信息的单位由对数的底来决定，以2为底，单位就是比特(bits)，以e为底就是奈特(nats)。自信息非负。</p></blockquote><h2 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h2><p>定义： xi和yi之间的互信息定义为</p><p>$$<br>I(x_i;y_i)&#x3D;log(\frac{P(x_i|y_i)}{P(x_i)})<br>$$</p><p>互信息的性质：</p><p>性质1：互易性 I(xi;yi)&#x3D; I(yi;xi)。<br>性质2：当xi和yi是统计上独立的，即P(xi|yi)&#x3D; P(xi)，则I(xi;yi)&#x3D;0。<br>性质3：互信息量可以是正的，也可以是负的。</p><blockquote><p>思考题：计算二元对称(BSC)信道的互信息量?</p><p>计算二元对称信道（Binary Symmetric Channel，BSC）的互信息量（Mutual Information）可以使用以下的LaTeX公式表示：</p><p><em>I</em>(<em>X</em>;<em>Y</em>)&#x3D;<em>H</em>(<em>Y</em>)−<em>H</em>(<em>Y</em>∣<em>X</em>)</p><p>其中：</p><ul><li><p><em>I</em>(<em>X</em>;<em>Y</em>) 表示信道输入 <em>X</em> 和输出 <em>Y</em> 之间的互信息量。</p></li><li><p><em>H</em>(<em>Y</em>) 表示接收端输出 <em>Y</em> 的熵（Entropy），可以用以下公式计算：</p><p>  $$<br>  H(Y) &#x3D; -\sum_{i&#x3D;1}^{2} P(Y&#x3D;y_i) \cdot \log_2(P(Y&#x3D;y_i))<br>  $$</p></li></ul><p>这里的 <em>y</em>1 和 <em>y</em>2 分别表示接收到的0和1的可能性，<em>P</em>(<em>Y</em>&#x3D;<em>yi</em>) 是接收到符号 <em>yi</em> 的概率。</p><ul><li><p><em>H</em>(<em>Y</em>∣<em>X</em>) 表示在已知输入 <em>X</em> 的条件下，接收端输出 <em>Y</em> 的条件熵（Conditional Entropy），可以用以下公式计算：</p><p>  $$<br>  H(Y|X) &#x3D; -\sum_{i&#x3D;1}^{2} \sum_{j&#x3D;1}^{2} P(X&#x3D;x_j, Y&#x3D;y_i) \cdot \log_2\left(\frac{P(X&#x3D;x_j, Y&#x3D;y_i)}{P(X&#x3D;x_j)}\right)<br>  $$</p></li></ul><p>对于二元对称信道（BSC），错误概率 p 相等，即 P(Y&#x3D;0∣X&#x3D;1)&#x3D;P(Y&#x3D;1∣X&#x3D;0)&#x3D;p，而 P(Y&#x3D;0∣X&#x3D;0)&#x3D;P(Y&#x3D;1∣X&#x3D;1)&#x3D;1−p。因此，可以使用这些概率值来计算上述公式中的各项。</p></blockquote><h2 id="平均自信息量-信息熵"><a href="#平均自信息量-信息熵" class="headerlink" title="平均自信息量(信息熵)"></a>平均自信息量(信息熵)</h2><p>定义：离散随机变量X的平均自信息定义为，其样本空间为{xi, i&#x3D;1, 2,…,n}，则事件X&#x3D;xi的平均自信息量的定义为</p><p>$$<br>H(X)&#x3D;E{log(\frac{1}{P(x_i)})}&#x3D;\sum^n_{i&#x3D;1}P(x_i)I(x_i)&#x3D;-\sum^n_{i&#x3D;1}P(x-_i)logP(x_i)<br>$$</p><p>其中H(X)表示每个信源符号的平均信息量。</p><h2 id="平均条件自信息量-条件熵"><a href="#平均条件自信息量-条件熵" class="headerlink" title="平均条件自信息量(条件熵)"></a>平均条件自信息量(条件熵)</h2><p>定义：平均条件自信息H(X|Y)定义为</p><p>$$<br>H(X|Y)&#x3D;\sum^n_{i&#x3D;1}\sum^m_{j&#x3D;1}P(x_iy_i)log\frac{1}{P(x_i|y_i)}<br>$$</p><blockquote><p>思考题：计算二元对称(BSC)信道的平均条件自信息量(条件熵)?</p></blockquote><h2 id="无失真信源编码"><a href="#无失真信源编码" class="headerlink" title="无失真信源编码"></a>无失真信源编码</h2><h3 id="等长信源编码定理"><a href="#等长信源编码定理" class="headerlink" title="等长信源编码定理"></a>等长信源编码定理</h3><p>定理: 一个熵为H(X)的离散无记忆信源，若对信源长为N的符号序列进行等长编码，设码字是从r个字母的码符号集合中，选取l个码元组成。对于任意的ε&gt;0，只要满足</p><p>$$<br>\frac{l}{N}\geq \frac{H(X)+\varepsilon}{log\gamma}<br>$$</p><p>则当N足够大时，可实现几乎无失真编码，即译码错误概率可为任意小。</p><h3 id="变长码"><a href="#变长码" class="headerlink" title="变长码"></a>变长码</h3><table><thead><tr><th>字母</th><th>码字</th><th>字母</th><th>码字</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>E</td><td>10</td></tr><tr><td>B</td><td>1</td><td>F</td><td>11</td></tr><tr><td>C</td><td>00</td><td>G</td><td>000</td></tr><tr><td>D</td><td>01</td><td>H</td><td>111</td></tr></tbody></table><p>若对字母序列ABADCAB进行编码，则得到0 1 0 01 00 0 1<br>译码不唯一：可能被译为DADAAAB(01 0 01 0 0 0 1)<br>或者AEDGB(0 10 01 000 1)</p><blockquote><p>注：变长码必须是惟一可译码，才能实现无失真编码。</p></blockquote><h3 id="变长信源编码定理"><a href="#变长信源编码定理" class="headerlink" title="变长信源编码定理"></a>变长信源编码定理</h3><p>定理:一个熵为H(X)的离散无记忆信源，并有r个码元的码符号集合，总可以找到一种无失真编码方法，构成惟一可译码，使其平均码长满足</p><p>$$<br>\frac{H(X)}{logr}\leq\bar{L}&lt;\frac{H(X)}{logr}+1<br>$$</p><p>则当N足够大时，可实现几乎无失真编码，即译码错误概率可为任意小。</p><h3 id="信道的信息传输率"><a href="#信道的信息传输率" class="headerlink" title="信道的信息传输率"></a>信道的信息传输率</h3><p>变长信源编码定理中的极限值H(X)&#x2F;logr同等长信源编码定理中的极限值是一致的。</p><p>定义：信道的信息传输率(码率)为</p><p>$$<br>R&#x3D;\frac{H(X)}{logr}<br>$$</p><p>得到编码后信道的信息传输率为</p><p>$$<br>R\le\bar{L}<br>$$</p><h2 id="经典的信源编码方法"><a href="#经典的信源编码方法" class="headerlink" title="经典的信源编码方法"></a>经典的信源编码方法</h2><h3 id="信源编码—霍夫曼-Huffman-编码"><a href="#信源编码—霍夫曼-Huffman-编码" class="headerlink" title="信源编码—霍夫曼(Huffman)编码"></a>信源编码—霍夫曼(Huffman)编码</h3><p>一个离散无记忆信源有7个符号xi, i&#x3D;1,..,7，P(X&#x3D;x1)&#x3D;0.37, P(X&#x3D;x2)&#x3D;0.33, P(X&#x3D;x3)&#x3D;0.16, P(X&#x3D;x4)&#x3D;0.07, P(X&#x3D;x5)&#x3D;0.04, P(X&#x3D;x6)&#x3D;0.02, P(X&#x3D;x7)&#x3D;0.01, 将7个信源符号按照概率递减的顺序进行排序，构造如图8所示的霍夫曼树。<br>按照编码路径从后往前返回，就得到对应的码字x7&#x3D;111111, x6&#x3D;111110, x5&#x3D;11110, x4&#x3D;1110，x3&#x3D;110, x2&#x3D;10，x1&#x3D;0。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%202.png" alt="Untitled"></p><blockquote><p>思考题：如何编程序实现霍夫曼编码?</p><ol><li>构建霍夫曼树：<ul><li>统计输入数据中每个字符的频率。</li><li>创建叶子节点，每个叶子节点代表一个字符，并将频率作为节点的权重。</li><li>将叶子节点放入一个优先队列（最小堆）中，以便频率最低的节点位于队列的前面。</li><li>重复以下步骤，直到只剩下一个节点为止：<ul><li>从队列中弹出两个频率最低的节点。</li><li>创建一个新的节点，其权重等于这两个节点的权重之和。</li><li>将新节点插入队列中。</li></ul></li><li>最后队列中剩下的节点就构成了霍夫曼树。</li></ul></li><li>生成霍夫曼编码：<ul><li>遍历霍夫曼树，从根节点开始，分别向左和向右遍历树的边。</li><li>每次向左移动时，将编码中添加一个 0，每次向右移动时，将编码中添加一个 1。</li><li>当到达叶子节点时，您就得到了字符的霍夫曼编码。</li></ul></li><li>构建编码表：<ul><li>将每个字符与其对应的霍夫曼编码存储在一个编码表中，以便在编码和解码过程中使用。</li></ul></li><li>编码和解码：<ul><li>使用编码表将输入数据编码为霍夫曼编码。</li><li>使用霍夫曼树将霍夫曼编码解码为原始数据。</li></ul></li></ol></blockquote><h3 id="游程编码"><a href="#游程编码" class="headerlink" title="游程编码"></a>游程编码</h3><p>游程：信源输出的字符序列中，各种字符连续的重复出现的字符串的个数。<br>游程编码：就是将这种字符序列映射成字符串的长度和字符串的位置的标志序列。<br>游程编码常用作图形文件的编码方式，如.bmp和.tiff。</p><blockquote><p>例子：考虑比特序列11111111111111100000000000000000001111，可以被表示成(15,1),(19,0),(4,1)，字符最长的重复的数目为19，因此，把该比特序列编码为(01111,1), (10011,0), (00100,1)，此时压缩率为18:38&#x3D;1:2.11。</p></blockquote><blockquote><p>思考题：如何编程序实现游程编码?</p><ol><li><strong>统计字符频率</strong>：<ul><li>首先，需要扫描输入文本并统计每个字符的频率。这是构建霍夫曼树的基础，因为频率高的字符将具有较短的编码。</li></ul></li><li><strong>构建霍夫曼树</strong>：<ul><li>基于字符频率，构建霍夫曼树。通常，使用一个优先队列（最小堆）来管理节点，每个节点代表一个字符及其频率。在构建过程中，反复合并两个最小频率的节点，创建一个新的节点，并将其插入回队列，直到队列中只剩下一个节点，即根节点，表示整个霍夫曼树已构建完成。</li></ul></li><li><strong>生成霍夫曼编码</strong>：<ul><li>遍历霍夫曼树，从根节点开始，每当沿着左子树移动时添加0，沿着右子树移动时添加1。当到达叶子节点时，记录下当前路径所对应的字符的编码。</li></ul></li><li><strong>构建编码表</strong>：<ul><li>将每个字符和它对应的霍夫曼编码存储在一个编码表中，以便在编码和解码过程中使用。</li></ul></li><li><strong>编码文本</strong>：<ul><li>使用编码表将输入文本中的字符编码为霍夫曼编码。</li></ul></li><li><strong>解码文本</strong>：<ul><li>使用霍夫曼树将霍夫曼编码解码为原始文本。</li></ul></li></ol></blockquote><h3 id="LZ-Lemple-Ziv-编码"><a href="#LZ-Lemple-Ziv-编码" class="headerlink" title="LZ(Lemple-Ziv)编码"></a>LZ(Lemple-Ziv)编码</h3><p>分段的方法：1)游程先取第一个符号作为第一段，然后再继续分段；2)若有出现与前面符号一样时，就再添加紧跟后面的一个符号一起组成一段；3)尽可能取最少个连着的符号并保证各段都不相同；4)以此类推，直至信源符号序列结束。<br>编码方法：首先去掉最后一个符号，然后看剩下的字符串在字典中的排序，这个排序值转换成二进制数作为指针X的值，最后一个信源符号作为码字第2项d的值，即得到码字(X, d)。</p><blockquote><p>例子：考虑比特序列101011011010101011，根据上面的编码方法可把该比特序列分段为1, 0, 10, 11, 01, 101, 010, 1011。<br>码字为：(000,1),( 000,0), (001,0), (001,1), (010,1), (011,1), (101,0), (110,1)。</p></blockquote><blockquote><p>思考题：如何编程序实现LZ编码?</p><ol><li><strong>初始化字典</strong>：创建一个空的字典，其中包含所有可能的单个字符作为初始词条。</li><li><strong>扫描输入数据</strong>：从左到右扫描输入数据，逐步构建编码输出。开始时，当前扫描位置指向输入数据的第一个字符。</li><li><strong>查找最长匹配</strong>：在字典中查找与当前扫描位置匹配的最长字符串（前缀），这个字符串必须存在于字典中。如果找到匹配，就将扫描位置移动到匹配字符串的末尾，否则将当前字符作为一个字典词条。</li><li><strong>输出编码</strong>：将匹配字符串的索引（或编码）输出到结果中，并将匹配字符串后的字符作为下一个字典词条的一部分。</li><li><strong>更新字典</strong>：将新的字典词条添加到字典中，以便下次匹配时使用。</li><li><strong>重复步骤3到步骤5</strong>，直到扫描完成整个输入数据。</li></ol></blockquote><h2 id="纠错码的理论基础"><a href="#纠错码的理论基础" class="headerlink" title="纠错码的理论基础"></a>纠错码的理论基础</h2><h3 id="信道容量"><a href="#信道容量" class="headerlink" title="信道容量"></a>信道容量</h3><p>定义：考虑某种概率分布为P(x)的离散无记忆信源，对于一个固定的信道，信道容量被定义为最大的平均互信息，此时传输每个符号平均获得的信息量最大，即对于每个固定的信道可以达到最大的信息传输率，即</p><p>$$<br>C&#x3D;\max_{P(X_j)}I(X;Y)&#x3D;\max_{P(X_J)}\sum^{q-1}<em>{j&#x3D;1}\sum^{r-1}</em>{i&#x3D;o}P(x_j)P(y_i|x_j)\log \frac {P(y_i|x_j)}{P(y_i)}<br>$$</p><p>其约束条件为</p><p>$$<br>P(x_j)\ge0\ ,\sum^{q-1}_{j&#x3D;0}P(x_j)&#x3D;1<br>$$</p><blockquote><p>思考题：如何计算给定某种信道的信道容量?</p><ol><li><p><strong>确定信道模型</strong>：首先，需要明确定义所使用的信道模型。不同的信道（例如二进制对称信道、高斯信道、无线信道等）具有不同的数学表示和特性。你需要了解信道的概率分布和噪声性质。</p></li><li><p><strong>计算信道容量</strong>：使用香农-哈特利定理来计算信道容量。该定理的公式如下：</p><p> $$<br> C+B·\log_2(1+SNR)<br> $$</p><p> 其中，</p><ul><li><em>C</em> 表示信道容量（比特每秒，bps）。</li><li><em>B</em> 表示信道的带宽（赫兹，Hz），它表示信号传输的频率范围。</li><li>SNRSNR 表示信噪比，定义为信号功率与噪声功率之比。通常以对数（以分贝为单位）表示。</li></ul></li><li><p><strong>SNR计算</strong>：计算信噪比（SNR）是信道容量计算的关键。SNR的计算方式取决于信道的特性。例如，在高斯信道中，SNR通常表示为信号功率与噪声功率之比。</p></li><li><p><strong>确定带宽</strong>：带宽（B）是信号传输的频率范围，通常以赫兹（Hz）表示。带宽的选择与具体的通信系统和应用有关。</p></li></ol></blockquote><h3 id="纠错编码的理论基础"><a href="#纠错编码的理论基础" class="headerlink" title="纠错编码的理论基础"></a>纠错编码的理论基础</h3><p>香农编码定理：如果系统的传输率小于信道容量，那么适当选择编码技术就能实现可靠通信，即可以将差错率减小到任意小的程度。</p><h3 id="信道编码定理"><a href="#信道编码定理" class="headerlink" title="信道编码定理"></a>信道编码定理</h3><p>定理：假设DMS有信源字符集X，熵为每信源符号H(X)比特，而且信源每Ts秒产生一个符号，那么信源的平均信息率为每秒H(X)&#x2F;Ts比特，假设信道可以每Tc秒使用一次，而信道容量为每次信道使用C比特，那么每单位时间的信道容量为每秒钟C&#x2F;Tc比特。如果H(X)&#x2F;Ts≤ C&#x2F;Tc，那么就存在编码方案使得在有噪声的信道上传输的信源消息，能够以任意小的错误概率进行恢复。</p><h1 id="第三章-线性分组"><a href="#第三章-线性分组" class="headerlink" title="第三章 线性分组"></a>第三章 线性分组</h1><h2 id="分组码"><a href="#分组码" class="headerlink" title="分组码"></a>分组码</h2><blockquote><p><strong>分组码：将消息序列分组进行编码</strong></p></blockquote><p>每组消息u有k个信息位，共有$2^k$个不同的消息</p><blockquote><p><strong>码字：编码器按照一定规则将每个输入消息u变换成二元n重v，n&gt;k，这个二元n重v称作消息u的码字或码矢。</strong></p></blockquote><p>所有$2^k$个码字组成的集合称作是分组码</p><blockquote><p>为什么在分组码中码字的个数是$2^k$个?<br>当编码字的位数是$2^k$时，这些码字可以更容易地排列成矩阵，例如二维数组，以便进行操作和计算。这种排列方式在编码和解码时通常更加高效。</p></blockquote><h2 id="线性分组码"><a href="#线性分组码" class="headerlink" title="线性分组码"></a>线性分组码</h2><p>线性分组码即具有线性性质的分组码</p><p><strong>定义：长为n，有$2^k$个码字的分组码，当且仅当其$2^k$个码字构成GF(2)上所有n重矢量空间的一个k维子空间时，称作线性(n, k)分组码。</strong></p><h2 id="生成矩阵"><a href="#生成矩阵" class="headerlink" title="生成矩阵"></a>生成矩阵</h2><p>∵ 线性(n,k)分组码C是一个k维子空间<br>∴ 在码C中能找到k个线性独立的码字$g_0, g_1,…, g_{k-1}，$使得C中的每个码字v都是这k个码字的一种线性组合，即 $v&#x3D;u_0g_0+u_1g_1+…+u_{k-1}g_{k-1}$</p><blockquote><p>生成矩阵：将k个线性独立的码字作为行，得到k×n阶矩阵</p><p>$$<br>G&#x3D;<br>\begin{pmatrix}<br>g_0\g_1\ \vdots \g_{k-1}<br>\end{pmatrix}&#x3D;\begin{pmatrix}<br>g_{00}&amp;g_{01}&amp;\dots&amp;g_{0n-1}\g_{10}&amp;g_{11}&amp;\dots&amp;g_{1n-1}\ \vdots \g_{(k-1)0}&amp;g_{(k-1)1}&amp;\dots&amp;g_{(k-1)n-1}<br>\end{pmatrix}<br>$$</p></blockquote><h2 id="一致校验-监督-矩阵"><a href="#一致校验-监督-矩阵" class="headerlink" title="一致校验(监督)矩阵"></a>一致校验(监督)矩阵</h2><p>∵ (n,k)线性码有r(r&#x3D;n-k)个校验码元<br>∴ 必须有r个独立的线性方程</p><p>对于任一码字c, 有cHT&#x3D;0</p><p>$∵c&#x3D;iG\<br>∴ GH^T&#x3D;0$</p><blockquote><p>校验矩阵：该矩阵由r行n列组成，即</p><p>$$<br>H&#x3D;\begin{pmatrix}<br>h_{1,n}&amp;h_{1,n-1}&amp;\dots&amp;h_{1,1}\h_{2,n}&amp;h_{2,n-1}&amp;\dots&amp;h_{2,1}\ \vdots \h_{r,n}&amp;h_{r,n-1}&amp;\dots&amp;h_{r,1}<br>\end{pmatrix}<br>$$</p></blockquote><p>一致校验矩阵的标准形式：经过初等变换，得到$H&#x3D;[Q I_r]$</p><h2 id="线性系统分组码"><a href="#线性系统分组码" class="headerlink" title="线性系统分组码"></a>线性系统分组码</h2><p><strong>定义：若(n,k)线性分组码C的生成矩阵形如$G&#x3D;[P I_k]$或$G&#x3D;[I_k P])$，此时称C为线性系统分组码。</strong></p><p>$$<br>G&#x3D;<br>\begin{pmatrix}<br>g_0\g_1\ \vdots \g_{k-1}<br>\end{pmatrix}&#x3D;[P \ I_k]&#x3D;\begin{pmatrix}<br>p_{0,0}&amp;p_{0,1}&amp;\dots&amp;p_{0,n-k-1}&amp; \vdots&amp;1&amp;0&amp;0&amp;\dots&amp;0 \p_{1,0}&amp;p_{1,1}&amp;\dots&amp;p_{1,n-k-1}&amp; \vdots&amp;0&amp;1&amp;0&amp;\dots&amp;0 \ p_{2,0}&amp;p_{2,1}&amp;\dots&amp;p_{2,n-k-1}&amp; \vdots&amp;0&amp;0&amp;1&amp;\dots&amp;0\ \vdots\ p_{k-1,0}&amp;p_{k-1,1}&amp;\dots&amp;p_{k-1,n-k-1}&amp; \vdots&amp;0&amp;0&amp;0&amp;\dots&amp;1<br>\end{pmatrix}<br>$$</p><p>此时，如果用任意消息u同G做乘法，就会发现每个码字都可以被分成两个部分：消息部分和冗余部分</p><h2 id="一致校验方程"><a href="#一致校验方程" class="headerlink" title="一致校验方程"></a>一致校验方程</h2><p>对于线性系统分组码</p><p>$$<br>v&#x3D;u·G&#x3D;(u_0,u_1,\dots,u_{k-1})·\begin{pmatrix}<br>p_{0,0}&amp;p_{0,1}&amp;\dots&amp;p_{0,n-k-1}&amp; \vdots&amp;1&amp;0&amp;0&amp;\dots&amp;0 \p_{1,0}&amp;p_{1,1}&amp;\dots&amp;p_{1,n-k-1}&amp; \vdots&amp;0&amp;1&amp;0&amp;\dots&amp;0 \ p_{2,0}&amp;p_{2,1}&amp;\dots&amp;p_{2,n-k-1}&amp; \vdots&amp;0&amp;0&amp;1&amp;\dots&amp;0\ \vdots\ p_{k-1,0}&amp;p_{k-1,1}&amp;\dots&amp;p_{k-1,n-k-1}&amp; \vdots&amp;0&amp;0&amp;0&amp;\dots&amp;1<br>\end{pmatrix}<br>$$</p><p>对应于消息$u&#x3D;(u_0,u_1,\dots,u_{k-1})$的码字是$v&#x3D;(v_0,v_1,\dots,v_{n-1})&#x3D;u·G$，即$v_{n-k+i}&#x3D;u_i , 0≤i≤k-1$</p><p>$v_j&#x3D;u_0p_{0j}+u_1p{1j}+…+u_{k-1}p_{k-1j}, 0≤j≤n-k-1$</p><p>上面两个式子正好反映系统的组成特性，最后这n-k个方程称为码C的一致校验方程。</p><h2 id="对偶码"><a href="#对偶码" class="headerlink" title="对偶码"></a>对偶码</h2><p><strong>定义：令S是$V_n$的k维子空间，并令$S_d$是$V_n$中这样矢量的集合，即对S中的任意u和$S_d$中的任意v，有u·v&#x3D;0，则$S_d$也是$V_n$的一个子空间，它称为S的对偶空间或零化空间。</strong></p><p>定理：令S是$V_n$中的一个k维子空间，则S的对偶空间的维数是n-k。</p><p>对偶码：以H为生成矩阵得到的(n,n-k)码称为码C的对偶码,记为$C_d$。</p><h2 id="系统码的一致校验矩阵"><a href="#系统码的一致校验矩阵" class="headerlink" title="系统码的一致校验矩阵"></a>系统码的一致校验矩阵</h2><p>若码C的生成矩阵具有系统形式$G&#x3D;[P I_k]$或$[I_k P]$，则其一致校验矩阵形如H&#x3D;$[I_{n-k} P^T]$或$H&#x3D;[P^T I_{n-k}]$。</p><h2 id="伴随式"><a href="#伴随式" class="headerlink" title="伴随式"></a>伴随式</h2><p>伴随式：当接收到r后，译码器计算下述n-k重$S&#x3D;r·H……T &#x3D;(s_0, s_1,…, s_{n-k-1})$则称S为r的伴随式。</p><p>当且仅当是一个码字(即无传输错误)时有S&#x3D;0，否则错误矢量本身就是一个码字，此时出现了不可检错误。只要码C设计适当，就几乎不会出现不可检错误。</p><h2 id="伴随式纠错"><a href="#伴随式纠错" class="headerlink" title="伴随式纠错"></a>伴随式纠错</h2><p>根据伴随式定义， 我们有$S&#x3D;r·H^T &#x3D;(v+e)·H^T&#x3D;v·H^T+e·H^T&#x3D;e·H^T$</p><p>可以看出，伴随式是错误图样的组合，即伴随式包含了一定程度的错误图样信息，因而可以用来纠错——伴随式纠错。</p><blockquote><p>考虑某(7,3)码，该码的生成矩阵G和H为</p><p>$$<br>G&#x3D;\begin{pmatrix}   0&amp;1&amp;1&amp;1&amp;1&amp;0&amp;0\     1&amp;0&amp;1&amp;1&amp;0&amp;1&amp;0\      1&amp;1&amp;1&amp;0&amp;0&amp;0&amp;1\end{pmatrix}, H&#x3D;\begin{pmatrix}   1&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1\     0&amp;1&amp;0&amp;0&amp;1&amp;0&amp;1\      0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0\       0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0\end{pmatrix}<br>$$</p><p>令u&#x3D;(101),v&#x3D;(1001101)是发送码字，r&#x3D;(0001101)是接收矢量，收到r后首先计算S&#x3D;r·HT &#x3D;(1000)≠0，由伴随式和错误图样的关系方程有：1&#x3D;e0+e5+e6, 0&#x3D;e1+e4+e6, 0&#x3D;e2+e4+e5+e6, 0&#x3D;e3+e4+e5, 则得到23&#x3D;8个错误图样(1000000), (1010111), (1101011), … …, 其中(1000000)是非零分量最少的图样，考虑BSC信道，则(1000000)是最为可能的错误矢量，因而确定v&#x3D;r+e&#x3D;(0001101)+ (1000000)&#x3D;(1001101)</p></blockquote><h2 id="汉明重量"><a href="#汉明重量" class="headerlink" title="汉明重量"></a>汉明重量</h2><p><strong>汉明重量：令v&#x3D;(v0, v1,…, vn-1)是二元n重，v的汉明重量w(v) 定义为v中非零分量的个数。</strong></p><blockquote><p>举例：设有两个码字{0100,1111},则它们的汉明重量为w(0100)&#x3D;1, w(1111)&#x3D;4</p></blockquote><p>重量分布：对于码长为n的一个分组码, 不同的码字可能具有 相同的汉明重量, 若记Ai为该码中汉明重量为i的码字个数, 称{A0, A1,…, An}是该码的重量分布。</p><h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p><strong>定义：令u&#x3D;(u0, u1,…, un-1)和v&#x3D;(v0, v1,…, vn-1)是两个二元n重，则u和v之间的汉明距离d(u, v)定义为u+v的汉明重量。</strong></p><blockquote><p>举例：设有两个码字{0100,1111},则它们的汉明距离d(0100, 1111)&#x3D;3</p></blockquote><p>汉明距离的性质：</p><ol><li>非负性，d(u, v)≥0；</li><li>d(u, v)&#x3D;0，当且仅当u&#x3D;v的时候；</li><li>对称性： d(u, v) &#x3D;d(v, u) ；</li><li>三角不等式： d(u, v)+d(v, w)≥d(u, w)</li></ol><h2 id="距离分布"><a href="#距离分布" class="headerlink" title="距离分布"></a>距离分布</h2><p><strong>定义：在(n,k)码中，任意两个码字之间都有一个汉明距离，两组不同码字之间可能有相同的汉明距离。若记Di(0≤i≤n)为距离为i的码字组数，那么称{D0, D1,…,Dn}为此分组码的距离分布，并且称能够使Di≠0的那个最小整数i为该码的最小码间距离。</strong></p><p>特别的，对于线性分组码，有如下定理：(n,k)线性码的最小码间距离等于非零码字的最小汉明重量。</p><blockquote><p><strong>定理：设(n,k)线性码C的最小码间距离为d，则1)若d≥t+1，则码C能检测t个随机错误；2)若d≥2t+1，则码C能纠正t个随机错误；3)若d≥t+e+1，则码C能纠正t (t≤e)个随机错误，同时还能检测e个随机错误。</strong></p></blockquote><p>定理：(n,k,d*)线性码C的最小码间距离d<strong>满足d</strong>≤n-k+1</p><p><strong>定义：若(n,k)线性码的最小码间距离d满足d&#x3D;n-k+1，那么称该码为最大距离可分码，简称MDS码。</strong></p><h2 id="标准阵"><a href="#标准阵" class="headerlink" title="标准阵"></a>标准阵</h2><p>令(n,k)线性码C的所有码字是接收矢量r是一个n重，则按如下的方式构造码C的标准阵：</p><p>$$<br>\begin{bmatrix}   v_1&#x3D;0&amp;v_2&amp;\dots&amp;v_i&amp;\dots&amp;v_{2^k}\     e_2&amp;e_2+v_2&amp;\dots&amp;e_2+v_i&amp;\dots&amp;e_2+v_{2^k}\      e_3&amp;e_3+v_2&amp;\dots&amp;e_3+v_i&amp;\dots&amp;e_3+v_{2^k}\   \vdots  \ e_{2^{n+k}}&amp;e_{2^{n+k}}+v_2&amp;\dots&amp;e_{2^{n+k}}+v_i&amp;\dots&amp;e_{2^{n+k}}+v_{2^k}\ \end{bmatrix}<br>$$</p><p>性质1：同一行中任意两个n重之和为一个码字。<br>性质2：在标准阵中，同一行没有两个n重是相同的，每个n重在且仅在一行中出现。</p><blockquote><p>性质2的证明：</p></blockquote><ol><li>假设第l行有2个n重是相同的，如对i≠j有$e_l+v_i&#x3D;e_l+v_j$，即$v_i&#x3D;v_j$，这与标准阵的构造相矛盾，故性质2的第一句话得证。</li><li>首先由定义知每个n重至少出现一次，假设一个n重在第l行和第m行(l&lt;m)都出现，则必存在i，使得该n重等于$e_l+v_i$，且存在j，使得该n重等于$e_m+v_j$，即有$e_m&#x3D;e_l+(v_i+v_j)&#x3D;e_l+v_s$，这意味着$e_m$在第l行，这与标准阵的构造定义相矛盾。<blockquote></blockquote></li></ol><h2 id="陪集"><a href="#陪集" class="headerlink" title="陪集"></a>陪集</h2><p>定义：标准阵中共有$2_{n-k}$行，它们称为码C的陪集。<br>陪集首：每个陪集中的第一个n重$e_i$称为陪集首。陪集中的任 何一个元素都可以作为陪集首，需要做置换操作。</p><p>对于一个码字$v_i$, 如果信道造成的错误图样是陪集首, 则接收矢量r在陪集中, 此时, 可以将接收矢量正确的译码为$v_i$; 否则, 若信道造成的错误图样不是陪集首, 则会造成错误译码。</p><blockquote><p>定理：陪集首是可纠正的错误图样，共有2n-k个可纠正的错误图样。</p></blockquote><h2 id="基于标准阵的译码方法"><a href="#基于标准阵的译码方法" class="headerlink" title="基于标准阵的译码方法"></a>基于标准阵的译码方法</h2><p>方法：如果接收矢量r落在标准阵中的第i行第j列，那么就将r译码为vj，同时错误图样为ei，即$r&#x3D;e_i+v_j$。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%203.png" alt="Untitled"></p><p>缺点：当所考虑的码C的n和k的值都很大的时候，标准阵列的长度就变得非常的巨大，此时，用标准阵来译码就变得不实用了。</p><h2 id="最小距离译码方法"><a href="#最小距离译码方法" class="headerlink" title="最小距离译码方法"></a>最小距离译码方法</h2><p>方法：对BSC信道，为了使译码错误概率最小，可以选择汉明重量最小的n重做为陪集首，即将接收矢量r译码为与r的汉明距离最小的那个码字。</p><blockquote><p>举例：考虑码C&#x3D;{00000,01010,10101,11111}，<br>该码的最小距离是2。<br>如果传输的码字是11111，接收的矢量是11110，那么，<br>d(11110, 00000)&#x3D;4, d(11110, 01010)&#x3D;2,<br>d(11110, 10101)&#x3D;3, d(11110, 11111)&#x3D;1。<br>用最小距离译码方法可以得出传输的码字就是11111这样的结论。</p></blockquote><blockquote><p>思考题：有办法来给标准阵降阶么?<br>结合前面计算伴随式的例子，可以知道伴随式比标准阵的长度短很多。因此，可以用伴随式译码来代替标准阵译码方法。</p></blockquote><h2 id="伴随式译码"><a href="#伴随式译码" class="headerlink" title="伴随式译码"></a>伴随式译码</h2><p>定理：一个陪集的所有$2^k$个n重有同样的伴随式。不同陪集的伴随式不同。</p><p>证明：如果x,y属于同一个陪集，那么</p><p>$$<br>\Leftrightarrow x+C&#x3D;y+C\ \Leftrightarrow x-y \in C\ \Leftrightarrow(x-y)H^T&#x3D;0\ \Leftrightarrow xH^T&#x3D;yH^T\ \Leftrightarrow S(x)&#x3D;S(y)<br>$$</p><p>伴随式译码举例:</p><p>举例：考虑码C&#x3D;{0000,1011,0101,1110}，对应的标准阵就是</p><p>$$<br>\begin{matrix}   0000&amp;1011&amp;0101&amp;1110&amp;00\ 1000&amp;0011&amp;1101&amp;0110&amp;11\ 0100&amp;1111&amp;0001&amp;1010&amp;01\ 0010&amp;1001&amp;0111&amp;1100&amp;10\ 陪集首&amp;&amp;&amp;&amp;伴随式\end{matrix}<br>$$</p><p>如果接收矢量是v&#x3D;(1101)，先通过公式$S&#x3D;vH^T$求出伴随式(11)，确定对应的陪集首(1000)，这就是错误向量e。然后根据e+v&#x3D;(1000)+(1101)求出传输的码字为(0101)</p><h2 id="完备码"><a href="#完备码" class="headerlink" title="完备码"></a>完备码</h2><p>定义：一个能达到汉明界的码成为完备码，满足</p><p>$$<br>M\begin{Bmatrix}\begin{pmatrix}n\0  \end{pmatrix}+ \begin{pmatrix}n\1  \end{pmatrix}(q-1)+ \begin{pmatrix}n\2  \end{pmatrix}(q-1)^2+ \dots+\begin{pmatrix}n\t  \end{pmatrix}(q-1)^t \end{Bmatrix} &#x3D;q^n<br>$$</p><p>其中, M为码字数目, q是q元, n是码长, t是纠错能力</p><p>特殊的, 对于二元完备码, 满足$2^{n-k}&#x3D;\sum^{t}_{i&#x3D;0}\begin{pmatrix}n\i  \end{pmatrix}$</p><h2 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h2><p>定理：q元汉明码Ham(r,q)是参数为(n,k,d)的线性码，其中,$r&#x3D;n-k, n&#x3D;(q^r-1)&#x2F;(q-1), k&#x3D;(q^r-1)&#x2F;(q-1)-r, d_{min}&#x3D;3$。</p><p>特殊的, 对于二元汉明码, 满足$(n, k)&#x3D;(2^r-1, 2^r-1-r)$。</p><blockquote><p>构造汉明码的两种方法：</p></blockquote><ol><li>构造H阵的标准形式H&#x3D;[Q Ir], Q是构造Ir后剩下的2r-1-r列任意排列。</li><li>H阵的列是按r重表示的二进制数的顺序排列。<blockquote></blockquote></li></ol><h1 id="第四章-循环码"><a href="#第四章-循环码" class="headerlink" title="第四章 循环码"></a>第四章 循环码</h1><p>循环移位：将n重$v&#x3D;(v_{n-1}, v_{n-2}, … , v_1, v_0)$的分量循环左移一位, 得到另一个n重$v(1)&#x3D;(v_{n-2}, … , v_1, v_0, v_{n-1})$, 称为v的循环移位。若v的分量循环左移i位, 得到$v(i)&#x3D;(v_{n-i-1}, … , v_1, v_0, v_{n-1}, … , v_{n-i})$。</p><p>循环码的定义：一个(n, k)线性码C，若它的每个码字的任何循环移位都仍然是一个码字，则称此码为循环码。</p><blockquote><p>循环码的优势：具有许多固有的代数结构，可以找到各种实用的译码方法，使用具有反馈的线性移位寄存器可以容易的实现编码和伴随式计算。</p></blockquote><h2 id="码字多项式"><a href="#码字多项式" class="headerlink" title="码字多项式"></a>码字多项式</h2><p>码字多项式：为研究循环码的代数特性，将码字$v&#x3D;(v_{n-1}, v_{n-2}, … , v_1, v_0)$的各个分量看成是多项式</p><p>$$<br>v(x)&#x3D;\sum^{n-1}<em>{i&#x3D;0}v_ix^i&#x3D;v</em>{n-1}x^{n-1}+\dots+v_1x+v_0<br>$$</p><p>的系数，此多项式称为v的码字多项式。</p><p>对应于码矢v(i)&#x3D;( vn-i-1, … , v1, v0, vn-1, … , vn-i)的码字多项式为$v^{(i)}(x)&#x3D;v_{n-i-1}x^{n-1}+v_{n-i-2}x^{n-2}+…+v_1x^{i+1}+v_0x^i+v_{n-1}x^{i-1}+…+v_{n-i+1}x+v_{n-i}$</p><p>码字多项式$v^{(i)}(x)$就是$x^iv^{(0)}(x)&#x2F;(x^n+1)$的余式。</p><h2 id="循环码的代数性质"><a href="#循环码的代数性质" class="headerlink" title="循环码的代数性质"></a>循环码的代数性质</h2><blockquote><p>定理1：循环码C中次数最低的非零码字多项式是唯一的。</p></blockquote><p>证明：令$g(x)&#x3D;\sum^r_{i&#x3D;0}g_ix_i,g_r&#x3D;1$是C中次数最低的码字多项式，若g(x)不唯一，则存在另一个码字多项式$g*(x)&#x3D;\sum^r_{i&#x3D;0}g^*_ix_i,g^*_r&#x3D;1$ ，由线性性质可知，g(x)+g*(x)也是一个码字多项式，但它的次数小于r，和前提矛盾，因此，循环码C中次数最低的非零码字多项式是唯一的。证毕。</p><blockquote><p>定理2：若$g(x)&#x3D;x^r+g_{r-1}x^{r-1}+…+g_1x+g_0$是(n, k)循环码C中次数最低的非零码字多项式, 则必有$g_0&#x3D;1$。</p></blockquote><p>证明：若$g_0&#x3D;0$，则$g(x)&#x3D;x(x^{r-1}+g_{r-1}x^{r-2}+…+g_2x+g_1)$，将g(x)循环左移n-1位之后，可以得到一个次数更低的码字多项式，其次数为r-1，和前提矛盾，则必有$g_0&#x3D;1$。证毕。<br>结合定理1和定理2，知在(n,k)循环码中，次数最低的非零码字多项式形如$g(x)&#x3D;x^r+g_{r-1}x^{r-1}+…+g_1x+1$。</p><p>考虑多项式$g^{(1)}(x)&#x3D;xg(x), g^{(2)}(x)&#x3D;x^2g(x),…，g^{(n-r-1)}(x)&#x3D;x^{n-r-1}g(x)$都是g(x)的循环移位, 它们都是码字多项式, 次数分别为r+1, r+2, …, n-1。<br>根据码字多项式的线性性质可知，它们的任意线性组合<br>$v(x)&#x3D;u_{n-r-1}x^{n-r-1}g(x)+…+u_1xg(x)+u_0g(x)&#x3D;(u_{n-r-1}x^{n-r-1}+…+u_1x+u_0)g(x)$也是C的码字多项式。<br>(n, k)循环码的码字多项式, 次数分别为r, r+1, r+2, … , n-1，次数小于或等于n-1并且是g(x)的倍式的二元多项式共有$2^{n-r}$个, 它们是(n, k)循环码C的所有码字, 因此, 必有k&#x3D;n-r或r&#x3D;n-k。</p><blockquote><p>定理3：若g(x)是(n, k)循环码C中次数最低的非零码字多项式，一个次数小于或等于n-1的二元多项式f(x)是码字多项式当且仅当f(x)是g(x)的倍式。</p></blockquote><p>证明：反证法。设f(x)是码字多项式且其次数小于或等于n-1,假设f(x)&#x3D;a(x)g(x)+b(x), deg(b(x))&lt;r，<br>由线性性质知b(x)&#x3D;f(x)+a(x)g(x)也是一个码字多项式,而deg(b(x))&lt;deg(g(x))，这和前提矛盾，则只能当f(x)是g(x)的倍式的时候，f(x)是码字多项式。证毕。</p><h2 id="生成多项式"><a href="#生成多项式" class="headerlink" title="生成多项式"></a>生成多项式</h2><blockquote><p>定理1：在(n,k)循环码C中存在且仅存在一个次数为n-k的码字多项式$g(x)&#x3D;x^{n-k}+g_{n-k-1}x^{n-k-1}+…+g_2x^2+g_1x+1$，称为生成多项式，使得每个次数小于或等于n-1的二元多项式是码字多项式当且仅当此多项式是g(x)的倍式。</p></blockquote><blockquote><p>定理2：(n, k)循环码的生成多项式g(x)是$x^n+1$的因式。</p></blockquote><p>证明：根据：码字多项式$v^{(i)}(x)$就是$x^iv^{(0)}(x)&#x2F;(x^n+1)$的余式。则有$x^kg(x)&#x3D;(x^n+1)+g^{(k)}(x)$，而$g^{(k)}(x)$是g(x)的k次循环移位，也是码字多项式，因此，它是g(x)的倍式。</p><blockquote><p>定理3：若g(x)是一个n-k次多项式，并且是$x^n+1$的因式，则g(x)生成一个(n, k)循环码。</p></blockquote><h2 id="循环码的生成矩阵"><a href="#循环码的生成矩阵" class="headerlink" title="循环码的生成矩阵"></a>循环码的生成矩阵</h2><p>考虑以$g(x)&#x3D;\sum^{n-k}_{i&#x3D;0}g_ix^i$为生成矩阵的(n,k)循环码C，由于$g(x), xg(x), … , x^{k-1}g(x)$张成C，将这k个多项式的k个n重做为k×n阶矩阵的行，一般选择前k-1位为0的向量作为g(x)，则得到C的生成矩阵为</p><p>$$<br>G(x)&#x3D;\begin{bmatrix} x^{K-1}g(x)\ \dots \xg(x)\g(x) \end{bmatrix}&#x3D;\begin{bmatrix} g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0&amp;0&amp;0&amp;0&amp;\dots&amp;0\ 0&amp;g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0&amp;0&amp;0&amp;\dots&amp;0\ 0&amp;0&amp;g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0&amp;0&amp;\dots&amp;0\ \dots&amp;&amp;&amp;\dots&amp;&amp;&amp;&amp;&amp;&amp;\dots \ 0&amp;0&amp;\dots&amp;0&amp;0&amp;g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0\end{bmatrix}<br>$$</p><p>其中$g_0&#x3D;g_{n-k}&#x3D;1$</p><h2 id="一致校验矩阵"><a href="#一致校验矩阵" class="headerlink" title="一致校验矩阵"></a>一致校验矩阵</h2><p>因为生成多项式g(x)是$x^{n+1}$的因式, 所以存在另一个多项式$h(x)&#x3D;\sum^k_{i&#x3D;0}h_ix^i,h_k&#x3D;h_0&#x3D;1$ , 使得g(x)h(x)&#x3D;xn+1, 此多项式h(x)称为码C的校验多项式h(x), 故可以得到码C的一致校验矩阵H。<br>设$v&#x3D;(v_{n-1}, … , v_1,v_0 )$是C的一个码矢, 则v(x)&#x3D;a(x)g(x), 有$v(x)h(x)&#x3D;a(x)g(x)h(x)&#x3D;a(x)(x^n+1)&#x3D;a(x)x^n+a(x)$, 由于deg(a(x))≤k-1, 故在$a(x)x^n+a(x)$中不会出现$x^{n-1}, … , x^{k+1}, x^k$等各次幂, 于是v(x)h(x)的展开式中$x^{n-1}, … , x^{k+1}, x^k$的系数等于零。<br>因此, 得到以下n-k个方程$h_0v_{n-j}+h_1v_{n-j-1}+…+h_kv_{n-j-k}&#x3D;0, j&#x3D;1, … , n-k$。则码C的一致校验矩阵为</p><p>$$<br>H&#x3D;\begin{bmatrix}     h_k&amp;h_{k-1}&amp;h_{k-2}&amp;\dots&amp;h_0&amp;0&amp;0&amp;\dots&amp;0\ 0&amp;h_k&amp;h_{k-1}&amp;\dots&amp;h_1&amp;h_0&amp;0&amp;\dots&amp;0\ \dots\ 0&amp;0&amp;0&amp;\dots&amp;h_k&amp;h_{k-1}&amp;h_{k-2}&amp;\dots&amp;h_0\end{bmatrix}<br>$$</p><h2 id="系统循环码的编码方法"><a href="#系统循环码的编码方法" class="headerlink" title="系统循环码的编码方法"></a>系统循环码的编码方法</h2><p>给定循环码的生成多项式g(x), 可以使该码成为系统形式。<br>假定待编码的消息是$u&#x3D;(u_{k-1}, … , u_1, u_0 )$, 则对应的消息多项式为$u(x)&#x3D;u_{k-1}x^{k-1}+…+u_2x^2+u_1x+u_0$, 从而有$x^{n-k}u(x)&#x3D;u_{k-1}x^{n-1}+…+u_1x^{n-k+1}+u_0x^{n-k}$。<br>用生成多项式g(x)除xn-ku(x), 得到xn-ku(x)&#x3D; a(x)g(x)+b(x), deg(b(x))&lt;n-k。</p><blockquote><p>循环码的编码是由多项式的乘法、除法以及加法运算完成的, 这些运算都可以由移位寄存器、加法器以及门电路来实现。</p></blockquote><p>系统循环码的编码步骤如下：<br>步骤1：先用xn-k乘以消息多项式$u(x)&#x3D;u_{k-1}x^{k-1}+…+u_2x^2+u_1x+u_0$；<br>步骤2：用生成多项式g(x)除$x^{n-k}u(x)$，得到余式b(x)；<br>步骤3：联合b(x)和$x^{n-k}u(x)$，得到码字多项式$v(x)&#x3D;x^n-ku(x)+b(x)$</p><h2 id="复习：多项式的除法"><a href="#复习：多项式的除法" class="headerlink" title="复习：多项式的除法"></a>复习：多项式的除法</h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%204.png" alt="Untitled"></p><h2 id="g-x-除法电路编码器"><a href="#g-x-除法电路编码器" class="headerlink" title="g(x)除法电路编码器"></a>g(x)除法电路编码器</h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%205.png" alt="Untitled"></p><h2 id="伴随式计算和错误检测"><a href="#伴随式计算和错误检测" class="headerlink" title="伴随式计算和错误检测"></a>伴随式计算和错误检测</h2><p>伴随式定义为$S&#x3D;rH^T$<br>对系统循环码而言, $r(x)&#x3D;\sum^{n-1}<em>{i&#x3D;0}r_ix^i$是接收多项式$g(x)&#x3D;\sum^{n-k-1}</em>{i&#x3D;0}g_ix^i$,<br>是生成多项式, 用g(x)去除r(x)所得的余式, 就是伴随式s(x), 即r(x)&#x3D;a(x)g(x)+s(x)。<br>∵ r(x)&#x3D;v(x)+e(x), v(x)&#x3D;q(x)g(x), r(x)&#x3D;a(x)g(x)+s(x)<br>∴ q(x)g(x)+e(x)&#x3D;a(x)g(x)+s(x)<br>∴ e(x)&#x3D;[q(x)+a(x)]g(x)+s(x)</p><h2 id="伴随式的性质"><a href="#伴随式的性质" class="headerlink" title="伴随式的性质"></a>伴随式的性质</h2><p>性质1：令s(x)是接收多项式r(x)的伴随式, 则用生成多项式g(x)除xs(x)所得的余式$s^{(1)}(x)$就是r(x)循环移位一次$r^{(1)}(x)$的伴随式。<br>性质2：(n, k)循环码能够检测长度小于等于n-k的任何突发错误, 换句话说, 每个长度小于等于n-k的突发错误的伴随式不等于0。<br>性质3：伴随式等于生成多项式除错误图样后所得的余式。</p><blockquote><p>伴随式的这些性质对于译码非常有用。举例来说, 若e(x)是可以纠正的错误图样, 则e(x)的循环移位也是可以纠正的错误图样。</p></blockquote><h2 id="循环码的译码"><a href="#循环码的译码" class="headerlink" title="循环码的译码"></a>循环码的译码</h2><blockquote><p>循环码的译码分为3步：1)计算伴随式; 2)由伴随式得到错误图样; 3)纠正错误。</p></blockquote><h1 id="第五章-BCH码"><a href="#第五章-BCH码" class="headerlink" title="第五章 BCH码"></a>第五章 BCH码</h1><h2 id="BCH码简介"><a href="#BCH码简介" class="headerlink" title="BCH码简介"></a>BCH码简介</h2><p>BCH码的优势：纠错能力强, 能够纠正多个随机错误的循环码; 编译码设备不太复杂; 到目前为止, 对于其他线性码的研究方法, 都是先构造一个码, 然后找出它的最小距离, 以估计该码的纠错能力, 对于BCH码, 反过来, 从先指定这个码能纠正多少个随机错误开始进行研究。</p><h3 id="本原元和本原多项式"><a href="#本原元和本原多项式" class="headerlink" title="本原元和本原多项式"></a>本原元和本原多项式</h3><p>本原元：有限域上存在元素a，使得G中的每个非零元素都是a的某次幂的形式，该元素a称为本原元。</p><p>本原多项式：有限域GF(q)上的本原多项式f(x),是系数取自GF(q)上，以扩域$GF(q^m)$中本原元为根的最小多项式。</p><p>定理1：若$b_1,b_2,..,b_{q-1}$是有限域GF(q)上的所有非零元素，则$x^{q-1}-1&#x3D;(x-b_1)(x-b_2)…(x-b_{q-1})$。</p><h3 id="举例-GF-23-上的乘法运算"><a href="#举例-GF-23-上的乘法运算" class="headerlink" title="举例: GF(23)上的乘法运算"></a>举例: GF(23)上的乘法运算</h3><p>选择本原元a&#x3D;x, 本原多项式$p(x)&#x3D;x^3+x+1$</p><table><thead><tr><th>$a^{-\infty}&#x3D;x^{-\infty}&#x3D;0$</th><th>000</th></tr></thead><tbody><tr><td>$a^0&#x3D;x^0&#x3D;1$</td><td>001</td></tr><tr><td>$a^1&#x3D;x$</td><td>010</td></tr><tr><td>$a^2&#x3D;x^2$</td><td>100</td></tr><tr><td>$a^3&#x3D;x+1$</td><td>011</td></tr><tr><td>$a^4&#x3D;x^2+x$</td><td>110</td></tr><tr><td>$a^5&#x3D;x^2+x+1$</td><td>111</td></tr><tr><td>$a^6&#x3D;x^2+1$</td><td>101</td></tr><tr><td>$a^7&#x3D;a^0&#x3D;1$</td><td></td></tr></tbody></table><p>乘法运算：</p><p>$$<br>(010)·(100)<br>\leftrightarrow a^3·a^4&#x3D;1<br>\leftrightarrow001\ (011)·(110)<br>\leftrightarrow a^6·a^5&#x3D;a^4<br>\leftrightarrow110<br>$$</p><p>因为本原元a&#x3D;x, 所以p(a)&#x3D;0</p><p>$$<br>a^3+a+1&#x3D;(x+1)+x+1&#x3D;0\ (011)+(010)+(001)&#x3D;(000)<br>$$</p><h3 id="GF-2-上多项式根的特点"><a href="#GF-2-上多项式根的特点" class="headerlink" title="GF(2)上多项式根的特点"></a>GF(2)上多项式根的特点</h3><p>定理：若f(x)是系数取自GF(2)的多项式, 令b是GF(2)扩域中的元素, 若b是f(x)的根, 则对任意的l≥0, $b^{2l}$也是f(x)的根。</p><blockquote><p>注：元素$b^{2l}$称为b的共轭元，以上定理说明若是b多项式f(x)的根，则b的所有共轭元$b^{2l}$也是f(x)的根。</p></blockquote><p>举例：${a^1, a^2, a^4}$是共轭的元素，因为它们都是极小多项式$f_2(x)&#x3D;x^3+x+1$的根。</p><p>最低公倍式：若f(x)为a(x)与b(x)的所有公倍式中次数最低的，并且首项系数为1，记为LCM(a(x), b(x))。</p><h2 id="BCH码的定义"><a href="#BCH码的定义" class="headerlink" title="BCH码的定义"></a>BCH码的定义</h2><p>BCH码的定义：给定任一有限域GF(q)及其扩域$GF(q^m)$, 其中, q是素数或者素数幂, m为一个正整数。若码元是取自GF(q)上的一个循环码, 它的生成多项式g(x)的根集合R中含有以下2t个连续根${b^p, b^{p+1},.., b^{p+2t-1}}$, 则由g(x)生成的循环码称为q进制的BCH码, 其中$b∈GF(q^m)$是域中的n阶元素, $b^{p+i} ∈GF(q^m) (0≤i≤2t-1)$, p是任意整数。对于常见的情况, p等于0或者1。若p&#x3D;1, 称之为狭义的BCH码。</p><p>本原BCH码的定义：若g(x)的根中有一个是$GF(q^m)$的本原元, 码长$n&#x3D;q^m-1$, 此时就称g(x)生成的BCH码为本原BCH码; 否则就称为非本原BCH码, 其码长是$q^m-1$的因子。</p><h3 id="BCH码的构造"><a href="#BCH码的构造" class="headerlink" title="BCH码的构造"></a>BCH码的构造</h3><p>构造方法：设$f_i(x)$和$q_i$分别是$b^{p+i}(0≤i≤2t-1)$的最小多项式和阶, 则BCH码的生成多项式g(x)和码长n可分别表示为$g(x)&#x3D;LCM(f_0(x), f_1(x),…, f_{2t-1}(x)), n&#x3D;LCM(q_0, q_1,…, q_{2t-1})$。</p><blockquote><p>构造可以纠t个错误的BCH码(其码长$n&#x3D;q^m-1$)的生成多项式的步骤如下：<br>步骤1：选择一个阶数为m的本原多项式, 构造扩域$GF(q^m)$;<br>步骤2：找到对应于$b^i(i&#x3D;1,…,p)$的极小多项式$f_i(x)$;<br>步骤3：能纠t个错误的BCH码的生成多项式为$g(x)&#x3D;LCM(f_1(x), f_2(x),…, f_{2t}(x))$。</p></blockquote><h3 id="BCH码限定理"><a href="#BCH码限定理" class="headerlink" title="BCH码限定理"></a>BCH码限定理</h3><p>定理1：若BCH码的生成多项式g(x)的根含有2t个连续根, 则该码的最小距离d≥2t+1。</p><p>d&#x3D;2t+1称为该码的设计距离。</p><blockquote><p>注：一旦固定n和t, 就可以得到该BCH码的生成多项式, 信息位的长度k可以由生成多项式的阶数得到。</p></blockquote><p>当n不变的情况下，较大的t，就会使得k较小；即冗余度高，可以纠更多的错误。</p><blockquote><p><strong>思考题</strong>：如何在由GF(2)生成的扩域GF(24)上构造BCH码的生成多项式？</p></blockquote><p>考虑本原多项式$p(z)&#x3D;z^4+z+1$, 本原元a&#x3D;z, a的幂次可以生成$GF(2^4)$上的所有非零元素。</p><table><thead><tr><th>a的幂次</th><th>$GF(2^4)$上的非零元素</th><th>极小多项式</th></tr></thead><tbody><tr><td>$a^1$</td><td>$z$</td><td>$x^4+x+1$</td></tr><tr><td>$a^2$</td><td>$z^2$</td><td>$x^4+x+1$</td></tr><tr><td>$a^3$</td><td>$z^3$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^4$</td><td>$z+1$</td><td>$x^4+x+1$</td></tr><tr><td>$a^5$</td><td>$z^2+z$</td><td>$x^2+x+1$</td></tr><tr><td>$a^6$</td><td>$z^3+z^2$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^7$</td><td>$z^3+z+1$</td><td>$x^4+x^3+1$</td></tr><tr><td>$a^8$</td><td>$z^2+1$</td><td>$x^4+x+1$</td></tr><tr><td>$a^9$</td><td>$z^3+z$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^{10}$</td><td>$z^2+z+1$</td><td>$x^2+x+1$</td></tr><tr><td>$a^{11}$</td><td>$z^3+z^2+z$</td><td>$x^4+x+1$</td></tr><tr><td>$a^{12}$</td><td>$z^3+z^2+z+1$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^{13}$</td><td>$z^3+z^2+1$</td><td>$x^4+x^3+1$</td></tr><tr><td>$a^{14}$</td><td>$z^3+1$</td><td>$x^4+x^3+1$</td></tr><tr><td>$a^{15}$</td><td>1</td><td>x+1</td></tr></tbody></table><p>如果想要构造可以纠1个错误的BCH码的生成多项式, 即t&#x3D;1, 码长n&#x3D;15<br>BCH码的生成多项式为$g(x)&#x3D;LCM(f_1(x), f_2(x),…, f_{2t}(x))$<br>根据上页的表格来获得极小多项式f1(x)和f2(x)<br>因此, 得到如下的可以纠正一个错误的BCH码的生成多项式$g(x)&#x3D;LCM(f_1(x), f_2(x))&#x3D; LCM(x^4+x+1, x^4+x+1)&#x3D;x^4+x+1$<br>∵deg(g(x))&#x3D;4, ∴n-k&#x3D;4, k&#x3D;11, 这样就得到了一个可以纠一个错误的BCH(15, 11)码, 该码的设计距离d&#x3D;2t+1&#x3D;3<br>可以计算出该码的最小距离也是3，即该码的设计距离等于该码的最小距离</p><p>如果想要构造可以纠2个错误的BCH码的生成多项式, 即t&#x3D;2, 码长n&#x3D;15<br>BCH码的生成多项式为$g(x)&#x3D;LCM(f_1(x), f_2(x),…, f_{2t}(x))&#x3D; LCM(f_1(x), f_2(x), f_3(x), f_4(x))$<br>根据11页的表格来获得极小多项式f1(x)-f4(x)<br>于是得到$g(x)&#x3D;LCM(f_1(x), f_2(x) , f_3(x), f_4(x))&#x3D; LCM(x^4+x+1, x^4+x+1, x^4+x^3+x^2+x+1, x^4+x +1)&#x3D;(x^4+x+1)(x^4+x^3+ x^2+x+1) &#x3D;x^8+x^7+x^6+x^4+1$<br>∵deg(g(x))&#x3D;8，∴n-k&#x3D;8，k&#x3D;7, 这样就得到了一个可以纠一个错误的BCH(15,7)码，该码的设计距离d&#x3D;2t+1&#x3D;5<br>可以计算出该码的最小距离也是5。</p><h1 id="第六章-RM码"><a href="#第六章-RM码" class="headerlink" title="第六章 RM码"></a>第六章 RM码</h1><h3 id="RM码的优点和缺点"><a href="#RM码的优点和缺点" class="headerlink" title="RM码的优点和缺点"></a>RM码的优点和缺点</h3><p><strong>缺点</strong>：与BCH码相比，除了一阶RM码和中等码长的RM码外，RM码的最小距离比同样码长的BCH码的最小距离小。RM码的纠错性能不如Turbo码和LDPC码<br><strong>优点</strong>：RM码能用大逻辑译码算法，比BCH码用的迭代算法简单。译码延时短，无错误平层现象，其误码率会随着信噪比增加无限接近于零。因此，RM码可以适应多种不同的信道，满足有实时性要求的应用环境，既可以单独使用，也可以作为内码与RS码等级联使用，从而大大提升纠错性能</p><h2 id="线性码"><a href="#线性码" class="headerlink" title="线性码"></a>线性码</h2><p><strong>定义</strong>：一个码长为n的p元码C叫做线性码，是指C是向量空间$F_p^n$的向量子空间，即C满足如下的性质：对$F_p^n$中任意元素α和β，如果$c_1$和$c_2$属于C，则$αc_1+βc_2$也属于C。<br><strong>定理</strong>：设C是参数为(n,k)的p元线性码。<br>1)若G是C的一个生成矩阵，而H是Fp上一个(n−k)行n列的矩阵。则H是C的一个校验矩阵当且仅当$rank(H)&#x3D;n−k$，并且$HG^T&#x3D;0_{n−k,k}$；<br>2) 若$G&#x3D;(I_k,P), H&#x3D;(−P^T,I_{n−k})，$则G是C的一个生成矩阵当且仅当H是C的一个校验矩阵。</p><h2 id="向量外积"><a href="#向量外积" class="headerlink" title="向量外积"></a>向量外积</h2><p><strong>定义</strong>：设$a&#x3D;(a_{n−1},a_{n−2},···,a_0),b&#x3D;(b_{n−1},b_{n−2},···,b_0)$是GF(2)上的两个n维向量，则向量$(a_{n−1}b_{n−1},a_{n−2}b_{n−2},···,a_0b_0)$称为a与b的外积，记为a×b。</p><h2 id="布尔函数"><a href="#布尔函数" class="headerlink" title="布尔函数"></a>布尔函数</h2><p><strong>定义</strong>：设m为正整数，一个m元布尔函数$f&#x3D;f(x_1,···,x_m)$是由$F_2^m$到$F_2$的映射，即m个变量$x_1,···,x_m$均取值于$F_2$，并且函数值也属于$F_2$。<br>由于$F_2^m$中向量的个数为$2^m$，而f在每个向量的取值均彼此独立地可取1或0，所以m元布尔函数共有$2^{2^m}$个。</p><blockquote><p>例子：一元布尔函数f(x)共有$2^{2^1}&#x3D;4$个，它们是：<br>1）f(0)&#x3D;f(1)&#x3D;0，即f(x)≡0；<br>2）f(0)&#x3D;f(1)&#x3D;1,即f(x)≡1；<br>3）f(0)&#x3D;0,f(1)&#x3D;1，即f(x)&#x3D;x；<br>4）f(0)&#x3D;1,f(1)&#x3D;0，即f(x)&#x3D;x+1。</p></blockquote><p><strong>定理</strong>：每个m元布尔函数$g(x_1,···,x_m)$均可唯一地表示成$g(x_1,···,x_m)&#x3D;c+c_1x_1 + ··· +c_mx_m+c_{12}x_1x_2+c_{13}x_1x_3+ ··· + c_{m-1,m}x_{m-1}x_m+c_{123}x_1x_2x_3+ ··· + c_{12···m}x_1x_2···x_m$，其中所有系数和常数都属于$F_2$。</p><p>令$v_0&#x3D;(0,0,···,0), v_1&#x3D;(1,0,···,0), v_2&#x3D;(0,1,···,0), v_3&#x3D;(1,1,···,0), ··· ,v_n-1&#x3D;(1,1,···,1), n&#x3D; 2^m，$然后便可把每个m元布尔函数$f(x_1,···, x_m)$表示成$F_2^n$中的向量(也叫 f 的真值表或向量表示)，具体为$c_f&#x3D;(f(v_0), f(v_1),···, f(v_{n-1}))∈F_2^n, n&#x3D; 2^m$<br>这时布尔函数相加和相乘分别对应于向量按分量相加和相乘。</p><h2 id="RM码"><a href="#RM码" class="headerlink" title="RM码"></a>RM码</h2><p><strong>定义</strong>：设$m≥1, n&#x3D;2^m, 0≤r≤m$。向量空间$F_2^n$的子集合<br>$RM(r,m)&#x3D;{c_f&#x3D;(f(v_0), f(v_1),···, f(v_{n-1}))∈F_2^n|f∈B_m,deg(f)≤r}$<br>叫做r阶的Reed-Muller码(简称RM码)，这里$v_i∈F_2^m$。</p><p><strong>定理</strong>：RM码RM(r,m)是线性码，基本参数为$(n,k,d)&#x3D;(2^m,∑_{t&#x3D;0}^r\begin{pmatrix}m\t\end{pmatrix}),2^{m-r})$</p><h3 id="生成矩阵-1"><a href="#生成矩阵-1" class="headerlink" title="生成矩阵"></a>生成矩阵</h3><p>对于每一对正整数r和m(m&gt;r),有一个码长为$2^m$的RM码，称为码长为$2^m$的r阶RM码。它的生成矩阵是由矩阵块$G_0,G_1,···,G_r$组成的，即$G&#x3D;\begin{pmatrix}G_0\G_1\\dots\G_r\end{pmatrix}$</p><p>G0是码长为$n&#x3D;2^m$的全“1”向量<br>G1是$m×2^m$阶矩阵，即$G_1$是由所有长度为m的二进制的列向量组成的。$G_1$的最左边一列是全“0”向量，最后一列为全“1”向量，其他各列则是从左至右依递增顺序排列的二进制m重列向量<br>$G_l$的行是由所有$G_l$的l个行向量作外积所得的向量组成，因而$G_l$是一个$\begin{pmatrix} m\l\end{pmatrix}*2^m$阶矩阵。显然在G的行是线性无关的条件下，r阶RM码的信息位为$k&#x3D;1+\begin{pmatrix} m\l\end{pmatrix}+\begin{pmatrix} m\2\end{pmatrix}+\dots+\begin{pmatrix} m\r\end{pmatrix}$。</p><h3 id="RM码的构造"><a href="#RM码的构造" class="headerlink" title="RM码的构造"></a>RM码的构造</h3><p>从RM码的定义可以看出，一个r阶RM码可以通过增广一个(r-1)阶RM码得到，而一个(r-1)阶RM码可以由删信一个r阶RM码而获得，即通过简单计算，增加一个G矩阵分量或直接删除一个G矩阵分量<br>RM码的构造简单，纠错能力强，很容易根据需要设计出不同码长的RM码</p><h2 id="译码算法"><a href="#译码算法" class="headerlink" title="译码算法"></a>译码算法</h2><p>从RM码的生成矩阵G中可以看出，Gl的每行重量为$2^{m-l}$，这个结论对于一般的r阶RM码都是对的，因此，G的每行都有偶重量<br>在GF(2)上，因为两个偶重量向量之和必为偶重量，所以G的行线性组合有偶重量。即RM码的所有码字重量皆为偶数<br>由于Gr行的重量为$2^{m-l}$，因而r阶RM码的最小重量不大于$2^{m-l}$</p><p>里德算法是专门为RM码设计的译码算法<br>里德算法使用择多逻辑判决的方法从接收矢量直接恢复信息，而不计算错误图样<br>里德算法可以纠正r阶RM码出现的$(1&#x2F;2)×2^{m-r}−1$个随机错误，并恢复k位信息。这说明码的最小重量至少为$2^{m-r}−1$，又RM码的最小重量为偶数，因而r阶RM码最小重量至少为$2^{m-r}$<br>综上所述，r阶RM码最小重量为$2^{m-r}$，即RM码最小距离为$2^{m-r}$<br>将信息向量分成r+1段，即写成$m&#x3D;(I_0,I_1,⋯,I_r)$,其中$I_i$包含$\begin{pmatrix} m\l\end{pmatrix}$个信息位，于是编程可表示为$v&#x3D;I_0G_0+I_1G_1+⋯+I_rG_r$  (1.1)<br>如果接收码字$r&#x3D;v+e&#x3D;I_0G_0+I_1G_1+⋯+I_rG_r+e$  (1.2)， 其中e为错误图样<br>通过对r阶RM码的译码计算，由接收码字r恢复了第r段信息Ir，然后计算<br>$r(1)&#x3D;r-I_rG_r&#x3D;I_0G_0+I_1G_1+⋯+I_{r-1}G_{r-1}+e$  (1.3)<br>这就把由接收码字r恢复m的问题简化成由r(1)恢复信息$m^{(1)}&#x3D;(I_0,I_1,⋯,I_{r-1})$的问题<br>继续采用同样方法就可逐步恢复所有信息，最终完成r阶RM码的译码</p><h1 id="第七章-卷积码"><a href="#第七章-卷积码" class="headerlink" title="第七章 卷积码"></a>第七章 卷积码</h1><blockquote><p><strong>卷积码与分组码的区别</strong><br>卷积码有记忆性，分组码无记忆性<br>卷积码充分利用了各组信息之间的相关性，信息序列不被分段，而是被连续处理<br>通常，卷积码的n和k比分组码的n和k要小的多<br>在同样的编码效率下，卷积码的性能优于分组码<br>在相似的纠错能力下，卷积码的实现比分组码简单<br>卷积码必须用序列逻辑电路来实现，更适用于前向纠错系统；分组码是用组合逻辑电路来实现</p></blockquote><h2 id="离散序列的非循环卷积运算"><a href="#离散序列的非循环卷积运算" class="headerlink" title="离散序列的非循环卷积运算"></a>离散序列的非循环卷积运算</h2><p>定义：设f(n)和g(n)是两个序列，则序列f和g的离散卷积运算为</p><p>$$<br>(f*g)(m)&#x3D;\sum_nf(n)g(m-n)<br>$$</p><h2 id="二元-2-1-2-卷积码的编码器"><a href="#二元-2-1-2-卷积码的编码器" class="headerlink" title="二元(2,1,2)卷积码的编码器"></a>二元(2,1,2)卷积码的编码器</h2><p>编码器主要由m&#x3D;2级移位寄存器，n&#x3D;2个模2加法器组成。所有的卷积码编码器都可以用这种类型的线性前馈移位寄存器来实现。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%206.png" alt="Untitled"></p><h3 id="冲激响应"><a href="#冲激响应" class="headerlink" title="冲激响应"></a>冲激响应</h3><blockquote><p>冲激响应：编码器的冲激响应就是通过令u&#x3D;(100…)所得到的两个输出序列。</p></blockquote><p>因为编码器有m个存储单元，所以冲激响应(生成序列)至多持续m+1个时间单元，且可以写成</p><p>$$<br>g^{(1)}&#x3D;(g^{(1)}_0,g^{(1)}_1,…,g^{(1)}_m),g^{(2)}&#x3D;(g^{(2)}_0,g^{(2)}_1,…,g^{(2)}_m)<br>$$</p><p>其中上标表示第几个输出端</p><blockquote><p>图6.1的(2,1,2)卷积码的冲激响应为$g^{(1)}&#x3D;(111), g^{(2)}&#x3D;(101)$<br>另外，冲激响应向量还可以表示输入、移位寄存器和输出之间的连接关系，1表示有连接，0表示没有连接</p></blockquote><h3 id="输出序列"><a href="#输出序列" class="headerlink" title="输出序列"></a>输出序列</h3><p>信息序列$u&#x3D;(u_1,u_2,u_3,…)$每次进入编码器1比特，编码器的两个输出序列</p><p>$$<br>v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…)<br>$$</p><p>可以通过输入序列u和编码器的两个冲激响应作卷积运算而得到。</p><blockquote><p>若u&#x3D;(1011), 图6.1的(2,1,2)卷积码的冲激响应为$g……{(1)}&#x3D;(111), g^{(2)}&#x3D;(101)$，则该卷积码的输出序列为$V^{(1)}&#x3D;u^<em>g^{(1)}&#x3D;(110001)$</em>, $V^{(2)}&#x3D;u^<em>g^{(2)}&#x3D;(100111)$</em></p></blockquote><h3 id="码字"><a href="#码字" class="headerlink" title="码字"></a>码字</h3><p>输出序列分别为$v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…)$的$(2,1,m)$的卷积码的码字，为$V^{(1)}$和$V^{(2)}$的交错，即</p><p>$$<br>v&#x3D;(v^{(1)}_0,v^{(2)}_0,v^{(1)}_1,v^{(2)}_1,…)<br>$$</p><blockquote><p>图6.1的(2,1,2)卷积码，若u&#x3D;(1011), 冲激响应为$g^{(1)}&#x3D;(111)$, $g^{(2)}&#x3D;(101)$，该卷积码的输出序列为$V^{(1)}&#x3D;u^<em>g^{(1)}&#x3D;(110001)$</em>, $V^{(2)}&#x3D;u^*g^{(2)}&#x3D;(100111)$*，得到的码字为v&#x3D;(11,10,00,01,01,11)</p></blockquote><p>以u&#x3D;(u1,u2,u3,…)为输入, 以$g^{(1)}&#x3D;(g^{(1)}_0,g^{(1)}_1,…,g^{(1)}_m),g^{(2)}&#x3D;(g^{(2)}_0,g^{(2)}_1,…,g^{(2)}_m)$</p><p>为生成序列的(2,1,m)卷积码的输出序列分别由方程$V^{(1)}&#x3D;u^*g^{(1)}$<em>和$V^{(2)}&#x3D;u^</em>g^{(2)}$*得到。</p><blockquote><p>图6.1的(2,1,2)卷积码的编码方程为<br>另外，编码方程中每一项的系数，还可以表示输入、移位寄存器和输出之间的连接关系，1表示有连接，0表示没有连接。</p><p>$$<br>\begin{cases} V_l^{(1)}&#x3D;u_l+u_{l-1}+u_{l-2}\ V_l^{(2)}&#x3D;u_l+u_{l-2} \end{cases},[V_l^{(1)}V_l^{(2)}]&#x3D;[u_lu_{l-1}u_{l-2}]\begin{bmatrix} 1&amp;1\1&amp;0\1&amp;1\end{bmatrix}<br>$$</p></blockquote><h3 id="生成矩阵-2"><a href="#生成矩阵-2" class="headerlink" title="生成矩阵"></a>生成矩阵</h3><p>(2,1, m)卷积码的生成矩阵：将生成序列g(1)和g(2)交织后形成的半无限矩阵</p><p>$$<br>G&#x3D;\begin{bmatrix}g^{(1)}_0&amp;g^{(2)}_0&amp;g^{(1)}_1&amp;g^{(2)}_1&amp;g^{(1)}_2&amp;g^{(2)}_2&amp;\dots&amp;g^{(1)}_m&amp;g^{(2)}_m&amp;0&amp;0&amp;0&amp;0&amp;\dots\ 0&amp;0&amp;g^{(1)}_0&amp;g^{(2)}_0&amp;g^{(1)}<em>1&amp;g^{(2)}<em>1&amp;\dots &amp;g^{(1)}</em>{m-1}&amp;g^{(2)}</em>{m-1}&amp;g^{(1)}<em>m&amp;g^{(2)}<em>m&amp;0&amp;0&amp;\dots \0&amp;0&amp;0&amp;0&amp;g^{(1)}<em>0&amp;g^{(2)}<em>0&amp;\dots&amp;g^{(1)}</em>{m-2}&amp;g^{(2)}</em>{m-2}&amp;g^{(1)}</em>{m-1}&amp;g^{(2)}</em>{m-1}&amp;g^{(1)}_m&amp;g^{(2)}_m&amp;\dots\ &amp;&amp;&amp;&amp;&amp;&amp;\ddots\end{bmatrix}<br>$$</p><p>以u&#x3D;(u1,u2,u3,…)为输入, G为生成矩阵的(2,1,m)的卷积码的码字为V&#x3D;uG。</p><h3 id="二元-3-2-1-卷积码的编码器"><a href="#二元-3-2-1-卷积码的编码器" class="headerlink" title="二元(3,2,1)卷积码的编码器"></a>二元(3,2,1)卷积码的编码器</h3><p>编码器主要有2个输入，3个输出，主要由m&#x3D;1级移位寄存器，n&#x3D;3个模2加法器组成。</p><h3 id="二元-3-2-m-卷积码的输入序列"><a href="#二元-3-2-m-卷积码的输入序列" class="headerlink" title="二元(3,2,m)卷积码的输入序列"></a>二元(3,2,m)卷积码的输入序列</h3><p>对于一般的(3,2,m)卷积码，由于k&#x3D;2，即每次有2比特进入编码器，所以输入序列u可以写成$v&#x3D;(v^{(1)}_0,v^{(2)}_0,v^{(1)}_1,v^{(2)}_1,…)$或分开写成2个序列$v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…)$</p><p>二元(3,2,m)卷积码的冲激响应$g^{(j)}<em>i&#x3D;(g^{(j)}</em>{i0},g^{(j)}<em>{i1},…,g^{(j)}</em>{im}),i&#x3D;1,2,j&#x3D;1,2,3$</p><p>输出序列分别为</p><p>$$<br>v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…), v^{(3)}&#x3D;(v^{(3)}_0,v^{(3)}_1,…)<br>$$</p><p>的(3,2,m)的卷积码的码字为</p><p>$$<br>v&#x3D;(v^{(1)}_0,v^{(2)}_0,v^{(3)}_0,v^{(1)}_1,v^{(2)}_1,v^{(3)}_1,…)<br>$$</p><h2 id="卷积码编码器的存储级数"><a href="#卷积码编码器的存储级数" class="headerlink" title="卷积码编码器的存储级数"></a>卷积码编码器的存储级数</h2><p>对于(n,k,m)卷积码，当k&gt;1时，编码器及用来描述它的符号都比较复杂，并且该编码器所含的k个移位寄存器的长度未必相同。</p><blockquote><p>存储级数：若ki是第i个移位寄存器的长度，则称所有k个移位寄存器中的最大长度为存储级数，即编码器的存储级数m定义为$m&#x3D;\max_{1&lt;i&lt;k}k_i$</p></blockquote><h2 id="卷积码编码器的约束长度和码速率"><a href="#卷积码编码器的约束长度和码速率" class="headerlink" title="卷积码编码器的约束长度和码速率"></a>卷积码编码器的约束长度和码速率</h2><p>对于(n, k, m)卷积码，编码器中每个信息位要保持m+1时间个单位，每个时间单位都可以影响编码器输出中的任何一个，这由移位寄存器的连接决定。</p><blockquote><p>约束长度：对于(n,k,m)卷积码，编码器的约束长度定义为$n_A&#x3D;n(m+1)$</p></blockquote><p>约束长度可以解释成1比特信息对编码器输出可以造成影响的最大数目。</p><blockquote><p>码速率：对于(n,k,m)卷积码，其码速率r&#x3D;k&#x2F;n</p></blockquote><h2 id="2-1-m-卷积码的多项式描述"><a href="#2-1-m-卷积码的多项式描述" class="headerlink" title="(2, 1, m)卷积码的多项式描述"></a>(2, 1, m)卷积码的多项式描述</h2><p>信息序列：$u$表示成$u(x)$</p><p>生成多项式：$g^{(1)}$表示成$g^{(1)}(x)$, $g^{(2)}$表示成$g^{(2)}(x)$</p><p>输出序列：$V^{(1)}$表示成$V^{(1)}(x)$, $V^{(2)}$表示成$V^{(2)}(x),$<br>码字：$V$表示成$V(x)$。于是$V^{(1)}(x)&#x3D;u(x)g^{(1)}(x), V^{(2)}(x)&#x3D;u(x)g^{(2)}(x),$<br>码字：$V(x)&#x3D;V^{(1)}(x^2)+xV^{(2)}(x^2)$</p><h2 id="n-k-m-卷积码的转移函数矩阵"><a href="#n-k-m-卷积码的转移函数矩阵" class="headerlink" title="(n, k, m)卷积码的转移函数矩阵"></a>(n, k, m)卷积码的转移函数矩阵</h2><p>于编码器是线性系统, 同任何有k个输入n个输出的线性系统一样，总共有k×n个转移函数。k×n阶转移函数矩阵为</p><p>$$<br>G(x)&#x3D;\begin{bmatrix}g_1^{(1)}&amp;g_1^{(1)}&amp;\dots&amp;g_1^{(1)}\ g_2^{(1)}&amp;g_2^{(1)}&amp;\dots&amp;g_2^{(1)}\ \dots \ g_k^{(1)}&amp;g_k^{(1)}&amp;\dots&amp;g_k^{(1)}\   \end{bmatrix}<br>$$</p><p>于是，码字$V(x)&#x3D;u(x)G(x)$, 其中, $u(x)&#x3D;(u^{(1)}(x), u^{(2)}(x),…, u^{(k)}(x)), V(x)&#x3D;(V^{(1)}(x), V^{(2)}(x),…, V^{(n)}(x))$, 并路之后, 码字变成$V(x)&#x3D;V^{(1)}(x^n)+xV^{(2)}(x^n)+…+x^{n-1}V^{(n)}(xn)$</p><h2 id="维特比-Viterbi-译码系统"><a href="#维特比-Viterbi-译码系统" class="headerlink" title="维特比(Viterbi)译码系统"></a>维特比(Viterbi)译码系统</h2><p>(n,k,m)卷积码, 如输入序列为x，输出码字为c，经过有噪声的信号传输后，得到接收序列r，然后经过Viterbi译码器，得到序列y。</p><p>对于码率为r的(n,k,m) 卷积码, 输入的信息长度为L，则输入序列为<br>$x&#x3D;(x_0^{(1)}, x_0^{(2)},…, x_0^{(k)}, x_1^{(1)}, x_1^{(2)},…, x_1^{(k)},…, x_{L+m-1}^{(1)}, x_{L+m-1}^{ (2)},…, x_{L+m-1 }^{(k)})$<br>对应输出的码字序列为<br>$c&#x3D;(c_0^{(1)}, c_0^{(2)},…, c_0^{(n)}, c_1^{(1)}, c_1^{(2)},…, c_1^{(n)},…, c_{L+m-1}^{(1)}, c_{L+m-1 }^{(2)},…, c_{L+m-1}^{ (n)})$<br>其中下标表示时间。<br>消息序列的尾部需要m个0比特使得移位寄存器的状态归0。一般的，默认移位寄存器从全零状态开始，最终还是以全零状态结束。</p><h1 id="第八章-Turbo码"><a href="#第八章-Turbo码" class="headerlink" title="第八章 Turbo码"></a>第八章 Turbo码</h1><h3 id="Turbo码的优点"><a href="#Turbo码的优点" class="headerlink" title="Turbo码的优点"></a>Turbo码的优点</h3><p>在信噪比较低的高噪声环境下性能优越（信道条件差的移动通信系统中有很大的应用潜力），而且具有很强的抗衰落、抗干扰能力。<br>Turbo码具有超乎寻常的优异的译码性能，可以纠正高速率数据传输时发生的误码。在直扩（CDMA）系统中采用Turbo码技术可以进一步提高系统的容量。<br>在短帧情况下的仿真结果表明短交织Turbo码在AWGN信道和Rayleigh衰落信道下仍具有接近信道容量的纠错能力。</p><h3 id="Turbo码的缺点"><a href="#Turbo码的缺点" class="headerlink" title="Turbo码的缺点"></a>Turbo码的缺点</h3><p>为获得较高的性能，Turbo码的编译码方式较为复杂。<br>具有较大的译码时延，这是由于block长度较大、译码需要多次迭代造成的。这样非常不利实时业务或高速数据的传输。<br>BER(比特出错概率)在10−5后会出现误码平层，这是由于Turbo码的重量分布造成的。对于某些对BER要求较高的应用就不适合，当然通过交织器的设计能够提供更大的码间最小距离，从而降低误码平层。</p><h3 id="分量码"><a href="#分量码" class="headerlink" title="分量码"></a>分量码</h3><p>卷积码的类型多样，如非递归卷积码(NRC)、非系统卷积码(NSC)、递归系统卷积码(RSC)。<br>在实际的系统中，由于RSC有突出的优点而被广泛采用。RSC码在具有良好的译码性能，且存在较高的交织增益，译码性能也会随着交织长度增加而提高。</p><h3 id="交织器"><a href="#交织器" class="headerlink" title="交织器"></a>交织器</h3><p>交织器的主要功能是使码重分布合理，降低数据序列的相关性，增大输出码字的最小汉明距，实现随机编码。</p><p><strong>分组交织器</strong>：将数据序列按行的顺序写入m×n的矩阵，然后按列的顺序读出，即完成交织过程。相应的解交织过程就是将交织后的数据序列按列写入m×n矩阵，再按照行的顺序读出。</p><p><strong>伪随机交织器</strong>：指交织映射随机生成的交织器，每个长度为N的伪随机交织器共有N！种可能的交织形式。这种交织器采用给定的随机地址交织映射，由这个已知的交织表对输入信息序列进行映射。</p><h3 id="删余处理"><a href="#删余处理" class="headerlink" title="删余处理"></a>删余处理</h3><p>在编码完成后，将分量码输出的两路校验信息输入删余器，按照一定的规则删除一部分校验信息，减小信息的冗余度，从而提高编码效率。</p><h2 id="Turbo码编码器的结构"><a href="#Turbo码编码器的结构" class="headerlink" title="Turbo码编码器的结构"></a>Turbo码编码器的结构</h2><p>三种：并行级联卷积码(PCCC)、串行级联卷积码(SCCC)和混合级联卷积码(HCCC)</p><h3 id="并行级联卷积码-PCCC"><a href="#并行级联卷积码-PCCC" class="headerlink" title="并行级联卷积码(PCCC)"></a>并行级联卷积码(PCCC)</h3><p>随机交织器：将信息序列U进行比特位置重排列得到U1（内容不变）<br>分量编码器：生成校验序列 $X_{p1}$ 和 $X_{p2}$（一般两个编码器结构相同）<br>删余矩阵：为了提高码率，周期地删除一些校验位，形成校验位序列Xp<br>复接：未编码序列Xs与Xp经过复接后，生成Turbo码序列X</p><h2 id="Turbo码的码率"><a href="#Turbo码的码率" class="headerlink" title="Turbo码的码率"></a>Turbo码的码率</h2><p>若两个分量码的码率分别为R1和R2，则Turbo码的码率为</p><p>$$<br>R&#x3D;\frac{R_1R_2}{R_1+R_2-R_1R_2}<br>$$</p><h2 id="Turbo码的译码"><a href="#Turbo码的译码" class="headerlink" title="Turbo码的译码"></a>Turbo码的译码</h2><p>Turbo码有一重要特点是其译码较为复杂，比常规的卷积码要复杂的多。<br>这种复杂不仅在于其译码要采用迭代的过程，而且采用的算法本身也比较复杂。</p><h3 id="译码算法-1"><a href="#译码算法-1" class="headerlink" title="译码算法"></a>译码算法</h3><p><strong>MAP算法</strong>：MAP算法采用递推、迭代方法，将最大似然对数比函数作为软判决的输出。但由于该算法需要多次迭代，复杂度较高，运算量非常大，而且对数和指数的运算在数字电路中比较难以实现，导致其在工程实现上受到了很大程度的限制。<br><strong>Max-log-MAP算法</strong>：即最大值运算，在MAP算法基础上通过减少格图搜索状态来达到简化的目的。Max-log-MAP对MAP所做的修改是在对数域里对一些函数进行计算，这样省去了很多的指数的运算和对数域的运算，很大程度上降低了运算的复杂度，大大简化了运算量；但是由于在计算过程有一些近似处理，所以Max-log-MAP算法不是最优的。<br><strong>Log-MAP算法</strong>：即对数域算法，Robertson等人在Max-log-MAP算法基础上进行了一些修改，使得Log-MAP算法相比于Max-log-MAP算法只多了一些查表及加法运算，尽管提高了一点复杂度但是性能却得到很大的提高。<br><strong>SOVA算法</strong>：即软输出Viterbi译码，SOVA算法在标准Viterbi译码算法上进行了一些修改：在进行最大似然路径选择时必须参考其先验信息；不但需要给出每个比特译码的准确结果，还需要计算出每个比特译码的可靠性，通过一些计算从中获取一些关于译码比特的先验信息，从而为下次迭代做好准备，大大减小了运算量，但性能受到了损失，大约损失了1dB。</p><h1 id="第九章-二维码"><a href="#第九章-二维码" class="headerlink" title="第九章 二维码"></a>第九章 二维码</h1><h2 id="二维码的概念与原理"><a href="#二维码的概念与原理" class="headerlink" title="二维码的概念与原理"></a>二维码的概念与原理</h2><p>行排式二维码，又称堆积式二维码或层排式二维码，其编码原理是建立在一维条码基础之上，按需要堆积成二行或多行。</p><p>矩阵式二维码，又称棋盘式二维码，它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码。</p><h2 id="二维码的特点"><a href="#二维码的特点" class="headerlink" title="二维码的特点"></a>二维码的特点</h2><p><strong>可靠性强</strong><br>条形码的读取准确率远远超过人工记录，平均每15000个字符才会出现一个错误。<br><strong>效率高</strong><br>条形码的读取速度很快，相当于每秒40个字符。<br><strong>易于制作</strong><br>条形码的编写很简单，制作也仅仅需要印刷，被称为“可印刷的计算机语言”。<br><strong>高密度</strong><br>二维码通过利用垂直方向的堆积来提高条码的信息密度，而且采用高密度图形表示。<br><strong>构造简单</strong><br>条形码识别设备的构造简单，使用方便。<br><strong>灵活实用</strong><br>条形码符号可以手工键盘输入，也可以和有关设备组成识别系统实现自动化识别，还可以和其他控制设备联系起来实现整个系统的自动化管理。<br><strong>成本低</strong><br>与其它自动化识别技术相比较，条形码技术仅仅需要一小张贴纸和相对构造简单的光学扫描仪，成本相当低廉。<br><strong>纠错功能</strong><br>二维码不仅能防止错误，而且能纠正错误，即使条形码部分损坏，也能将正确的信息还原出来。<br><strong>多语言形式，可表示图像</strong><br>二维码具有字节表示模式，即提供了一种表示字节流的机制。不论何种语言文字它们在计算机中存储时以机内码的形式表现，而内部码都是字节码，可识别多种语言文字的条码。<br><strong>具有加密体制</strong><br>可以先用一定的加密算法将信息加密，再用二维码表示在识别二维条码时，再加以一定的解密算法，便可以恢复所表示的信息。</p><h2 id="QR码的生成与识别"><a href="#QR码的生成与识别" class="headerlink" title="QR码的生成与识别"></a>QR码的生成与识别</h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%207.png" alt="Untitled"></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%208.png" alt="Untitled"></p><p><strong>寻像图形、位置探测图形：</strong><br>协助扫描软件定位QR码并转换坐标系。<br>寻像图形包括三个相同的位置探测图形，分别位于图形中的左上角、右上角和左下角。每个位置探测图形由7*7个模块组成。如图，寻像图形为黑色区域。</p><p><strong>位置探测图形分隔符：</strong><br>区分功能图形和编码区域。<br>每个位置探测图形和编码区域之间有宽度为1个模块的分隔符。位置探测图形分隔符为灰色区域，此区域应为空白。</p><p><strong>定位图形：</strong><br>确定符号的密度和版本，提供决定模块坐标的基准位置。<br>定位图形为图中的茶色区域，水平和垂直的定位图形分别始于第6行和第6列。</p><p><strong>校正图形：</strong><br>在图像有一定程度损坏的情况下，译码软件可以通过它同步图像模块的坐标映像。<br>矫正图形的数量视符号和版本号而定，版本1没有校正图形，版本2及以上均含有校正图形。</p><p><strong>格式信息：</strong><br>存放纠错等级和掩模信息。<br>格式信息是一个15位数据，由2位纠错指示符+3位掩模图形参考+10位纠错码组成，为图中深蓝色区域。</p><p>同时，左下角格式信息编号8上方的橙色区域，此区域永远为深色模块，不用于存放任何信息。</p><p><strong>版本信息：</strong><br>用于存放QR码的版本号。<br>为图中红色区域，两个3*6模块。</p><p><strong>扩展图形：</strong><br>最初的目的是用于将来对QR码功能的扩展，并不用于对数据的编码。<br>扩展图形由位于符号右下角的一个4个模块组成的方块以及位于符号右边和下边的一些8个模块的块组成。8个模块的块的数目取决于符号的版本，计算公式为：<br>8模块的数目&#x3D;2*(N DIV 2)<br>其中N为版本号，DIV表示除法运算。<br>扩展图形为图中红框区域，即版本7中有6个8模块组成的块和1个4模块组成的块。</p><h3 id="QR码的纠错能力："><a href="#QR码的纠错能力：" class="headerlink" title="QR码的纠错能力："></a><strong>QR码的纠错能力：</strong></h3><table><thead><tr><th>级别</th><th>纠错能力</th></tr></thead><tbody><tr><td>L</td><td>约7%</td></tr><tr><td>M</td><td>约15%</td></tr><tr><td>Q</td><td>约25%</td></tr><tr><td>H</td><td>约30%</td></tr></tbody></table><h2 id="举例说明QR码的编码过程。"><a href="#举例说明QR码的编码过程。" class="headerlink" title="举例说明QR码的编码过程。"></a>举例说明QR码的编码过程。</h2><h2 id="识别步骤"><a href="#识别步骤" class="headerlink" title="识别步骤"></a>识别步骤</h2><p>条码定位<br>条码分割<br>解码</p><h3 id="条码定位"><a href="#条码定位" class="headerlink" title="条码定位"></a>条码定位</h3><p>定位采用以下步骤：<br>1.利用点运算的阈值理论将采集到的图像变为二值图像，即对图像进行二值化处理；<br>2.得到二值化图像后，对其进行膨胀运算；<br>3.对膨胀后的图像进行边缘检测得到条码区域的轮廓。<br>4.确定寻像图形<br>5.探测图形中心坐标<br>6.确定两个举例<br>7.确定版本号<br>8.构造位图<br>9.得到纠错等级和掩模图形</p><h3 id="条码分割"><a href="#条码分割" class="headerlink" title="条码分割"></a>条码分割</h3><p>分割采用以下步骤：<br>1.将原图像按比例缩小进行分割，计算其特征值；<br>2.分块继承父块纹理类别，结合其周围纹理类型进行修正；<br>3.重复步骤二直至图像被划分为2*2大小，分割结束；<br>4.分割结束后，图中可能出现的孤立的小区域可作为噪声删除。</p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><pre><code>得到一幅标准的条码图像后，对该符号进行网络取样，对网格每一个交点上的图像像素取样，并根据阈值确定是深色块还是浅色块。构造一个位图，用二进制的“1”表示深色像素，“0”表示浅色像素，从而得到条码的原始二进制序列值，然后对这些数据进行纠错和译码：1.异或处理（XOR）2.确定符号码字3.重新排列码字序列4.执行错误检测和纠错译码程序最后根据条码的逻辑编码规则把这些原始的数据位流转换成数据码字。</code></pre><h1 id="第十章-极化码"><a href="#第十章-极化码" class="headerlink" title="第十章 极化码"></a>第十章 极化码</h1><h2 id="极化码概述与研究现状"><a href="#极化码概述与研究现状" class="headerlink" title="极化码概述与研究现状"></a>极化码概述与研究现状</h2><p>极化码优点：<br>1、是目前唯一的香农信道容量可达的编码方式<br>2、有坚实的理论基础<br>3、编解码复杂度低<br>4、精细的码率调整机制（信息块长度可以一比特一比特的递减）<br>5、极化码的递归特性易于通过硬件实现（母码长度为N的Polar码可以用两个母码长度为N&#x2F;2的Polar码实现）</p><p>极化码缺点：<br>1、汉明距离较小，在短码情况下影响解码性能，一定程度上可以通过选择合适的冻结比特位置进行规避。适合长码编码。<br>2、SC译码延时较大。</p><h3 id="极化（Polar）码起源"><a href="#极化（Polar）码起源" class="headerlink" title="极化（Polar）码起源"></a>极化（Polar）码起源</h3><blockquote><p>截止频率越高，系统响应越快<br>因此Polar码的最初设计的出发点是为了提升截止频率</p></blockquote><p>在随机编码和最大似然条件下，信道截止速率R0决定了相应的码块的错误概率：</p><p>$$<br>P_e&#x3D;2^{−N∙R_0}<br>$$</p><p>其中，N为码块长度。实际信道的传输速率R小于R_0、使用随机编码和ML编码时，信道平均错误概率：</p><p>$$<br>P _e&#x3D;2^{−N（R_0−R）}<br>$$</p><h3 id="极化码的基本原理"><a href="#极化码的基本原理" class="headerlink" title="极化码的基本原理"></a>极化码的基本原理</h3><p>对于Polar码基本原理可以归结为三点：信道合并、信道分离、信道极化。其中信道合并和信道极化是在编码时完成的；信道分离是在解码时完成。</p><p><strong>信道选择：</strong><br>对于编码方案通常根据某种信道设计，Polar码主要考虑以下信道进行分析：</p><p>二进制离散无记忆信道（B-DMC）:二进制删除信道（BEC）;二进制对称信道（BSC）</p>]]></content>
    
    
    <summary type="html">信息论与编码的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://zhangyuanhe.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析课程笔记</title>
    <link href="https://zhangyuanhe.top/2024/01/09/BUPT_note/Notes%20on%20Algorithm%20Design%20and%20Analysis/"/>
    <id>https://zhangyuanhe.top/2024/01/09/BUPT_note/Notes%20on%20Algorithm%20Design%20and%20Analysis/</id>
    <published>2024-01-09T13:00:00.000Z</published>
    <updated>2024-01-17T12:58:35.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法设计与分析-王东滨"><a href="#算法设计与分析-王东滨" class="headerlink" title="算法设计与分析 王东滨"></a>算法设计与分析 王东滨</h1><h1 id="第一章-算法概述"><a href="#第一章-算法概述" class="headerlink" title="第一章 算法概述"></a>第一章 算法概述</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>能够对一定规范的输入，在有限时间内活的所要求的输出。</p><p>不同的算法可能用不同的时间、空间或效率解决问题。</p><p>算法是有穷的指令序列：</p><ul><li>输入：有零或若干个外部提供的量作为算法的输入</li><li>输出：算法产生至少一个量作为输出</li><li>确定性：组成算法的每条指令是清晰，无歧义的</li><li>有穷性：算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的</li></ul><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>程序是算法用某种程序设计语言的具体实现</p><p>程序可能不满足算法的性质。</p><p>操作系统是在一个无限循环中执行的程序，因而不是一个算法</p><h2 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h2><p>理解问题→精确解或近似解选择数据结构算法设计策略→设计算法→证明正确性→分析算法→设计程序</p><h2 id="算法复杂性"><a href="#算法复杂性" class="headerlink" title="算法复杂性"></a>算法复杂性</h2><p><strong><strong>算法复杂性 &#x3D; 算法所需要的计算机资源</strong></strong></p><p>算法时间复杂性T(n)</p><p>算法空间复杂性S(n)</p><p><strong>其中<em>n</em>是问题的规模（输入大小）</strong></p><p>C&#x3D;F(N,I,A)</p><p>C：算法复杂性</p><p>N：解的问题的规模</p><p>I：算法的输入</p><p>A：算法本身</p><p>*F( N，I，A )*：由参数确定的三元函数</p><p>***<em>时间复杂性 <em>T&#x3D; T ( N，I，A ) ；</em>空间复杂性 <em>S&#x3D; S ( N，I，A )</em></em>*</p><p>通常A隐含在复杂性函数名当中，简写为：</p><p><strong>T&#x3D; T ( N，I) ；S&#x3D;S ( N，I)</strong></p><h2 id="算法的时间复杂性"><a href="#算法的时间复杂性" class="headerlink" title="算法的时间复杂性"></a><strong><strong>算法的时间复杂性</strong></strong></h2><p>1）<strong>最坏情况</strong>下的时间复杂性</p><p>$$<br>T_{\max}(n)&#x3D;\max {T(I)|\mathrm{size}(I)＝n}<br>$$</p><p>2）<strong>最好情况</strong>下的时间复杂性</p><p>$$<br>T_{\min}(n)&#x3D;\min {T(I)|\mathrm{size}(I)＝n}<br>$$</p><p>3）<strong>平均情况</strong>下的时间复杂性</p><p>$$<br>T_{\min}(n)&#x3D;\sum_\mathrm{size(I)&#x3D;n} p(I)T(I)<br>$$</p><p>其中I是问题的规模为<em>n</em>的实例，<em>p</em>(I)是实 例I出现的概率算法渐进复杂性</p><h2 id="算法渐近复杂性"><a href="#算法渐近复杂性" class="headerlink" title="算法渐近复杂性"></a><strong><strong>算法渐近复杂性</strong></strong></h2><p>$$<br>T(n)\rightarrow \infty \<br>$$</p><p>$$<br>(T(n)-t(n))&#x2F;T(n)\rightarrow 0 , \mathrm{as}\ n \rightarrow \infty<br>$$</p><p><em>t</em>(<em>n</em>)是<em>T</em>(<em>n</em>)的渐近性态，为算法的渐近复杂性。在数学上，<em>t</em>(<em>n</em>)是<em>T</em>(<em>n</em>)的渐近表达式，是<em>T</em>(<em>n</em>)略去低阶项留下的主项</p><p>$$<br>\mathrm{as}\ n \rightarrow \infty<br>$$</p><p> <em>t</em>(<em>n</em>)渐进于<em>T</em>(<em>n</em>)， <em>t</em>(<em>n</em>)替代<em>T</em>(<em>n</em>)作为算法的复杂性度量</p><h2 id="渐近分析的记号"><a href="#渐近分析的记号" class="headerlink" title="渐近分析的记号"></a><strong><strong>渐近分析的记号</strong></strong></h2><h3 id="渐进上界记号O"><a href="#渐进上界记号O" class="headerlink" title="渐进上界记号O"></a><em><strong><em>渐进上界记号</em>O</strong></em></h3><p><em>f</em>(<em>n</em>) &#x3D; <em>O</em>(<em>g</em>(<em>n</em>))</p><dl><dt>$$<br>{存在正常数c和n_0,使得对所有n\ge n_0有</dt><dd>0 \le cg(n) \le f(n) }<br>$$</dd></dl><h3 id="渐进下界记号Ω"><a href="#渐进下界记号Ω" class="headerlink" title="渐进下界记号Ω"></a><strong><strong>渐进下界记号Ω</strong></strong></h3><p><strong><em>f</em>(<em>n</em>) &#x3D;Ω(<em>g</em>(<em>n</em>))</strong></p><dl><dt>$$<br>{存在正常数c和n_0,使得对所有n\ge n_0有</dt><dd>0 \le f(n) \le cg(n) }<br>$$</dd></dl><h3 id="非紧上界记号o"><a href="#非紧上界记号o" class="headerlink" title="非紧上界记号o"></a><em><strong><em>非紧上界记号</em>o</strong></em></h3><p><em>f</em>(<em>n</em>) &#x3D; o(<em>g</em>(<em>n</em>))</p><p>$$<br>{<br>对于任何正常数c&gt;0，存在正数和n_0 \ge 0<br>使得对所有n \ge n_0有: 0 \le cg(n) &lt; f(n) }\</p><p>等价于  \frac{f(n)}{g(n)} \rightarrow c\ ,\ as \ n \rightarrow \infty<br>$$</p><h3 id="非紧下界记号ω"><a href="#非紧下界记号ω" class="headerlink" title="非紧下界记号ω"></a><strong><strong>非紧下界记号ω</strong></strong></h3><p><em>f</em>(<em>n</em>) &#x3D; <strong><strong>ω</strong></strong>(<em>g</em>(<em>n</em>))</p><p>$$<br>{对于任何正常数c&gt;0，存在正数和n_0 \ge 0使得对所有n \ge n_0有: 0 \le f(n) &lt; bcg(n) }<br>\<br>等价于\frac{f(n)}{g(n)} \rightarrow c\ ,\ as \ n \rightarrow \infty<br>$$</p><p>$$<br>f(n) \in \omega(g(n))\Leftrightarrow g(n) \in o(f(n))<br>$$</p><p><strong><strong>紧渐近界记号Θ</strong></strong></p><p><em><strong>f(n) &#x3D;* Θ *(g(n))</strong></em></p><p><em><em>当且仅当</em>f*(<em>n</em>) &#x3D; <em>O</em>(<em>g</em>(<em>n</em>))且*f</em>(<em>n</em>) &#x3D;ω(<em>g</em>(<em>n</em>)) ， <em>f(n) 与g(n)<em>同阶</em></em></p><p>$$<br>{存在正常数c_1,c_2和n_0使得对所有n \ge n_0有：c_1g(n) \le f(n)<br>\le c2g(n) }<br>$$</p><h3 id="定理1："><a href="#定理1：" class="headerlink" title="定理1："></a>定理1：</h3><p>$$<br>\Theta(g(n)) &#x3D; O(g(n)) \cap \omega(g(n))<br>$$</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>$$<br>算法复杂度定义、 O(g(n))、 \omega(g(n))<br>$$</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>$$<br>O(f(n))+O(g(n)) &#x3D; O(max{f(n),g(n)}) \<br>O(f(n))+O(g(n)) &#x3D; O(f(n)+g(n)) \<br>O(f(n))*O(g(n)) &#x3D; O(f(n)*g(n))<br>$$</p><h1 id="第二章-递归与分治策略"><a href="#第二章-递归与分治策略" class="headerlink" title="第二章 递归与分治策略"></a>第二章 递归与分治策略</h1><blockquote><p>分治法的设计思想是，将一个难以直接解决的大问题， 分割成一些规模较小的相同问题，以便各个击破，分而治之。</p></blockquote><h2 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h2><p>直接或间接地调用自身的算法称为<strong>递归算法</strong>。 </p><p>用函数自身给出定义的函数称为<strong>递归函数</strong>。</p><p>例1 阶乘函数</p><p>阶乘函数</p><p>$$<br>n!&#x3D;\begin{cases}1 &amp;&amp; n&#x3D;0\ n(n-1)!&amp;&amp; n&gt;0\end{cases}<br>$$</p><p>边界条件与递归方程是递归函数的二个要素，递归函 数只有具备了这两个要素，才能在有限次计算后得出 结果。</p><p>例2 Fibonacci数列</p><p>无穷数列1,1,2,3,5, 8 , 13 , 21 , 34 , 55 , … … , 称 为Fibonacci数列。它可以递归地定义为：</p><p>$$<br>F(n)&#x3D;\begin{cases}1 &amp;&amp; n&#x3D;0\ 1&amp;&amp; n&#x3D;1\ F(n-1)+F(n-2)&amp;&amp; n&gt;1\end{cases}<br>$$</p><p>前面例中的函数都可以找到相应的非递归方式定义：</p><p>$$<br>n!&#x3D;1 ·2 · 3 … …(n- 1) ·n\ F(n)&#x3D;\frac{1}{\sqrt{5}}((\frac{1+\sqrt{5}}{2})^{n+1}-\frac{1-\sqrt{5}}{2})^{n+1})<br>$$</p><p>例3 Ackerman函数</p><p>当一个函数及它的一个变量是由函数自身定义时，称这个函数是双递归函数。Ackerman 函数A(n,m) 定义如下：</p><p>$$<br>A(1,0)&#x3D;2\ A(0,m)&#x3D;1 \qquad m\ge 0\ A(n,0)&#x3D;n+2 \qquad n\ge 2\ A(n,m)&#x3D;A(A(n-1,m),m-1)\qquad  n,m\ge 1<br>$$</p><p>A(n,m) 的自变量m 的每一个值都定义了一个单变量函数：<br>■ M&#x3D;0 时， A(n,0)&#x3D;n+2<br>■ M&#x3D;1 时 ，A(n,1)&#x3D;A(A(n-1,1),0)&#x3D;A(n-1,1)+2, 和A(1,1)&#x3D;2故 A(n,1)&#x3D;2*n<br>■ M&#x3D;2 时， A(n,2)&#x3D;A(A(n-1,2),1)&#x3D;2A(n-1,2), 和A(1,2)&#x3D;A(A(0,2),1)&#x3D;A(1,1)&#x3D;2, 故A(n,2)&#x3D; 2^n。</p><p>■ M&#x3D;3 时，类似的可以推出</p><p>$$<br>2^{2^{2^{ \dots^{2} }}}<br>$$</p><p>■ M&#x3D;4 时， A(n,4)的增长速度非常快，以至于没有适当的数学式 子来表示这一函数。</p><p><strong>本例中的Ackerman 函数却无法找到非递归的定义。</strong></p><p>例4 排列问题</p><p>设计一个递归算法生成n个元素{r,r₂ ,…,r}的全排列。<br>设R&#x3D;{r₁ ,r₂…,rn}是要进行排列的n个元素， Ri&#x3D;R- {ri}。 集合X中元素的全排列记为perm(X)。<br>(r)perm(X) 表示在全排列perm(X) 的每一个排列前加上前 缀得到的排列。 R 的全排列可归纳定义如下：</p><p>当n&#x3D;1 时， perm(R)&#x3D;(r), 其 中r是集合R 中唯一的元素；<br>当n&gt;1 时， perm(R) 由(r₁)perm(R₁),(r₂)perm(R₂),., (rn)perm(Rn)构成。</p><p>例5 整数划分问题</p><p>将正整数n表示成一系列正整数之和： n&#x3D;n₁+n₂+…+nk, 其中n₁ ≥n₂ ≥… ≥nx≥1,k≥1。<br>正整数n的这种表示称为正整数n的划分。求正整数n的不 同划分个数。</p><blockquote><p>例如正整数6有如下11种不同的划分：<br>6;<br>5+1;<br>4+2,4+1+1;<br>3+3,3+2+1,3+1+1+1;<br>2+2+2,2+2+1+1,2+1+1+1+1;<br>1+1+1+1+1+1。</p></blockquote><p>在本例中，如果设p(n)为正整数n的划分数，则难以找到递归关 系，因此考虑增加一个自变量：将最大加数n 不大于m 的划分 个数记作q(n,m)。 可以建立q(n,m)的如下递归关系。<br>q(n,n)&#x3D;1+q(n,n- 1);<br>正整数n的划分由n₁&#x3D;n 的划分和n≤n-1 的划分组成。</p><p>q(n,m)&#x3D;q(n,m- 1)+q(n-m,m),n&gt;m&gt;1;<br>正整数n的最大加数n,不大于m 的划分由n₁&#x3D;m 的划分和 n₁ ≤m-1 的划分组成。</p><p>$$<br>q(n,m)&#x3D;\begin{cases}1&amp;&amp; n&#x3D;1,m&#x3D;1 \q(n,n) &amp;&amp; n&lt;m\ 1+q(n,n-1)&amp;&amp; n&#x3D;m\ q(n,m-1)+q(n-m,m)&amp;&amp; n&gt;m&gt;1\end{cases}<br>$$</p><p>例6 Hanoi塔问题</p><p>设a,b,c是3个塔座。开始时，在塔座a上有一叠共n个圆盘，,这 些圆盘自下而上、由大到小地叠在一起。各圆盘从小到大编号 为1,2 n, 现要求将塔座a上的这一叠圆盘移到塔座b 上，并仍按同样顺序叠置。在移动圆盘时应遵守以下移动规则：</p><p>规则1:每次只能移动1个圆盘；</p><p>规则2:任何时刻都不允许将较大的圆盘压在较小的圆盘之上；</p><p>规则3:在满足移动规则1和2的前提下，可将圆盘移至a,b,c中 任一塔座上。</p><h2 id="递归小结"><a href="#递归小结" class="headerlink" title="递归小结"></a>递归小结</h2><p><strong>优点：</strong> 结构清晰，可读性强，而且容易用 数学归纳法来证明算法的正确性，因此它 为设计算法、调试程序带来很天方便。<br><strong>缺点：</strong> 递归算法的运行效率较低，无论是 耗费的讦算时间还是占用的存储空间都比非递归算法要多。</p><p><strong>解决方法</strong>：在递归算法中消除递归调用，使其转化为非递归算法。<br>1 、 采用一个用户定义的栈来模拟系统的递归调用工作栈。该方法通用性强，但本质上还是递归，只不过人工做了本来由编译器做的事情， 优化效果不明显。<br>2、 用递推来实现递归函数。<br>3 、通过变换能将一些递归转化为尾递归，从而迭代求出结果。<br>后两种方法在时空复杂度上均有较大改善， 但其适用范围有限。</p><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><h3 id="分治法的适用条件"><a href="#分治法的适用条件" class="headerlink" title="分治法的适用条件"></a>分治法的适用条件</h3><p>分治法所能解决的问题一般具有以下几个特征：<br>1)该问题的规模缩小到一定的程度就可以容易地解决；<br>2)该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质<br>3)利用该问题分解出的子问题的解可以合并为该问题的解；<br>4)该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p><blockquote><p>人们从大量实践中发现，在用分治法设计算法时， 最好使子问题的规模大致相同。即将一个问题分成 大小相等的k个子问题的处理方法是行之有效的。<br>这种使子问题规模大致相等的做法是出自一种平衡 (balancing) 子问题的思想，它几乎总是比子问题 规模不等的做法要好。</p></blockquote><p>一个分治法将规模为n的问题分成k个规模为n&#x2F;m 的子问题去 解。设分解阀值n0&#x3D;1, 且adhoc 解规模为1的问题耗费1个单位 时间。再设将原问题分解为k个子问题以及用merge 将k个子问 题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分 治法解规模为|P|&#x3D;n的问题所需的计算时间，则有：</p><p>$$<br>T(n)&#x3D;\begin{cases})(1)&amp;&amp; n&#x3D;1\ kT(n&#x2F;m)+f(n)&amp;&amp; n&gt;1\end{cases}<br>$$</p><p>通过迭代法求得方程的解：</p><p>$$<br>T(n)&#x3D;n^{log_m k}+\sum_{j&#x3D;0}^{log_m n-1}k^jf(n&#x2F;m^j)<br>$$</p><h3 id="二分搜索技术"><a href="#二分搜索技术" class="headerlink" title="二分搜索技术"></a>二分搜索技术</h3><p>给定已按升序排好序的n个元素a[0:n-1], 现要在这n个元素中找 出一特定元素x。</p><blockquote><p>分析：很显然此问题分解出的子问题相互独立，即在a[i]的前 面或后面查找x是独立的子问题，因此满足分治法的适用条件。</p></blockquote><p>据此容易设计出二分搜索算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>  Type&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(Type a[], <span class="type">const</span> Type&amp; x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"><span class="title">while</span>  <span class="params">(r&gt;=  I)</span></span>&#123;</span><br><span class="line"><span class="type">int</span>  m  =(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x == a[m]) </span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line"><span class="keyword">if</span>  (x&lt;a[m])  </span><br><span class="line">r  =  m- <span class="number">1</span>;</span><br><span class="line">  elsel=m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>算法复杂度分析：<br>每执行一次算法的while循环， 待搜索数组的大小减少一半。因此，在最坏情况下， while循环被执行了 O(logn)次。循环体内运算需要O(1)时间，因此整个算法在最坏情况下 的计算时间复杂性为O(logn)。</p></blockquote><h3 id="大整数的乘法"><a href="#大整数的乘法" class="headerlink" title="大整数的乘法"></a>大整数的乘法</h3><p>请设计一个有效的算法，可以进行两个n 位大整数的乘法运算</p><p>直接计算： O(n²)</p><p>$$<br>T(n)&#x3D;\begin{cases}O(1)&amp;n&#x3D;1\ 4T(n&#x2F;2)+O(n)&amp;n&gt;1 \end{cases}\T(n)&#x3D;O(n^2)\ \  \ X&#x3D;a2^{n&#x2F;2}+b \ \ \ \ \ Y&#x3D;c2^{n&#x2F;2}+d\ XY&#x3D;ac2^n+(ad+bc)2^{n&#x2F;2}+bd<br>$$</p><blockquote><p>复杂度分析</p><p>$$<br>T(n)&#x3D;\begin{cases}O(1)&amp;n&#x3D;1\ 3T(n&#x2F;2)+O(n)&amp;n&gt;1 \end{cases}\T(n)&#x3D;O(n^{\log3})&#x3D;O(n^{1.59})<br>$$</p></blockquote><h3 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h3><p>传统方法： O(n³)</p><p>A 和B 的乘积矩阵C 中的元素C[i,j]定义为：</p><p>$$<br>c[i][j]&#x3D;\sum^n_{k&#x3D;1}A[i][k]B[k][j]<br>$$</p><blockquote><p>若依此定义来计算A 和B的乘积矩阵C, 则每计算C的一个元素C[i][j], 需要做n次乘法和n-1次加法。因此，算出矩阵C 的个元素所需的计算时间为O(n3)</p></blockquote><p>假设矩阵A</p><p>和矩阵B都是$N*N(N&#x3D;2^n)$的方矩阵，求C&#x3D;AB，如下所示：</p><p>$C_{11}&#x3D;A_{11}B_{11}+A_{12}B_{21}\<br>C_{12}&#x3D;A_{11}B_{12}+A_{12}B_{22}\<br>C_{21}&#x3D;A_{21}B_{11}+A_{22}B_{21}\<br>C_{22}&#x3D;A_{21}B_{12}+A_{22}B_{22}\$</p><p>$$<br>T(n)&#x3D;\begin{cases}O(1)&amp;n&#x3D;2\ 8T(n&#x2F;2)+O(n^2)&amp;n&gt;2 \end{cases}\T(n)&#x3D;O(n^{3})<br>$$</p><p>使用递归算法：</p><p>$$<br>P_1 &#x3D;A_{11} · B_{12} - A_{11} · B_{22}\<br>P_2 &#x3D;A_{11}·B_{22} + A_{12}·B_{22}\<br>P_3 &#x3D;A_{21} · B_{11} + A_{22}· B_{11}\<br>P_4 &#x3D;A_{22} · B_{21} - A_{22} · B_{11}\<br>P_5 &#x3D; A_{11} · B_{11} + A_{11} · B_{22} + A_{22} · B_{11} + A_{22} · B_{22}\<br>P_6 &#x3D; A_{12} · B_{21} + A_{12}· B_{22 }- A_{22} · B_{21} - A_{22} · B_{22}\<br>P_7 &#x3D; A_{11}·B_{11} + A_{11} · B_{12 }- A_{21}·B_{11} - A_{21} · B_{12}<br>$$</p><p>$$<br>C_{11} &#x3D; P_5 + P_4 – P_2 + P_6\<br>C_{12}&#x3D;P_1+P_2\<br>C_{21}&#x3D;P_3 + P_4\<br>C_{22} &#x3D; P_5 + P_1 - P_3 -P_7<br>$$</p><blockquote><p>复杂度分析</p><p>$$<br>T(n)&#x3D;\begin{cases}O(1)&amp;n&#x3D;2\ 7T(n&#x2F;2)+O(n^2)&amp;n&gt;2 \end{cases}\T(n)&#x3D;O(n^{\log7})&#x3D;O(n^{2.81})<br>$$</p></blockquote><h3 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h3><blockquote><p>在一个2k×2k个方格组成的棋盘中，恰有一个方格与其它方格不 同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋 盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的 特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不 得重叠覆盖。</p></blockquote><p>当k&gt;0 时，将2k×2k棋盘分割为4个2k1×2k-1 子棋盘(a)所示。<br>特殊方格必位于4个较小子棋盘之一中，其余3个子棋盘中无特 殊方格。为了将这3个无特殊方格的子棋盘转化为特殊棋盘，可 以用一个L型骨牌覆盖这3个较小棋盘的会合处，如 (b)所示，从 而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这 种分割，直至棋盘简化为棋盘1×1。</p><h3 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h3><blockquote><p>基本思想： 将待排序元素分成大小大致相同的2个子集合，分 别对2个子集合进行排序，最终将排好序的子集合合并成为所 要求的排好序的集合。</p></blockquote><p>最坏时间复杂度： O(nlogn)<br>平均时间复杂度： O(nlogn)<br>辅助空间： O(n)</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>对输入的子数组a[p:r],按以下三个步骤进行排序：<br>1 ) 分 解 (divide): 以a[p]为基准元素将a[p:r]划分为3段a[p:q-1],a[q],a[q+1:r],其 中a[p:q-1]中任何一个元素 小于等于a[q];a[q+1:r]中任何一个元素大于等于a[q]<br> 2)递归求解：通过递归调用快速排序算法，分别对a[p:q-1]和a[q+1:r]进行排序<br>3)合并：由于a[p:q-1]和a[q+1:r]的排序是就地进行的，因此在a[p:q-1]和a[q+1:r]都已排好序了，不需执行任 何计算， a[p:r]则已排好序了。</p><p><img src="/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%20%E7%8E%8B%E4%B8%9C%E6%BB%A8%2080393194011f4696b44921b77e96b51b/Untitled.png" alt="Untitled"></p><blockquote><p>最坏情况：发生在划分过程产生的两个区域分别包含 n-1个元素和1个元素的时候。<br>最 坏 时 间 复 杂 度 ： O ( n²)<br>最好情况：每次划分所取的基准都恰好为中值。<br>最 好 时 间 复 杂 度 ： O ( n l o g n )</p></blockquote><h2 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h2><p>给定线性序集中n个元素和一个整数k,1≤k≤n,要求找出这n个 元素中第k 小的元素</p><blockquote><p>在最坏情况下，算法randomizedSelect需要$O(n^2)$计算时间 但可以证明，算法randomizedSelect可以在O(n)平均时间内 找出n个输入元素中的第k小元素。</p></blockquote><p>●将n个输入元素划分成[n&#x2F;57个组，每组5个元素，只可能 有一个组不是5个元素。用任意一种排序算法，将每组中的 元素排好序，并取出每组的中位数，共[n&#x2F;5个 。<br>●递归调用select 来找出这[ n&#x2F;57个元素的中位数。如果 「n&#x2F;57是偶数，就找它的2个中位数中较大的一个。以这个元素作为划分基准。</p><p>$$<br>T(n)&#x3D;\begin{cases}C_1&amp;n&lt;75\ C_2n+T(n&#x2F;5)+T(3n&#x2F;4)&amp;n&gt;75\end{cases}\T(n)&#x3D;O(n)<br>$$</p><h3 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h3><p>设计一个满足以下要求的比赛日程表：<br>(1)每个选手必须与其他n-1个选手各赛一次；<br>(2)每个选手一天只能赛一次；<br>(3)循环赛一共进行n-1天。</p><blockquote><p>按分治策略，将所有的选手分为两半， n个选手的比赛日程表 就可以通过为n&#x2F;2个选手设计的比赛日程表来决定。递归地用 对选手进行分割，直到只剩下2个选手时，比赛日程表的制定 就变得很简单。这时只要让这2个选手进行比赛就可以了。</p></blockquote><h1 id="第3章-动态规划"><a href="#第3章-动态规划" class="headerlink" title="第3章 动态规划"></a><strong>第3章 动态规划</strong></h1><h2 id="算法总体思想"><a href="#算法总体思想" class="headerlink" title="算法总体思想"></a><strong>算法总体思想</strong></h2><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分<br>解成若干个子问题<br>但是经分解得到的子问题往往不是互相独立的。不同子问题的<br>数目常常只有多项式量级。在用分治法求解时，有些子问题被<br>重复计算了许多次。</p><h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a><strong>矩阵连乘问题</strong></h2><p>完全加括号的矩阵连乘积可递归地定义为：</p><p>（1）单个矩阵是完全加括号的；<br>（2）矩阵连乘积A是完全加括号的，则A可表示为2个完全加括号的矩阵连乘积 和的乘积并加括号，即A&#x3D;(BC)</p><p>◼ 由于矩阵乘法满足结合律，所以计算矩阵的连乘可以有许多不<br>同的计算次序。这种计算次序可以用加括号的方式来确定。<br>◼ 若一个矩阵连乘积的计算次序完全确定，也就是说该连乘积已<br>完全加括号，则可以依此次序反复调用2个矩阵相乘的标准算<br>法计算出矩阵连乘积<br>◼ 特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。<br>◼ 矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。</p><h3 id="建立递归关系"><a href="#建立递归关系" class="headerlink" title="建立递归关系"></a><strong>建立递归关系</strong></h3><p>设计算$A_i* A_{i+1}<em>…</em> A_j$ 的矩阵连乘积表示为$A[i:j]$，$1≤i≤j≤n$，所需</p><p>要的最少的乘次数为$m[i,j]$，则原问题的最优值可表示为$m[1,n]$</p><p>◼ 当$i&#x3D;j$时，$A[i:j]&#x3D;Ai$，因此，$m[i,i]&#x3D;0，i&#x3D;1,2,…,n$</p><p>◼ 当$i&lt;j$时，</p><p>若$A [i:j]$ 在$A_k$和$A_{k+1}$间断开为最优，则：</p><p>$A[i:j] &#x3D; A[i:k] A[k+1:j], i⩽k&lt;j$</p><p>$A[i:k]$为 $<strong>A[i]$的行数 $x A[k]$的列数</strong> 的矩阵</p><p>$<strong>A[i]$的行 $&#x3D; A[i-1]$的列 $&#x3D; p_{i-1}$</strong> ，$A[k]$的列数$&#x3D; p_k$</p><p>故：$A[i:k]$ 为$<em>p_{i-1}$$</em> p_k$*的矩阵$A[k+1:j]$为$<em>p_k$$</em> p_j$*的矩阵,则所需计算次数： $m[i, j] &#x3D; m[i,k]+ m[k +1, j]+ p_{i−1}p_kp_j$</p><h3 id="用动态规划法求最优解"><a href="#用动态规划法求最优解" class="headerlink" title="用动态规划法求最优解"></a><strong>用动态规划法求最优解</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="type">int</span> *p，<span class="type">int</span> n，<span class="type">int</span> **m，<span class="type">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">2</span>; r &lt;= n; r++) <span class="comment">/* r 为连乘矩阵的数量 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - r+<span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> j=i+r<span class="number">-1</span>;</span><br><span class="line">m[i][j] = m[i+<span class="number">1</span>][j]+ p[i<span class="number">-1</span>]*p[i]*p[j];</span><br><span class="line">s[i][j] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i+<span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line"><span class="type">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i<span class="number">-1</span>]*p[k]*p[j];</span><br><span class="line"><span class="keyword">if</span> (t &lt; m[i][j]) &#123; m[i][j] = t; s[i][j] = k;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划算法的基本要素"><a href="#动态规划算法的基本要素" class="headerlink" title="动态规划算法的基本要素"></a><strong>动态规划算法的基本要素</strong></h2><h3 id="一、最优子结构"><a href="#一、最优子结构" class="headerlink" title="一、最优子结构"></a><strong><strong>一、最优子结构</strong></strong></h3><ul><li>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为<strong>最优子结构性质</strong>。</li><li>在分析问题的最优子结构性质时，所用的方法具有普遍性：首先假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾。</li><li>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。最优子结构是问题能用动态规划算法求解的前提。</li></ul><blockquote><p>同一个问题可以有多种方式刻划它的最优子结构，有些表示方法的求解速度更快（空间占用小，问题的维度低）</p></blockquote><h3 id="二、重叠子问题"><a href="#二、重叠子问题" class="headerlink" title="二、重叠子问题"></a><strong><strong>二、重叠子问题</strong></strong></h3><ul><li>递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为<strong>子问题的重叠性质</strong>。</li><li>动态规划算法，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。</li><li>通常不同的子问题个数随问题的大小呈多项式增长。因此用动态规划算法只需要多项式时间，从而获得较高的解题效率。</li></ul><h3 id="三、备忘录方法"><a href="#三、备忘录方法" class="headerlink" title="三、备忘录方法"></a><strong><strong>三、备忘录方法</strong></strong></h3><p>备忘录方法的控制结构与直接递归方法的控制结构相同，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题的重复求解。</p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><strong>最长公共子序列</strong></h2><p><strong>给定序列$X&#x3D;{x_1,x_2,…, x_m}$，另一序列$Z&#x3D;{z_1,z_2,…, z_m}$。</strong></p><p>若Z是X的子序列，是指存在一个严格递增下标序列$<strong>{i_1,i_2,…,i_k}$，使得对于所有$j&#x3D;1,2,…,k$有：$z_j&#x3D; x_{ij}$ 。</strong></p><p>例如：序列$Z&#x3D;{B，C，D，B}$是序列$X&#x3D;{A，B，C，B，D，A，B}$的子序列，相应的递增下标序列为${2，3，5，7}$。给定2个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。</p><p>给定2个序列$X&#x3D;{x_1,x_2,…, x_m}$和$Y&#x3D;{y_1,y_2,…, y_n}$，找出X和Y的最长公共子序列。</p><p>设序列$X&#x3D;{x_1,x_2,…, x_m}$和$Y&#x3D;{y_1,y_2,…, y_n}$的最长公共子序列为$Z&#x3D;{z_1,z_2,…,z_k}$ 则</p><p>(1)若$x_m&#x3D;y_n$，则$z_k&#x3D;x_m&#x3D;y_n$，且$Z_{k-1}$是$X_{m-1}$和$Y_{n-1}$最长公共子序列。</p><p>(2)若$x_m≠y_n$且$z_k≠x_m$，则$Z$是$X_{m-1}$和$Y$的最长公共子序列。</p><p>(3)若$x_m≠y_n$且$z_k≠y_n$，则$Z$是$X$和$Y_{n-1}$的最长公共子序列</p><p>其中，$<strong>X_{m-1}&#x3D;{x_1,x_2,…,x_{m-1}}$， $Y_{n-1} &#x3D;{y_1,y_2,…,y_{n-1}}$， $Z_k-1 &#x3D;{z_1,z_2,…,z_{k-1}}$</strong></p><p>由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用c[i][j]记录序列和的最长公共子序列的长度。<strong>其中，</strong> $X&#x3D;{x_1,x_2,…, x_m}$;$Y&#x3D;{y_1,y_2,…, y_n}$<strong>。当i&#x3D;0或j&#x3D;0时，空列是X</strong>i<strong>和Y</strong>j<strong>的最长公共子序列。故此时C[i][j]&#x3D;0。其它情况下，</strong>由最优子结构性质可建立递归关系如下：</p><p>$$<br>c[i][j]&#x3D;\begin{cases} 0&amp;i&#x3D;0,j&#x3D;0\ c[i-1][j-1]+1&amp;i,j&gt;0;x_i&#x3D;y_j\ max{c[i][j-i],c[i-1][j]}&amp;i,j&gt;0;x_i\neq y_j\end{cases}<br>$$</p>]]></content>
    
    
    <summary type="html">算法设计与分析的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://zhangyuanhe.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网络安全课程笔记</title>
    <link href="https://zhangyuanhe.top/2024/01/09/BUPT_note/Notes%20on%20network%20security/"/>
    <id>https://zhangyuanhe.top/2024/01/09/BUPT_note/Notes%20on%20network%20security/</id>
    <published>2024-01-09T13:00:00.000Z</published>
    <updated>2024-01-17T12:58:37.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络安全-武斌"><a href="#网络安全-武斌" class="headerlink" title="网络安全 武斌"></a>网络安全 武斌</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="网络空间"><a href="#网络空间" class="headerlink" title="网络空间"></a>网络空间</h2><p>物理网络位置→逻辑层面（逻辑网络组件）→社会和认知层面（网络上的人）</p><h2 id="安全共性"><a href="#安全共性" class="headerlink" title="安全共性"></a>安全共性</h2><p>硬件安全</p><p>系统安全</p><p>协议安全</p><p>网络安全</p><p>硬件性能的快速提升促进不同网络逐渐趋同</p><p>硬件趋同→应用技术趋同→安全威胁扩展</p><p>云上问题层出不穷</p><p>共性安全问题：</p><ul><li>漏洞挖掘利用</li><li>协议权限类似：面临Dos等攻击</li><li>安全防护方法类似</li></ul><h2 id="网络安全现状"><a href="#网络安全现状" class="headerlink" title="网络安全现状"></a>网络安全现状</h2><p>略</p><h1 id="网络安全概述"><a href="#网络安全概述" class="headerlink" title="网络安全概述"></a>网络安全概述</h1><h2 id="资产保护"><a href="#资产保护" class="headerlink" title="资产保护"></a>资产保护</h2><ul><li>物理资源：物理资源是具有物理形态的资产</li><li>知识资源：知识资源可以是任何信息的形式，并直在组织的事务处理中起一定的作用</li><li>时间资源</li><li>信誉资源</li></ul><p>损失：</p><ul><li>即时的损失</li><li>长期的恢复所需花费</li></ul><p><strong>安全强度－安全代价的折中</strong>：</p><ul><li>用户方便程度</li><li>管理复杂性</li><li>对现有系统的影响</li><li>对不同平台的支持</li></ul><p><strong>安全强度、安全代价和侵入可能性的关系</strong></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled.png" alt="Untitled"></p><h1 id="信息安全模型"><a href="#信息安全模型" class="headerlink" title="信息安全模型"></a>信息安全模型</h1><p>信息保密技术的研究基础：</p><p>① 发展各种密码算法及其应用 ：</p><p>DES（数据加密标准）、 RSA（公开密钥体制）、 ECC（椭圆曲线离散对数密码体制）等。</p><p>② 计算机信息系统安全模型和安全评价准则 ：</p><p>访问监视器模型、多级安全模型等；TCSEC（可信计算机系统评价准则）、 ITSEC（信息技术安全评价准则）等。</p><p>信息保障（IA）</p><pre><code>定义：确保信息和信息系统的可用性、完整性、可控性、保密性、不可否认性来保护信息</code></pre><p><strong>信息保障技术框架IATF</strong>：由美国国家安全局制定，提出 “<strong>纵深防御策略</strong>”DiD（ Defense-in-Depth Strategy）。</p><p>强调人、技术、操作这三个核心原则。</p><p>在信息保障的概念下，信息安全保障的<strong>PDRR模型</strong>的内涵已经超出了传统的信息安全保密，而是保护（ Protection）、检测（Detection）、响应（Reaction ）和恢复（Restore）的有机结合。</p><h2 id="网络攻击类型及分类"><a href="#网络攻击类型及分类" class="headerlink" title="网络攻击类型及分类"></a>网络攻击类型及分类</h2><h3 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h3><p>从安全属性来看，攻击类型可分为4类： 阻断攻击、截取攻击、篡改攻击、伪造攻击。</p><p>( 1)阻断攻击</p><p>阻断攻击使系统的资产被破坏，无法提供用户使用，这是一种针对可用性的攻击。例如，破坏硬盘之类的硬件，切断通信线路，使文件管理系统失效等。</p><p>(2)截取攻击<br>截取攻击可使非授权者得到资产的访问，这是一种针对机密性的攻击。非授权者可以是一个人、一个程序或一台计算机，例如， 通过窃昕获取网上数据以及非授权的复制文件和程序。</p><p>(3)篡改攻击<br>篡改攻击是非授权者不仅访问资产，而且能修改信息，这是一种针对完整性的攻击。例如，改变数据文件的值，修改程序以及在 网上正在传送的报文内容。</p><p>(4)伪造攻击<br>伪造攻击是非授权者在系统中插入伪造的信息，这是一种针对真实性的攻击。例如：在网上插入伪造的报文，或在文件中加入一 些记录。</p><h3 id="主动攻击和被动攻"><a href="#主动攻击和被动攻" class="headerlink" title="主动攻击和被动攻"></a>主动攻击和被动攻</h3><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%201.png" alt="Untitled"></p><p><strong>被动攻击</strong></p><p>目的是获取正在传输的信息。<strong>被动攻击包括传输报文内容的泄露 和通信流量分析</strong>。报文内容的泄露易于理解，一次电话通信、一 份电子邮件报文、正在传送的文件都可能包含敏感信息或秘密信息</p><p>对被动攻击的<strong>检测十分困难</strong>，因为攻击并不涉及数据的任何改变。然而阻止这些攻击的成功是可行的，因此，对被动攻击<strong>强调的 是阻止而不是检测</strong>。</p><p><strong>主动攻击</strong></p><p>包含对数据流的某些修改，或者生成一个假的数据流。它可分成4类:</p><p><strong>(1)伪装</strong></p><blockquote><p>伪装是一个实体假装成另一个实体。伪装攻击往往连同另一类主动攻击一 起进行。<br><strong>(2)回答 （重放）</strong><br>回答攻击包含数据单元的被动捕获，随之再重传这些数据，从而产生一个<br>非授权的效果。</p></blockquote><p><strong>(3)修改报文</strong></p><blockquote><p>修改报文攻击意味着合法报文的某些部分已被修改，或者报文的延迟和重<br>新排序，从而产生非授权的效果。</p></blockquote><p><strong>(4)拒绝服务</strong></p><blockquote><p>拒绝服务攻击是阻止或禁止通信设施的正常使用和管理。这种攻击可能针 对专门的 目标(如安全审计服务) ，抑制所有报文直接送到目的站;也可能破 坏整个网络，使网络不可用或网络超负荷，从而降低网络性能。</p></blockquote><blockquote><p>主动攻击和被动攻击具有相反的特性。被动攻击难以检测出来， 然而有阻止其成功的方法。而主动攻击难以绝对地阻止，因为要 做到这些，就要对所有通信设施、通路在任 何时间进行完全的保 护。因此对主动攻击采取检测的方法，并从破坏中</p></blockquote><p><strong>访问攻击</strong><br>攻击者企图获得非授权信息，这种攻击可能发生在信息驻留在计算机系统中或在网络上传输的情况下。是针对信息机密性的攻击。</p><p>常见的访问攻击有3种:</p><blockquote><p>(1)窥探(snooping)：是查信息文件，发现某些攻击者感兴趣的信息。攻击者试图打开计算机系统的文件，直到找到所需信息；<br>(2)窃听(eavesdropping)：是偷听他人的对话，为了得到非授权的信息访问，攻击者必须将自己放在一个信息通过的地方，一般采用电子的窃听方式；<br>(3)截获(interception)：不同于窃听 ，它是一种主动攻击方式。攻击者截获信息是通过将自己插入信息通过的通路，且在信息到达目的地前能事先 捕获这些信息。</p></blockquote><p><strong>篡改攻击</strong><br>篡改攻击是攻击者企图修改信息，而他们本来是无权修改的。这种攻击可能发生在信息驻留在计算机系统中或在网络上传输的情况下 , 是针对信息完整性的攻击。</p><p>常见的篡改攻击有3种:</p><blockquote><p>(1)改变：改变已有的信息 。例如，攻击者改变己存在的员工工资，改变以 后的信息虽然仍存在于该组织，但已经是不正确的信息。这种改变攻击的 目标通常是敏感信息或公共信息。<br>(2)插入 ：插入信息可以改变历史的信息 。例如，攻击者在银行系统中加 一个事务处理，从而将 客户账户的资金转到自己账户上。<br>(3)删除 ：删除攻击是将已有的信息去除，可能是将历史记录的信息删除 。例如，攻击者将一个事务处理记录从银行结账单中删除，从而造成银行 资金的损失。</p></blockquote><p><strong>拒绝服务攻击</strong></p><p>拒绝服务攻击(Denial-of-Service ， DoS)是拒绝合法用户使用系统 、信息、能力等各种资源。可分成以下4种:</p><blockquote><p>(1)拒绝访问信息：使信息不可用 ，信息被破坏或者将信息改变成不可使用状态，也可能信息仍存在，但已经被移到不可访问的位置。<br>(2)拒绝访问应用：目标是操纵或显示信息的应用。通常对正在运行应用程序的计算机系统进行攻击，使应用程序不可用而不能完成任务。<br>(3)拒绝访问系统：通常是使系统宕机，使运行在该计算机系统上的所有应用无法运行，使 存储在该计算机系统上的所有信息不可用。<br>(4)拒绝访问通信：是针对通信的一种攻击，已有很多年历史。这类攻击可能用切断通信电缆、干扰无线电通信以及用过量的通信负载来淹没网络。</p></blockquote><p><strong>否认攻击</strong><br>否认攻击是针对信息的可审性进行的。否认攻击企图给出假的信息或者否认已经发生的现实事件或事务处理。<br>否认攻击包括两类:</p><blockquote><p>(1)假冒：假冒是攻击者企图装扮或假冒别人和别的系统。这种攻击可能发生在个人通信、事务处理或系统对系统的通信中。<br>(2)否认：否认一个事件是简单地抵赖曾经登录和处理的事件。例如，一个人用信用卡在商店 里购物，然而当账单送到时，告诉信用卡公司，他从未到该商店购物。</p></blockquote><h2 id="网络信息安全服务"><a href="#网络信息安全服务" class="headerlink" title="网络信息安全服务"></a>网络信息安全服务</h2><ul><li>机密性服务：提供信息的保密。</li><li>完整性服务：提供信息的正确性。</li><li>可用性服务：提供的信息是可用的。</li><li>可审性服务：本身不针对攻击提供保护，需与其它服务结合。&#96;</li></ul><h3 id="机密性防护"><a href="#机密性防护" class="headerlink" title="机密性防护"></a>机密性防护</h3><p><strong>文件机密性</strong></p><blockquote><p>为实现文件机密性服务，所需提供的机制包括物理安全机制、计算机文件访 问控制以及文件加密。<br>文件机密性的要求包括身份标识和身份鉴别、正确的计算机系统配置，如使 用加密则还需合适的密钥管理。</p></blockquote><p><strong>信息传输机密性</strong></p><blockquote><p>可基于每个报文信息进行加密保护，也可以对链路上的所有 通信进行加密。</p></blockquote><p><strong>通信流机密性</strong></p><blockquote><p>这些信息形式通过通信分析可识别组织之间的通信情况。 例如，很多新闻机构发现某一时刻有大量的快餐送至政 府某重要机关，则可推测某些紧急事件甚至是危机可能发生。</p></blockquote><h3 id="完整性防护"><a href="#完整性防护" class="headerlink" title="完整性防护"></a>完整性防护</h3><p><strong>文件完整性</strong></p><blockquote><p>完整性服务也必须和身份标识、身份鉴别功能结合在一起。</p></blockquote><p><strong>信息传输完整性</strong></p><blockquote><p>信息在传输中也可能被修改，然而如果不实施截获攻击就很难对 传输中的信息进行修改。</p></blockquote><blockquote><p>完整性服务可成功地阻止篡改攻击和否认攻击。任何篡改攻击都可能改变文件或传输中的信息，当完整性服务能检测到非授权者的访问，篡改攻击就不能成功进行。当完整性服务和身份 标识、身份鉴别服务很好地结合，即使组织以外的文件被 改变也能被检测出来。</p></blockquote><h3 id="可用性防护"><a href="#可用性防护" class="headerlink" title="可用性防护"></a>可用性防护</h3><p>可用性是用来对拒绝服务攻击的系统恢复。可用性并不能阻止DoS，但 可用性服务可用来减少这类攻击的影响。</p><h3 id="可审性防护"><a href="#可审性防护" class="headerlink" title="可审性防护"></a>可审性防护</h3><p>身份标识与身份鉴别</p><blockquote><p>有两个目的：其一是对试图执行一个功能的每个人的身份进行标识；其二是验证这些人声称的身份。<br>身份鉴别可使用以下任何一种或其组合的方法 实现:</p></blockquote><p>. (1)知识因子——你知道什么，如口令或PIN(个人身份标识号)。<br>. (2)拥有因子——你有什么，如智能卡或标记。<br>. (3)生物因子——你是什么，如指印、视网膜。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名是通信双方在网上交换信息用公钥密码防止伪造和欺骗的一种身份认证。</p><h3 id="Kerberos鉴别"><a href="#Kerberos鉴别" class="headerlink" title="Kerberos鉴别"></a>Kerberos鉴别</h3><p>Kerberos使用<strong>对称密钥加密算法</strong>来实现，通过可信第三方 密钥分发中心的认证服务，它提供了网络通信方之间相互 的身份认证手段，而且并不依赖于主机操作系统和地址。</p><h2 id="网络安全评估"><a href="#网络安全评估" class="headerlink" title="网络安全评估"></a>网络安全评估</h2><h3 id="1-可信计算机系统评估准则（TCSEC-）"><a href="#1-可信计算机系统评估准则（TCSEC-）" class="headerlink" title="1. 可信计算机系统评估准则（TCSEC ）"></a>1. 可信计算机系统评估准则（TCSEC ）</h3><p>橘皮书</p><blockquote><p>D级，无保护级<br>C1级， 自主安全保护级<br>C2级，受控存取保护级<br>B1级，标记安全保护级<br>B2级，结构化保护级<br>B3级，安全域级<br>A级，验证设计级</p></blockquote><h3 id="2-信息技术安全评估准则（ITSEC-）"><a href="#2-信息技术安全评估准则（ITSEC-）" class="headerlink" title="2. 信息技术安全评估准则（ITSEC ）"></a>2. 信息技术安全评估准则（ITSEC ）</h3><p>白皮书</p><p>ITSEC定义了从E0级（没有任何保证）到E6级（形式化 验证）的七个安全等级。<br>目前，ITSEC已大部分被CC替代</p><h3 id="3-信息安全技术通用评估准则（CC-）"><a href="#3-信息安全技术通用评估准则（CC-）" class="headerlink" title="3. 信息安全技术通用评估准则（CC ）"></a>3. 信息安全技术通用评估准则（CC ）</h3><blockquote><p>简介和一般模型：正文介绍了CC中的有关术语、基本概 念和一般模型以及与评估有关的一些框架，附录部分主 要介绍保护轮廓（PP）和安全目标（ST）的基本内容。<br>安全功能要求：按“类-族-组件 ”的方式提出安全功能要求， 提供了表示评估目标TOE安全功能要求的标准方法。<br>安全保证要求 ：定义了评估保证级别，建立了一系列安 全保证组建作为表示TOE保证要求的标准方法。</p></blockquote><h3 id="4-我国信息安全评估准则"><a href="#4-我国信息安全评估准则" class="headerlink" title="4. 我国信息安全评估准则"></a>4. 我国信息安全评估准则</h3><blockquote><p>第一级：用户自主保护级<br>第二级：系统审计保护级<br>第三级：安全标记保护级<br>第四级：结构化保护级<br>第五级：访问验证保护级</p></blockquote><h2 id="网络安全评估方式"><a href="#网络安全评估方式" class="headerlink" title="网络安全评估方式"></a>网络安全评估方式</h2><ol><li><p>风险评估</p></li><li><p>生存性评估</p></li><li><p>网络安全态势评估</p></li><li><p>网络攻击效果评估</p></li><li><p>安全测评</p></li><li><p>信息安全工程能力评估</p></li><li><p>信息系统审计</p></li></ol><h1 id="网络攻击—ARP-攻击"><a href="#网络攻击—ARP-攻击" class="headerlink" title="网络攻击—ARP 攻击"></a>网络攻击—ARP 攻击</h1><h2 id="嗅探技术"><a href="#嗅探技术" class="headerlink" title="嗅探技术"></a>嗅探技术</h2><p>嗅探技术，是一种常用的收集有用数据信息的网络监听方法，是网络安全攻防技术中很重要的一种。</p><p>以太网嗅探。网卡一般具有四种接收工作模式</p><p>· 广播 (Broadcast) 模式，可以接收局域网内目的地址为广播 地址(全1地址)的所有数据报；<br>· 多 播 (Multicast) 模式，可以接收目的地址为多播地址的所有 数据报;<br>· 直 接 (Directory) 模式，也就是单播 (Unicast) 模式，只接 收目的地址为本机MAC 地址的所有数据报；<br>· 混杂 (Promiscuous) 模式，能够接收通过网卡的所有数据报。</p><p>网卡被设置成混杂模式时，无论监听到的数据帧目的地址如何，网卡能接收所有达到自身的数据。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><blockquote><p>交换机 (Switch) 意为“开关”是一种用于电(光)信号转发的网络设备。它可以为接入交换机的任意两 个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机。</p></blockquote><p>交换机工作于OSI 参考模型的第二层，即数据链路层。交换机内部 的CPU 会在每个端口成功连接时，通过将MAC 地址和端口对应，形成一张MAC 表。</p><h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><blockquote><p>地址解析协议，即ARP(Address Resolution Protocol), 是根据IP地址获取物理地址 的一个TCP&#x2F;IP协议。</p></blockquote><p>网络通信一般以 IP地址为源、目的地址，但工作在数据链路层的交换机、网卡等并不能识别IP地址，需要获取MAC 地址才能通信。</p><p>主机设有一个 ARP高速缓存 ，存放局域网中主机的IP地址和MAC 地址对。当两台主机进行通信时，通过查询ARP 缓 存表来进行IP地址到MAC 地址的转换。缓存表中不存在查 找项时， 运行ARP广播查找目标主机的MAC地址。ARP缓存表中的每一个映射地址项都有生存时间，进行定时更新。</p><p><strong>ARP 协议工作过程</strong></p><p>● 源主机A 首先判断目的主机B是否处于同一子网(根据本子网的子 网掩码和目标主机IP地址)。</p><p>● 若目的主机位于同一子网内</p><blockquote><p>主 机A 先检查ARP 缓存内是否有主机B 的MAC 地址。<br>如果没有，主机A会发送一个ARP 请求广播包，此包内包含着其欲与之通信的主机的IP地址，也就是主机B的IP地址。<br>当 主 机B收到此广播后，会将自己的MAC 地址利用ARP 响应包传给主机A, 并更新自己的ARP 缓存，也就是同时将主机A的IP地 址&#x2F;MAC 地址对保存起来，以供后面使用。<br>主 机A 在得到主机B 的MAC 地址后，就可以与主机B通信了。同时，主机A也将主机B 的IP地址&#x2F;MAC 地址对保存在自己的ARP 缓 存内。</p></blockquote><h2 id="ARP-攻击技术"><a href="#ARP-攻击技术" class="headerlink" title="ARP 攻击技术"></a>ARP 攻击技术</h2><p>● 在交换式网络环境下，通信参与者有三个：</p><blockquote><p>通信双方A和B<br>交换机S<br>攻击者C<br>要想达到嗅探的目的，可以有三个攻击点， (1)交换机S, (2)目标主机A和B,(3) 自 己C。</p></blockquote><p>发送大量虚假MAC 地址数据报</p><blockquote><p>交换机虽然可以维护一张端口-MAC 的地址映射表，但是由于交换机内存有限，地址映射表的大小也就有限。<br>如果主机C 发送大量虚假MAC 地址的数据报，快速填满地址映射表。交换机在地址映射表被填满后，就会像HUB 一样以广播 方式处理数据报。<br>这种方法不适合采用静态地址映射表的交换机，而且也不是所有交换机都采用这种转发处理方式。</p></blockquote><h3 id="ARP-欺骗"><a href="#ARP-欺骗" class="headerlink" title="ARP 欺骗"></a>ARP 欺骗</h3><p>ARP 欺骗利用修改主机ARP 缓存表的方法达到嗅探的目的，是一种中间人攻击。主机C 为了达到嗅探的目的，会向主机A 和主机B分别发送ARP 应答包，告诉它们IP地址为IPB 的主机MAC 地址为MACC,IP 地址为IPA 的主机MAC地址为MACC。<br>这 样 ， 主 机A 和主机B 的ARP 缓存中就会有IPB—MACC 和IPA—MACC 的记录。这样，主机A 和主机B的通信数据都流向了主机C, 主机C 只要再发送到 其真正的目的地就可以了。当然ARP 缓存表项是动态更新的(一般为两分 钟),如果没有更新信息， ARP 映射项会自动删除。所以，主机C 在监听过 程中，还要不断地向主机A 和主机B 发送伪造的ARP 应答包。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/Untitled%202.png" alt="Untitled"></p><p><strong>修改本地MAC 地址</strong></p><blockquote><p>也可以通过修改本地MAC 地址为目标主机MAC 地址来实现嗅探。把主机C 的MAC 地址修改为目标主机B 的MAC 地址，交换机会将 MACB 和端口c对应起来。<br>在以后收到目的地址为MACB 的数据报后，交换机会将包从端口c发送出去。这样就达到了监听的目的。<br>但同样地，这种方法只适用于动态生成地址映射表的交换机，并且没有采用其它策略。</p></blockquote><h2 id="ARP-攻击溯源"><a href="#ARP-攻击溯源" class="headerlink" title="ARP 攻击溯源"></a>ARP 攻击溯源</h2><h3 id="方法一-：捕包分析"><a href="#方法一-：捕包分析" class="headerlink" title="方法一 ：捕包分析"></a>方法一 ：捕包分析</h3><blockquote><p>在网络内任意一台主机上运行抓包软件，捕获所有到达本机的数据包。如果发现有某个IP不断发送ARP Request请求包，那么这台电脑一般就是攻击源。<br>原 理 ：ARP 攻击行为方式主要有两种， 一是欺骗网关，二是欺骗网内的所有主机。最终的结果是，在网关的ARP 缓存表中，网内所有活动主机 的MAC 地址均为中毒主机的MAC 地址；网内所有主机的ARP 缓存表中， 网关的MAC 地址也成为中毒主机的MAC 地址。前者保证了从网关到网 内主机的数据包被发到中毒主机，后者相反，使得主机发往网关的数据 包均发送到中毒主机。</p></blockquote><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>使用arp-a 命令任意选两台不能上网的主机，在DoS 命令窗口下运行arp-a命令。例如在结果中，两台电脑除了网关的IP, MAC 地址对应项，都包含了192.168.0.186的这个IP, 则可以断定 192.168.0.186这台主机就是攻击源。<br>原理： 一般情况下，网内的主机只和网关通信。正常情况下， 一台主机的ARP 缓存中应该只有网关的MAC 地址。如果有其他主机 的MAC 地址，说明本地主机和这台主机最后有过数据通信发生。 如果某台主机(例如上面的192.168.0.186)既不是网关也不是服 务器，但和网内的其他主机都有通信活动，且此时又是ARP 攻击 发作时期，那么攻击源也就是它了。</p><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>使用tracert 命令在任意一台受影响的主机上，在DoS 命令窗口下运行如下命令： tracert 61.135.179.148。<br>● 假定设置的缺省网关为10.8.6.1,在跟踪一个外网地址时， 第一跳却是10.8.6.186,那么， 10.8.6.186就是攻击源。<br>● 原理：中毒主机在受影响主机和网关之间，扮演了“中间人” 的角色。所有本应该到达网关的数据包，由于错误的MAC地址，均被发到了中毒主机。此时，中毒主机越俎代庖，起了缺省网关的作用。</p><h2 id="ARP-攻击防御方法"><a href="#ARP-攻击防御方法" class="headerlink" title="ARP 攻击防御方法"></a>ARP 攻击防御方法</h2><h3 id="方法一：减少过期时间"><a href="#方法一：减少过期时间" class="headerlink" title="方法一：减少过期时间"></a>方法一：减少过期时间</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ndd -set /dev/arp arp cleanup interval <span class="number">60000</span></span><br><span class="line">#ndd -set /dev/ip ip ire flush interval <span class="number">60000</span></span><br><span class="line"><span class="number">60000</span>=<span class="number">60000</span>毫秒默认是<span class="number">300000</span></span><br></pre></td></tr></table></figure><p>加快过期时间，并不能避免攻击，但是使得攻击更加困难，带来的影响是在网络中会大量的出现 ARP 请求和回复，请不 要在繁忙的网络上使用。</p><h3 id="方法二：建立静态ARP表"><a href="#方法二：建立静态ARP表" class="headerlink" title="方法二：建立静态ARP表"></a>方法二：建立静态ARP表</h3><p>这是一种很有效的方法，而且对系统影响不大。缺点是破坏了动<br>态ARP 协议。可以建立如下的文件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[test.<span class="property">nsfocus</span>.<span class="property">com</span>](<span class="attr">http</span>:<span class="comment">//test.nsfocus.com/) 08:00:20:ba:a1:f2</span></span><br><span class="line">user. [nsfocus.<span class="property">com</span>](<span class="attr">http</span>:<span class="comment">//nsfocus.com/) 08:00:20:ee:de:1f</span></span><br></pre></td></tr></table></figure><p>使用arp -f filename加载进去，这样的ARP 映射将不会过期和被新<br>的ARP 数据刷新，除非使用arp-d 才能删除。但是一旦合法主机的 网卡硬件地址改变，就必须手工刷新这个arp文件。这个方法，不 适合于经常变动的网络环境。</p><h3 id="方法三：禁止ARP"><a href="#方法三：禁止ARP" class="headerlink" title="方法三：禁止ARP"></a>方法三：禁止ARP</h3><p>可以通过ipconfig interface-arp 完全禁止ARP, 这样， 网卡不会发送ARP 和接受ARP 包。但是使用前提是使用 静态的ARP 表，如果不在ARP 表中的计算机，将不能通 信。<br>这个方法不适用与大多数网络环境，因为这增加了网络管理的成本。但是对小规模的安全网络来说，还是有效 可行的。</p><h1 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a><strong>拒绝服务攻击</strong></h1><h2 id="典型DoS—Ping-of-Death"><a href="#典型DoS—Ping-of-Death" class="headerlink" title="典型DoS—Ping of Death"></a><strong>典型DoS—Ping of Death</strong></h2><p>攻击者故意在ICMP Echo数据包(Ping包)之后附加非常多的冗余信息，使数据包的尺寸超过65535个字节的上限。</p><p>接收方对这种数据包进行处理时就会出现内存分配错误，导致TCP&#x2F;IP堆栈溢出，从而引起系统崩溃，挂起或重启。</p><h2 id="典型DoS——Teardrop"><a href="#典型DoS——Teardrop" class="headerlink" title="典型DoS——Teardrop"></a><strong>典型DoS——Teardrop</strong></h2><p>Teardrop指的是向目标机器发送损坏的IP包，诸如重叠的包或过大的包载荷，该攻击通过TCP&#x2F;IP协议栈中分片重组代码中的bug来瘫痪各种不同的操作系统。</p><h2 id="典型DoS——Land攻击"><a href="#典型DoS——Land攻击" class="headerlink" title="典型DoS——Land攻击"></a><strong>典型DoS——Land攻击</strong></h2><p>Land攻击：利用特殊的TCP封包传送至目标主机，使其因无法判别而当机或被迫重新启动。</p><p>攻击原理是：用一个特别构造的SYN包，<strong>它的源地址和目标地址都被设置成某一个服务器地址</strong>。此举将导致接受服务器向它自己的地址发送SYN一ACK消息，结果这个地址又发回ACK消息并创建一个空连接。被攻击的服务器每接收一个这样的连接都将保留，直到超时。</p><h2 id="典型DoS—SYN洪水"><a href="#典型DoS—SYN洪水" class="headerlink" title="典型DoS—SYN洪水"></a><strong>典型DoS—SYN洪水</strong></h2><p><strong>原理：</strong></p><ul><li>每个机器都需要为半开连接分配一定的资源</li><li>这种半开连接的数量是有限制</li><li>攻击方利用TCP连接三次握手过程，打开大量的半开TCP连接</li><li>目标机器不能进一步接受TCP连接。机器就不再接受进来的连接请求。</li></ul><h2 id="典型DoS—Smurf"><a href="#典型DoS—Smurf" class="headerlink" title="典型DoS—Smurf"></a><strong>典型DoS—Smurf</strong></h2><p><strong>原理：</strong></p><ul><li>攻击者向一个广播地址发送ICMP Echo请求，并且用受害者的IP地址作为源地址</li><li>广播地址网络上的每台机器响应这些Echo请求，同时向受害者主机发送ICMP Echo-Reply应答</li><li>受害者主机会被这些大量的应答包淹没</li></ul><h2 id="传统DoS的变化"><a href="#传统DoS的变化" class="headerlink" title="传统DoS的变化"></a><strong>传统DoS的变化</strong></h2><h3 id="CC攻击：Challenge-Collapsar"><a href="#CC攻击：Challenge-Collapsar" class="headerlink" title="CC攻击：Challenge Collapsar"></a><strong>CC攻击：Challenge Collapsar</strong></h3><p>原理：CC攻击的原理就是攻击者控制某些主机不停地发大量数据包给对方服务器造成服务器资源耗尽，一直到宕机崩溃。</p><h3 id="慢速攻击"><a href="#慢速攻击" class="headerlink" title="慢速攻击"></a><strong>慢速攻击</strong></h3><p>对HTTP服务器，先建立了一个连接，指定一个比较大的content-length，然后以非常低的速度发包，比如1-10s发一个字节，然后维持住这个连接不断开。</p><p>如果客户端持续建立这样的连接，那么服务器上可用的连接将一点一点被占满，从而导致拒绝服务。</p><h2 id="基于误用的DDoS检测"><a href="#基于误用的DDoS检测" class="headerlink" title="基于误用的DDoS检测"></a><strong>基于误用的DDoS检测</strong></h2><p>基于误用方法依赖于<strong>攻击特征的选取</strong>, 一般用于检测利用漏洞型的DDoS攻击。</p><p>基于误用的DDoS检测主要是利用了<strong>特征匹配</strong>、<strong>模型推理</strong>、<strong>状态转换</strong>和<strong>专家系统</strong>的方法</p><h2 id="基于异常的DDoS检测"><a href="#基于异常的DDoS检测" class="headerlink" title="基于异常的DDoS检测"></a><strong>基于异常的DDoS检测</strong></h2><p>基于异常的DDoS检测取决于<strong>检测模型的建⽴</strong>，不同的模型对应着不同的检测⽅式，主要包括<strong>统计检测、模式预测、⼈⼯智能检测、机器学习检测</strong>四种⽅法</p><h2 id="按算法部署位置分类的检测方法"><a href="#按算法部署位置分类的检测方法" class="headerlink" title="按算法部署位置分类的检测方法"></a><strong>按算法部署位置分类的检测方法</strong></h2><p>l源端检测</p><p>Ø源端DDoS攻击检测指的是将检测算法布置在发出攻击数据包的主机所处⽹络的边界路由器上。</p><p>Ø将DDoS攻击检测系统部署在源端, 可以使得攻击数据流在进⼊⽹络之前被阻⽌。</p><p>l中间⽹络检测</p><p>Ø中间⽹络DDoS攻击检测是指将攻击检测算法部署在整个⽹络上, 包括路由器、交换机或其他⽹络设备。</p><p>Ø在中间⽹络进⾏检测,通常是在核⼼路由器上部署分布式的DDoS防御检测系统。</p><p>l⽬的端检测</p><p>Ø⽬的端DDoS攻击检测是指将攻击检测算法部署在被攻击的主机和相关⽹络设备上。⽬前应⽤得最多的攻击检测都是在⽬的端(即受害端)进⾏的。</p><h2 id="低速率拒绝服务-low-rate-denial-of-service"><a href="#低速率拒绝服务-low-rate-denial-of-service" class="headerlink" title="低速率拒绝服务(low-rate denial of service)"></a><strong>低速率拒绝服务(low-rate denial of service)</strong></h2><p>当前研究的LDoS攻击：针对TCP 拥塞控制机制的攻击不需要维持持续的高速攻击流，利用网络协议或应用服务协议的<strong>自适应机制中</strong>存在的安全漏洞，通过周期性地发送高速脉冲攻击数据包，达到降低受害端的服务性能的目的。</p><p>TCP拥塞控制机制</p><p>Ø 慢启动(slow start)、拥塞避免(congestion avoidance)<br>Ø 快速重传(fast retransmit)、快速恢复(fast recovery)<br>Ø 发送端会根据当前的链路拥塞情况动态地调整发送报文的速率</p><h2 id="LDoS-攻击的检测"><a href="#LDoS-攻击的检测" class="headerlink" title="LDoS 攻击的检测"></a><strong>LDoS 攻击的检测</strong></h2><p>一般传统的 DoS 攻击检测方法：针对网络数据流和服务器<strong>负荷激增等特征</strong>进行检测</p><h3 id="特征检测"><a href="#特征检测" class="headerlink" title="特征检测"></a><strong><strong>特征检测</strong></strong></h3><p>lLDoS攻击的脉冲强度、持续时间和攻击周期等特征也很明显，特别是结合其<strong>周期性特征和短时高速脉冲特征，</strong>能够很好检测到攻击。</p><p>l最常见的防御策略就是<strong>改进路由器的主动队列管理</strong>(active queuemanagement, AQM)</p><p>l目标：一是丢弃符合设定攻击特征的数据流的数据包；二是重新进行带宽分配，尽量保护TCP 数据流，抑制LDoS 攻击流。</p><h3 id="动态时间封装-Dynamic-time-warping-DTW"><a href="#动态时间封装-Dynamic-time-warping-DTW" class="headerlink" title="动态时间封装(Dynamic time warping,DTW)"></a>动态时间封装(Dynamic time warping,DTW)</h3><p>五元组(T,L,R,S,N)描述攻击特征</p><p>ØT 表示攻击的周期<br>ØL 表示一个突发攻击流持续的时间<br>ØR表示突发攻击流量的峰值速率<br>ØS 表示计时开始到第一个突发攻击流量开始之间的时间差<br>ØN 表示背景流量的等级</p><h1 id="DNS威胁与防范"><a href="#DNS威胁与防范" class="headerlink" title="DNS威胁与防范"></a><strong>DNS威胁与防范</strong></h1><h2 id="DNS-概述"><a href="#DNS-概述" class="headerlink" title="DNS 概述"></a><strong>DNS 概述</strong></h2><p>域名系统（Domain Name System，DNS)在Internet上具有举足轻重的作用，负责<strong>在域名和IP地址之间进行转换</strong>。</p><p>因特网的<strong>域名系统</strong>被设计成为一个<strong>联机分布式数据库系统</strong>，并采用客户服务器方式运行。</p><p>DNS使用的大多数名字都可在本地解析，仅有少量解析需要在因特网上通信，因此系统效率很高。</p><p>因特网域名系统采用<strong>层次树状结构</strong>的命名方法，任何一个连接到因特网的主机或路由器都有一个<strong>唯一的层次结构的名字</strong>，即域名（Domain Name）。这里，“域”是名字空间中的一个可被管理的划分。域还可以继续划分为子域，如：二级域、三级域等</p><h2 id="DNS-资源记录"><a href="#DNS-资源记录" class="headerlink" title="DNS 资源记录"></a><strong>DNS 资源记录</strong></h2><p>理论上对于每一个域名我们只需要在域名服务器上保存一条记录即可。这里的记录一般叫作<strong>域名资源记录</strong>，它是一个<strong>五元组</strong>，可以用以下格式表示：</p><p>1.Domain_name: 指出这条记录适用于哪个域名；</p><p>2.Time_to_live: 用来表明记录的生存周期，也就是说最多可以缓存该记录多长时间（后面会讲到缓存机制）；</p><p>3.Class: 一般总是IN；</p><p>4.Type: 记录的类型；</p><p>5.Value: 记录的值，如果是A记录，则value是一个IPv4地址。</p><h2 id="WHOIS的概念"><a href="#WHOIS的概念" class="headerlink" title="WHOIS的概念"></a><strong>WHOIS的概念</strong></h2><p>“WHOIS”是当前域名系统中不可或缺的一项信息服务。</p><p>很多用户希望进一步了解域名、名字服务器的详细信息，这就会用到WHOIS。</p><p>对于域名的注册服务机构（registrar）而言，要确认域名数据是否已经正确注册到域名注册中心（registry），也经常会用到WHOIS。</p><p>直观来看，WHOIS就是<strong>链接到域名数据库的搜索引擎</strong>，一般来说是属于网络信息中心（NIC）所提供和维护的名字服务之一。</p><h2 id="DNS工作流程"><a href="#DNS工作流程" class="headerlink" title="DNS工作流程"></a><strong>DNS工作流程</strong></h2><p><strong>递归查询：</strong>一般客户机和服务器之间是递归查询，DNS服务器如果未能在本地找到相应的信息，就代替用户向其它服务器进行查询，这时它是代替用户扮演了解析器（resolver）的角色，直到最后把结果找到，也可能根本没有结果，那就返回错误，并返回给用户为止。</p><p><strong>迭代查询：</strong>一般服务器之间属于反复查询。DNS服务器返回的要么是本地存在的结果信息，要么是一个错误码，告诉查询者你要的信息这里没有，然后再返回一个可能会有查询结果的DNS服务器地址，让查询者到那里去查一查。</p><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a><strong>DNS协议</strong></h2><p>DNS既可以使用TCP，又可以使用UDP，端口为53.</p><p>Ø DNS主从服务器之间区传送传输时使用TCP协议<br>Ø 客户端与DNS服务器之间传输时用的是UDP协议</p><p><strong>头部：</strong></p><p><strong>会话标识（2字节）：</strong>是DNS报文的ID标识，对于请求报文和其对应的应答报文，这个字段是相同的，通过它可以区分DNS应答报文是哪个请求的响应</p><p><strong><strong>标志位：</strong></strong></p><table><thead><tr><th>QR</th><th>opcode</th><th>AA</th><th>TC</th><th>RD</th><th>RA</th><th>(zero)</th><th>rcode</th></tr></thead><tbody><tr><td>1</td><td>4</td><td>1</td><td>1</td><td>1</td><td>1</td><td>3</td><td>4</td></tr></tbody></table><p><strong><strong>数量字段：</strong></strong></p><p><strong><strong>数量字段（总共8字节）：Questions、Answer RRs、Authority RRs、Additional RRs 各自表示后面的四个区域的数目。Questions表示查询问题区域节的数量，Answer RRs表示回答区域的数量，Authority RRs表示授权区域的数量，Additional RRs表示附加区域的数</strong></strong></p><h3 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h3><p>Ø <strong>QR– 识别查询和答复消息的1位字段： 0 查询；1 应答；</strong></p><p>Ø <strong>Opcode – 描述消息类型的4位字段：</strong></p><p>0 标准查询（由名字到地址）；<br>1 逆向查询；<br>2 服务状态请求 ；</p><p>Ø <strong>AA – 授权回答：1位字段。当设置为1时，识别由命令名字服务器作出的答复</strong></p><p>Ø <strong>TC – 可切断。1位字段。当设置为1，表明消息已被切断。</strong></p><p>Ø <strong>RD – 1位字段。由名字服务器设置为1请求递归服务。</strong></p><p>Ø <strong>RA –1位字段。由名字服务器设置表示递归服务的可用性。</strong></p><p>Ø <strong>Z –3位字段。备用，设置为0.</strong></p><p>Ø <strong>Rcode – 响应代码，</strong>由名字服务器设置的4位字段用以识别查询状态。表示返回码，0表示没有差错，3表示名字差错，2表示服务器错误（Server Failure）</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h3><p><strong>查询名：</strong>长度不固定，且不使用填充字节，一般该字段表示的就是需要查询的域名（如果是反向查询，则为IP，反向查询即由IP地址反查域名）</p><p><strong>域名（2字节或不定长）：</strong>格式和Queries区域的查询名字字段是一样的。。</p><p><strong>查询类型：</strong>表明资源记录的类型，同Queries。</p><p><strong>查询类：</strong>对于Internet信息，总是1。</p><h3 id="DNS安全威胁"><a href="#DNS安全威胁" class="headerlink" title="DNS安全威胁"></a><strong>DNS安全威胁</strong></h3><p><strong>DNS的安全漏洞主要体现在以下三个方面。</strong></p><p>(1) DNS报文只使用<strong>序列号</strong>来进行有效性鉴别，序列号由客户程序设置并由服务器返回结果，客户程序通过它来确定响应与查询是否匹配，这就引入了序列号攻击的危险。</p><p>(2) 从协议定义上来看，在DNS应答报文中可以<strong>附加信息</strong>，该信息可以和所请求的信息没有直接关系，这样，攻击者就可以在应答中随意添加某些信息，如：指示某域的权威域名服务器的域名及IP，导致在被影响的域名服务器上查询该域的请求都会被转向攻击者所指定的域名服务器上去，从而对网络的完整性构成威胁。</p><p>(3) DNS的<strong>缓存机制</strong>，当一个客户端&#x2F;DNS服务器，收到有关域名和IP的映射信息时，它会将该信息存放在缓存中，当再次遇到对此域名的查询请求时就直接使用缓存中的结果而无需重新查询。可以通过ipconfig &#x2F;displaydns命令查看本地DNS缓存信息。</p><p><strong>缓冲区溢出攻击</strong></p><p>1、更改MX记录，造成邮件被截获、修改或删除。</p><p><strong>2、更改A记录，将www服务器的域名指向黑客具有的同样www</strong>内容的主机，诱使访问者登陆，获取访问者的密码等相关信息</p><p><strong>3、利用这台主机作为攻击其他机器的跳板</strong></p><p><strong>拒绝服务攻击</strong></p><p>造成的危害是：域名无法解析为IP地址，用户无法访问互联网</p><p><strong>信息泄露</strong></p><p>一旦这些信息泄露，攻击者就可以根据它推测出主域名服务器的网络结构，为进一步攻击提供参考依据。</p><h2 id="DNS安全防范"><a href="#DNS安全防范" class="headerlink" title="DNS安全防范"></a><strong>DNS安全防范</strong></h2><p>应对DNS服务器面临的安全隐患主要依据以下两个准则：</p><p>选择安全的没有缺陷的BIND版本<br>DNS服务器配置正确可靠</p><h1 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a><strong>Web安全</strong></h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a><strong>XSS</strong></h2><p>Xss（cross site scripting）攻击,全称跨站脚本攻击。</p><p>跨站脚本攻击是指通过存在安全漏洞的web网站注册用户的测览器内，运行非法的HTML标签或JavaScript进行的一种攻击.</p><blockquote><p>XSS的原理是恶意攻击者往 web 页面里插入恶意可执行网页脚本代码，当 用户测览该页之时，嵌入其中 web 里面的脚本代码会被执行，从而可以 达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p></blockquote><p><strong>非持久型 Xss（反射型 Xss ）</strong></p><p>反射型XSS，也叫非持久型XSS，是指发生请求时， XSS代码出现在请求URL中， 作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后 测览器解析并执行。</p><p>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击,拿 到用户隐私数据。<br>攻击者需要诱骗点击<br>反馈率低，所以较难发现和响应修复</p><p>具体流程：<br>1、Alice给Bob发送一个恶意构造了Web的URL。<br>2、Bob点击并查看了这个URL。<br>3、恶意页面中的JavaScript打开一个具有漏洞的HTML页面并将其安装在Bob电脑上。<br>4、具有漏洞的HTML页面包含了在Bob电脑本地域执行的JavaScript。<br>5、Alice的恶意脚本可以在Bob的电脑上执行Bob所持有的权限下的命令。</p><p><strong>存储型xss，也叫持久型xss</strong></p><p>持久型 Xss 漏洞，也被称为存储型 Xss 漏洞， 一般存在于 F。rm 表单提交 等交互功能，如发帖留言，提交文本信息等，黑客利用的 Xss 漏洞，将内容 经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出 的注入代码时，恰好将其演染执行。<br>注入页面方式不是来源于 URL，refferer，f。rms 等，而是来源于后端从数 据库中读出来的数据，不需要诱骗点击。</p><p>持久型 Xss 有以下几个特点:</p><blockquote><p>持久性,植入在数据库中<br>危害面广,甚至可以让用户机器变成 DD。S 攻击的肉鸡。<br>盗取用户敏感私密信息。</p></blockquote><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF（Cross-Site ReqUest Forgery）,跨站请求伪造攻击</p><p>CSRF是一种常见的web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p><p><strong>CSRF防御</strong></p><p>一般的 CSRF 防御也都在服务端进行，主要从以下两个方面入手：<br><strong>正确使用 GET，POST 请求和 cookie</strong><br>. GET 请求常用在查看，列举，展示等不需要改变资源属性的时候（数据库 query 查询的时候）<br>. POST 请求常用在 From 表单提交，改变一个资源的属性或者做其他一些事情的时 候（数据库有 insert、update、delete 的时候）<br><strong>在非 GET 请求中增加 token</strong><br>. 为每个用户生成一个唯一的 cookie token，所有表单都包含同一个伪随机值，但 是由于用户的 cookie 很容易由于网站的 XSS 漏洞而被盗取，所以这个方案必须 要在没有 XSS 的情况下才安全。<br>. 每个 POST 请求使用验证码，这个方案算是比较完美的，但是需要用户多次输入 验证码，用户体验比较差，所以不适合在业务中大量运用。<br>. 渲染表单的时候，为每一个表单包含一个 csrfToken，提交表单的时候，带上 csrfToken，然后在后端做 csrfToken 验证。</p><h3 id="OS命令注入"><a href="#OS命令注入" class="headerlink" title="OS命令注入"></a>OS命令注入</h3><p>os命令注入攻击指通过web应用，执行非法的操作系统命令达到攻击的<br>目的。只要在能调用she II函数的地方就有存在被攻击的风险。倘若调 用she II时存在疏漏，就可以执行插入的非法命令。</p><h2 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h2><p>SQL注入攻击的本质<br><strong>把用户输入的数据当做代码执行</strong></p>]]></content>
    
    
    <summary type="html">网络安全的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://zhangyuanhe.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>复杂网络期末复习总结</title>
    <link href="https://zhangyuanhe.top/2024/01/02/BUPT_note/Review%20of%20Complex%20network/"/>
    <id>https://zhangyuanhe.top/2024/01/02/BUPT_note/Review%20of%20Complex%20network/</id>
    <published>2024-01-02T13:00:00.000Z</published>
    <updated>2024-01-17T12:44:05.446Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h4 id="度、度分布的概念"><a href="#度、度分布的概念" class="headerlink" title="度、度分布的概念"></a><strong>度、度分布的概念</strong></h4><p>度：在网络中，度是一个用来描述节点（即网络中的个体）的重要性的概念。节点的度是指与该节点直接相连的边的数量。</p><p>度分布：度分布是描述网络中每个节点度数的概率分布。它是一个统计量，可以反映整个网络的结构特征。</p><p>节点 <code>n</code> 的度 <code>k(n) = 该节点的连接数</code></p><p>平均度  <code>&lt;k&gt;</code></p><p>度函数: <code>P(k) ： 一个随机选取的节点有 k 个连接的概率</code></p></li><li><h4 id="介数（中心性）概念"><a href="#介数（中心性）概念" class="headerlink" title="介数（中心性）概念"></a><strong>介数（中心性）概念</strong></h4><p>任意一对节点间最短路径所经过的次数<br>一个节点的介数就是一个节点在网络中所有最短路径中出现的频率<br>介数反映了相应的节点或边在整个网络中的作用和影响力，是一个全局几何量。<br>介数用于描述节点之间的连接强度和在网络中的重要性。介数可以通过计算节点之间的最短路径长度来衡量节点之间的连通性，从而反映节点在网络中的地位和作用。</p><p>介数在现实生活中的意义非常广泛，以下是列举的一些可能的现实意义：</p><ol><li>社交网络分析：介数可以帮助我们分析社交网络中节点之间的连接强度和信息传播效率。例如，高介数的节点可能在网络中扮演着信息传播的关键角色，对于社交网络中的群体动态和信息传播具有重要的影响。</li><li>网络安全：介数可以用于分析网络攻击路径和防御策略。例如，攻击者可以通过寻找高介数的节点来攻击网络，因此了解节点的介数分布可以帮助我们更好地防御网络攻击。</li><li>交通网络分析：介数可以用于分析交通网络中节点之间的连通性和运输效率。高介数的节点可能在网络中扮演着重要的交通枢纽角色，对于交通网络的运行和优化具有重要的意义。</li></ol><p><strong>介数中心性：</strong><br>从每块中的任一节点到其他某块中的任一节点的最短路径必然要经过节点H。<br>这种以经过某个节点的最短路径的数目来刻画节点重要性的指标就称为介数中心性(Betweeness centrality)，简称介数(BC)。</p><p><strong>计算介数中心性：</strong></p><p>计算介数中心性（Betweenness Centrality）通常涉及以下几个步骤：</p><ol><li><p>确定网络的最短路径:</p><ul><li>对于网络中的每一对节点 ( (s, t) )，找出所有最短路径。最短路径可以使用如Dijkstra算法或Floyd-Warshall算法来计算。</li></ul></li><li><p>计算每个节点的介数中心性:</p><ul><li>对于每个节点 ( v )（不包括起点和终点），计算在所有最短路径中 ( v ) 出现的次数。</li><li>对于每一对节点 ( (s, t) )，如果存在多条最短路径，那么每条路径对节点 ( v ) 的贡献应考虑为 ( \frac{1}{\text{路径数}} )。</li><li>对于每个节点 ( v )，其介数中心性 ( C_B(v) ) 定义为它出现在所有最短路径中的次数的总和，通常标准化为 ( \frac{C_B(v)}{(\text{节点数} - 1)(\text{节点数} - 2)&#x2F;2} )。</li></ul></li><li><p>标准化:</p><ul><li>为了使介数中心性的值与网络大小无关，通常对介数中心性进行标准化。</li></ul></li></ol></li><li><h4 id="聚集系数"><a href="#聚集系数" class="headerlink" title="聚集系数"></a><strong>聚集系数</strong></h4><p>聚类系数是一个度量网络中节点聚集成群体的倾向。具体来说，它衡量一个节点的邻居节点之间相互连接的程度。在一个给定的节点上，聚类系数计算的是该节点的邻居之间实际存在的边数与可能存在的最大边数之间的比例。</p><p>例如，在社交网络中，一个人的聚类系数高意味着他们的朋友彼此之间也很可能是朋友。高聚类系数通常表明网络中存在紧密连接的社区或群体。相反，低聚类系数可能表明网络的联系更为分散。</p><p>在复杂网络分析中，聚类系数是理解网络结构特征的重要工具，它有助于揭示网络中的社区结构、小世界特性等。不同类型的网络（如社交网络、生物网络、技术网络）的聚类系数特性可能有显著差异。</p><p>集聚系数（群系数）（Clustering coefficient）： 朋友的朋友还是不是朋友的情况</p><p>集聚系数及其分布<br>$$<br>M&#x3D;\sum_{l\in E;x,y\in N_v}\varphi^x_l\varphi^y_l\C_v&#x3D;\frac{M}{C^2_n}<br>$$<br>正则网络的集聚系数</p><p>(a) 全连接网络   <code>C = 1</code></p><p>(b) 最近邻居网络 <code>C=3/4</code></p><p>(c) 星形网络    $$C_{star}&#x3D;0\ or\ c_{star}&#x3D;1$$</p><p>随机网络的集聚系数<code>C=p=&lt;k&gt;/N&lt;&lt;1</code></p></li><li><h4 id="粒子群算法"><a href="#粒子群算法" class="headerlink" title="粒子群算法"></a><strong>粒子群算法</strong></h4><p><strong>粒子群算法是一种基于鸟群捕食行为的优化算法，它利用群体中的个体对信息的共享和运动的演化来求解问题。</strong></p><p>粒子群优化（Particle Swarm Optimization，PSO）是一种基于种群的随机优化技术，其基本思想是受到鸟群觅食行为的启示。PSO 是一种群体智能（群体智能是一组集体智能，涵盖了多代理环境下的群体交互）。在一个 PSO 算法中，有一个种群在问题空间内飞行，每个个体（在这里被称为“粒子”）都有一个由速度和位置构成的向量。粒子通过追踪最佳粒子（个人的最佳）和整个群体中的最佳粒子（全局最佳）来更新其位置和速度。</p><p>PSO 算法的基本步骤包括初始化、速度和位置的设定、个体最佳和全局最佳的设定、更新速度和位置、以及更新个体最佳和全局最佳。</p><p>PSO 算法的主要优点包括：易于实现、收敛速度快、适用于解决不同类型的问题。这些优点使得 PSO 成为机器学习、神经网络和其他优化领域的重要候选者。</p><p>但是，虽然 PSO 有其优点，但它在算法的具体实现中仍有一些挑战需要克服，如学习率的设计、维数的影响以及全局搜索的难题等。因此，在使用 PSO 时，需要根据具体问题进行调整和优化。</p></li><li><h4 id="什么是小世界网络"><a href="#什么是小世界网络" class="headerlink" title="什么是小世界网络"></a><strong>什么是小世界网络</strong></h4><p><strong>这种网络属性意味着一些彼此并不相识的人，可以通过一条很短的熟人链条被联系在一起</strong></p><p>小世界网络是一种复杂网络模型，它具有两个主要的特点：</p><ol><li>节点度分布遵循幂律分布，即节点的度k（与该节点直接相连的节点数目）服从一个非常窄的小世界网络分布。这使得网络中的很多节点具有相对较高的度，从而保证了网络的聚集程度和连通性。</li><li>网络的平均路径长度非常短，即小世界效应显著。这意味着信息在网络中的传播速度非常快，信息传播的效率非常高。</li></ol><p>这种网络结构可以解释为，在网络中，一个人的朋友的朋友可能也是他的熟人，而网络中的节点数量却远少于实际的网络连接数量。这种特性使得小世界网络模型在社交网络、社交媒体、信息传播等领域得到了广泛的应用和关注。</p></li><li><h4 id="无标度网络特点"><a href="#无标度网络特点" class="headerlink" title="无标度网络特点"></a><strong>无标度网络特点</strong></h4><p>无标度网络是一种特殊的网络模型，其特点是节点的度分布遵循幂律分布，即大多数节点的度数相对较低，但也有少数节点具有非常高的度数，呈现出一种无标度的特性。</p><p>无标度网络的特点主要体现在以下几个方面：</p><ol><li><p>节点度分布的随机性：无标度网络中的节点度数分布是随机的，而且是非均衡的。这意味着节点的度数不是均匀分布的，而是集中分布在少数几个高度的节点上。</p></li><li><p>节点度的随机涨落：无标度网络中的节点度分布存在一个标度因子，而大多数节点的度数接近这个标度因子，但少数节点可能存在较大的偏差，从而导致节点的度数存在随机涨落。</p></li><li><p>网络的自相似性：无标度网络具有自相似性，即网络中的不同尺度具有相似的结构。这意味着在网络中，不同的节点之间存在着相似的关系，而这种关系并不是完全随机的。</p></li></ol><p>总之，无标度网络是一种特殊的网络模型，具有高度聚集性和自相似性等特点。这些特点使得无标度网络在许多领域中得到了广泛的应用和关注，如社交网络、信息传播、互联网等。</p></li><li><h4 id="六度分离概念"><a href="#六度分离概念" class="headerlink" title="六度分离概念"></a><strong>六度分离概念</strong></h4><p>六度分离概念是一个社交概念，指认为世界上任何两个人之间都只有六个人连接。这个概念是由哈佛大学的心理学教授Stanley Milgram在1967年提出的，他通过“小世界理论”认为，通过六度分离，任何两个不相识的人都可以通过熟人朋友等建立联系，形成一个社会网络。这个概念也说明了社交网络中人与人之间的联系的普遍性和重要性。</p></li><li><h4 id="混沌可预测性，混沌可预测吗？可长期预测还是可短期预测"><a href="#混沌可预测性，混沌可预测吗？可长期预测还是可短期预测" class="headerlink" title="混沌可预测性，混沌可预测吗？可长期预测还是可短期预测"></a><strong>混沌可预测性，混沌可预测吗？可长期预测还是可短期预测</strong></h4><p>混沌系统是否可预测取决于预测的时间尺度。一般来说，混沌系统在短期内的行为可能具有一定的可预测性，这是因为混沌系统通常具有敏感依赖于初值的特点，这意味着小的初始扰动在系统的演化过程中可能会放大，从而导致短期内的行为表现出一定的规律性。</p><p>然而，对于长期预测，混沌系统的可预测性变得更为复杂。一方面，混沌系统的动力学性质决定了它在长期内的行为可能呈现出随机性或复杂性，表现出“蝴蝶效应”的特点，即一个小扰动可能会在大范围内产生影响。这使得混沌系统的长期预测变得非常困难，甚至是不可能的。另一方面，对于某些混沌系统，如洛伦茨吸引子和 Rossler 吸引子等，在一定的条件下，长期行为也可能具有一定的可预测性。</p><p>总的来说，混沌系统是否可预测取决于预测的时间尺度。在短期内，混沌系统可能具有一定的可预测性，而在长期内，其行为可能呈现出随机性和复杂性，不可预测。不过，通过数学模型、计算机模拟和经验数据等手段，我们可以尝试对混沌系统进行短期或长期预测，从而为实际应用提供参考。</p></li><li><h4 id="列举复杂网络相关期刊"><a href="#列举复杂网络相关期刊" class="headerlink" title="列举复杂网络相关期刊"></a><strong>列举复杂网络相关期刊</strong></h4><p>复杂网络是一个多学科交叉的研究领域，覆盖物理学、计算机科学、数学和社会科学等多个领域。以下是一些主要的与复杂网络相关的期刊及其特点：</p><ol><li>Physical Review E</li></ol><ul><li><strong>特点</strong>：专注于统计、非线性和软物质物理学的研究。它包括了复杂网络的物理和数学特性的研究。</li></ul><ol start="2"><li>Social Networks</li></ol><ul><li><strong>特点</strong>：专注于社交网络的理论和实证研究。涵盖社交网络分析的方法和应用，包括社交网络中的结构和功能。</li></ul><ol start="3"><li>Network Science</li></ol><ul><li><strong>特点</strong>：涵盖网络科学的广泛主题，包括网络结构、动态和建模。适合跨学科研究，涉及社会学、经济学、计算机科学等领域。</li></ul><ol start="4"><li>Journal of Complex Networks</li></ol><ul><li><strong>特点</strong>：集中在复杂网络的数学、物理和计算机科学方面。包括网络理论的发展和网络模型的应用。</li></ul><ol start="5"><li>Advances in Complex Systems</li></ol><ul><li><strong>特点</strong>：研究复杂系统的多学科期刊，包括复杂网络的理论和应用研究。关注系统之间的相互作用和网络行为。</li></ul><ol start="6"><li>IEEE Transactions on Network Science and Engineering</li></ol><ul><li><strong>特点</strong>：由IEEE出版，集中在网络科学和工程领域的应用研究。包括网络动力学、优化和网络中的数据分析。</li></ul><ol start="7"><li>Chaos: An Interdisciplinary Journal of Nonlinear Science</li></ol><ul><li><strong>特点</strong>：专注于混沌理论及其在各种系统中的应用，包括复杂网络。涉及物理、工程、生物学和其他自然科学领域。</li></ul><ol start="8"><li>European Physical Journal B</li></ol><ul><li><strong>特点</strong>：涵盖凝聚态物理、统计物理、原子分子和光物理等领域，包括复杂网络的物理特性研究。</li></ul><ol start="9"><li>Computational Social Networks</li></ol><ul><li><strong>特点</strong>：专注于计算方法在社交网络分析中的应用。包括网络模型、社交媒体分析和社交网络挖掘等。</li></ul><ol start="10"><li>Discrete Dynamics in Nature and Society</li></ol><ul><li><strong>特点</strong>：涉及自然和社会科学中的离散动态系统，包括网络理论、图论和应用数学在复杂系统中的应用。</li></ul></li><li><h4 id="用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值"><a href="#用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值" class="headerlink" title="用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值"></a><strong>用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值</strong></h4><p><em>下面解释用遗传算法求函数$$ f(x)&#x3D;x2, x^2[0,31]$$的最大值的一些重要步骤。这里只介绍第一代群体的生成过程与结果</em></p><p>(1) 编码<br>由于在该例中$$x\in [0,31]$$，因此，将变量x编码为5位长的二进制形式。如x&#x3D;13可表示为01101</p><p>(2) 初始群体的生成</p><p> 随机产生初始群体的每个个体，群体的大小为4(如表1).</p><p>(3)适应度计算</p><p> 将每个个体x的函数值 f(x)作为该个体的适应度。如个体01101的适应度为 $$f(13)&#x3D;13^2&#x3D;169$$<br>(4) 选择<br>计算每个个体的适应度所占的比例 $$\frac{f_i}{\sum^n_{j&#x3D;1}f_i}$$</p><p>(5) 交叉与变异</p><p>这里采用简单交叉操作：首先对配对库中的个体进行随机配对；其次，在配对个体中随机设定交叉处，配对个体彼此交换部分信息(如表1)。于是得到4个新个体，这4个新个体就形成了新一代群体。        比较新旧群体，不难发现新群体中个体适应度的平均值和最大值都有明显的提高。由此可见，新群体中的个体的确是朝着期望的方向进化了。</p></li><li><h4 id="利用混沌神经网络求解函数最小值"><a href="#利用混沌神经网络求解函数最小值" class="headerlink" title="利用混沌神经网络求解函数最小值"></a><strong>利用混沌神经网络求解函数最小值</strong></h4><p>例如，求$\min\left( x_{1}^{2} + 2x_{2}^{2} \right) &#x3D; E$</p><ol><li>求偏导</li></ol><blockquote><p>$$\frac{\partial E}{\partial x_{1}} &#x3D; 2x_{1}\frac{\partial E}{\partial x_{2}} &#x3D; 4x_{2}$$</p></blockquote><ol start="2"><li>带入混沌神经网络</li></ol><p>$$\begin{aligned}<br> &amp; x_{1}(t) &#x3D; \frac{1}{1 + e^{- y_{1}(t)\left( 1 + \varepsilon_{1}(t)) \right.\ }} \<br> &amp; y_{1}(t + 1) &#x3D; ky_{1}(t) + \alpha\left( - 2x_{1} \right) - z_{1}(t)\left( x_{1}(t) - I_{0} \right) \<br> &amp; z_{1}(t + 1) &#x3D; (1 - \beta)z_{1}(t) \<br> &amp; \varepsilon_{1}(t + 1) &#x3D; (1 - \gamma)\varepsilon_{1}(t)<br>\end{aligned}$$</p><p>$$\begin{aligned}<br> &amp; x_{2}(t) &#x3D; \frac{1}{1 + e^{- y_{2}(t)\left( 1 + \varepsilon_{2}(t)) \right.\ }} \<br> &amp; y_{2}(t + 1) &#x3D; ky_{2}(t) + \alpha\left( - 4x_{2} \right) - z_{2}(t)\left( x_{2}(t) - I_{0} \right) \<br> &amp; z_{2}(t + 1) &#x3D; (1 - \beta)z_{2}(t) \<br> &amp; \varepsilon_{2}(t + 1) &#x3D; (1 - \gamma)\varepsilon_{2}(t)<br>\end{aligned}$$</p><p>（tips！注意到，偏导的地方要写成偏导的相反数！并且有n个偏导就要写n*4个式子）</p><ol start="3"><li>使用混沌神经网络迭代计算求解，得到最小值时，$x_{1} &#x3D; 0,x_{2} &#x3D; 0$，函数值$E &#x3D; 0$。</li></ol></li><li><h4 id="交叉耦合构造散列函数"><a href="#交叉耦合构造散列函数" class="headerlink" title="交叉耦合构造散列函数"></a><strong>交叉耦合构造散列函数</strong></h4><p>该方法以交叉耦合映象格子为核心,<br>充分利用其不同于普通时空混沌系统的优良的混乱扩散特性 .首先<br>,将明文分组并行注入交叉耦合映象格子的各格点<br>.然后通过多轮混沌迭代使其具有良好的混沌特性 ,并同时利用<br>Logistic映射作为密钥生成器,对结果进行混沌调制。</p><p><strong>主模块：</strong></p><p>①将消息 M分割成 t个消息块 $M_{1}\ldots,M_{t}$ 每个消息块包含 n个字节<br>,且最后一个块填充 Mt &#x3D;＊…＊10… 0l(M).其中,<br>l(M)表示M的长度的二进制形式, 长度为 64 bit,不足 64 bit时高位添 1个介符<br>1再补 0。n可根据实际需要取值。</p><p>②将每个消息块中各字节元素按对应的ASCII码线性变换，线性变换公式为</p><p>$$C_{i,j} &#x3D; \left{ \begin{aligned}<br> &amp; - \frac{M_{i,j}}{128}\ \ \ \  &amp; &amp; 0 \leqslant A\left( M_{i,j} \right) \leqslant 127 \<br> &amp; \frac{M_{i,j} - 128}{128}\ \ \ \  &amp; &amp; 128 \leqslant A\left( M_{i,j} \right) \leqslant 225<br>\end{aligned}\ (1) \right.\ $$</p><p>③令第 i个消息块对应 $C_{i,1}\ldots,C_{i,n}$分别为交叉耦合映象格子中<br>n个格子初值,<br>且$x_{0}(1) &#x3D; C_{i,1},x_{0}(2) &#x3D; C_{i,2},\ldots,x_{0}(n) &#x3D; C_{i,n}.$其中,<br>$x_{0}(0)$和$x_{0}(n + 1)$由密钥生成模块产生.</p><p>④应用交叉耦合映象格子模型进行 R轮初值迭代, 得到<br>$x_{R}(1)\ldots,x_{R}(n).$</p><p>⑤根据式 (1), 对 $x_{R}(1)\ldots,x_{R}(n)$进行逆变换,<br>得到$X_{R}(1)\ldots,X_{R}(n).$</p><p>⑥将$X_{R}(1)\ldots,X_{R}(n).$循环左移$L_{i}$字节，得到<br>$Y_{R}(1)\ldots,Y_{R}(n).$</p><p>⑦每个消息块依次执行 ③ ～ ⑥, t个消息块即可变为 t组<br>$Y_{R}(1)\ldots,Y_{R}(n).$</p><p>⑧将得到的 t组 n字节 $Y_{R}(1)\ldots,Y_{R}(n).$按比特位异或,得到 8n bit的<br>Hash值.</p><p><strong>密钥生成模块：</strong></p><p>①将 128 bit初始密钥线性映射到 0 ～ 1之间, 作为 Logistic映射的初值。</p><p>②第 i组消息在主模块中的子密钥以第 i-1 组中第 2个子密钥的值作为初值,<br>分别迭代 100 + A(i)和 100 +A(i)+n+1轮得到.</p><p>③将最后一组消息所对应的第 2个子密钥作为初值,迭代 t轮, 得到<br>t个实数$s_{1}\ldots,s_{t}$.主模块中移动字节数 $L_{i} &#x3D; s_{i}(n - 1)$</p></li></ol>]]></content>
    
    
    <summary type="html">复杂网络期末考试的初步总结，供学弟学妹参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="复习总结" scheme="https://zhangyuanhe.top/tags/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>编译原理实验期末复习</title>
    <link href="https://zhangyuanhe.top/2024/01/01/BUPT_note/Review%20of%20Compilation%20principle/"/>
    <id>https://zhangyuanhe.top/2024/01/01/BUPT_note/Review%20of%20Compilation%20principle/</id>
    <published>2024-01-01T13:00:00.000Z</published>
    <updated>2024-01-17T14:45:28.807Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Project 1: 词法分析和语法分析</strong></p><p>在这个项目中，你将为BUPT编程语言（BPL）实现一个编译器的词法分析器和语法分析器。BPL是一种类C的编程语言，它去除了C标准中的大多数高级特性，比如宏和指针。项目的目标是编译BPL程序到MIPS32汇编代码。以下是关于词法分析和语法分析部分的详细说明。</p><p><strong>1. 词法分析 (Lexical Analysis)</strong>:</p><ul><li><strong>Flex工具</strong>: 你将使用GNU Flex生成词法分析器。Flex是一个快速的词法分析器生成器。你需要指定要匹配的令牌模式和对每个令牌应用的操作。Flex会将这些规格转换成一个NFA，然后将它转换成一个等价的DFA，并尽可能地最小化这个自动机，最终生成实现词法分析器的C代码。</li><li><strong>Flex编码</strong>: 在使用Flex时，你将使用正则表达式来定义模式，并使用C代码来定义动作。你将编写.lex文件，并通过Flex生成一个C源文件，该文件包含一个实现所有规则和相应动作的有限自动机。</li><li><strong>Flex特性</strong>: Flex还提供了一些有用的特性，如行号记录（yylineno）、输入和输出函数（input()和unput()），以及更多用于控制词法分析过程的函数。</li></ul><p><strong>2. 语法分析 (Syntax Analysis)</strong>:</p><ul><li><strong>Bison工具</strong>: 你将使用GNU Bison生成语法分析器。Bison是一个解析器生成器，你提供一个文法规范的输入，Bison将生成一个LALR(1)解析器来识别该文法的句子。这个解析器接受来自Flex的输入令牌流，以识别指定的上下文无关文法。</li><li><strong>Bison编码</strong>: 类似于Flex，Bison的源代码也包含可选的声明、定义和用户例程部分。你将为每个产生式关联一个动作，这允许你在使用该产生式进行规约时执行任何处理。你需要定义文法的每个非终结符，为每个规则指定优先级和结合性，并设置用于在词法分析器和解析器之间通信的全局变量。</li><li><strong>Bison特性</strong>: Bison还提供了一些高级特性，如符号位置信息、错误恢复和冲突解决机制等。这些特性可以帮助你更有效地实现语法分析器，并提供更稳健的错误处理和更精确的语法分析。</li></ul><p><strong>项目要求</strong>:</p><ul><li>你需要实现一个解析器，它接受单个命令行参数（BPL文件路径），并输出语法有效的BPL程序的语法树或报告代码中存在的所有词法&#x2F;语法错误。</li><li>你的解析器应该能够识别未定义字符或标记、结构非法等词法和语法错误，并为语法有效的BPL程序打印出其语法树。</li><li>你可以实现其他功能，如单行&#x2F;多行注释、宏预处理器、文件包含、for语句等。</li></ul><p>通过这个项目，你将学会如何使用现代的编译器工具（Flex和Bison）来自动化词法分析和语法分析过程，从而更深入地理解编译器前端的工作原理。同时，这也是构建编译器其他部分（如语义分析、中间代码生成、目标代码生成等）的基础。</p><p><strong>Project 2: 语义分析</strong></p><p>在Project 2中，你将继续构建BUPT编程语言（BPL）编译器的功能，专注于语义分析阶段。在前一个项目中完成词法和语法分析后，你已经能够生成语法有效的BPL程序的语法树。现在，语义分析阶段将确保程序有一个明确的定义，即验证程序的逻辑正确性，例如变量是否已声明、类型是否匹配等。</p><ol><li><p><strong>语义分析</strong>:</p><ul><li><strong>作用</strong>：语义分析主要确保程序中的所有声明和表达式在逻辑上是有意义和合法的，包括类型检查、变量声明、函数调用等。</li><li><strong>实现方式</strong>：不同于前一个项目中的工具辅助（如Flex和Bison），在这一阶段，你需要手动编写代码来实现语义分析，这可能是实现BPL编译器中最费力的部分。你需要设计各种数据结构（如符号表和数据类型表示）并仔细考虑它们最合适的实现方式。</li></ul></li><li><p><strong>符号表</strong>:</p><ul><li><strong>概述</strong>：符号表是映射名字到其关联信息的数据结构。在语义分析过程中，编译器将不断更新表中的信息以反映作用域内的内容。符号表的两个典型操作是插入和查找特定符号。</li><li><strong>实现</strong>：可以使用各种抽象数据类型来实现符号表，包括链表、二叉搜索树和哈希表。每种数据结构在空间&#x2F;时间复杂性和实现难度方面有所不同。你可以选择适合你需求的数据结构。</li></ul></li><li><p><strong>作用域检查</strong>:</p><ul><li><strong>概述</strong>：作用域检查是确定程序中的标识符是否在该位置可访问的过程。你可以使用不同的方法来实现支持作用域的符号表，比如命令式单一表方法或功能式独立表方法。</li><li><strong>实现</strong>：可以采用单一全局表，每个作用域内的符号在退出时移除；或者使用作用域栈，每个新的作用域开启一个新的符号表，并在作用域关闭时将其弹出。</li></ul></li><li><p><strong>类型检查</strong>:</p><ul><li><strong>类型系统</strong>：在编程语言中，类型是一组值和在这些值上操作的集合。BPL有两类数据类型：基本类型（由硬件直接提供，如int、char和float）和派生类型（由基本类型或派生类型聚合而成，如数组、结构体等）。</li><li><strong>类型等价性</strong>：如何确定两个类型是否等价？对于基本类型，问题很简单，例如int只等价于int。对于派生类型，事情就复杂多了。通常有两种类型等价性：命名等价性和结构等价性。命名等价性考虑类型的名称，而结构等价性考虑类型的结构。</li><li><strong>派生类型表示</strong>：实现层面上，代表原始类型使用常量就足够了。对于派生类型，例如数组和结构体，表示它们就比较复杂了。常见的技术是存储定义类型的基本信息为多级链表。</li></ul></li><li><p><strong>项目要求</strong>:</p><ul><li><strong>输入格式</strong>：与上一个项目相同，即执行文件<code>bplc</code>接受表示BPL程序路径的单个命令行参数。对于语义上合法的BPL程序，你的语义分析器不应该产生任何输出信息；否则，应该打印出有意义的错误信息。</li><li><strong>错误检测</strong>：你的分析器应该能够检测到一系列的语义错误，如未定义变量的使用、类型不匹配、函数调用参数不匹配等，并能够报告错误类型和行号。</li></ul></li></ol><p>通过这个项目，你将学习如何实现一个编译器的语义分析阶段，这是编译器理解程序并检测错误的关键环节。这个阶段需要对语言的类型系统、作用域规则和其他语义规则有深入的理解。</p><p><strong>Project 3: 中间代码生成</strong></p><ol><li><p><strong>概述</strong>：这个阶段的目的是让编译器为给定的源程序生成中间表示（IR），可以进一步优化以获得更好的运行时性能。IR是独立于机器和语言的源代码表示，大多数编译器首先将源程序翻译为某种形式的IR，然后将其转换为机器代码。IR的使用增强了抽象性，并实现了前端和后端之间更清晰的分离。大多数优化都是在中间代码上完成的。</p></li><li><p><strong>中间表示</strong>：中间表示有多种形式，包括线性IR、树IR和图IR等。这个阶段的输出是一种线性IR，特别是三地址代码（TAC），其中每条指令最多可以有三个操作数。这种IR有助于现代编译器优化，例如常量传播和死代码消除。TAC通常存储在一组四元组中，每个四元组包括一个操作符和两个源操作数及一个目标结果。</p></li><li><p><strong>运行时环境</strong>：编程语言提供了对硬件细节的抽象，但现代计算机硬件只能理解低级原语。编译器必须与操作系统配合以支持目标架构上的高级抽象，并生成额外的代码来维护高级功能。此外，编译器应该管理目标机制，以便生成的代码可以在相同的运行时环境中运行。</p></li><li><p><strong>数据表示</strong>：描述了如何在编译器中表示各种基本数据类型，包括字符、整数和布尔值等，以及指针的存储方式。此外，还介绍了如何在低级别上表示数组和结构体等复杂数据类型。</p></li><li><p><strong>函数调用</strong>：描述了函数调用的处理，包括活动函数的激活记录存储在堆栈中的细节以及参数传递的方法。详细介绍了按值传递和按引用传递这两种参数传递方式。</p></li><li><p><strong>翻译方案</strong>：要从解析树生成TAC，需要按后序遍历树，然后根据某些特定模式转换树节点。介绍了如何使用语法制导的翻译来完成此任务，并且为每个非终结符X实现一组translate_X函数。对于表达式和函数调用，提供了详细的翻译方案。</p></li><li><p><strong>项目要求</strong>：描述了项目的输入格式和假设条件，例如所有测试用例没有词法&#x2F;语法&#x2F;语义错误，只有整型原始类型变量等。这些假设意味着您可以在实现代码生成器时忽略它们的违规行为。</p></li></ol><p><strong>Project 4: 目标代码生成</strong></p><ol><li><p><strong>概述</strong>: 这个阶段是编译器工作流的最后一步，即目标代码生成。在前一阶段，三地址代码（TAC）作为中间表示（IR）已经被生成，但更底层的细节还未处理。目标代码生成是将这些三地址代码处理并最终生成可以在MIPS32机器上运行的可执行代码。</p></li><li><p><strong>实验环境</strong>: 描述了目标机器代码可以在模拟器中运行的环境设置。特别提到了SPIM模拟器，它是一个运行MIPS32程序的独立模拟器。</p></li><li><p><strong>指令选择</strong>:</p><ul><li><strong>编写MIPS32汇编</strong>: 介绍了MIPS32架构的基础知识，包括寄存器使用、数据移动和程序案例。讨论了如何将中间表示转换为机器代码，这个过程依赖于机器。</li><li><strong>翻译三地址码</strong>: 指出指令选择实际上是一个模式匹配问题。讨论了如何将TAC转换为数据操作和跳转指令，以及如何进行更优化的代码生成。</li></ul></li><li><p><strong>寄存器分配</strong>:</p><ul><li><strong>本地寄存器分配</strong>: 介绍了变量和寄存器数量的限制，以及如何在基本块内分配寄存器。探讨了寄存器分配的启发式算法，并提供了具体的寄存器分配实现例程。</li><li><strong>全局寄存器分配</strong>: 讨论了跨多个基本块分配寄存器的复杂性，并介绍了活性分析和图着色分配作为解决方案。这部分详细讨论了如何通过活性分析和图着色算法来进行有效的全局寄存器分配。</li></ul></li><li><p><strong>过程调用约定</strong>:</p><ul><li><strong>堆栈布局</strong>: 描述了堆栈帧的布局以及如何在过程调用中传递参数和返回值。讨论了寄存器和堆栈的使用约定，以及如何在过程调用中保存和恢复寄存器值。</li><li><strong>调用和返回序列</strong>: 详细说明了调用者和被调用者在过程调用中的责任，包括寄存器的保存和恢复，参数的传递，以及返回值的处理。</li></ul></li><li><p><strong>项目要求</strong>:</p><ul><li><strong>基本要求</strong>: 概述了项目的基础要求和假设条件，如中间代码的逻辑正确性，没有结构体或数组变量，以及所有整数常量都可以由MIPS32立即数表示。</li><li><strong>所需任务</strong>: 指出需要完成的两项主要任务，即寄存器分配和TAC翻译。讨论了如何设计和实现寄存器分配算法，以及如何翻译一些特定的TAC指令。</li></ul></li></ol><p>这份文档为目标代码生成阶段提供了详细的指导，包括理论知识、具体实施策略和项目要求，使学生能够理解并实现编译器的这一关键部分。<br>#</p>]]></content>
    
    
    <summary type="html">编译原理实验部分期末考试的初步总结，供学弟学妹参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="复习总结" scheme="https://zhangyuanhe.top/tags/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>信息系统安全期末复习总结</title>
    <link href="https://zhangyuanhe.top/2024/01/01/BUPT_note/Review%20of%20Information%20System%20Security/"/>
    <id>https://zhangyuanhe.top/2024/01/01/BUPT_note/Review%20of%20Information%20System%20Security/</id>
    <published>2024-01-01T13:00:00.000Z</published>
    <updated>2024-01-17T12:25:48.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h1><h2 id="信息系统概论"><a href="#信息系统概论" class="headerlink" title="信息系统概论"></a>信息系统概论</h2><h3 id="什么是信息系统"><a href="#什么是信息系统" class="headerlink" title="什么是信息系统"></a>什么是信息系统</h3><ul><li>信息系统是一个集成的组件集合，用于收集、存储和处理数据，以及传递信息、知识和数字产品。商业公司和其他组织依靠信息系统来执行和管理他们的运营、与客户和供应商互动，以及在市场上竞争。</li><li>信息系统是支持数据密集型应用程序的软件和硬件系统。</li></ul><h3 id="信息系统的架构、架构的复杂度"><a href="#信息系统的架构、架构的复杂度" class="headerlink" title="信息系统的架构、架构的复杂度"></a>信息系统的架构、架构的复杂度</h3><h4 id="单机架构"><a href="#单机架构" class="headerlink" title="*单机架构*"></a><em><strong>*单机架构*</strong></em></h4><p>在网站开设初期，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。</p><h4 id="第一次演进：Tomcat与数据库分开部署"><a href="#第一次演进：Tomcat与数据库分开部署" class="headerlink" title="*第一次演进：Tomcat与数据库分开部署*"></a><em><strong>*第一次演进：Tomcat与数据库分开部署*</strong></em></h4><p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能</p><h4 id="第二次演进：引入本地缓存和分布式缓存"><a href="#第二次演进：引入本地缓存和分布式缓存" class="headerlink" title="*第二次演进：引入本地缓存和分布式缓存*"></a><em><strong>*第二次演进：引入本地缓存和分布式缓存*</strong></em></h4><p>在Tomcat服务器增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的HTML页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力</p><h4 id="第三次演进：引入反向代理实现负载均衡"><a href="#第三次演进：引入反向代理实现负载均衡" class="headerlink" title="*第三次演进：引入反向代理实现负载均衡*"></a><em><strong>*第三次演进：引入反向代理实现负载均衡*</strong></em></h4><p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发</p><h4 id="第四次演进：数据库读、写分离"><a href="#第四次演进：数据库读、写分离" class="headerlink" title="*第四次演进：数据库读、写分离*"></a><em><strong>*第四次演进：数据库读、写分离*</strong></em></h4><p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据</p><h4 id="第五次演进：数据库按业务分库"><a href="#第五次演进：数据库按业务分库" class="headerlink" title="*第五次演进：数据库按业务分库*"></a><em><strong>*第五次演进：数据库按业务分库*</strong></em></h4><p>把不同业务的数据保存到不同的数据库中，降低业务之间的资源竞争，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决</p><h4 id="第六次演进：把大表拆分为小表"><a href="#第六次演进：把大表拆分为小表" class="headerlink" title="*第六次演进：把大表拆分为小表*"></a><em><strong>*第六次演进：把大表拆分为小表*</strong></em></h4><p>这种做法显著增加了数据库运维的难度，对DBA的要求较高!!!</p><p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀地分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能</p><h4 id="第七次演进：使用LVS或F5使多个Nginx负载均衡"><a href="#第七次演进：使用LVS或F5使多个Nginx负载均衡" class="headerlink" title="*第七次演进：使用LVS或F5使多个Nginx负载均衡*"></a><em><strong>*第七次演进：使用LVS或F5使多个Nginx负载均衡*</strong></em></h4><p>LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。</p><h4 id="第八次演进：通过DNS轮询实现机房间的负载均衡"><a href="#第八次演进：通过DNS轮询实现机房间的负载均衡" class="headerlink" title="*第八次演进：通过DNS轮询实现机房间的负载均衡*"></a><em><strong>*第八次演进：通过DNS轮询实现机房间的负载均衡*</strong></em></h4><p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href="http://www.taobao.com时,dns服务器会使用轮询策略或其他策略,来选择某个ip供用户访问/">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问</a></p><h4 id="第九次演进：引入NoSQL数据库和搜索引擎等技术"><a href="#第九次演进：引入NoSQL数据库和搜索引擎等技术" class="headerlink" title="*第九次演进：引入NoSQL数据库和搜索引擎等技术*"></a><em><strong>*第九次演进：引入NoSQL数据库和搜索引擎等技术*</strong></em></h4><p>针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key&#x2F;value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决</p><h4 id="第十次演进：大应用拆分为小应用"><a href="#第十次演进：大应用拆分为小应用" class="headerlink" title="*第十次演进：大应用拆分为小应用*"></a><em><strong>*第十次演进：大应用拆分为小应用*</strong></em></h4><p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决</p><h4 id="第十一次演进：复用的功能抽离成微服务"><a href="#第十一次演进：复用的功能抽离成微服务" class="headerlink" title="*第十一次演进：复用的功能抽离成微服务*"></a><em><strong>*第十一次演进：复用的功能抽离成微服务*</strong></em></h4><p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理</p><h4 id="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"><a href="#第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异" class="headerlink" title="*第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异*"></a><em><strong>*第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异*</strong></em></h4><p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构</p><h2 id="信息系统安全概论"><a href="#信息系统安全概论" class="headerlink" title="信息系统安全概论"></a>信息系统安全概论</h2><h3 id="信息系统常见的安全威胁"><a href="#信息系统常见的安全威胁" class="headerlink" title="信息系统常见的安全威胁"></a>信息系统常见的安全威胁</h3><h4 id="自然威胁"><a href="#自然威胁" class="headerlink" title="自然威胁"></a>自然威胁</h4><p>自然威胁通常不是故意造成的，但它们会对信息系统产生破坏性影响。</p><ol><li><p><strong>自然灾害</strong>：</p><ul><li>地震：可能破坏服务器室、数据中心和其他基础设施。</li><li>洪水：可能泛滥至关键设施，导致硬件损坏和数据丢失。</li><li>风暴和雷击：可能引起停电或电力浪涌，损坏设备。</li></ul></li><li><p><strong>火灾</strong>：</p><ul><li>火灾可能会摧毁物理设施，包括服务器、网络设备等。</li></ul></li><li><p><strong>环境变化</strong>：</p><ul><li>温度变化或湿度过高或过低都可能对敏感设备造成损害。</li></ul></li></ol><h4 id="人为威胁"><a href="#人为威胁" class="headerlink" title="人为威胁"></a>人为威胁</h4><p>人为威胁通常是有意为之的，旨在从中获利或者对信息系统产生破坏。</p><ol><li><strong>恶意软件攻击</strong>：<ul><li>病毒、蠕虫、特洛伊木马、勒索软件等。</li></ul></li><li><strong>网络钓鱼和社会工程</strong>：<ul><li>攻击者诱导用户提供敏感数据或执行不安全操作。</li></ul></li><li><strong>内部威胁</strong>：<ul><li>滥用权限、数据泄露或内部破坏活动。</li></ul></li><li><strong>数据泄露</strong>：<ul><li>由于不当的数据处理或安全措施不足导致敏感信息外泄。</li></ul></li><li><strong>篡改和破坏</strong>：<ul><li>数据或软件的故意篡改，以及对硬件的物理破坏。</li></ul></li><li><strong>拒绝服务（DoS&#x2F;DDoS）攻击</strong>：<ul><li>通过大量请求使网络服务不可用。</li></ul></li><li><strong>身份盗窃和冒用</strong>：<ul><li>盗用他人身份访问受限资源。</li></ul></li><li><strong>刻意的信息分发</strong>：<ul><li>例如，泄露机密文件，可能是出于政治、个人利益或其他原因.</li></ul></li></ol><h3 id="信息系统安全的概念"><a href="#信息系统安全的概念" class="headerlink" title="信息系统安全的概念"></a>信息系统安全的概念</h3><p>（1）基于信息保障的理解，信息系统安全保障是在信息系统的整个生命周期中，通过对信息系统的风险分析，制定并执行相应的安全保障策略，从技术、管理、工程和人员等方面提出安全保障要求，确保信息系统的保密性、完整性和可用性，降低安全风险到可接受的程度，从而保障系统实现组织机构的使命;</p><p>（2）基于风险控制的理解，即把系统的风险控制到一个可以接受的范围之内；</p><p>（3）基于状态迁移的理解，即系统的状态无论怎么迁移，也不可能进入对应不安全</p><p>状态的空间；</p><p>（4）基于时间的理解，即发现攻击的时间+做出响应的时间&lt;黑客实现攻击的时间；</p><p>（5）基于安全体系架构的理解，以云计算为例，讲稿提供了多种典型安全架构，它</p><p>们要么提供很好的隔离性，要么以可信、可控的方式，可以保证信息系统的业务连</p><p>续性。</p><p>（6）基于安全策略的理解，即一个信息系统是“安全系统”，指的是该系统达到了</p><p>当初设计时所制定的安全策略的要求。</p><h2 id="安全需求和安全策略"><a href="#安全需求和安全策略" class="headerlink" title="安全需求和安全策略"></a>安全需求和安全策略</h2><h3 id="安全需求，一般性的安全需求"><a href="#安全需求，一般性的安全需求" class="headerlink" title="安全需求，一般性的安全需求"></a>安全需求，一般性的安全需求</h3><p><strong>安全需求</strong>：就是在设计一个安全系统时<strong>期望得到的安全保障</strong></p><p><strong>一般性的安全需求</strong></p><p><strong>机密性需求</strong>，防止信息被泄漏给未授权的用户</p><p>​自主安全策略、强制安全策略；需知原则</p><p><strong>完整性需求，</strong>防止未授权用户对信息的修改</p><p>​维护系统资源在一个有效的、预期的状态，防止资源被不正确、不适当的修改；维</p><p>​护系统不同部分的一致性；防止在涉及记账或审计的事件中“舞弊”行为的发生。</p><p><strong>可用性需求，</strong>保证授权用户对系统信息的可访问性</p><p>​“授权用户的任何正确的输入，系统会有相应的正确的输出”</p><p><strong>可记账性需求，</strong>防止用户对访问过某信息或执行过某一操作以否认</p><p>​可对发生的事件、操作等进行回溯</p><h3 id="安全策略：访问控制策略（包括-DAC、MAC-等），如何从安全策略的角度理解信息系统安全"><a href="#安全策略：访问控制策略（包括-DAC、MAC-等），如何从安全策略的角度理解信息系统安全" class="headerlink" title="安全策略：访问控制策略（包括 DAC、MAC 等），如何从安全策略的角度理解信息系统安全"></a>安全策略：访问控制策略（包括 DAC、MAC 等），如何从安全策略的角度理解信息系统安全</h3><p>最典型的安全策略是自主访问控制策略DAC和强制访问控制策略MAC，它们描绘了大部分系统的实际需求，并且这两类策略在多数安 全系统中都提供了相应的实施机制。</p><p><strong>自主访问控制策略</strong></p><p>允许系统中信息的拥有者按照自己的意愿去指定谁可以以何种访问模式去访问该客体</p><p>❖ 自主访问控制策略通常</p><p>➢ 基于系统内用户（如用户ID），加上对用户的访问授权（如权能表），或者客体的访问属性（如访问控制表ACL）来决定该用户是否有某权限访问该客体</p><p>❖ 或者基于要访问信息的内容</p><p>❖ 或者基于用户当时所处的角色</p><p><strong>强制访问控制策略</strong></p><p>在强制访问控制系统中，所有主体（用户，进程）和客体（文件，数据）都被分配了安全标签，安全标签标识一个安全等级。</p><p>➢ 主体（用户，进程）被分配一个安全等级</p><p>➢ 客体（文件，数据）也被分配一个安全等级</p><p>➢ 访问控制执行时对主体和客体的安全级别进行比较</p><p><strong>访问控制策略的组成</strong></p><p><strong>主体</strong></p><p>系统内行为的发起者。通常是用户发起的进程</p><p><strong>客体</strong></p><p>系统内所有主体行为的直接承担者</p><p><strong>系统环境（上下文）</strong></p><p>系统主、客体属性之外的某些状态</p><p>从安全策略的角度理解信息系统安全涉及到制定一套全面的指导原则和框架，这些原则和框架能够指导组织在技术、流程和人力层面上采取措施，以确保信息系统的保密性、完整性和可用性。</p><h3 id="主体、客体及其属性"><a href="#主体、客体及其属性" class="headerlink" title="主体、客体及其属性"></a>主体、客体及其属性</h3><p><strong>主体是系统内行为的发起者，通常是用户发起的进程</strong></p><p>​<strong>信息的访问者（用户）</strong></p><p>​一个获得授权可以访问系统资源的自然人。</p><p>​授权包括：对信息的读&#x2F;写&#x2F;删除&#x2F;追加&#x2F;执行以及授予&#x2F;撤销另外一个用户对信息的访问权限等。</p><p>​<strong>信息的拥有者</strong></p><p>​该用户拥有对此信息的完全处理权限，除非该信息被系统另外加以访问控制。</p><p>​<strong>系统管理员</strong></p><p>​为使系统能正常运转，而对系统的运行进行管理的用户</p><p><strong>主体属性</strong></p><p>​<strong>用户ID&#x2F;组ID</strong> </p><p>​例如用于Unix按位的访问控制、常规自主访问控制</p><p>​<strong>用户访问许可级别</strong></p><p>​例如用于强制访问控制。</p><p>​<strong>权能表</strong></p><p>​例如用于强制访问控制。</p><p>​<strong>角色</strong></p><p>​例如用于Unix按位的访问控制、常规自主访问控制</p><p><strong>访问控制策略的相关方⎯⎯客体</strong></p><p>​<strong>一般客体</strong></p><p>​在系统内以客观、具体的形式存在的信息实体，如文件、目录等</p><p>​<strong>设备客体</strong></p><p>​指系统内的设备，如软盘、打印机等</p><p>​<strong>特殊客体</strong></p><p>​某些主体</p><p><strong>客体属性</strong></p><p>​<strong>敏感性标签</strong></p><p>​一个敏感性标签由2部分组成：信息的敏感性级别和范畴</p><p>​<strong>访问控制列表</strong></p><p>​表示系统中哪些用户可以对此信息进行何种访问</p><p>​由信息的拥有者加以管理</p><h3 id="访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码"><a href="#访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码" class="headerlink" title="访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码"></a>访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码</h3><p><strong>标准ACL_靠近目的地址</strong></p><p>只使用数据包的源地址作为测试条件。所有决定是基于源IP地址的。</p><p>标准访问列表的创建根据 “动作”＋“源地址” ，即允许谁、拒绝谁的方法来创建</p><p><strong>扩展ACL——基于源地址、目的地址、协议、端口_靠近源地址</strong></p><p>可以测试IP包的第3层和第4层报头中的字段。包括源IP地址、目的IP地址、网络层报头中的协议字段（如，TCP、UDP、ICMP等）以及位于传输层报头中的端口号。</p><p><strong>通配掩码</strong></p><p>路由器使用<strong>IP地址</strong>和<strong>通配掩码</strong>（wildcard-mask）一起来分辨匹配的地址范围，它跟子网掩码刚好相反。</p><p>它不像子网掩码告诉路由器IP地址的哪一位属于网络号一样，通配符掩码告诉路由器为了判断出匹配，它需要检查IP地址中的多少位。</p><p><strong>通配掩码某位是0</strong>表示检查相应bit位的值</p><p><strong>通配掩码某位是1</strong>表示不检查（忽略）相应位的值</p><h2 id="信息系统的风险评估"><a href="#信息系统的风险评估" class="headerlink" title="信息系统的风险评估"></a>信息系统的风险评估</h2><h3 id="风险的概念"><a href="#风险的概念" class="headerlink" title="风险的概念"></a>风险的概念</h3><p>风险指在某一特定环境下，在某一特定时间段内，特定的威胁利用资产的一种或一组薄弱点，导致资产的丢失或损害的潜在可能性，即特定威胁事件发生的可能性与后果的结合。</p><h3 id="什么是安全风险评估"><a href="#什么是安全风险评估" class="headerlink" title="什么是安全风险评估"></a>什么是安全风险评估</h3><p><strong>安全风险组成的四要素：</strong>信息系统资产（Asset）、信息系统脆弱性（Vulnerability）、信息安全威胁（Threat）、信息系统安全保 护措施（Safeguard）。</p><h3 id="风险评估的要素"><a href="#风险评估的要素" class="headerlink" title="风险评估的要素"></a>风险评估的要素</h3><p><strong>风险评估围绕着资产、威胁、脆弱性和安全措施这些基本要素展开。</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220191732221.png" alt="image-20231220191732221"></p><h2 id="信息系统等级保护"><a href="#信息系统等级保护" class="headerlink" title="信息系统等级保护"></a>信息系统等级保护</h2><h3 id="什么是等级保护，等级保护是《网络安全法》规定的一项基本制度"><a href="#什么是等级保护，等级保护是《网络安全法》规定的一项基本制度" class="headerlink" title="什么是等级保护，等级保护是《网络安全法》规定的一项基本制度"></a>什么是等级保护，等级保护是《网络安全法》规定的一项基本制度</h3><p><strong>网络安全等级保护是指对国家重要信息、法人和其他组织及公民的专有信息以及公开信息和存储、传输、处理这些信息的信息系统分等级实行安全保护，对信息系统中使用的信息安全产品实行按等级管理，对信息系统中发生的信息安全事件分等级响应、处置。</strong></p><p><strong>网络安全等级保护工作包括定级、备案、建设整改、等级测评、监督检查五个阶段。</strong></p><h2 id="信息系统的物理安全"><a href="#信息系统的物理安全" class="headerlink" title="信息系统的物理安全"></a>信息系统的物理安全</h2><h3 id="物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等"><a href="#物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等" class="headerlink" title="物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等"></a>物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等</h3><p><strong>环境安全</strong></p><p>对系统所在环境的安全保护</p><p>​<strong>机房三度要求</strong></p><p>​温度&#x2F;湿度&#x2F;洁净度</p><p>​<strong>防火与防水要求</strong></p><p>​为避免火灾、水灾，应采取如下具体措施:</p><p>​（1）隔离</p><p>​（2）火灾报警系统</p><p>​（3）灭火设施</p><p>​（4）管理措施</p><p>​<strong>机房防盗要求</strong></p><p>​<strong>机房防鼠</strong></p><p>​<strong>防静电措施</strong></p><p>​<strong>接地要求</strong></p><p>​<strong>防雷击措施</strong></p><p>​<strong>机房选址要求</strong></p><p><strong>线路安全</strong></p><p>窃听&#x2F;搭线窃听&#x2F;海底电缆窃听</p><p>光纤通信技术</p><p><strong>电源系统安全</strong></p><p>不间断电源（UPS）</p><p><strong>介质安全：</strong>电磁战</p><h3 id="电磁泄漏"><a href="#电磁泄漏" class="headerlink" title="电磁泄漏"></a>电磁泄漏</h3><p>电磁分析攻击作为最有效的旁路攻击技术之一，是通过在密码芯片周围放置线圈，测量芯片在运算期间辐射的电磁信号，研究电磁场与内部处理数据之间的相关性而获取内部秘密参量。</p><h3 id="电源调整器，不间断电源（UPS）"><a href="#电源调整器，不间断电源（UPS）" class="headerlink" title="电源调整器，不间断电源（UPS）"></a>电源调整器，不间断电源（UPS）</h3><h2 id="信息系统的可靠性"><a href="#信息系统的可靠性" class="headerlink" title="信息系统的可靠性"></a>信息系统的可靠性</h2><h3 id="可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）"><a href="#可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）" class="headerlink" title="可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）;"></a>可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）;</h3><h3 id="可维修产品、不可维修产品的可靠性指标，可用度"><a href="#可维修产品、不可维修产品的可靠性指标，可用度" class="headerlink" title="可维修产品、不可维修产品的可靠性指标，可用度"></a>可维修产品、不可维修产品的可靠性指标，可用度</h3><h4 id="可靠性的定义"><a href="#可靠性的定义" class="headerlink" title="*可靠性的定义*"></a><em><strong>*可靠性的定义*</strong></em></h4><p>在规定的条件下、在给定的时间内，系统能实施应有功能的能力。</p><h4 id="可靠性参数"><a href="#可靠性参数" class="headerlink" title="*可靠性参数*"></a><em><strong>*可靠性参数*</strong></em></h4><p>$T_{MTTF}：$平均失效前时间  <strong>不可修系统</strong></p><p>$T_{MTBF}：$平均故障间隔时间  <strong>可修系统</strong></p><p>$R：$<em><strong>*可靠度*</strong></em></p><p>$λ：$<em><strong>*失效率*</strong></em></p><h4 id="寿命"><a href="#寿命" class="headerlink" title="*寿命*"></a><em><strong>*寿命*</strong></em></h4><p>通常用一个非负随机变量$X$来描述产品的寿命。</p><p>$X$的分布函数为</p><p>$F(t) &#x3D; P{X \le t}，t\ge0$</p><p>有了寿命分布<em>F</em>(<em>t</em>) ，就知道产品的平均寿命</p><p>$EX&#x3D;\int_0^\infty tdF(t)$</p><h4 id="可靠度R"><a href="#可靠度R" class="headerlink" title="可靠度R"></a>可靠度R</h4><p>产品在时刻 <em>t</em> 之前都正常工作（不失效）的概率，即产品在时刻 <em>t</em>的生存概率，称为无故障工作概率（可靠度函数）</p><p>$$ R(t)&#x3D;P{X&gt;t}&#x3D;\int_0^\infty dF(t)&#x3D;\int_0^\infty f(t)dt \ 𝑹(t) +F(t)&#x3D;1$$</p><blockquote><p>假设 C 是一个具有 <em>N</em> 个元器件的数字系统，在一定的条件和环境（如温度、湿度、电压等）下运行，并且随着时间 <em>t</em> 的推移质量逐步下降</p></blockquote><p>系统<strong>C</strong>在时刻 <em>t</em> 能正常工作的概率<em>R(t)&#x3D;S(t)&#x2F;N</em></p><p>**<em>R</em>(<em>t</em>)**称为系统 <strong>C</strong> 在时刻 <em>t</em> 的可靠度。</p><h4 id="失效率λ"><a href="#失效率λ" class="headerlink" title="失效率λ"></a>失效率λ</h4><p>假设<em>F</em>(<em>t</em>)是绝对连续的，即存在分布密度函数$<em>f(t)&#x3D;F’(t)</em>$且$F(t)&#x3D;\int_0^tf(x)dx$</p><blockquote><p>将发生故障的条件概率密度叫做失效率。 $λ(t)&#x3D;f(t)&#x2F;R(t)&#x3D;-R’(t)&#x2F;R(t)$ 失效率**λ(<em>t</em>)**表示系统中元器件失效的速率。</p></blockquote><h4 id="λ-t-的浴缸形曲线（Bathtub-curve）"><a href="#λ-t-的浴缸形曲线（Bathtub-curve）" class="headerlink" title="λ(t)的浴缸形曲线（Bathtub-curve）"></a>λ(t)的浴缸形曲线（Bathtub-curve）</h4><p><strong>第一阶段 早期失效期（Infant Mortality）</strong></p><p>器件在开始使用时失效率很高，但随着产品工作时间的增加，失效率迅速降低。这一阶段失效的原因大多是由于设计、原材料和制造过程中的缺陷造成的。为了缩短这一阶段的时间，产品应在投入运行前进行试运转，以便及早发现、修正和排除故障；或通过试验进行筛选，剔除不合格品。</p><p><strong>第二阶段 偶然失效期，也称随机失效期（Random Failures）</strong></p><p>这一阶段的特点是失效率较低，且较稳定，往往可近似看作常数。这一时期是产品的良好使用阶段。由于在这一阶段中，产品失效率近似为一常数，故设<em></em>(<em>t</em>)&#x3D;<em>λ</em>（常数）由可靠度计算公式得$R(t)&#x3D;e^{-λt}$ 这一式表明<strong>设备的可靠性与失效率成指数关系</strong>。</p><p><strong>第三阶段 耗损失效期（Wearout）</strong></p><p>该阶段的失效率随时间的延长而急速增加，主要原因是器件的损失己非常的严重，寿命快到尽头了，可适当的维修或直接更换。</p><p>R(t)和λ的关系</p><p>可靠性不仅是时间<em>t</em>的函数，而且与失效率****λ****有着密切的关联。</p><p>$$ R(t)&#x3D;e^{\int^t_0\lambda(t)dt } $$</p><h4 id="可维修产品的平均维修时间"><a href="#可维修产品的平均维修时间" class="headerlink" title="*可维修产品的平均维修时间*"></a><em><strong>*可维修产品的平均维修时间*</strong></em></h4><p>可维修产品的可维护性平均维修时间（MTTR，Mean Time To Repair）来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间（即设备处于故障状态时间的平均值，或设备修复时间的平均值）。系统的可维护性越好，平均维修时间越短</p><p>$$ MTTR&#x3D;\int^\infty _0t\mu(t)dt$$</p><blockquote><p>$<em>\mu(t)</em>$是维修时间的概率密度函数</p></blockquote><h4 id="可维修产品的维修性指标：可用性"><a href="#可维修产品的维修性指标：可用性" class="headerlink" title="*可维修产品的维修性指标：可用性*"></a><em><strong>*可维修产品的维修性指标：可用性*</strong></em></h4><p>可维修产品的可用性定义为：</p><p>$$ \frac{MTBF}{MTBF+MTTR}*100% $$</p><p><strong>计算机系统可靠性举例</strong></p><p>已知世界上第一代电子管计算机ENIAC有20000个电子管，假 设每个电子管的失效率为&#x3D;0.5%&#x2F;kh（千小时），试求： （1）该计算机的MTTF； （2）若要求计算机的可靠性在95%以上，则至多可以工作多久？</p><p>$$ MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i}&#x3D;\frac{1}{\frac{0.05}{100}*\frac{1}{1000}*20000}&#x3D;\frac{1}{0.01}&#x3D;100H\ R(t)&#x3D;e^{-\frac{t}{MTTF}}\ t&#x3D;5H $$</p><h3 id="容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术"><a href="#容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术" class="headerlink" title="容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术"></a>容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术</h3><h4 id="故障检测和诊断"><a href="#故障检测和诊断" class="headerlink" title="故障检测和诊断"></a><strong>故障检测和诊断</strong></h4><p>故障检测（Fault Detection）：判断系统是否存在故障的过程故障检测的作用是确认系统是否发生了故障，指示故障的状态，即查找故障源和故障性质。一般来说，故障检测只能找到错误点（错误单元），不能准确找到故障点。</p><p>故障诊断（Fault Diagnosis）：检测出系统存在故障后要进行故障的定位，找出故障所在的位置。</p><h4 id="故障屏蔽技术"><a href="#故障屏蔽技术" class="headerlink" title="故障屏蔽技术"></a><strong>故障屏蔽技术</strong></h4><p>故障屏蔽技术是防止系统中的故障在该系统的信息结构中产生差错的各种措施的总称，其实质是在故障效应达到模块的输出以前，利用冗余资源将故障影响掩盖起来，达到容错目的。</p><h4 id="冗余技术"><a href="#冗余技术" class="headerlink" title="冗余技术"></a><strong>冗余技术</strong></h4><p>硬件冗余</p><p>时间冗余</p><p>软件冗余</p><p>信息冗余:<strong>奇偶校验</strong></p><p>所谓冗余就是超过系统实现正常功能的额外资源。</p><p><strong>硬件冗余：三模冗余</strong></p><p>三模冗余可以由用户手动完成，也可以依靠工具完成。Xilinx推出了XIlInXtMrtool ，可以方便地实现三模冗余设计，并且可以方便地配置被冗余项，大大方便了用户。</p><p><strong>时间冗余技术</strong></p><p>基本思想：重复执行指令或者一段程序来消除故障的影响，以达到容错的效果，它是用消耗时间来换取容错的目的</p><p><strong>三模冗余（TMR）</strong>是一种常见的容错技术，通过三个相同的系统或组件并行工作，并使用投票逻辑来确定最终输出。这种方式可以容忍一个子系统的故障，因为即便有一个子系统产生错误输出，另外两个正确的输出可以通过多数表决来决定正确的响应。</p><p>然而，TMR也有潜在的弱点，例如如果两个系统同时失败并产生了相同的错误输出，TMR可能会选择错误的结果。为了改进TMR的容错能力，可以采取以下措施：</p><h5 id="1-错误检测与恢复"><a href="#1-错误检测与恢复" class="headerlink" title="1. 错误检测与恢复"></a>1. 错误检测与恢复</h5><ul><li><strong>自我检查</strong>：在TMR系统中加入自检逻辑，使得每个模块在表决过程之前进行错误检查。</li><li><strong>错误恢复</strong>：当检测到错误时，启动错误恢复机制，如重置或重新同步该模块。</li><li><strong>动态重新配置</strong>：如果确定某个模块故障，可以动态将其从系统中移除并替换。</li></ul><h5 id="2-多数表决器与冗余"><a href="#2-多数表决器与冗余" class="headerlink" title="2. 多数表决器与冗余"></a>2. 多数表决器与冗余</h5><ul><li><strong>增加冗余级别</strong>：使用四模或更多模冗余系统来提高容错能力，如N模冗余可以容忍N&#x2F;2-1个错误。</li><li><strong>改进表决逻辑</strong>：采用更复杂的表决机制，例如加权表决、模糊逻辑表决或基于信任度的表决，以识别最可靠的模块输出。</li></ul><h5 id="3-组合多种容错技术"><a href="#3-组合多种容错技术" class="headerlink" title="3. 组合多种容错技术"></a>3. 组合多种容错技术</h5><ul><li><strong>时间冗余</strong>：在TMR系统中加入时间冗余技术，如回滚恢复或检查点，以便在出现错误时回到之前的状态。</li><li><strong>软件冗余</strong>：在不同的模块上运行不同版本的软件或算法（N版本编程），以降低软件故障的影响。</li></ul><h5 id="4-故障隔离与恢复"><a href="#4-故障隔离与恢复" class="headerlink" title="4. 故障隔离与恢复"></a>4. 故障隔离与恢复</h5><ul><li><strong>故障隔离</strong>：在系统中加入故障隔离机制，如隔离故障模块，阻止其影响其他模块。</li><li><strong>定期测试与维护</strong>：定期进行系统测试，以确保每个模块都在正常工作状态，并进行必要的维护和更新。</li></ul><h5 id="5-使用先进算法"><a href="#5-使用先进算法" class="headerlink" title="5. 使用先进算法"></a>5. 使用先进算法</h5><ul><li><strong>预测性故障处理</strong>：使用人工智能或机器学习算法来预测故障并提前处理，以减少故障的影响。</li><li><strong>比较和分析系统行为</strong>：对系统的行为进行实时分析，比较其与预期行为的差异来预测潜在的故障。</li></ul><p>通过结合这些改进措施，可以提高TMR系统的可靠性和容错能力，减少判决错误的可能性。然而，每种措施都可能带来额外的成本和复杂性，因此需要根据应用的关键性和可用资源来平衡设计选择。</p><h3 id="RAID-56重要"><a href="#RAID-56重要" class="headerlink" title="RAID(56重要)"></a>RAID(56重要)</h3><p>廉价磁盘冗余阵列（Redundant Arrays of Inexpensive Disks），以多个低成本磁盘构成磁盘子系统，提供比单一硬盘更完备的可靠性和高性能</p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220230358791.png" alt="image-20231220230358791"></p><p><strong>数据基带条阵列（RAID0）</strong></p><p>分块无校验型，无冗余存储。简单将数据分配到各个磁盘上，不提供真正容错性。带区化至少需要2个硬盘，可支持8&#x2F;16&#x2F;32个磁盘</p><p>优点</p><p>➢ 允许多个小区组合成一个大分</p><p>➢ 更好地利用磁盘空间，延长磁盘寿命</p><p>➢ 多个硬盘并行工作，提高了读写性能</p><p>缺点</p><p>➢ 不提供数据保护，任一磁盘失效，数据可能丢失，且不能自动恢复。</p><p><strong>磁盘镜象（RAID1）</strong></p><p>每一组盘至少两台，数据同时以同样的方式写到两个盘上，两个盘互为镜象。磁盘镜象可以是分区镜象、全盘镜象。容错方式以空间换取，实施可以采用镜象或者双工技术</p><p>优点</p><p>➢ 可靠性高，策略简单，恢复数据时不必停机。</p><p>缺点</p><p>➢ 有效容量只有总容量的1&#x2F;2，利用率50%。由于磁盘冗余，硬件开销较大，成本较高</p><p><strong>循环奇偶校验阵列（RAID5）</strong></p><p>与RAID4类似，但校验数据不固定在一个磁盘上，而是循环地依次分布在不同的磁盘上，也称块间插入分布校验。它是目前采用最多、最流行的方式，至少需要3个硬盘。</p><p>优点</p><p>➢ 校验分布在多个磁盘中，写操作可以同时处理；</p><p>➢ 为读操作提供了最优的性能；</p><p>➢ 一个磁盘失效，分布在其他盘上的信息足够完成数据重建 </p><p>缺点</p><p>➢ 数据重建会降低读性能；</p><p>➢ 每次计算校验信息，写操作开销会增大，是一般存储操作时间的3倍。</p><p><strong>二维奇偶校验阵列（RAID6）</strong></p><p>RAID6是指带有两种分布存储的检验信息的磁盘阵列，它是对RAID5的扩展，主要是用于要求数据绝对不能出错的场合，使用了二种奇偶校验方法，需要N+2个磁盘</p><h3 id="纠删码（Erasure-Code）"><a href="#纠删码（Erasure-Code）" class="headerlink" title="纠删码（Erasure Code）"></a>纠删码（Erasure Code）</h3><p>是一种前向错误纠正技术（Forward ErrorCorrection，FEC），主要应用在网络传输中避免包的丢失，存储系统利用它来提高存储可靠性。相比多副本复制而言， 纠删码能够以更小的数据冗余度获得更高数据可靠性， 但编码方式较复杂，需要大量计算 。</p><p>EC的定义：Erasure Code是一种编码技术，它可以将n份原始数据，增加m份数据，并能通过n+m份中的任意n份数据，还原为原始数据。即如果有任意小于等于m份的数据失效，仍然能通过剩下的数据还原出来。</p><h2 id="计算机取证"><a href="#计算机取证" class="headerlink" title="计算机取证"></a>计算机取证</h2><h3 id="什么是计算机取证"><a href="#什么是计算机取证" class="headerlink" title="什么是计算机取证"></a>什么是计算机取证</h3><p><strong>计算机取证不过是简单地将计算机调查和分析技术应用于对潜在的、有法律效力的证据的确定与获取上。</strong></p><p><strong>计算机取证是使用软件和工具，按照一些预先定义的程序全面地检查计算机系统，以提取和保护有关计算机犯罪的证据。</strong></p><p>综合：<strong>计算机取证是指对能够为法庭接受的、足够可靠和有说服性的，存在于计算机和相关外设中的计算机证据的确认、保护、提取和归档的过程。</strong></p><h3 id="潜在证据"><a href="#潜在证据" class="headerlink" title="潜在证据"></a>潜在证据</h3><p><strong>证据通常都是在可以存储数据的硬件驱动器、存储设备或媒体中发现的。</strong></p><p>计算机取证是指使用科学方法和技术收集、保存、分析计算机系统、网络、通信设备中的数据，以作为法庭上的证据。在计算机取证过程中，潜在证据可能包括各种形式的数据和信息，这些数据可能存储在不同的地方，包括但不限于：</p><ol><li><p><strong>硬盘驱动器：</strong> 存储在硬盘上的文件、删除的文件、隐藏或未分配的磁盘空间中的数据、日志文件、系统恢复点和磁盘映像。</p></li><li><p><strong>移动存储设备：</strong> 如USB闪存驱动器、外部硬盘、SD卡、手机及其他便携式存储媒介中的数据。</p></li><li><p><strong>操作系统日志：</strong> 包括系统事件日志、安全日志、应用程序日志，它们记录了用户活动、系统错误、登录尝试和其他系统事件。</p></li><li><p><strong>网络设备：</strong> 如路由器、交换机、防火墙的日志文件，以及其他网络传输数据，可能包括网络流量、IP地址、MAC地址、传输的数据包等。</p></li><li><p><strong>云存储和服务：</strong> 云端的数据，包括在线文档、电子邮件、日历、通讯录、上传的照片和视频等。</p></li><li><p><strong>电子邮件：</strong> 电子邮件内容、附件、邮件头信息、已删除的邮件等。</p></li><li><p><strong>浏览器历史记录：</strong> 包括网页浏览历史、下载历史、书签、Cookies、缓存文件等。</p></li><li><p><strong>社交媒体：</strong> 社交网络上的帐户信息、聊天记录、发布的内容、好友列表、登录时间等。</p></li><li><p><strong>软件和应用程序：</strong> 安装在系统上的软件和应用程序可能包含有关用户行为的信息。</p></li><li><p><strong>内存：</strong> RAM中可以找到许多运行时的信息，如正在或最近运行的程序、系统状态、打开的文件等。</p></li><li><p><strong>元数据：</strong> 文件和文档的元数据，如创建时间、最后修改时间、作者信息等。</p></li><li><p><strong>加密的数据：</strong> 加密文件、硬盘或设备，需要破解密码才能访问其中的数据。</p></li><li><p><strong>日志文件：</strong> 各种系统和应用程序生成的日志文件记录了许多系统事件和用户活动。</p></li><li><p><strong>注册表信息：</strong> Windows注册表包含了系统和应用程序的配置信息，用户活动和设备使用记录。</p></li></ol><p>在进行计算机取证时，不仅要收集上述信息，还需要保持证据的完整性和可用性。这通常涉及到创建原始数据的完整副本（即制作镜像）并使用哈希值来保证数据未被更改。取证分析人员应该遵循严格的程序和协议，确保证据链完整且在法律程序中可以接受。</p><h2 id="操作系统安全"><a href="#操作系统安全" class="headerlink" title="操作系统安全"></a>操作系统安全</h2><h3 id="操作系统安全的概念"><a href="#操作系统安全的概念" class="headerlink" title="操作系统安全的概念"></a>操作系统安全的概念</h3><p>操作系统安全是指一系列的措施和技术，旨在保护操作系统免受未经授权访问、使用、泄露、破坏、修改或拒绝服务攻击。操作系统是计算机硬件和用户之间的接口，它管理着计算机资源和应用程序的执行。由于操作系统在计算机网络中的核心作用，其安全性对整个计算系统的安全至关重要。（chat）</p><h3 id="操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道"><a href="#操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道" class="headerlink" title="操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道"></a>操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道</h3><p><strong>Lampson关于隐通道的定义</strong>按常规不会用于传送信息但却被利用于泄漏信息的信息传送渠道。</p><p><strong>TCSEC关于隐通道的定义</strong>可以被进程利用来以违反系统安全策略的方式进行非法传输信息的通信通道</p><p>➢ 存储隐通道<br>❖ 限制：进程P不能与进程Q通信。<br>❖ 共享：文件系统。<br>❖ 目的：进程P想发送一条消息给进程Q。<br>❖ 一种使用存储隐通道的方法：<br>    ➢ 进程P在两进程都能读的一个目录中创建一个名为“send”的文件<br>    ➢ 进程Q要读消息前，Q删除文件send➢ 进程P创建一个文件，命名为0bit或者1bit来代表要传输的比特；<br>    ➢ 进程Q记录这个比特，并删除这个文件<br>    ➢ …<br>    ➢ 最后进程P创建一个名为“end”的文件。通信结束。</p><p>➢ 时间隐通道</p><p>❖ 针对KVM&#x2F;370系统的研究发现，可以基于两个虚拟机接收的CPU时间片来建立隐通道<br>    ➢ 若发送方想要发送比特0，则立即释放CPU<br>    ➢ 否则它将使用全部的时间片<br>    ➢ 接收方通过获得CPU的速度可以推断出前者发送的是0还是1<br>❖ 共享资源：CPU时间</p><h3 id="基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU-等概念"><a href="#基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU-等概念" class="headerlink" title="基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU 等概念"></a>基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU 等概念</h3><p><strong>活动目录（Active Directory，缩写为AD）</strong>是微软公司开发的一种目录服务，用于Windows域网络。它主要提供授权和认证的服务，使用LDAP（轻量级目录访问协议）、Kerberos和DNS等标准协议。活动目录允许管理员在网络范围内管理权限和控制对网络资源的访问。</p><h4 id="域"><a href="#域" class="headerlink" title="域"></a><strong>域</strong></h4><p><strong>就是共享用户账号、计算机账号和安全策略的计算机集合</strong></p><p><strong>域是一个安全边界</strong>：资源在一个域中参与共享。</p><p>域中集中存储用户账号的计算机就是域控制器，域控制器存储着目录数据并管理用户域的交互关系，包括用户登录过程、身份验证和目录搜索等。</p><h4 id="活动目录和域控制器"><a href="#活动目录和域控制器" class="headerlink" title="活动目录和域控制器"></a><strong>活动目录和域控制器</strong></h4><p><strong>一个域中可有一个或多个域控制器，各域控制器间可以相互复制活动目录</strong></p><h4 id="组织单元-（OU）"><a href="#组织单元-（OU）" class="headerlink" title="组织单元 （OU）"></a>组织单元 （OU）</h4><p>OU是一种类型的目录对象⎯⎯容器，其作用主要用来委派对用户、组及资源集合的管理权限<br>    ◼ 控制用户&#x2F;组对资源的访问<br>    ◼ 建立&#x2F;应用组策略对象<br>    ◼ 实现管理委派<br>    ◼ 组织具有公共属性的对象，如打印机</p><h3 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h3><p><strong>组策略GPMC</strong>⎯⎯“一对多”的管理</p><p>组策略是Windows Server 2003操作系统中提供的一种重要的更新和配置管理技术。<br>     系统管理员使用组策略来为计算机和用户组管理桌面配置指定的选项<br>     组策略很灵活，它包括如下的一些选项：基于注册表的策略设置、安全设置、软件安装、脚本、计算机启动与关闭、用户登录和注销，文件重定向等<br>     Windows Server 2003包括几百种可以配置的组策略设置。组策略设置允许企业管理员通过增强和控制用户桌面来减少总的开销</p><p>• 策略提供大量定制桌面的管理<br>• 组策略管理控制台（GPMC）让管理工作更简单<br>• RsOP得到组策略应用的结果<br>• 主要优势：<br>• 降低管理、支持与培训成本<br>• 提升用户工作效率<br>• 允许极大量的定制项目 – 其扩展性不会牺牲定制的灵活性</p><h1 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2. 基本原理"></a>2. 基本原理</h1><h2 id="信息系统概论-1"><a href="#信息系统概论-1" class="headerlink" title="信息系统概论"></a>信息系统概论</h2><h3 id="针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术"><a href="#针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术" class="headerlink" title="针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术"></a>针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术</h3><p><strong>秒杀架构设计思路</strong></p><p><strong>将请求拦截在系统上游，降低下游压力：</strong>秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，甚至导致死锁，最终请求超时。</p><p><strong>充分利用缓存：</strong>利用缓存可极大提高系统读写速度。</p><p><strong>消息中间件：</strong>消息队列可以削峰，将拦截大量并发请求，这是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。</p><p><strong>限流，削峰，异步处理，内存缓存，可拓展</strong></p><p><strong>关键技术：</strong></p><ol><li><p><strong>负载均衡</strong>：通过使用负载均衡器分散流量至多个服务器，可以提高系统的处理能力</p></li><li><p><strong>分布式缓存</strong>：使用如Redis或Memcached这样的分布式缓存系统可以极大地减少数据库的压力，通过缓存热点数据来快速响应用户请求。</p></li><li><p><strong>数据库分离</strong>：将读操作和写操作分离，通过读写分离和数据库集群来提高数据库的并发处理能力。</p></li><li><p><strong>消息队列</strong>：引入消息队列，可以平衡负载和解耦服务，通过异步处理来提高系统的响应速度和吞吐量。</p></li><li><p><strong>限流与降级</strong>：通过限流算法防止系统超载，确保系统稳定性。在高流量情况下，及时的服务降级也很关键。</p></li><li><p><strong>数据分片与分区</strong>：对数据库进行水平分区或使用分布式数据库，可将数据分散在不同的节点上，减少单点负载。</p></li><li><p><strong>服务的无状态设计</strong>：确保服务无状态，这样可以无缝扩展服务实例以处理更多的并发请求。</p></li><li><p><strong>CDN</strong>：使用内容分发网络（CDN）可以将静态资源缓存到离用户更近的地方，减少主服务器的负担。</p></li><li><p><strong>动静分离</strong>：通过将动态内容和静态内容分开处理，可以提高处理速度和效率。</p></li><li><p><strong>弹性伸缩</strong>：云服务提供了基于需求自动扩展和缩减服务器实例数量的能力，可以根据流量的实时变化来调整资源。</p></li><li><p><strong>数据库优化</strong>：包括数据库索引优化、查询优化和合理的数据库架构设计，以减少查询时间和提高效率。</p></li><li><p><strong>应用性能监控（APM）</strong>：使用各种监控工具来实时监控应用程序的性能，快速定位并解决性能瓶颈问题。</p></li></ol><h2 id="信息系统安全概论-1"><a href="#信息系统安全概论-1" class="headerlink" title="信息系统安全概论"></a>信息系统安全概论</h2><h3 id="信息系统为什么是脆弱的？"><a href="#信息系统为什么是脆弱的？" class="headerlink" title="信息系统为什么是脆弱的？"></a>信息系统为什么是脆弱的？</h3><p><strong>硬件组件</strong></p><p>信息系统硬件组件的安全隐患多来源于设计，主要表现为物理安全方面的问题。</p><p><strong>软件组件</strong></p><p>软件组件的安全隐患来源于设计和软件工程中的问题。</p><p>➢ 漏洞</p><p>➢ 不必要的功能冗余引起安全脆弱性；</p><p>➢ 未按安全等级要求进行模块化设计，安全等级不能达到预期</p><p><strong>网络和通信协议</strong></p><p>➢ TCP&#x2F;IP协议族本身的缺陷</p><p>➢ 基于TCP&#x2F;IP协议Internet的安全隐患</p><p>• 缺乏对用户身份的鉴别</p><p>• 缺乏对路由协议的鉴别认证</p><p>• TCP&#x2F;UDP的缺陷</p><h3 id="攻防不对称性及应对思路，拟态主动防御"><a href="#攻防不对称性及应对思路，拟态主动防御" class="headerlink" title="攻防不对称性及应对思路，拟态主动防御"></a>攻防不对称性及应对思路，拟态主动防御</h3><p>攻防不对称性是指在网络安全中，攻击者和防御者所面临的条件和需求不同，进而导致的力量不平衡。具体来说，攻击者只需找到系统中的一个漏洞即可实施攻击，而防御者则需要保护系统的所有潜在脆弱点，这显然是一项更艰巨的任务。</p><p>攻防不对称性的特点包括：</p><ul><li><strong>成本不对称</strong>：攻击者通常花费较少资源就能发起有效攻击，而防御者则需要投入大量资源来防御潜在的多样化攻击。</li><li><strong>知识不对称</strong>：攻击者只需要知道特定的漏洞信息就可以发起攻击，而防御者则需要全面了解整个信息系统的安全状况。</li><li><strong>倡议不对称</strong>：攻击者可以挑选时间和地点发起攻击，而防御者则需要时刻准备应对意料之外的攻击。</li></ul><h4 id="应对思路"><a href="#应对思路" class="headerlink" title="应对思路"></a>应对思路</h4><p>在面对攻防不对称性的挑战时，防御者可以采取以下策略来增强安全防御能力：</p><ol><li><p><strong>分层防御</strong>：通过多层安全措施来保护信息系统，即使攻击者突破了一层防御，其他层次的安全措施仍然可以阻止攻击的进一步发展。</p></li><li><p><strong>最小权限原则</strong>：只授予用户或系统完成其职责所必需的信息访问权限，以此减少攻击面。</p></li><li><p><strong>持续监测和审计</strong>：实施实时监控和定期审计，确保对系统的异常行为和安全事件能够及时发现并响应。</p></li><li><p><strong>定期更新和补丁管理</strong>：确保所有系统和软件都安装了最新的安全更新和补丁。</p></li><li><p><strong>安全意识教育</strong>：提高组织内部用户的安全意识，减少因用户失误导致的安全事件。</p></li><li><p><strong>事故响应计划</strong>：制定并实施有效的事故响应计划，以便在发生安全事件时能够迅速采取行动，减轻损失。</p></li></ol><h4 id="拟态主动防御"><a href="#拟态主动防御" class="headerlink" title="拟态主动防御"></a>拟态主动防御</h4><p>拟态防御是一种新型的安全防御技术，其基本思想是通过动态变换系统的攻击面，使攻击者无法准确掌握目标系统的真实状态，从而增加攻击者的不确定性和攻击成本。拟态防御可以通过以下方式实现：</p><ul><li><strong>动态变换</strong>：定期或根据某种算法自动更改系统配置，如IP地址、端口号、协议等，使攻击者难以确定有效攻击向量。</li><li><strong>混淆技术</strong>：在系统中部署虚假的信息和服务，迷惑攻击者，引导其走向陷阱或死胡同。</li><li><strong>强化随机性</strong>：采用随机化技术在系统设计和运行中引入不确定性，比如随机分配资源和任务，让攻击路径变得难以预测。</li><li><strong>主动应对</strong>：系统能够监测到攻击行为时，主动调整策略或者改变系统行为，对攻击者造成反制。</li></ul><p>采用拟态防御可以显著提高攻击的难度，从而在一定程度上缓解攻防不对称的问题。然而，这也需要更高级的设计和管理能力，确保系统在变换的过程中不会影响正常服务。</p><h3 id="5G-对信息系统安全带来的挑战"><a href="#5G-对信息系统安全带来的挑战" class="headerlink" title="5G 对信息系统安全带来的挑战"></a>5G 对信息系统安全带来的挑战</h3><p>5G网络是第五代移动通信技术，它为用户提供了更高的数据传输速率、更低的延迟和更高的连接密度。尽管这些优点为用户带来了许多便利，但5G技术的引入也给信息系统安全带来了新的挑战：</p><ol><li><p><strong>更大的攻击面</strong>：5G网络支持更多的设备连接，包括物联网(IoT)设备，这大大扩展了潜在的攻击面。每个设备都可能成为攻击者的目标。</p></li><li><p><strong>供应链风险</strong>：5G网络涉及复杂的供应链，其中包括多家供应商的设备和软件。供应链的安全弱点可能会影响整个网络。</p></li><li><p><strong>端到端加密挑战</strong>：随着5G网络对加密和隐私保护的要求提高，确保端到端加密的有效实施变得更加困难。</p></li><li><p><strong>更高的带宽和低延迟带来的问题</strong>：虽然这些特性改善了用户体验，但它们也使得发起大规模、高速度的攻击（比如DDoS攻击）更加容易。</p></li><li><p><strong>设备鉴别和管理问题</strong>：随着设备数量的激增，有效地识别和管理这些设备，确保它们都是安全的和符合政策的，变得更加困难。</p></li><li><p><strong>切片管理的复杂性</strong>：5G网络采用了网络切片技术，为不同的服务需求提供定制化的网络环境。每个切片都需要单独管理，提出了对安全策略和隔离机制的高要求。</p></li><li><p><strong>移动边缘计算(MEC)的安全性</strong>：5G促进了MEC的发展，将计算能力带到网络边缘靠近用户。这种分散型计算架构带来了数据存储和处理的安全性问题。</p></li><li><p><strong>物理层和无线接口的威胁</strong>：5G网络的无线接口和物理层也可能面临攻击，例如通过嗅探、欺骗和重放攻击来威胁数据的保密性和完整性。</p></li></ol><h4 id="应对措施"><a href="#应对措施" class="headerlink" title="应对措施"></a>应对措施</h4><p>针对以上挑战，可以采取以下措施来提高5G网络的信息系统安全：</p><ul><li><strong>增强设备安全</strong>：确保所有接入网络的设备都符合严格的安全标准。</li><li><strong>多层安全策略</strong>：实现针对不同网络层次和业务类型的安全策略，包括物理、网络、应用层的安全措施。</li><li><strong>身份管理和访问控制</strong>：强化用户和设备的身份管理系统，实施有效的访问控制策略。</li><li><strong>网络监控和异常检测</strong>：使用先进的监控工具和机器学习技术来检测异常行为和潜在的安全威胁。</li><li><strong>加强供应链安全</strong>：对供应链合作伙伴进行严格的安全审查，确保所有组件都符合安全标准。</li><li><strong>安全架构设计</strong>：在设计网络和服务时，将安全作为核心考虑因素。</li><li><strong>隔离和随机性</strong>：运用网络切片和虚拟化技术，确保不同服务之间的隔离，以及在安全配置中加入随机性，提高攻击的难度。</li></ul><h3 id="信息系统安全保障模型：CMM-框架"><a href="#信息系统安全保障模型：CMM-框架" class="headerlink" title="信息系统安全保障模型：CMM 框架"></a>信息系统安全保障模型：CMM 框架</h3><p>在安全技术上，不仅要考虑具体的产品和技术，更要考虑信息系统的安全技术体系架构。</p><p>建立相应的安全保障管理体系，形成长效和持续改进的安全管理机制。</p><p>建立相应的安全保障管理体系，形成长效和持续改进的安全管理机制。</p><p>注重人的安全意识以及安全专业技能和能力等。</p><p><strong>安全保障能力维</strong></p><p>第一能力级别0：未实施</p><p>第二能力级别1：基本执行</p><p>第三能力级别2：计划跟踪</p><p>第四能力级别3：充分定义</p><p>第五能力级别4：量化控制</p><p>第六能力级别5：持续改进</p><h2 id="安全需求和安全策略-1"><a href="#安全需求和安全策略-1" class="headerlink" title="安全需求和安全策略"></a>安全需求和安全策略</h2><h3 id="常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）"><a href="#常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）" class="headerlink" title="常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）"></a>常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）</h3><h4 id="访问能力表（Capability-List-CL）"><a href="#访问能力表（Capability-List-CL）" class="headerlink" title="访问能力表（Capability List, CL）"></a>访问能力表（Capability List, CL）</h4><p>访问能力表是一种基于能力的访问控制机制，它将权限与用户（或用户的程序）关联起来，而不是与资源关联。每个用户都有一个能力列表，指明了该用户能够访问的资源以及相应的访问权限。</p><p><strong>主要特点</strong>：</p><ul><li>每个用户或进程都有一个与之关联的能力列表。</li><li>能力列表指出用户可以访问的资源及其访问权限（如读、写、执行）。</li><li>能力可以被传递或委托，使得用户可以将某些权限授予其他用户或进程。</li></ul><p><strong>优势</strong>：</p><ul><li>权限的分发和管理与具体的资源分离开来。</li><li>可以方便地为用户配置一组资源的权限。</li><li>更容易实现权限的细粒度控制。</li></ul><p><strong>劣势</strong>：</p><ul><li>管理能力列表可能会变得复杂，尤其是在用户数目众多、系统资源广泛的情况下。</li><li>如果能力列表被泄露或未受到妥善保护，可能会产生安全风险。</li></ul><h4 id="访问控制列表（Access-Control-List-ACL）"><a href="#访问控制列表（Access-Control-List-ACL）" class="headerlink" title="访问控制列表（Access Control List, ACL）"></a>访问控制列表（Access Control List, ACL）</h4><p>访问控制列表是一种更为常见的访问控制机制，它将权限与资源关联起来。对于系统中的每个资源（如文件、目录或设备），都有一个对应的ACL，列出了具有访问该资源权限的所有用户及其访问级别。</p><p><strong>主要特点</strong>：</p><ul><li>每个资源（如文件或目录）都有一个与之关联的访问控制列表。</li><li>ACL列出了具有访问权限的用户或用户组以及各自的权限。</li><li>管理者可以对每个资源设置不同用户或用户组的不同权限。</li></ul><p><strong>优势</strong>：</p><ul><li>权限与资源直接关联，容易理解和管理。</li><li>适用于需要对单个资源进行精细访问控制的情况。</li><li>多数操作系统和文件系统都原生支持ACL。</li></ul><p><strong>劣势</strong>：</p><ul><li>对于需要大量权限变更的环境，维护ACL可能会变得繁琐。</li><li>对于每个资源，都需要独立设置和维护权限，难以批量操作。</li></ul><p>总的来说，CL提供了一种以用户或进程为中心的权限管理方式，而ACL则是以资源为中心的权限管理方式。在实现安全策略时，选择哪一种机制取决于特定的应用场景、安全需求以及管理复杂性的考虑。</p><h3 id="常见的强制访问控制模型：Bell-LaPadula、BIBA-原理、优缺点及其应用"><a href="#常见的强制访问控制模型：Bell-LaPadula、BIBA-原理、优缺点及其应用" class="headerlink" title="常见的强制访问控制模型：Bell-LaPadula、BIBA 原理、优缺点及其应用"></a>常见的强制访问控制模型：Bell-LaPadula、BIBA 原理、优缺点及其应用</h3><p>Bell-LaPadula和Biba模型都是传统的访问控制模型，旨在保护信息系统的安全。这两个模型是为了不同的安全目标而设计的，分别关注保密性和完整性。</p><h3 id="Bell-LaPadula模型"><a href="#Bell-LaPadula模型" class="headerlink" title="Bell-LaPadula模型"></a>Bell-LaPadula模型</h3><p><strong>原理</strong>:<br>Bell-LaPadula模型是第一个用于计算机安全性的形式数学模型，主要关注保护数据的保密性。它是在军事和政府环境中应对机密信息泄露问题而创建的。Bell-LaPadula模型通过以下两个核心规则来实现保密性目标：</p><ol><li><p><strong>简单安全性属性（Simple Security Property，也称为”no read up”，NRU）</strong>:<br>用户不得读取高于其安全级别的数据，防止泄露敏感信息。</p></li><li><p><strong>星形安全性属性（Star Property，也称为”no write down”，NWD）</strong>:<br>用户不得写入低于其安全级别的数据，防止敏感信息流向较低安全级别。</p><p>BLP 保密模型基于两种规则来保障数据的机密度与敏感度：</p><p>➢ 不上读（NRU）⎯⎯主体不可读安全级别高于它的数据</p><p>➢ 不下写（NWD）⎯⎯主体不可写安全级别低于它的数据</p></li></ol><p><strong>优点</strong>:</p><ul><li>提供了明确的安全性规则，易于实施在需要严格访问控制的环境中。</li><li>对于保密性要求非常严格的系统，如军事或政府秘密项目，模型提供了坚实的理论基础。</li></ul><p><strong>缺点</strong>:</p><ul><li>过分强调安全性，可能会限制信息的合法共享和灵活性。</li><li>不处理数据完整性和可用性问题。</li></ul><p><strong>应用</strong>:<br>Bell-LaPadula模型主要适用于需要严格保密性控制的环境，例如军事、情报和政府部门的高安全级别系统。</p><h3 id="Biba模型"><a href="#Biba模型" class="headerlink" title="Biba模型"></a>Biba模型</h3><p><strong>原理</strong>:<br>Biba模型是另一种经典的安全性模型，它的设计目的是保护数据的完整性，防止未授权的信息修改。它通过以下两个主要的规则来实施：</p><ol><li><p><strong>简单完整性属性（Simple Integrity Property，也称为”no write up”，NWU）</strong>:<br>用户不得写入高于其安全级别的数据，防止将错误或低质量的信息传递到更高的完整性级别。</p></li><li><p><strong>星形完整性属性（Star Property，也称为”no read down”，NRD）</strong>:<br>用户不得读取低于其安全级别的数据，以免受到低质量数据的影响。</p><p>BIBA模型基于两种规则来保障数据的完整性的保密性：</p><p>➢ <strong>不下读（NRU）属性主体不能读取安全级别低于它的数据</strong></p><p>➢<strong>不上写（NWD）属性主体不能写入安全级别高于它的数据</strong></p></li></ol><p><strong>优点</strong>:</p><ul><li>强调了数据的完整性和一致性。</li><li>适用于需要保持数据不变性和准确性的应用场景。</li></ul><p><strong>缺点</strong>:</p><ul><li>与Bell-LaPadula模型类似，Biba也不处理系统的可用性问题。</li><li>在实际中可能会限制数据的正常使用和共享。</li></ul><p><strong>应用</strong>:<br>Biba模型适用于那些对数据完整性要求极高的场所，如银行系统、医疗记录系统和任何需要确保数据不被未经授权篡改的环境。</p><p>总的来说，Bell-LaPadula模型和Biba模型各自针对信息系统安全的不同方面提供了理论框架和保护措施。然而，它们在现代信息系统中的应用可能受限于其在灵活性和完整性（Bell-LaPadula）或保密性（Biba）方面的局限性。实际应用中，可能需要结合其他模型和策略，如Clark-Wilson模型（数据完整性和商业决策的正确性）或角色基访问控制（RBAC）模型（基于用户角色的权限分配），以满足现代信息系统的多样性安全需求。</p><p>从这两个属性来看，BIBA与BLP模型的两个属性是相反的：</p><p>➢ BLP模型提供保密性；</p><p>➢ BIBA模型对于数据的完整性提供保障。</p><h3 id="安全策略如何应用到防火墙等安全设备中"><a href="#安全策略如何应用到防火墙等安全设备中" class="headerlink" title="安全策略如何应用到防火墙等安全设备中"></a>安全策略如何应用到防火墙等安全设备中</h3><p><strong>Internet</strong>上用户的安全级别为“公开”，依照<strong>BIBA</strong>模型，Web服务器上数据的完整性将得</p><p>到保障，<strong>Internet</strong>上的用户只能读取服务器上的数据而不能更改它。因此，任何<strong>POST</strong>操作</p><p>将被拒绝。</p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220191040383.png" alt="image-20231220191040383"></p><h2 id="信息系统的风险评估-1"><a href="#信息系统的风险评估-1" class="headerlink" title="信息系统的风险评估"></a>信息系统的风险评估</h2><h3 id="风险处置策略"><a href="#风险处置策略" class="headerlink" title="风险处置策略"></a>风险处置策略</h3><p><strong>降低风险（Reduce Risk）</strong></p><p>采取适当的控制措施来降低风险，包括技术手段和管理手段，如安装防火墙，</p><p>杀毒软件，或是改善不规范的工作流程、制定业务连续性计划，等等。</p><p><strong>避免风险（Avoid Risk）</strong></p><p>通过消除可能导致风险发生的条件来避免风险的发生，如将公司内外网隔离</p><p>以避免来自互联网的攻击，或是将机房安置在不可能造成水患的位置，等等。</p><p><strong>转移风险（Transfer Risk)</strong></p><p>将风险全部或者部分地转移到其他责任方，例如购买商业保险。</p><p><strong>接受风险（Accept Risk）</strong></p><p>在实施了其他风险应对措施之后，对于残留的风险，可以有意识地选择接受。</p><h3 id="信息系统安全风险计算模型"><a href="#信息系统安全风险计算模型" class="headerlink" title="信息系统安全风险计算模型"></a>信息系统安全风险计算模型</h3><p>风险计算模型是对通过风险分析计算风险值过程的抽象，它主要包括资产评估、威胁评估、脆弱性评估。</p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220192309588.png" alt="image-20231220192309588"><img src="D:\my_data\blog\zyhblog-img\image-20231220192334775.png" alt="image-20231220192334775"><em><strong>*资产等级计算公式*</strong></em></p><p>AV&#x3D;F(AC, AI, AA)</p><p>Asset Value 资产价值</p><p>Asset Confidentiality 资产保密性赋值</p><p>Asset Integrity 资产完整性赋值</p><p>Asset Availability 资产可用性赋值</p><p>例1：AV&#x3D;MAX(AC, AI, AA)</p><p>例2：AV&#x3D;AC+AI+AA</p><p>例3：AV&#x3D;AC×AI×AA</p><h4 id="威胁来源列表"><a href="#威胁来源列表" class="headerlink" title="*威胁来源列表*"></a><em><strong>*威胁来源列表*</strong></em></h4><table><thead><tr><th>来源</th><th></th><th>描述</th></tr></thead><tbody><tr><td>环境因素</td><td></td><td>断电、静电、灰尘、潮湿、温度、鼠蚁虫害、电磁干扰、洪灾、火灾、地震、意外 事故等环境危害或自然灾害，以及软件、硬件、数据、通信线路等方面的故障</td></tr><tr><td>人为因素</td><td>恶意人员</td><td>不满的或有预谋的内部人员对信息系统进行恶意破坏；</td></tr><tr><td>采用自主或内外勾结的方式盗窃机密信息或进行篡改，获取利益外部人员利用信息系统的脆弱性,对网络或系统的机密性、完整性和可用性进行破坏，以获取利益或炫耀能力</td><td></td><td></td></tr><tr><td>人为因素</td><td>非恶意人员</td><td>内部人员由于缺乏责任心，或者由于不关心和不专注，或者没有遵循规章制度和操作流程而导致故障或信息损坏；</td></tr><tr><td>内部人员由于缺乏培训、专业技能不足、不具备岗 位技能要求而导致信息系统故障或被攻击</td><td></td><td></td></tr></tbody></table><h4 id="风险计算方法"><a href="#风险计算方法" class="headerlink" title="风险计算方法"></a><strong>风险计算方法</strong></h4><p>$$风险值&#x3D;R(A, T, V) &#x3D; R(L(T, V), F(Ia,Va))$$</p><p><strong>R</strong>安全风险计算函数</p><p><strong>A</strong>资产</p><p><strong>T</strong>威胁</p><p><strong>V</strong>脆弱性</p><p><strong>Ia</strong>安全事件所作用的资产价值</p><p><strong>Va</strong> 脆弱性严重程度</p><p><strong>L</strong>威胁利用资产的脆弱性导致安全事件发生的可能性</p><p><strong>F</strong>安全事件发生后产生的损失</p><h2 id="信息系统等级保护-1"><a href="#信息系统等级保护-1" class="headerlink" title="信息系统等级保护"></a>信息系统等级保护</h2><h3 id="等级保护主要工作流程，定级的流程，备案的流程，备案地点"><a href="#等级保护主要工作流程，定级的流程，备案的流程，备案地点" class="headerlink" title="等级保护主要工作流程，定级的流程，备案的流程，备案地点"></a>等级保护主要工作流程，定级的流程，备案的流程，备案地点</h3><p><img src="D:\my_data\blog\zyhblog-img\image-20231220213058592.png" alt="image-20231220213058592"></p><h4 id="等级保护主要工作流程"><a href="#等级保护主要工作流程" class="headerlink" title="*等级保护主要工作流程*"></a><em><strong>*等级保护主要工作流程*</strong></em></h4><p>1 <strong>定级  定级是等级保护的首要环节</strong></p><p>2 <strong>备案 备案是等级保护的核心</strong></p><p>3 <strong>建设整改 建设整改是等级保护工作落实的关键</strong></p><p>4 <strong>等级测评 等级测评是评价安全保护状况的方法</strong></p><h4 id="定级流程"><a href="#定级流程" class="headerlink" title="定级流程"></a><strong>定级流程</strong></h4><p><img src="D:\my_data\blog\zyhblog-img\image-20231220213206332.png" alt="image-20231220213206332"></p><h4 id="备案的流程"><a href="#备案的流程" class="headerlink" title="备案的流程"></a><strong>备案的流程</strong></h4><p>运营、使用单位在确定等级后到所在地的市级及以上公安机关备案。</p><p>• 新建二级及以上信息系统在投入运营后30日内、已运行的二级及以上信息系统在等级确定30日内备案。</p><p>• 公安机关对信息系统备案情况进行审核，对符合要求的在10个工作日内颁发等级保护备案证明。</p><p>• 对于定级不准的，应当重新定级、重新备案。对于重新定级的，公安机关一般会建议备案单位组织专家进行重新定级评审，并报上级主管部门审批。</p><h4 id="备案地点"><a href="#备案地点" class="headerlink" title="备案地点"></a><strong>备案地点</strong></h4><p><strong>二级以上信息系统</strong></p><p>由信息系统运营使用单位(备案单位)到地市级以上公安机关网络安全保卫部门办理备案手续，填写《信息系统安全等级保护备案表》 。</p><p><strong>隶属于省级的备案单位</strong></p><p>其跨地（市）联网运行的信息系统，由省级公安机关网络安全保卫部门受理备案</p><p><strong>隶属于中央的在京单位</strong></p><p>其跨省或者全国统一联网运行并由主管部门统一定级的信息系统，由主管部门向公安部备案。</p><p><strong>跨省或者全国统一联网运行的信息系统</strong></p><p>在各地运行、应用的分支系统，由所在地地市级以上公安机关网络安全保卫部门受理备案。</p><p><strong>各部委统一定级信息系统在各地的分支系统</strong></p><p>即使是上级主管部门定级的，也要到当地公安网络安全保卫部门备案。</p><h3 id="等级保护主要工作：定级备案，建设整改，等级测评，监督检查"><a href="#等级保护主要工作：定级备案，建设整改，等级测评，监督检查" class="headerlink" title="等级保护主要工作：定级备案，建设整改，等级测评，监督检查"></a>等级保护主要工作：定级备案，建设整改，等级测评，监督检查</h3><p>等级保护制度是针对信息系统安全的一系列规定和措施，旨在确保信息系统达到一定的安全保护等级。这个制度通常涵盖了信息系统的定级备案、建设整改、等级测评和监督检查等主要工作。接下来，我会逐一详细介绍这些工作。</p><h4 id="1-定级备案"><a href="#1-定级备案" class="headerlink" title="1. 定级备案"></a>1. 定级备案</h4><p>在定级备案阶段，信息系统的管理者或者所有者需要对系统进行安全等级的划分。这个过程包括：</p><ul><li><strong>安全等级的划分</strong>：依据信息系统的业务特点和安全需求，以及系统可能面临的安全威胁，将系统分类到不同的安全等级中。</li><li><strong>风险评估</strong>：对系统可能受到的各种威胁和脆弱性进行评估，以确定系统应达到的安全保护等级。</li><li><strong>文件备案</strong>：将信息系统的安全等级和相关的风险评估结果报告给相关的监管机构，进行备案。</li></ul><h4 id="2-建设整改"><a href="#2-建设整改" class="headerlink" title="2. 建设整改"></a>2. 建设整改</h4><p>一旦完成了系统的定级工作，接下来就是根据评定的安全等级来进行系统的安全建设或者整改。这个阶段的工作包括：</p><ul><li><strong>安全措施的落实</strong>：根据信息系统的安全等级，实施必要的安全保护措施，如物理安全、网络安全、主机安全、应用安全、数据安全和紧急响应等。</li><li><strong>制定安全管理制度</strong>：包括安全操作规程、安全事件处理流程、用户管理规定等。</li><li><strong>人员培训</strong>：对管理人员、操作人员进行安全意识和技能培训，确保相关人员能够理解和遵守安全规程。</li><li><strong>系统整改</strong>：针对安全评估中发现的问题，进行必要的技术整改和管理整改。</li></ul><h4 id="3-等级测评"><a href="#3-等级测评" class="headerlink" title="3. 等级测评"></a>3. 等级测评</h4><p>等级测评是对信息系统实施的安全保护措施进行评价的过程，以确保这些措施能够满足既定的安全需求。这个阶段包括：</p><ul><li><strong>安全测评</strong>：通过内部检查或者聘请外部专业机构来进行系统的安全测评。</li><li><strong>评估报告</strong>：生成测评报告，其中详细说明测评过程、发现的问题以及改进建议。</li><li><strong>整改落实</strong>：根据测评报告中的建议，对系统进行进一步的整改。</li></ul><h4 id="4-监督检查"><a href="#4-监督检查" class="headerlink" title="4. 监督检查"></a>4. 监督检查</h4><p>为了确保信息系统安全保护措施的持续有效，需要进行定期的监督检查。这包括：</p><ul><li><strong>定期审计</strong>：定期对系统的安全状况进行审计，确保持续遵守安全规程和政策。</li><li><strong>监督检查</strong>：监管机构可能会定期进行监督检查，以确保信息系统的安全保护措施得到有效实施。</li><li><strong>连续监控</strong>：实施实时监控系统，以便对安全事件做出快速响应。</li></ul><p>等级保护工作要求信息系统的所有者、管理者和使用者共同参与，它是一个持续的过程，需要随着威胁环境和技术的发展而不断调整和完善。在不同国家和地区，等级保护的具体实施标准和流程可能会有所不同，但上述介绍的核心内容通常是普遍适用的。</p><h2 id="信息系统的物理安全-1"><a href="#信息系统的物理安全-1" class="headerlink" title="信息系统的物理安全"></a>信息系统的物理安全</h2><h3 id="环境安全：机房的三度要求，常见的消防设计、防盗措施等"><a href="#环境安全：机房的三度要求，常见的消防设计、防盗措施等" class="headerlink" title="环境安全：机房的三度要求，常见的消防设计、防盗措施等"></a>环境安全：机房的三度要求，常见的消防设计、防盗措施等</h3><p>温度、湿度和洁净度并称为三度，为保证计算机网络系统的正常运行，对机房内的三度都有明确的要求。为使机房内的三度达到规定的要求，空调系统、去湿机、除尘器是必不可少的设备。重要的计算机系统安放处还应配备专用的空调系统，它比公用的空调系统在加湿、除尘等方面有更高的要求</p><p><strong>温度：机房温度一般应控制在18～22℃</strong></p><p><strong>湿度：相对湿度一般控制在40％～60％为宜</strong></p><p><strong>洁净度：尘埃颗粒直径&lt;0.5微米，含尘量&lt;1万颗&#x2F;升</strong></p><p>《七氟丙烷（HFC-227ea）洁净气体灭火系统设计规范》</p><p><strong>机房防盗要求</strong></p><p>视频监视系统是一种更为可靠的防盗设备，能对计算机网络系统的外围环境、操作环境进行实时全程监控。对重要的机房，还应采取特别的防盗措施，如值班守卫、出入口安装金属探测装置等。</p><p>在需要保护的重要设备、存储媒体和硬件上贴上特殊标签（如磁性标签），当有人非法携带这些重要设备或物品外出时，检测器就会发出报警信号。</p><p>将每台重要的设备通过光纤电缆串接起来，并使光束沿光纤传输，如果光束传输受阻，则自动报警</p><h3 id="供电安全：GB-T-2887-2000-规定的三类供电方式，电源防护措施，接地与防雷要求"><a href="#供电安全：GB-T-2887-2000-规定的三类供电方式，电源防护措施，接地与防雷要求" class="headerlink" title="供电安全：GB&#x2F;T 2887-2000 规定的三类供电方式，电源防护措施，接地与防雷要求"></a>供电安全：GB&#x2F;T 2887-2000 规定的三类供电方式，电源防护措施，接地与防雷要求</h3><p><strong>GB&#x2F;T 2887-2000将供电方式分为三类</strong></p><p>一类供电 需要建立不间断供电系统。兵工厂、大型钢厂、火箭发射基地、医院等.</p><p>二类供电 需要建立带备用的供电系统。</p><p>三类供电 按一般用户供电考虑。</p><p><strong>电源防护措施</strong></p><p>不间断电源</p><p>电源相关操作</p><p>​系统接地、正确开关机、电缆连接和卡的插拔、电源要匹配</p><p>电源调整器</p><p><strong>接地可以为计算机系统的数字电路提供一个稳定的0V参考电位</strong></p><h3 id="电磁泄漏产生的原理、电磁泄漏的途径及防护方法"><a href="#电磁泄漏产生的原理、电磁泄漏的途径及防护方法" class="headerlink" title="电磁泄漏产生的原理、电磁泄漏的途径及防护方法"></a>电磁泄漏产生的原理、电磁泄漏的途径及防护方法</h3><p>电磁泄漏指电子设备的杂散电磁能量通过导线或空间向外扩散。</p><p>任何处于工作状态的电磁信息设备，如计算机、打印机、复印机、传真机、手机电话等，都存在不同程度的电磁泄漏问题，这是无法摆脱的电磁现象。</p><p>如果这些泄漏“夹带”着设备所处理的信息，均可构成了电磁信息泄漏。</p><p><strong>电磁泄漏的途径</strong></p><p>以电磁波形式的辐射泄漏</p><p>电源线、控制线、信号线和地线造成的传导泄漏</p><p><strong>铜网式屏蔽室</strong></p><p>用于电子设备防电磁干扰、高频医疗设备、雷达产品实验测试等计量检测场所。</p><h2 id="信息系统的可靠性-1"><a href="#信息系统的可靠性-1" class="headerlink" title="信息系统的可靠性"></a>信息系统的可靠性</h2><h3 id="失效率的规律，失效率、寿命、可靠度三者之间关系的推导"><a href="#失效率的规律，失效率、寿命、可靠度三者之间关系的推导" class="headerlink" title="失效率的规律，失效率、寿命、可靠度三者之间关系的推导"></a>失效率的规律，失效率、寿命、可靠度三者之间关系的推导</h3><p>失效率（Failure Rate）、寿命（Lifetime）和可靠度（Reliability）是评估产品或系统性能的三个关键指标，并且它们之间存在一定的数学关系。下面是简要推导这些指标之间关系的过程。</p><h3 id="失效率（λ）"><a href="#失效率（λ）" class="headerlink" title="失效率（λ）"></a>失效率（λ）</h3><p>失效率通常表示为单位时间内的故障次数的期望值，通常使用“每小时故障数”（Failures per Hour）来表示。对于许多产品来说，失效率随时间的变化而变化，并且可以通过失效密度函数（failure density function）f(t)来描述。</p><h3 id="寿命（L）"><a href="#寿命（L）" class="headerlink" title="寿命（L）"></a>寿命（L）</h3><p>寿命通常是指产品或系统正常工作直到发生第一次故障所经历的时间。平均寿命可以通过失效率函数λ(t)来计算，如果λ(t)是恒定的，那么平均寿命就是失效率的倒数（1&#x2F;λ）。</p><h3 id="可靠度（R-t-）"><a href="#可靠度（R-t-）" class="headerlink" title="可靠度（R(t)）"></a>可靠度（R(t)）</h3><p>可靠度是指在特定时间t内系统或产品无故障正常工作的概率。它可以通过失效密度函数f(t)和可靠度函数R(t)来描述。可靠度函数是一个从零时刻开始到时间t的累积分布函数（CDF）的补，即：</p><p>$$ R(t) &#x3D; 1 - F(t) $$</p><p>其中，F(t)是累积分布函数，表示在时间t之前发生故障的概率。F(t)可以通过失效密度函数f(t)积分得到：</p><p>$$ F(t) &#x3D; \int_0^t f(x) dx $$</p><p>因此，可靠度R(t)也可以通过积分失效率λ(t)来表示：</p><p> $$R(t) &#x3D; e^{-\int_0^t \lambda(x) dx} $$</p><p>如果失效率是常数λ（即系统处于稳态失效率），则上述关系简化为：</p><p>$$ R(t) &#x3D; e^{-\lambda t} $$</p><p>所以，如果你知道了系统的失效率，你就可以计算出在任何给定时间t的可靠度。反过来，如果你知道了系统的可靠度函数，你也可以求出平均寿命（即平均无故障工作时间，MTTF），它是失效密度函数f(t)的期望值：</p><p>$$ MTTF &#x3D; \int_0^{\infty} t f(t) dt $$</p><p>对于恒定失效率的情况，MTTF简化为失效率的倒数：</p><p>$$MTTF &#x3D; \frac{1}{\lambda}$$</p><p>这些关系和推导基于对失效率和可靠度的连续时间分析。在实际应用中，失效率可能会随时间变化，例如对于新产品可能会遵循所谓的“浴盆曲线”（先下降后上升）。在这种情况下，以上简化的公式可能不适用，需要更复杂的模型来描述失效率随时间的变化。</p><h3 id="可靠性模型：串联，并联模型的寿命、可靠度推导"><a href="#可靠性模型：串联，并联模型的寿命、可靠度推导" class="headerlink" title="可靠性模型：串联，并联模型的寿命、可靠度推导"></a>可靠性模型：串联，并联模型的寿命、可靠度推导</h3><h4 id="串联系统"><a href="#串联系统" class="headerlink" title="*串联系统*"></a><em><strong>*串联系统*</strong></em></h4><p>假设第<em>i</em>个部件的寿命为$X_i$，可靠度为$<em>R_i(t)&#x3D;P{X_i &gt;t}，i&#x3D;1, 2, …,n,</em>$第$<em>i</em>$个部件的失效率为$<em>\lambda_i(t)</em>$$，X_1，X_2 ，…，X_n$相互独立。若</p><p>初始时刻$<em>t&#x3D;0</em>$，所有部件都是新的，且同时开始工作。</p><p>(1) 系统的寿命是： $X&#x3D;min{X_1 ，X_2，…，X_n}$</p><p>(2) 系统的可靠度是：</p><p>$$ R(t)&#x3D;P{min(X_1 ，X_2，…，X_n)&gt;t}&#x3D;\Pi^n_{i&#x3D;1}R_i(t)\ &#x3D;\Pi^n_{i&#x3D;1}exp{-\int^t_0\lambda_i(u)du} $$</p><p>(3) 系统的失效率为：</p><p>$$ \lambda(t)&#x3D;-\frac{R’(t)}{R(t)}&#x3D;\sum^n_{i&#x3D;1}\lambda_i(t) $$</p><p>(4) 系统的平均寿命为:</p><p>$$ MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\int^\infty_0exp{-\int^t_0\lambda(u)du}dt $$</p><p>当$R_i(t)&#x3D;exp{-\lambda_t}，i&#x3D;1, 2, …, n$时（及当第<em>i</em>个部件的命遵从参数为$<em>\lambda_i</em>$的</p><p>指数分布时），系统的可靠度和平均寿命为</p><p>$$ R(t)&#x3D;exp{-\sum^n_{i&#x3D;1}\lambda_it}\ MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i} $$</p><h4 id="并联系统"><a href="#并联系统" class="headerlink" title="*并联系统*"></a><em><strong>*并联系统*</strong></em></h4><p>(1) 系统的寿命是： $X&#x3D;max{X_1，X_2，…，X_n }$</p><p>(2) 系统的可靠度是：</p><p>$$ R(t)&#x3D;P{max(X_1 ，X_2，…，X_n)&gt;t}\ &#x3D;1-P{max(X_1 ，X_2，…，X_n)\le t } \ &#x3D;1-\Pi^n_{i&#x3D;1}[1-R_i(t)] $$</p><p>(3) 系统的平均寿命为：</p><p>$$ MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\sum^n_{i&#x3D;1}\frac{1}{\lambda_i}\ &#x3D;sum_{1\le&lt;i&lt;j\le n}\frac{1}{\lambda_1+\lambda_j}+…+(-1)^{n-1}\frac{1}{\lambda_1+…+\lambda_n} $$</p><h3 id="硬件可靠性和软件可靠性的不同"><a href="#硬件可靠性和软件可靠性的不同" class="headerlink" title="硬件可靠性和软件可靠性的不同"></a>硬件可靠性和软件可靠性的不同</h3><p>硬件可靠性和软件可靠性在概念上有一些基本的差异，这些差异主要反映了它们的固有属性和它们出错的本质。</p><h4 id="硬件可靠性"><a href="#硬件可靠性" class="headerlink" title="硬件可靠性"></a>硬件可靠性</h4><ol><li><strong>物理耗损</strong>：硬件可靠性受到物理组件老化和环境条件（如温度、湿度、机械应力等）的影响，这些因素会导致硬件随时间而退化。</li><li><strong>失效率</strong>：硬件的失效率可以通过“浴盆曲线”来描述，即开始时有较高的初期故障率（新品早期失效），然后进入一段低故障率的稳定期（有用寿命期），最后由于磨损和老化进入失效率上升的磨损期。</li><li><strong>可预测性</strong>：许多硬件故障是可以预测的，通过定期维护和替换部件可以预防。</li><li><strong>冗余设计</strong>：硬件系统经常通过冗余组件来提高可靠性，如RAID系统中的多硬盘冗余，电源和冷却系统的冗余配置等。</li><li><strong>测试与质量控制</strong>：硬件的质量可以在生产时通过物理测试来控制和保证。</li></ol><h4 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h4><ol><li><strong>设计和逻辑错误</strong>：软件故障通常是由设计不当、编程错误、逻辑漏洞等原因引起的，与物理磨损无关。</li><li><strong>失效行为</strong>：软件的失效率不遵循物理磨损的模式，软件不会因为时间推移而衰老，但软件的失效通常是由于不断发现的新错误或者在新环境中的不适应。</li><li><strong>不确定性和复杂性</strong>：软件系统经常涉及复杂的交互和非确定性的行为，这使得确保软件可靠性成为一项挑战。</li><li><strong>更新和补丁</strong>：软件通过更新和补丁程序来修正已知错误，因此，软件的可靠性可以通过软件更新来提高。</li><li><strong>测试的限制</strong>：由于软件的复杂性和使用情境的多样性，不可能测试软件的所有可能路径，因此总有未知错误的可能性。</li></ol><h4 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h4><ul><li><strong>稳态和动态行为</strong>：硬件通常在一定条件下具有稳定的行为，而软件则更多表现出动态和多变的行为。</li><li><strong>故障模式</strong>：硬件故障通常是随机的，而软件故障则是系统性的，一旦触发了软件中的某个错误，通常它总是在相同的条件下发生。</li><li><strong>修复方式</strong>：硬件故障的修复可能包括更换或修理物理组件，而软件故障的修复通常是修改代码或配置。</li></ul><p>总的来说，虽然两者都关注于减少故障并提高系统的整体可靠性，但由于硬件和软件在本质上有所不同，它们的可靠性策略和实施方法也不相同。硬件可靠性更多关注于物理特性和冗余设计，而软件可靠性则更侧重于设计、测试和持续的维护。</p><h3 id="软件的四种常见的可靠性模型及其主要思想"><a href="#软件的四种常见的可靠性模型及其主要思想" class="headerlink" title="软件的四种常见的可靠性模型及其主要思想"></a>软件的四种常见的可靠性模型及其主要思想</h3><p><strong>失效时间间隔模型</strong></p><p>这类模型最常用的方法是假定第i个失效到第i+1个失效间隔时间服从某一分布，而分布的参数依赖于各间隔时间内程序中的残留错误数。通过测试所得到的失效间隔时间数据来估计模型的参数，由获得的模型可以估算软件的可靠度以及各失效间的平均工作时间等；</p><p>另一种方法是把失效间隔时间看作随机过程，然后通过适当的时间序列模型来分析和描述软件的失效过程。这类模型有Jelinski-Moranda的非增长模型 、 Schick-Wolverton 模 型 、 Littlewood-Verrall 的 贝 叶 斯 模 型 和 GoelOkumoto的不完善模型等。</p><p><strong>缺陷计数模型</strong></p><p>这类模型关心的是在特定的时间间隔内软件的错误数或失效数，并假定故障累计数服从某个己知的随机过程，过程强度是时间的离散或连续函数，根据在给定的测试时间间隔发现的错误数或失效数来估计故障强度、均值等参数。随着错误的不断排除，在单位时间内发现的失效数将不断减少。当时间间隔事先确定时，在每个间隔时间内的失效次数就是随机变量。这类模型有Shooman模型、Musa的执行时间模型、Goel-Okumoto的NHPP模型、Goel的NHPP 模型和Musa-Okumoto的对数泊淞执行时间模型等等。</p><p><strong>基于输入域错误</strong></p><p>这类模型的基本思路是通过将一组已知的错误人为地植入到一个固有错误总数尚不清楚的程序中，然后在程序的测试中观察并统计发现的植入错误数和程序总的错误数，通过计数的比值估计程序的固有错误总数，从而得到软件可靠度及其有关指标。这类模型的代表是Mills的超几何分布模型。</p><p><strong>植入模型的模型</strong></p><p>这类模型的基本研究方法是根据程序的使用情况，找出程序可能输入的概率分布，根据这种分布产生一个测试用例的集合。由于得到输入的分布难度较大，一般将输入域划分成等价类，每个等价类与程序的一条执行路径相联。在输入域上随机抽取测试用例，执行相应的程序测试，观测故障，从而推断出各项指标。这类模型以Nelson模型为代表，还有Brown-Lipow的基于输入域模型和Ramamoorthy-Bastani的基于输入域模型。</p><h3 id="冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的-N-Version-Programming-和-Recovery-Block-的对比"><a href="#冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的-N-Version-Programming-和-Recovery-Block-的对比" class="headerlink" title="冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的 N-Version Programming 和 Recovery Block 的对比"></a>冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的 N-Version Programming 和 Recovery Block 的对比</h3><p>冗余是提高可靠性、可用性和系统鲁棒性的一种技术，通常通过在系统中加入额外的信息或组件来实现。不同类型的冗余有着不同的实现原理和相应的优缺点。</p><h4 id="时间冗余（Time-Redundancy）"><a href="#时间冗余（Time-Redundancy）" class="headerlink" title="时间冗余（Time Redundancy）"></a>时间冗余（Time Redundancy）</h4><p><strong>原理：</strong> 时间冗余通过在系统中多次执行同一操作来提高可靠性。如果第一次执行产生了错误，系统可以回滚到一个已知的良好状态，并重新执行该操作。</p><p><strong>优点：</strong></p><ul><li>不需要额外的硬件，节约成本。</li><li>可以动态应对偶发性错误。</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的响应时间，降低了性能。</li><li>对于持续性错误无效，如由设计缺陷引起的软件错误。</li></ul><h4 id="信息冗余（Information-Redundancy）"><a href="#信息冗余（Information-Redundancy）" class="headerlink" title="信息冗余（Information Redundancy）"></a>信息冗余（Information Redundancy）</h4><p><strong>原理：</strong> 信息冗余利用额外的数据位（如校验位、奇偶校验、校验和、Hamming码等）来检测和&#x2F;或纠正错误。这在数据传输和存储系统中非常常见。</p><p><strong>优点：</strong></p><ul><li>能够检测或修正数据中的错误，提高数据完整性。</li><li>适用于数据通信和存储操作。</li></ul><p><strong>缺点：</strong></p><ul><li>需要额外的存储空间或带宽。</li><li>复杂的纠错码可能需要额外的计算资源。</li></ul><h4 id="硬件冗余（Hardware-Redundancy）"><a href="#硬件冗余（Hardware-Redundancy）" class="headerlink" title="硬件冗余（Hardware Redundancy）"></a>硬件冗余（Hardware Redundancy）</h4><p><strong>原理：</strong> 硬件冗余通过增加备用的物理组件（如备用服务器、电源、网络连接等）来提高系统可靠性。当一个组件失败时，备用组件可以接管其功能。</p><p><strong>优点：</strong></p><ul><li>提供即时的故障切换，提高系统的可用性。</li><li>增加的组件可以在检测到故障时即刻接管，减少了系统停机时间。</li></ul><p><strong>缺点：</strong></p><ul><li>成本高昂，因为需要购买额外的硬件设备。</li><li>物理空间要求可能增加。</li></ul><h4 id="软件冗余（Software-Redundancy）"><a href="#软件冗余（Software-Redundancy）" class="headerlink" title="软件冗余（Software Redundancy）"></a>软件冗余（Software Redundancy）</h4><p><strong>原理：</strong> 软件冗余通常指的是运行多个软件副本或使用不同算法实现相同功能，以便在一个副本失败时另一个可以接管。</p><p><strong>优点：</strong></p><ul><li>可以在不更改硬件的情况下增加可靠性。</li><li>能够应对软件缺陷和系统性错误。</li></ul><p><strong>缺点：</strong></p><ul><li>如果所有软件副本含有相同的缺陷，那么冗余可能无效。</li><li>对资源的需求增加（如内存和CPU时间）。</li></ul><h4 id="三模冗余（TMR-Triple-Modular-Redundancy）"><a href="#三模冗余（TMR-Triple-Modular-Redundancy）" class="headerlink" title="三模冗余（TMR, Triple Modular Redundancy）"></a>三模冗余（TMR, Triple Modular Redundancy）</h4><p><strong>原理：</strong> TMR是一种特殊类型的硬件冗余，它涉及三个相同的系统或组件并行工作，并通过表决逻辑来确定最终输出。如果一个组件故障，另外两个正确的输出可以通过多数表决得出正确的结果。</p><p><strong>优点：</strong></p><ul><li>可以容忍单个组件的故障而不影响整体系统。</li><li>提供了自动故障检测和修正能力。</li></ul><p><strong>缺点：</strong></p><ul><li>高昂的成本，因为需要三倍的硬件。</li><li>如果两个组件同时失败，系统可能无法正确决策。</li></ul><p>冗余的应用需根据系统要求、环境、故障模型以及成本效益分析来选择。在实际应用中，经常会组合使用不同类型的冗余策略来达到最佳的可靠性和成本效益平衡。</p><p><strong>“N-Version Programming”（N版本编程）和”Recovery Block”（恢复块）</strong>是两种不同的软件冗余技术，它们的目的都是为了提供容错能力并提高软件的可靠性。尽管目标类似，但它们的设计哲学、实现方式和适用场景有所不同。</p><h4 id="N版本编程（N-Version-Programming）"><a href="#N版本编程（N-Version-Programming）" class="headerlink" title="N版本编程（N-Version Programming）"></a>N版本编程（N-Version Programming）</h4><p><strong>原理：</strong></p><ul><li>N版本编程是通过独立地开发多个软件版本（称为“版本”），这些版本由不同的团队使用不同的工具和技术开发，以实现相同的规格和功能。</li><li>运行时，所有版本并行运行，它们的输出通过一个投票系统来决定最终结果。</li></ul><p><strong>优点：</strong></p><ul><li>提高了可靠性，因为不太可能所有版本都会在相同的输入下失败。</li><li>由于各个版本是独立开发的，它们可能会有不同的错误模式，从而降低全局故障的风险。</li></ul><p><strong>缺点：</strong></p><ul><li>成本高昂，需要多组开发团队和多倍的开发资源。</li><li>如果所有版本遵循相同的错误规格或理解，错误可能会在所有版本中重现。</li><li>投票机制的设计和实施可能复杂且需要精确。</li></ul><h4 id="恢复块（Recovery-Block）"><a href="#恢复块（Recovery-Block）" class="headerlink" title="恢复块（Recovery Block）"></a>恢复块（Recovery Block）</h4><p><strong>原理：</strong></p><ul><li>恢复块在设计上包含了主程序块和一个或多个备用程序块。每个块都试图完成相同的任务，但是如果主程序块失败（通过某种形式的验收测试来判定），控制就会传递到备用块。</li><li>备用块按顺序执行，直到一个块通过验收测试或所有块都失败为止。</li></ul><p><strong>优点：</strong></p><ul><li>实现简单，只有在主块失败时才会尝试执行备用块，从而节约了资源。</li><li>可以在不同级别的粒度上实现，例如，可以在整个程序、单个函数或者代码段的层面上应用恢复块。</li></ul><p><strong>缺点：</strong></p><ul><li>如果验收测试不能准确地检测到所有类型的错误，那么故障可能仍会被传递下去。</li><li>需要额外的时间来执行验收测试以及在块之间切换，可能会导致性能开销。</li><li>可能会增加编程复杂性，特别是在设计验收测试时。</li></ul><p><strong>对比：</strong><br>N版本编程和恢复块两种方法在实践中有不同的适用性和效果。N版本编程更注重在不同版本间提供多样性，从而减少共同故障的可能性，但成本高昂且实现复杂。恢复块则侧重于在一个版本失败时有序地退回到备用方案，通常实现起来更简单，成本较低，但其对验收测试的依赖性较高。</p><p>选择哪种技术取决于特定应用的需求、可用资源、预期的可靠性水平以及对性能的影响。在安全关键和高可靠性需求的系统中，这些技术或它们的组合可能是提高软件容错能力的有效方法。</p><h3 id="RAID5-RAID6-的原理"><a href="#RAID5-RAID6-的原理" class="headerlink" title="RAID5&#x2F;RAID6 的原理"></a>RAID5&#x2F;RAID6 的原理</h3><p>RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列）是一种数据存储虚拟化技术，旨在提高数据存储的可靠性和性能。RAID通过将多块硬盘组合成一个或多个阵列来工作，数据被分散在这些硬盘上，以实现冗余和&#x2F;或提高速度。</p><h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><p><strong>原理：</strong></p><ul><li>RAID 5至少需要三块硬盘。它通过分布式奇偶校验来提供数据冗余。这意味着每个数据块和一个校验块被分布在不同的硬盘上。</li><li>数据和校验信息被分割成等大小的块，在所有驱动器上均匀分布。校验块由当前所有硬盘上的数据块计算得出，使用的是异或（XOR）操作。</li><li>如果一个硬盘出现故障，可以通过剩余硬盘上的数据块和校验块，使用XOR运算来重建丢失的数据。</li></ul><p><strong>优点：</strong></p><ul><li>提供了单块硬盘冗余，任何一块硬盘故障都能重建数据。</li><li>相对于RAID 1，RAID 5在使用更少的额外存储容量提供冗余的同时，还提供了良好的读取性能。</li></ul><p><strong>缺点：</strong></p><ul><li>写入性能由于要更新校验信息而受到影响。</li><li>当硬盘出现故障时，重建过程会占用大量的I&#x2F;O资源，并且在此期间，数据处于无冗余保护的状态，如果再有硬盘失败，数据会丢失。</li></ul><h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p><strong>原理：</strong></p><ul><li>RAID 6类似于RAID 5，但它使用两个独立的奇偶校验块，而不是一个。这样，RAID 6可以容忍两块硬盘同时故障而不丢失数据。</li><li>RAID 6至少需要四块硬盘。它采用了更复杂的校验算法，通常是基于两个不同的异或运算。</li><li>与RAID 5一样，数据和校验块在所有驱动器上分布。但由于有两个校验块，RAID 6在处理校验时需要更多的计算。</li></ul><p><strong>优点：</strong></p><ul><li>相比RAID 5，RAID 6提供了更高的数据冗余，能够容忍两块硬盘同时故障。</li><li>适用于大容量硬盘和大型阵列，因为这些环境中硬盘故障的概率更高。</li></ul><p><strong>缺点：</strong></p><ul><li>写入性能损失比RAID 5更大，因为需要计算和写入两个校验块。</li><li>由于额外的校验块，RAID 6牺牲了更多的存储容量。</li></ul><p><strong>总结：</strong><br>RAID 5和RAID 6都是通过在硬盘之间分配数据和校验信息来提供冗余，但它们的冗余级别和性能特点不同。RAID 5在提供冗余和性能方面做了平衡，而RAID 6则更注重在更高的冗余级别。选择哪种RAID阵列取决于用户对性能、存储效率和数据安全的具体需求。</p><h3 id="Reed-Solomon-纠删码的基本原理及其在通信和大规模数据存储中的应用"><a href="#Reed-Solomon-纠删码的基本原理及其在通信和大规模数据存储中的应用" class="headerlink" title="Reed-Solomon 纠删码的基本原理及其在通信和大规模数据存储中的应用"></a>Reed-Solomon 纠删码的基本原理及其在通信和大规模数据存储中的应用</h3><p>erasure code有很多种，其中RS code是最基本的一种。RS codes是基于 Galois Field 的一种编码算法，在RS codes中使用$$GF(2^w)$$，其中$$2^w&gt;n+m$$.</p><p>因此，对每一段的<em>n</em>份数据，我们都可以通过B * D 得到：</p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220235445622.png" alt="image-20231220235445622"></p><p>假如D1、D4、C2 失效，那么我们可以同时从矩阵B和B*D中，去掉响应的行，得到下面的等式</p><p><img src="D:\my_data\blog\zyhblog-img\image-20231220235501565.png" alt="image-20231220235501565"><img src="D:\my_data\blog\zyhblog-img\image-20231220235507658.png" alt="image-20231220235507658"></p><h2 id="计算机取证-1"><a href="#计算机取证-1" class="headerlink" title="计算机取证"></a>计算机取证</h2><h3 id="取证的范围"><a href="#取证的范围" class="headerlink" title="取证的范围"></a>取证的范围</h3><p>首先依据搜查令或其他授权，根据案件的细节、硬件和软件系统的性质、潜在证据以及整个获取证据现场的环境来确定哪些证据将要进行重点检查。</p><h3 id="取证过程应该遵循的原则"><a href="#取证过程应该遵循的原则" class="headerlink" title="取证过程应该遵循的原则"></a>取证过程应该遵循的原则</h3><ol><li>取证过程中不能对目标设备有任何改动，读取硬盘数据必须用“只读锁”</li><li>所有提取的文件都要经过签名，保证不被篡改</li><li>保存证据的硬盘每次使用前都要“洗盘”——清零操作（Erases）</li><li>尽可能优先提取易失性数据——内存、网络数据包等等</li><li>分析证据的工作应该在工作副本(对目标硬盘逐位、逐字节的镜像）上进行</li></ol><h3 id="取证的一般过程"><a href="#取证的一般过程" class="headerlink" title="取证的一般过程"></a>取证的一般过程</h3><ol><li>记录被检查系统的硬件和软件配置，确认被检查系统所包含的硬件和软件。</li><li>拆开被检查计算机，检查计算机的硬盘。注意：在这个过程中要注意避免静电和强磁场</li><li>确认将要收集的存储设备，这些存储设备既可能是内置的也可能是外置的，有的系统可能同时拥有这两种设备。</li><li>记录内置存储设备和硬件配置，包括：<br>驱动情况(例如，品牌、型号、尺寸、跳线、硬件接口等)<br>内部部件(例如，声卡、显卡、网卡、视频采集卡等。)</li><li>通过受控制的引导程序恢复可疑系统的配置信息</li><li>尽可能地将存储器从可疑计算机中拆卸下来，使用预先准备好的监测系统来进行证据的提取</li></ol><h3 id="常见的取证工具"><a href="#常见的取证工具" class="headerlink" title="常见的取证工具"></a>常见的取证工具</h3><p>确定系统的审核策略auditpol</p><p>转储Windows系统注册表中的特定信息（键）reg</p><p>以文本文件格式转储注册表regdump</p><p>转储SAM数据库，可破解密码pwdump6</p><p>监控成功和失败的系统登录NTLast</p><p>侦测隐藏在NTFS文件流中的文件Sfind</p><p>扫描文件系统找出在某时段内被访问过的文件Afind</p><p>转储Windows系统的事件日志Dumpel</p><h2 id="操作系统安全-1"><a href="#操作系统安全-1" class="headerlink" title="操作系统安全"></a>操作系统安全</h2><h3 id="操作系统的一般性安全机制：隔离，访问控制，审计，加密"><a href="#操作系统的一般性安全机制：隔离，访问控制，审计，加密" class="headerlink" title="操作系统的一般性安全机制：隔离，访问控制，审计，加密"></a>操作系统的一般性安全机制：隔离，访问控制，审计，加密</h3><h4 id="隔离控制"><a href="#隔离控制" class="headerlink" title="隔离控制"></a><strong>隔离控制</strong></h4><p><strong>物理隔离</strong>：例如，把不同的打印机分配给不同安全级别的用户。</p><p><strong>时间隔离：</strong>例如，以不同安全级别的程序在不同的时间使用计算机。</p><p><strong>加密隔离</strong>：例如，把文件、数据加密，使无关人员无法阅读。</p><p><strong>逻辑隔离</strong></p><p>首先要对存储单元的地址进行保护：使非法用户不能访问那些受到保护的存储单元</p><p>其次要对被保护的存储单元提供各种类型的保护：最基本的保护类型是“读&#x2F;写”和“只读”。复杂一些的保护类型还包括“只执行”、“不能存取”等操作。不能存取的存储单元，若被用户存取时，系统要及时发出警报或中断程序执行。</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a><strong>访问控制</strong></h4><p>访问控制是操作系统的安全控制核心。访问控制是确定谁能访问系统，能访问系统何种资源以及在何种程度上使用这些资源。访问控制包括对系统各种资源的存取控制</p><p><strong>身份认证、确定访问权限、实施访问控制的权限</strong></p><h4 id="安全审计"><a href="#安全审计" class="headerlink" title="安全审计"></a><strong>安全审计</strong></h4><p>要求任何影响系统安全性的行为都被跟踪和记录在案，安全系统拥有把用户标识与它被跟踪和记录的行为联系起来的能力。<br>• 审计信息必须有选择性的保留和保护，所有与安全相关的事件记录在审计日志文件中，所有审计数据必须防止受到未授权的访问、修改和破坏，以作为日后对事件调查的依据。<br>• 审计系统能记录以下事件：和标识与鉴别机制相关的事件、将客体导入用户地址空间的操作、删除客体、系统管理员执行的操作及其他与安全相关的事件。</p><h4 id="安全加密"><a href="#安全加密" class="headerlink" title="安全加密"></a>安全加密</h4><p><strong>加密机制用于安全传输</strong></p><p>一个IPSee安全策略由IP筛选器和筛选器操作两部分构成。其中IP筛选器决定哪些报文应当引起IPSee安全策略的关注，筛选器操作是指“允许”还是“拒绝”报文的通过。在Windows 2003Server系统的服务端和客户端都提供了对IPSee的支持，从而增强了安全性。</p><p><strong>加密机制用于文件安全</strong></p><p>EFS加密实际上综合了对称加密和不对称加密</p><h3 id="国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色"><a href="#国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色" class="headerlink" title="国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色"></a>国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色</h3><p>国产操作系统的发展主要是为了满足本国的法律法规要求、信息安全等级保护标准、以及本地化支持的需求。相对于国外的主流操作系统，国产操作系统在安全机制设计方面可能具有以下特色：</p><h4 id="1-符合本地法规"><a href="#1-符合本地法规" class="headerlink" title="1. 符合本地法规"></a>1. 符合本地法规</h4><p>国产操作系统往往更加符合本国的法律法规和政策要求，比如数据保护法、信息内容监管等，以保证操作系统及其应用的合规性。</p><h4 id="2-安全加固"><a href="#2-安全加固" class="headerlink" title="2. 安全加固"></a>2. 安全加固</h4><p>部分国产操作系统可能针对特定的安全威胁进行了加固，以应对国内网络环境中的特定安全挑战，如更高级别的身份验证、加密技术和访问控制等。</p><h4 id="3-可信计算"><a href="#3-可信计算" class="headerlink" title="3. 可信计算"></a>3. 可信计算</h4><p>为了增强系统的信任度，国产操作系统可能内置了支持可信计算的技术，包括硬件身份验证、系统完整性验证等。</p><h4 id="4-可审核性"><a href="#4-可审核性" class="headerlink" title="4. 可审核性"></a>4. 可审核性</h4><p>国产操作系统可能会提供更加透明的审计功能，方便对系统行为和数据流向进行监控、记录和审计，以追踪潜在的安全问题。</p><h4 id="5-私有化定制"><a href="#5-私有化定制" class="headerlink" title="5. 私有化定制"></a>5. 私有化定制</h4><p>国产操作系统可能提供更多的定制服务，以符合国内企业或政府部门的特定需求，包括私有云部署、定制化的安全策略和服务等。</p><h4 id="6-支持国产硬件和加密算法"><a href="#6-支持国产硬件和加密算法" class="headerlink" title="6. 支持国产硬件和加密算法"></a>6. 支持国产硬件和加密算法</h4><p>国产操作系统可能会有更好的支持国产CPU架构（如龙芯、飞腾等）和国产加密算法（如国密SM系列算法）的能力。</p><h4 id="7-系统更新与维护"><a href="#7-系统更新与维护" class="headerlink" title="7. 系统更新与维护"></a>7. 系统更新与维护</h4><p>在维护和系统更新方面，国产操作系统可能会强调更快的本地化响应速度，及时补丁发布和定制化的更新服务。</p><h4 id="8-本地化支持"><a href="#8-本地化支持" class="headerlink" title="8. 本地化支持"></a>8. 本地化支持</h4><p>国产操作系统提供更深层次的本地化支持，不仅限于语言包，还可能包括本地化的用户界面、帮助文档以及用户支持服务。</p><h4 id="9-应对国内网络环境"><a href="#9-应对国内网络环境" class="headerlink" title="9. 应对国内网络环境"></a>9. 应对国内网络环境</h4><p>国产操作系统可能会内置特定的功能和服务，以更好地应对中国特有的网络环境，如对国内常用应用和服务的优化。</p><p>需要指出的是，这些特色并不是说国外的主流操作系统不具备，而是国产操作系统可能会在这些方面做出更多本地化和定制化的设计。另外，不同的国产操作系统，在安全机制上的具体实现和特色会有所不同。</p><h3 id="基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU"><a href="#基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU" class="headerlink" title="基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU"></a>基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU</h3><p>见上</p><h3 id="物联网和虚拟化技术对操作系统带来的安全挑战"><a href="#物联网和虚拟化技术对操作系统带来的安全挑战" class="headerlink" title="物联网和虚拟化技术对操作系统带来的安全挑战"></a>物联网和虚拟化技术对操作系统带来的安全挑战</h3><p>伴随着大数据和云时代的到来，虚拟化技术的应用已经越来越成熟。如何运用虚拟化技术给终端客户提供一个安全、稳定、高效的桌面环境，成为了一个日益热门的话题。</p><p>物联网（IoT）和虚拟化技术是近年来信息技术领域的两个重要趋势，它们对操作系统的安全性提出了新的挑战。</p><h4 id="物联网（IoT）带来的安全挑战："><a href="#物联网（IoT）带来的安全挑战：" class="headerlink" title="物联网（IoT）带来的安全挑战："></a>物联网（IoT）带来的安全挑战：</h4><h5 id="1-设备多样性和管理难度"><a href="#1-设备多样性和管理难度" class="headerlink" title="1. 设备多样性和管理难度"></a>1. 设备多样性和管理难度</h5><p>物联网环境中，设备种类繁多，从传感器到智能家电，再到工业控制系统，这些设备运行的操作系统多样，且往往资源受限，这增加了维护和管理的复杂性。</p><h5 id="2-面向设备的安全攻击"><a href="#2-面向设备的安全攻击" class="headerlink" title="2. 面向设备的安全攻击"></a>2. 面向设备的安全攻击</h5><p>物联网设备由于资源有限，可能无法运行复杂的安全软件，这使得它们更容易受到攻击，如固件劫持、物理篡改等。</p><h5 id="3-数据安全和隐私保护"><a href="#3-数据安全和隐私保护" class="headerlink" title="3. 数据安全和隐私保护"></a>3. 数据安全和隐私保护</h5><p>物联网设备通常会收集大量个人或敏感数据，安全地存储和传输这些数据成为了一大挑战。</p><h5 id="4-网络安全问题"><a href="#4-网络安全问题" class="headerlink" title="4. 网络安全问题"></a>4. 网络安全问题</h5><p>物联网设备通常需要连接到互联网，这可能导致网络层面的安全问题，如DDoS攻击利用了大量未加密的物联网设备。</p><h5 id="5-更新和补丁分发"><a href="#5-更新和补丁分发" class="headerlink" title="5. 更新和补丁分发"></a>5. 更新和补丁分发</h5><p>物联网设备的更新机制往往不如传统 IT 系统那样成熟，这意味着安全漏洞可能长时间得不到修复。</p><h4 id="虚拟化技术带来的安全挑战："><a href="#虚拟化技术带来的安全挑战：" class="headerlink" title="虚拟化技术带来的安全挑战："></a>虚拟化技术带来的安全挑战：</h4><h5 id="1-虚拟化平台的安全"><a href="#1-虚拟化平台的安全" class="headerlink" title="1. 虚拟化平台的安全"></a>1. 虚拟化平台的安全</h5><p>虚拟化平台（如VMware、Xen、KVM等）本身的安全性至关重要，因为它们成为了多个虚拟机共享的基础设施。</p><h5 id="2-虚拟机逃逸攻击"><a href="#2-虚拟机逃逸攻击" class="headerlink" title="2. 虚拟机逃逸攻击"></a>2. 虚拟机逃逸攻击</h5><p>如果攻击者成功实施虚拟机逃逸，他们可以从一个虚拟机访问宿主机或者其他虚拟机，从而破坏整个虚拟化环境的隔离性。</p><h5 id="3-虚拟网络安全"><a href="#3-虚拟网络安全" class="headerlink" title="3. 虚拟网络安全"></a>3. 虚拟网络安全</h5><p>在虚拟化环境中，传统网络安全解决方案可能难以直接应用，因为虚拟机之间的网络交互可能完全在软件定义的网络内部进行。</p><h5 id="4-资源池共享安全问题"><a href="#4-资源池共享安全问题" class="headerlink" title="4. 资源池共享安全问题"></a>4. 资源池共享安全问题</h5><p>虚拟化环境中不同虚拟机共享相同的物理资源，如CPU和内存，这可能导致资源竞争以及隔离性的问题。</p><h5 id="5-快照和移动性带来的数据安全问题"><a href="#5-快照和移动性带来的数据安全问题" class="headerlink" title="5. 快照和移动性带来的数据安全问题"></a>5. 快照和移动性带来的数据安全问题</h5><p>虚拟机的快照和移动性功能，虽然带来了便利，但也带来了数据泄露的风险。</p><h5 id="6-管理和配置的复杂性"><a href="#6-管理和配置的复杂性" class="headerlink" title="6. 管理和配置的复杂性"></a>6. 管理和配置的复杂性</h5><p>虚拟化环境增加了管理和配置的复杂性，不当的配置可能导致安全漏洞。</p><p>为了应对这些挑战，操作系统需要集成更多的安全特性，比如增强的访问控制、隔离机制、加密技术以及实时的监控和响应系统。同时，对于物联网和虚拟化环境中的安全事件，需要有专门的检测和应对策略。此外，开发和维护适用于这些环境的安全准则和最佳实践也同样重要。</p><h3 id="身份认证协议，一次性口令（OTP），Kerberos-协议的原理"><a href="#身份认证协议，一次性口令（OTP），Kerberos-协议的原理" class="headerlink" title="身份认证协议，一次性口令（OTP），Kerberos 协议的原理"></a>身份认证协议，一次性口令（OTP），Kerberos 协议的原理</h3><p><strong>OTP的主要思路是</strong>：在登录过程中加入不确定因素，使每次登录过程中传送的口令信息都不相同，以提高登录过程安全性。</p><p>例如：登录密码&#x3D;MD5(用户名＋密码 ＋时间）系统接收到登录口令后做一个验算即可验证用户的合法性。</p><p><strong>Kerberos认证</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231222205144084.png" alt="image-20231222205144084"></p><p><strong>交换第一轮：获取票据许可票据</strong></p><p>​<strong>Step (1) 用户请求票据许可票据</strong></p><p>➢ 用户请求票据许可票据的工作在登录工作站时进行。<br>➢ 登录时用户被要求输入用户名，输入后系统会向认证服务器AS以明文方式发送一条包含用户和TGS服务两者名字的请求。<br>$$<br>C\to AS:ID_C||ID_{tgs}||TS_1<br>$$<br>​<strong>Step (2) AS发放票据许可票据和会话密钥</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231222213355240.png" alt="image-20231222213355240"></p><p><strong>第二轮：获取访问票据</strong></p><p>​<strong>Step (3) C请求服务器票据</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231222213404437.png" alt="image-20231222213404437"></p><p>​<strong>Step (4) TGS发放服务器票据和会话密钥</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231222213412913.png" alt="image-20231222213412913"></p><p><strong>第三轮：获取服务</strong></p><p>​<strong>Step (5) 工作站将票据和认证符发给服务器</strong></p><p><img src="D:\my_data\blog\zyhblog-img\image-20231222213419461.png" alt="image-20231222213419461"></p><p>​<strong>Step (6) 服务器验证票据TicketS和认证符中的匹配，然后许可访问服务。</strong><br>$$<br>S\to C:E_{Kc,s}[TS_5+1]<br>$$</p><h3 id="组策略的主要优势，组策略和-OU-的关系"><a href="#组策略的主要优势，组策略和-OU-的关系" class="headerlink" title="组策略的主要优势，组策略和 OU 的关系"></a>组策略的主要优势，组策略和 OU 的关系</h3><p><strong>主要优势：</strong></p><p>• <strong>降低管理、支持与培训成本</strong></p><p>• <strong>提升用户工作效率</strong></p><p>• <strong>允许极大量的定制项目</strong> <strong>–</strong> <strong>其扩展性不会牺牲定制的灵活性</strong></p><p>组策略是一种用于中央管理和配置操作系统、应用程序和用户设置的工具，而组织单位（OU）是在Active Directory中用来组织用户、组和设备的容器。通过将组策略应用于特定的OU，管理员能够对网络中的不同用户和计算机群组进行精确和灵活的管理，同时利用OU的层级结构实现策略的继承和覆盖，从而实现高效的策略部署和权限控制。</p><h2 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h2><h3 id="数据库面临的安全威胁"><a href="#数据库面临的安全威胁" class="headerlink" title="数据库面临的安全威胁"></a>数据库面临的安全威胁</h3><p><strong>按照导致的后果分类</strong></p><p>• 信息泄露：未授权的用户有意&#x2F;无意得到的信息。</p><p>• 数据修改：未授权的数据修改，违反信息完整性。</p><p>• 拒绝服务：影响用户访问和数据库资源的使用。</p><p><strong>按照发生的方式分类</strong></p><p>​<strong>偶然的、无意的侵犯或破坏</strong></p><p>​• 自然或意外的灾害</p><p>​• 硬件或软件的故障&#x2F;错误导致的数据丢失和泄露</p><p>​• 人为的失误系和安全机制</p><p>​<strong>蓄意的侵犯或敌意的攻击</strong></p><p>​• 授权用户滥用、误用其权限</p><p>​• 病毒、特洛伊木马、天窗（后门）、隐通道</p><p>​• 绕过DBMS直接对数据进行读写</p><p>​• 为了某种目的，故意把错误数据注入数据库，使之保存错误信息并随着时间的推移扩散</p><p><strong>按照表现形式的分类</strong></p><p>• 滥用过高权限</p><p>• 滥用合法权限</p><p>• 权限提升</p><p>• 平台漏洞</p><p>• SQL注入</p><p>• 审计记录不足</p><p>• 拒绝服务</p><h3 id="数据库的安全防御纵深体"><a href="#数据库的安全防御纵深体" class="headerlink" title="数据库的安全防御纵深体"></a>数据库的安全防御纵深体</h3><p><img src="D:\my_data\blog\zyhblog-img\image-20231222212721493.png" alt="image-20231222212721493"><img src="D:\my_data\blog\zyhblog-img\image-20231222212738244.png" alt="image-20231222212738244"></p><h3 id="数据库的安全漏洞"><a href="#数据库的安全漏洞" class="headerlink" title="数据库的安全漏洞"></a>数据库的安全漏洞</h3><p>数据库安全漏洞通常指的是那些可能被恶意用户利用以非法访问、窃取、损坏或篡改数据的系统弱点。数据库中的安全漏洞可能以不同形式存在，以下是一些常见的数据库安全漏洞类型：</p><ol><li><p><strong>SQL注入</strong>：这是一种常见的攻击手段，攻击者通过在应用程序的输入字段中输入恶意SQL代码，企图对数据库执行未授权的查询或操作。</p></li><li><p><strong>不恰当的权限配置</strong>：如果用户或应用程序被授予过多权限，它们就可能进行不应当的数据库修改，或访问不该访问的数据。</p></li><li><p><strong>敏感数据暴露</strong>：敏感信息未经加密或不正确的加密存储在数据库中，容易被泄漏。</p></li><li><p><strong>配置缺陷</strong>：数据库的默认配置可能不够安全，例如默认账户和密码未更改，导致易于被攻破。</p></li><li><p><strong>未更新的数据库系统</strong>：未及时安装数据库软件的补丁和更新可能会留下安全漏洞，易受已知漏洞的攻击。</p></li><li><p><strong>注入漏洞</strong>：不仅限于SQL注入，还包括其它形式的注入，如LDAP注入、ORM注入等。</p></li><li><p><strong>缓冲区溢出</strong>：当输入数据超出数据库引擎预期的处理能力时，可能会导致执行任意代码。</p></li><li><p><strong>不安全的存储过程和触发器</strong>：如果存储过程或触发器编写不当，它们可能成为执行不受控制的SQL代码的途径。</p></li><li><p><strong>信息泄露</strong>：系统错误信息包含敏感信息，如数据库结构细节、系统路径等，有助于攻击者构造攻击。</p></li><li><p><strong>身份认证绕过</strong>：如果认证机制有漏洞，攻击者可能无需合法凭据就能访问数据库。</p></li><li><p><strong>跨站脚本攻击（XSS）</strong>：如果数据库中存储的数据用于网页内容，未经适当清理就插入HTML页面，可能会执行恶意脚本。</p></li><li><p><strong>未充分保护的备份</strong>：数据库备份如果未加密或存储在不安全的位置，可能被攻击者访问。</p></li></ol><p>为了保护数据库免受安全漏洞的影响，重要的措施包括定期更新和打补丁、实施最小权限原则、加密敏感数据、使用入侵检测系统、进行安全审计以及提供安全意识培训等。</p><h1 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a><strong>3.</strong> <strong>基本操作</strong></h1><h2 id="信息系统概述"><a href="#信息系统概述" class="headerlink" title="信息系统概述"></a>信息系统概述</h2><h3 id="能进行简单的信息系统架构设计，可参考讲义提供的阿里架构"><a href="#能进行简单的信息系统架构设计，可参考讲义提供的阿里架构" class="headerlink" title="能进行简单的信息系统架构设计，可参考讲义提供的阿里架构"></a>能进行简单的信息系统架构设计，可参考讲义提供的阿里架构</h3><p>简单的信息系统架构设计参考阿里巴巴的架构，显然需要考虑到系统的可扩展性、可靠性和高并发处理能力。以下是一个高层次的架构设计概要：</p><h4 id="基础设施层"><a href="#基础设施层" class="headerlink" title="基础设施层"></a>基础设施层</h4><ol><li><p><strong>云服务提供商</strong>：选择云服务，如阿里云，以便利用其弹性计算、存储和网络资源。</p></li><li><p><strong>全球负载均衡</strong>：使用DNS级别的负载均衡或阿里云的全局负载均衡服务确保跨地域的流量分配。</p></li></ol><h4 id="数据持久层"><a href="#数据持久层" class="headerlink" title="数据持久层"></a>数据持久层</h4><ol><li><p><strong>数据库</strong>：采用分布式数据库解决方案，如阿里云的PolarDB或RDS来处理高并发读写操作，实现读写分离和数据分片。</p></li><li><p><strong>缓存</strong>：使用Redis或Memcached作为缓存层减少对数据库的访问频率。</p></li><li><p><strong>存储</strong>：使用对象存储服务（如阿里云OSS）来存储和分发静态内容。</p></li></ol><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ol><li><p><strong>微服务架构</strong>：划分微服务，每个服务负责具体的业务功能，相互独立，通过阿里云的容器服务和Kubernetes进行管理。</p></li><li><p><strong>消息队列</strong>：采用RocketMQ等消息系统处理异步任务和解耦服务间的通信。</p></li><li><p><strong>API网关</strong>：使用API网关管理微服务的入口，提供认证、授权、流量控制等功能。</p></li></ol><h4 id="业务逻辑层"><a href="#业务逻辑层" class="headerlink" title="业务逻辑层"></a>业务逻辑层</h4><ol><li><p><strong>业务微服务</strong>：根据不同的业务功能划分服务，如订单处理、用户管理、产品目录等。</p></li><li><p><strong>定时任务服务</strong>：处理需要周期性执行的业务逻辑。</p></li></ol><h4 id="客户端层"><a href="#客户端层" class="headerlink" title="客户端层"></a>客户端层</h4><ol><li><p><strong>Web前端</strong>：使用现代JavaScript框架（如React或Vue.js）构建用户友好的单页面应用（SPA）。</p></li><li><p><strong>移动端</strong>：开发原生或混合移动应用。</p></li></ol><h4 id="辅助层"><a href="#辅助层" class="headerlink" title="辅助层"></a>辅助层</h4><ol><li><p><strong>CDN</strong>：内容分发网络缓存静态资源，减轻后端服务的压力。</p></li><li><p><strong>监控和日志</strong>：集成监控工具（如Prometheus）和日志服务（如ELK Stack）进行系统监控和日志分析。</p></li><li><p><strong>安全</strong>：实现网络安全策略、数据加密、DDoS防护等。</p></li></ol><h4 id="运维层"><a href="#运维层" class="headerlink" title="运维层"></a>运维层</h4><ol><li><p><strong>自动化部署</strong>：使用CI&#x2F;CD工具（如Jenkins）自动化部署流程。</p></li><li><p><strong>容器编排</strong>：使用Docker和Kubernetes进行容器化部署和管理。</p></li></ol><p>确保在设计时考虑到系统的可观测性、可维护性和灾难恢复能力。此外，对于“秒杀”类型的场景，还需要特别设计限流、熔断机制以及足够的预热和压力测试来确保系统在高负载下的稳定性。</p><h3 id="能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术"><a href="#能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术" class="headerlink" title="能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术"></a>能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术</h3><p><strong>将请求拦截在系统上游，降低下游压力：</strong>秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，甚至导致死锁，最终请求超时。</p><p><strong>充分利用缓存：</strong>利用缓存可极大提高系统读写速度。</p><p><strong>消息中间件：</strong>消息队列可以削峰，将拦截大量并发请求，这是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。</p><h2 id="信息系统安全概论-2"><a href="#信息系统安全概论-2" class="headerlink" title="信息系统安全概论"></a>信息系统安全概论</h2><h3 id="根据业务使命、工作环境进行信息系统安全威胁分析"><a href="#根据业务使命、工作环境进行信息系统安全威胁分析" class="headerlink" title="根据业务使命、工作环境进行信息系统安全威胁分析"></a>根据业务使命、工作环境进行信息系统安全威胁分析</h3><p>进行信息系统安全威胁分析时，考虑业务使命和工作环境是至关重要的。以下是一个分析框架，它考虑了这些因素，并帮助识别和评估潜在的安全威胁。</p><h4 id="1-理解业务使命"><a href="#1-理解业务使命" class="headerlink" title="1. 理解业务使命"></a>1. 理解业务使命</h4><ul><li><strong>业务目标</strong>：确定业务的主要目标和目的，分析哪些信息系统对实现这些目标至关重要。</li><li><strong>关键资产</strong>：识别业务运作的关键资产，包括重要的数据类型、系统、技术和人力资源。</li><li><strong>业务流程</strong>：了解业务流程及其对信息系统的依赖程度，以及流程被破坏时对业务的影响。</li><li><strong>合规要求</strong>：考虑行业标准和法规要求，如GDPR、HIPAA、PCI-DSS等对信息安全管理的影响。</li></ul><h4 id="2-分析工作环境"><a href="#2-分析工作环境" class="headerlink" title="2. 分析工作环境"></a>2. 分析工作环境</h4><ul><li><strong>物理环境</strong>：评估信息系统所在的物理环境，包括访问控制、灾害风险（如洪水、火灾）和其他相关因素。</li><li><strong>网络环境</strong>：理解网络架构，包括互联网接入方式、内部网络隔离以及远程访问的安全性。</li><li><strong>技术栈</strong>：识别使用的所有技术（软件、硬件、云服务等），包括它们的安全状态和历史漏洞。</li><li><strong>操作环境</strong>：涉及日常操作中可能出现的风险，例如员工的安全意识水平、数据处理和存储的安全性等。</li></ul><h4 id="3-安全威胁分析"><a href="#3-安全威胁分析" class="headerlink" title="3. 安全威胁分析"></a>3. 安全威胁分析</h4><ul><li><strong>威胁识别</strong>：列出可能影响信息系统的所有潜在威胁，包括恶意软件、黑客攻击、内部威胁、物理盗窃等。</li><li><strong>威胁评估</strong>：针对每项威胁，评估其可能性和对业务的潜在影响。这通常涉及风险评估矩阵。</li><li><strong>脆弱性评估</strong>：识别系统的脆弱点，包括未打补丁的软件、弱密码政策、员工培训缺失等。</li></ul><h4 id="4-采取防御措施"><a href="#4-采取防御措施" class="headerlink" title="4. 采取防御措施"></a>4. 采取防御措施</h4><ul><li><strong>预防措施</strong>：根据分析结果实施必要的安全措施，如加强访问控制、更新和打补丁、安全配置和加密措施。</li><li><strong>监控和检测</strong>：部署监控系统以检测可疑行为和迹象，确保能够及时响应潜在攻击。</li><li><strong>应急计划</strong>：制定并练习应急响应计划，以便在安全事件发生时能迅速采取行动。</li></ul><h4 id="5-持续改进"><a href="#5-持续改进" class="headerlink" title="5. 持续改进"></a>5. 持续改进</h4><ul><li><strong>审计和复审</strong>：定期进行安全审计，以评估现有措施的有效性，并根据新出现的威胁和漏洞进行调整。</li><li><strong>教育与培训</strong>：定期对员工进行安全培训，提高他们的安全意识和应对安全威胁的能力。</li></ul><h3 id="能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构"><a href="#能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构" class="headerlink" title="能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构"></a>能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构</h3><p><img src="D:\my_data\blog\zyhblog-img\image-20231219230840678.png" alt="image-20231219230840678"></p><h2 id="安全需求和安全策略-2"><a href="#安全需求和安全策略-2" class="headerlink" title="安全需求和安全策略"></a>安全需求和安全策略</h2><h3 id="根据安全威胁分析安全需求"><a href="#根据安全威胁分析安全需求" class="headerlink" title="根据安全威胁分析安全需求"></a>根据安全威胁分析安全需求</h3><p>根据安全威胁分析安全需求是一个重要的步骤，用于确保信息系统的安全性。这个过程涉及识别可能影响系统安全的潜在威胁，并基于这些威胁制定相应的安全需求和措施。以下是这一过程中的关键步骤：</p><h4 id="1-威胁建模"><a href="#1-威胁建模" class="headerlink" title="1. 威胁建模"></a>1. 威胁建模</h4><p>威胁建模通常是分析安全威胁的第一步，旨在识别系统可能面临的安全威胁。它可以帮助确定攻击者可能利用的弱点和系统可能受到的攻击类型。常见的威胁建模方法包括STRIDE模型，它涵盖以下威胁类型：</p><ul><li><strong>Spoofing</strong>（身份冒充）</li><li><strong>Tampering</strong>（数据篡改）</li><li><strong>Repudiation</strong>（否认）</li><li><strong>Information Disclosure</strong>（信息泄露）</li><li><strong>Denial of Service</strong>（服务拒绝）</li><li><strong>Elevation of Privilege</strong>（提权）</li></ul><h4 id="2-风险评估"><a href="#2-风险评估" class="headerlink" title="2. 风险评估"></a>2. 风险评估</h4><p>在威胁建模的基础上，进行风险评估以确定哪些威胁具有最高的风险。风险通常根据两个因素评估：威胁的可能性和威胁的影响。这可以通过不同的风险评估框架进行，如FAIR（Factor Analysis of Information Risk）或传统的风险矩阵。</p><h4 id="3-定义安全需求"><a href="#3-定义安全需求" class="headerlink" title="3. 定义安全需求"></a>3. 定义安全需求</h4><p>通过识别最高风险的威胁，可以定义系统的安全需求。这些需求应该旨在减轻或消除风险。安全需求通常包括以下几个方面：</p><ul><li><strong>保密性</strong>：确保信息不被未授权的个人或系统访问。</li><li><strong>完整性</strong>：保护数据免受未授权的修改。</li><li><strong>可用性</strong>：确保在需要时能够访问信息和资源。</li><li><strong>认证</strong>：确保参与者的身份得到确认。</li><li><strong>授权</strong>：确保只有授权用户才能访问资源。</li><li><strong>审计</strong>：记录和监控系统活动，以便在问题发生时可以进行检查。</li></ul><h4 id="4-实施安全控制"><a href="#4-实施安全控制" class="headerlink" title="4. 实施安全控制"></a>4. 实施安全控制</h4><p>根据定义的安全需求，选择和实施合适的安全控制措施。控制措施可以是技术性的，比如使用防火墙、加密和入侵检测系统；也可以是管理性的，比如制定安全策略、培训和应急计划；还可以是物理性的，比如安全门禁系统和监控摄像头。</p><h4 id="5-验证和测试"><a href="#5-验证和测试" class="headerlink" title="5. 验证和测试"></a>5. 验证和测试</h4><p>实施安全控制后，需要验证和测试它们的有效性。这可以通过安全审计、渗透测试、漏洞扫描等方式进行。</p><h4 id="6-持续监控和评估"><a href="#6-持续监控和评估" class="headerlink" title="6. 持续监控和评估"></a>6. 持续监控和评估</h4><p>安全需求的制定并不是一次性的活动。必须定期监控系统以检测新的安全威胁，并对安全需求进行评估和更新。</p><p>通过这个连续的循环过程，组织可以确保他们的安全措施保持最新，能够应对不断变化的威胁环境。这个过程不仅适用于信息技术系统，还适用于物理安全和组织的各个方面。</p><h3 id="可根据需要编写标准-ACL-或扩展-ACL，特别是通配掩码的使用"><a href="#可根据需要编写标准-ACL-或扩展-ACL，特别是通配掩码的使用" class="headerlink" title="可根据需要编写标准 ACL 或扩展 ACL，特别是通配掩码的使用"></a>可根据需要编写标准 ACL 或扩展 ACL，特别是通配掩码的使用</h3><p><strong>创建标准ACL实例</strong></p><p>Router(config)# access-list 1 permit 192.168.1.0 0.0.0.255</p><p>Router(config)# access-list 1 permit 192.168.2.2 0.0.0.0</p><p>允许192.168.1.0&#x2F;24和主机192.168.2.2的流量通过</p><p><strong>Examples:</strong> <strong>扩展****ACL</strong></p><ol><li><strong>Lab_A(config)#access-list 110 deny tcp any host 172.16.30.2 eq www</strong></li></ol><p>含义：拒绝任何IP地址通过TCP协议访问主机172.16.30.2的www服务。隐含的意思是主机可以访问172.16.30.2的其它服务，限制更为细致。</p><ol start="2"><li><strong>Lab_A(config)#access-list 110 permit tcp 192.168.10.0 0.0.0.255 host</strong></li></ol><p><strong>172.16.30.2 eq 23 log</strong></p><p>含义：允许网段192.168.10.0 255.255.255.0通过TCP协议访问主机172.16.30.2的23端口的服务即Telnet服务，且记录访问日志。</p><ol start="3"><li><strong>Lab_A(config)#access-list 110 permit ip any any</strong></li></ol><p>含义：允许所有使用IP协议的IP访问其它所有IP，即允许所有。</p><h2 id="信息系统的风险评估-2"><a href="#信息系统的风险评估-2" class="headerlink" title="信息系统的风险评估"></a>信息系统的风险评估</h2><h3 id="给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等"><a href="#给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等" class="headerlink" title="给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等"></a>给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等</h3><p>进行安全风险评估是一个系统化的过程，涉及对可能影响信息系统的风险进行识别、评估和优先级排序。这个过程通常包括以下几个关键步骤：</p><h4 id="1-风险分析方法"><a href="#1-风险分析方法" class="headerlink" title="1. 风险分析方法"></a>1. 风险分析方法</h4><p>选择一个适合组织需求的风险分析方法是重要的第一步。常见的方法包括：</p><ul><li><strong>定性分析</strong>：依赖于专业知识和经验来评估风险的概率和影响，结果通常使用诸如”低”、”中”、”高”这样的等级来描述。</li><li><strong>定量分析</strong>：使用数值方法来计算风险概率和影响，通常依赖于历史数据和统计技术。</li><li><strong>半定量分析</strong>：结合定性和定量分析的优点，通过打分系统来量化风险。</li></ul><h4 id="2-资产分类方法及识别模型"><a href="#2-资产分类方法及识别模型" class="headerlink" title="2. 资产分类方法及识别模型"></a>2. 资产分类方法及识别模型</h4><p>对于信息系统来说，资产是指所有的信息资源和相关的组件，如硬件、软件、数据和人力资源。资产分类和识别是风险评估的基础。常用的分类方法包括：</p><ul><li><strong>按照功能</strong>：例如，服务器、用户终端、网络设备等。</li><li><strong>按照数据类型</strong>：如个人身份信息、财务报告、知识产权等。</li><li><strong>按照重要性</strong>：关键资产、重要资产和非关键资产。</li></ul><h4 id="3-威胁赋值"><a href="#3-威胁赋值" class="headerlink" title="3. 威胁赋值"></a>3. 威胁赋值</h4><p>威胁赋值是指识别可能对资产造成损害的所有潜在威胁，并对这些威胁的严重性进行评估。威胁可以来自多个来源，如自然灾害、技术故障、人为错误或恶意攻击。为了评估威胁，组织通常会：</p><ul><li><strong>列出威胁来源</strong>：包括内部和外部来源。</li><li><strong>评估威胁发生的可能性</strong>：通常分为“不太可能”、“可能”、“很可能”等。</li><li><strong>考虑威胁的潜在影响</strong>：对业务的影响，如财务损失、声誉损害等。</li></ul><h4 id="4-脆弱性赋值"><a href="#4-脆弱性赋值" class="headerlink" title="4. 脆弱性赋值"></a>4. 脆弱性赋值</h4><p>脆弱性是指系统、程序或网络中的弱点，可以被威胁所利用。脆弱性赋值包括以下步骤：</p><ul><li><strong>脆弱性扫描</strong>：使用自动工具检测系统的已知脆弱性。</li><li><strong>脆弱性评估</strong>：分析扫描结果，评估每个脆弱性被利用的可能性和潜在的影响。</li><li><strong>脆弱性优先级排序</strong>：确定哪些脆弱性最值得注意。</li></ul><h4 id="5-风险评估"><a href="#5-风险评估" class="headerlink" title="5. 风险评估"></a>5. 风险评估</h4><p>最后，结合威胁赋值和脆弱性赋值的结果来评估风险。风险可以定义为威胁和脆弱性相结合的概率与其潜在影响的乘积。对于每个风险，评估其：</p><ul><li><strong>概率</strong>：风险出现的可能性有多大。</li><li><strong>影响</strong>：如果风险实际发生，会对组织造成多大的损害。</li></ul><p>根据评估的结果，组织可以确定哪些风险需要优先处理，并制定相应的风险缓解措施。这可能包括技术控制（如加密和访问控制）、管理控制（如策略和流程）和物理控制（如安全门和监控相机）。</p><p>风险评估是一个动态的过程，需要定期更新，以反映新的威胁、脆弱性和业务环境的变化。</p><h2 id="信息系统等级保护-2"><a href="#信息系统等级保护-2" class="headerlink" title="信息系统等级保护"></a>信息系统等级保护</h2><h3 id="给定某信息系统的业务使命及操作环境，可进行定级和备案"><a href="#给定某信息系统的业务使命及操作环境，可进行定级和备案" class="headerlink" title="给定某信息系统的业务使命及操作环境，可进行定级和备案"></a>给定某信息系统的业务使命及操作环境，可进行定级和备案</h3><p>北京邮电大学教务系统是一个关键的信息系统，它处理学生的注册、课程分配、成绩记录等重要数据。进行定级和备案操作需遵循以下步骤：</p><h4 id="1-业务使命和操作环境分析"><a href="#1-业务使命和操作环境分析" class="headerlink" title="1. 业务使命和操作环境分析"></a>1. 业务使命和操作环境分析</h4><ul><li><strong>业务使命</strong>：教务系统的业务使命是管理学生的教育相关信息，包括课程注册、成绩管理、学位认证等。</li><li><strong>操作环境</strong>：教务系统在北京邮电大学校园内部署，在校园网络环境下运行，并由学校的IT部门维护。</li></ul><h4 id="2-定级"><a href="#2-定级" class="headerlink" title="2. 定级"></a>2. 定级</h4><h5 id="信息资产识别和价值评估"><a href="#信息资产识别和价值评估" class="headerlink" title="信息资产识别和价值评估"></a>信息资产识别和价值评估</h5><ul><li>确认教务系统中所有的硬件和软件资源，以及它们的配置。</li><li>评估学生和教职工的个人信息、成绩资料、课程信息等数据的价值和敏感性，因为这些信息通常包含个人隐私。</li></ul><h5 id="威胁和脆弱性分析"><a href="#威胁和脆弱性分析" class="headerlink" title="威胁和脆弱性分析"></a>威胁和脆弱性分析</h5><ul><li>确定可能对教务系统构成威胁的各种因素，包括网络攻击、内部数据泄露、自然灾害等。</li><li>分析系统存在的脆弱性，如软件漏洞、硬件故障或人为错误。</li></ul><h5 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h5><ul><li>结合资产价值、威胁和脆弱性来评估风险。</li><li>评估数据泄露、系统中断等对学校运营及声誉可能造成的影响。</li></ul><h5 id="安全等级划分"><a href="#安全等级划分" class="headerlink" title="安全等级划分"></a>安全等级划分</h5><ul><li>根据以上评估的结果，参照国家或行业的标准，给教务系统定一个合适的安全等级。</li><li>根据中国的相关标准，教务系统可能被定为三级或四级信息系统，因为它处理大量的个人敏感数据。</li></ul><h4 id="3-备案"><a href="#3-备案" class="headerlink" title="3. 备案"></a>3. 备案</h4><h5 id="编制备案材料"><a href="#编制备案材料" class="headerlink" title="编制备案材料"></a>编制备案材料</h5><ul><li>准备详细的系统描述，包括它的功能、数据流、用户访问模式等。</li><li>包含定级的相关文档，比如风险评估报告、安全保护措施描述、安全管理制度等。</li></ul><h5 id="提交备案"><a href="#提交备案" class="headerlink" title="提交备案"></a>提交备案</h5><ul><li>将所有准备好的材料提交给北京市海淀区公安局的信息网络安全监管部门。</li><li>包括备案申请表、系统等级评估报告、风险管理方案等。</li></ul><h5 id="后续跟进"><a href="#后续跟进" class="headerlink" title="后续跟进"></a>后续跟进</h5><ul><li>等待海淀区公安局审核并确认备案。</li><li>根据公安局的要求，可能需要提供额外的信息或对系统进行必要的安全改进。</li><li>在备案通过后，定期更新备案信息，如系统升级、安全事件等均可能需要重新评估和备案。</li></ul><p>进行定级和备案操作是为了确保教务系统的安全性，防护措施的适当性，并且遵守中国的法律法规要求，保护学生和教职工的个人信息安全。</p><h2 id="信息系统的物理安全-2"><a href="#信息系统的物理安全-2" class="headerlink" title="信息系统的物理安全"></a>信息系统的物理安全</h2><h3 id="机房设计和建设中应该考虑的安全因素"><a href="#机房设计和建设中应该考虑的安全因素" class="headerlink" title="机房设计和建设中应该考虑的安全因素"></a>机房设计和建设中应该考虑的安全因素</h3><p>在机房设计和建设中考虑的安全因素非常广泛，既包括物理安全措施，也包括环境控制、电源管理等。以下是一些关键的安全因素：</p><h4 id="物理安全"><a href="#物理安全" class="headerlink" title="物理安全"></a>物理安全</h4><ol><li><strong>门禁系统</strong>：确保只有授权人员能够进入机房。门禁系统通常包括卡片读取器、生物识别系统等。</li><li><strong>监控系统</strong>：安装视频监控设备监视机房内外的活动，以防止未授权的访问或其他安全事件。</li><li><strong>安全门和窗户</strong>：使用坚固的材料制作门和窗户，防止非法闯入。</li><li><strong>物理隔离</strong>：机房应与其他非关键区域物理隔离，减少潜在的物理风险。</li></ol><h3 id="火灾防护"><a href="#火灾防护" class="headerlink" title="火灾防护"></a>火灾防护</h3><ol><li><strong>自动喷水灭火系统</strong>：在必要时可采用，但不适用于高端电子设备。</li><li><strong>化学灭火系统</strong>：使用FM200或其他适用于机房的化学灭火剂。</li><li><strong>烟雾探测器和报警系统</strong>：确保一旦发生火情，立即发出警报并启动灭火系统。</li></ol><h4 id="环境控制"><a href="#环境控制" class="headerlink" title="环境控制"></a>环境控制</h4><ol><li><strong>温度和湿度控制</strong>：维持适宜的温度和湿度水平以保护设备免受损害。</li><li><strong>空调系统</strong>：设计高效的空调系统，并具备备用冷却系统以防主系统故障。</li></ol><h4 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h4><ol><li><strong>不间断电源（UPS）</strong>：确保在市电断电的情况下，关键设备能够继续运行。</li><li><strong>备用发电机</strong>：在长时间的电力中断时，能够供应机房所需的电力。</li><li><strong>电源分配单元（PDU）</strong>：合理分配电源，确保电力供应的稳定性与安全性。</li></ol><h4 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h4><ol><li><strong>网络安全设备</strong>：部署适当的防火墙和入侵检测系统来保障网络安全。</li><li><strong>数据备份</strong>：定期备份重要数据，并将备份保存在安全的离线位置。</li></ol><h4 id="管理措施"><a href="#管理措施" class="headerlink" title="管理措施"></a>管理措施</h4><ol><li><strong>访问记录</strong>：记录所有访问机房人员的详情，包括时间和日期。</li><li><strong>维护和操作程序</strong>：建立严格的维护和操作流程，确保每项操作都能追溯并符合安全规范。</li></ol><h4 id="法规遵从"><a href="#法规遵从" class="headerlink" title="法规遵从"></a>法规遵从</h4><ol><li><strong>符合当地法规</strong>：确保机房设计符合当地建筑、电力、消防等相关法规。</li><li><strong>行业标准遵从</strong>：遵循行业标准如TIA-942、ISO&#x2F;IEC 27001等。</li></ol><h4 id="灾害恢复"><a href="#灾害恢复" class="headerlink" title="灾害恢复"></a>灾害恢复</h4><ol><li><strong>灾害恢复计划</strong>：制定并定期测试灾害恢复计划，确保在灾难发生时能够快速恢复操作。</li></ol><p>这些安全因素的考虑能够确保机房免受各种潜在风险的影响，保障信息系统的稳定与数据的安全。在实际应用中，应根据机房的规模、功能和位置，以及所支持的业务的重要性，来确定上述安全措施的具体要求和实施方案。</p><h2 id="计算机取证-2"><a href="#计算机取证-2" class="headerlink" title="计算机取证"></a>计算机取证</h2><h3 id="知道常见的取证工具"><a href="#知道常见的取证工具" class="headerlink" title="知道常见的取证工具"></a>知道常见的取证工具</h3><p>确定系统的审核策略auditpol</p><p>转储Windows系统注册表中的特定信息（键）reg</p><p>以文本文件格式转储注册表regdump</p><p>转储SAM数据库，可破解密码pwdump6</p><p>监控成功和失败的系统登录NTLast</p><p>侦测隐藏在NTFS文件流中的文件Sfind</p><p>扫描文件系统找出在某时段内被访问过的文件Afind</p><p>转储Windows系统的事件日志Dumpel</p><h3 id="制定一个简单的取证方案"><a href="#制定一个简单的取证方案" class="headerlink" title="制定一个简单的取证方案"></a>制定一个简单的取证方案</h3><p>制定一个简单的计算机取证方案包括多个步骤，每个步骤都需要遵循特定的协议和最佳实践。以下是一个基础的计算机取证方案示例：</p><h4 id="1-准备阶段"><a href="#1-准备阶段" class="headerlink" title="1. 准备阶段"></a>1. 准备阶段</h4><ul><li><strong>取证计划：</strong> 制定详细的取证分析计划，包括目标、作业范围、所需工具和资源等。</li><li><strong>法律考虑：</strong> 确保有合法权限进行取证调查，了解相关法律、法规和标准。</li><li><strong>取证工具和软件：</strong> 准备必要的取证工具，如磁盘镜像工具、文件恢复工具、取证分析软件等。</li><li><strong>取证团队：</strong> 确定参与取证分析的团队成员的角色和责任。</li></ul><h4 id="2-采集阶段"><a href="#2-采集阶段" class="headerlink" title="2. 采集阶段"></a>2. 采集阶段</h4><ul><li><strong>现场评估：</strong> 如果是实际现场，首先进行现场评估，记录现场情况，拍照或录像。</li><li><strong>证据保护：</strong> 确保证据不被篡改，避免在取证过程中电磁干扰或物理损坏。</li><li><strong>创建数据镜像：</strong> 对存储设备进行物理或逻辑镜像，并验证镜像的完整性（使用哈希值）。</li><li><strong>文档记录：</strong> 记录详细的证据采集过程，包括时间、日期、位置、人员、操作步骤等。</li></ul><h4 id="3-分析阶段"><a href="#3-分析阶段" class="headerlink" title="3. 分析阶段"></a>3. 分析阶段</h4><ul><li><strong>初步审查：</strong> 初步审查镜像文件以确认潜在的证据文件。</li><li><strong>文件恢复：</strong> 使用恢复工具寻找删除、隐藏或丢失的文件。</li><li><strong>日志文件分析：</strong> 分析系统、网络和应用程序的日志文件。</li><li><strong>关键词搜索：</strong> 执行关键词搜索，以查找相关的文件和通讯记录。</li><li><strong>时间线分析：</strong> 构建时间线，以了解事件发生的顺序。</li><li><strong>数据整理：</strong> 整理和分类发现的证据，准备报告。</li></ul><h4 id="4-文档和报告阶段"><a href="#4-文档和报告阶段" class="headerlink" title="4. 文档和报告阶段"></a>4. 文档和报告阶段</h4><ul><li><strong>报告编写：</strong> 编写详细的取证报告，包括方法、发现、结论和推荐。</li><li><strong>证据保管：</strong> 确保所有证据物品得到妥善保存，避免未授权访问和损坏。</li><li><strong>审阅和分析：</strong> 让同行或法律专家审阅报告，确保报告的准确性和完整性。</li></ul><h4 id="5-呈现阶段"><a href="#5-呈现阶段" class="headerlink" title="5. 呈现阶段"></a>5. 呈现阶段</h4><ul><li><strong>法庭陈述：</strong> 准备在法庭上作为证人陈述的材料，包括可视化展示证据。</li><li><strong>证据链维护：</strong> 在法庭上清晰地展示证据链，确保每一环都能够得到证明。</li></ul><h4 id="6-结束阶段"><a href="#6-结束阶段" class="headerlink" title="6. 结束阶段"></a>6. 结束阶段</h4><ul><li><strong>案件复盘：</strong> 审查整个案件处理过程，总结经验教训。</li><li><strong>数据销毁：</strong> 如果法律要求或客户同意，安全销毁敏感数据。</li></ul><p>在执行上述任何步骤时，都需要遵守诚信、保密和合法性的原则，确保证据的可靠性和法庭的可接受性。此外，整个过程中，团队成员应该接受定期培训，以确保他们的技能和知识与行业标准保持同步。</p>]]></content>
    
    
    <summary type="html">信息系统安全期末考试的初步总结，供学弟学妹参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="复习总结" scheme="https://zhangyuanhe.top/tags/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>软件安全作业二——安全的sprintf函数</title>
    <link href="https://zhangyuanhe.top/2023/12/31/Information_Security_Experiment/software_security/SSH2/"/>
    <id>https://zhangyuanhe.top/2023/12/31/Information_Security_Experiment/software_security/SSH2/</id>
    <published>2023-12-31T01:00:00.000Z</published>
    <updated>2024-01-17T14:42:13.120Z</updated>
    
    <content type="html"><![CDATA[<ol><li>详述函数编写思路和流程</li></ol><p>本次实现的sprintf函数需要实现以下功能：</p><p>a) 不会产生缓冲区溢出</p><p>b) 不能被格式字符串控制输出内容</p><p>c) 实现安全的变参</p><p>为实现以上功能：<br>函数首先检查传入的目标缓冲区指针和大小是否有效，若无效则返回 -1 表示参数无效。</p><p>使用 va_list 类型的变量 args 来处理可变数量的参数，通过 va_start 宏初始化。</p><p>使用一个循环遍历格式化字符串 format，逐个处理其中的字符：</p><p>对于普通字符，直接将其复制到目标缓冲区中；对于 %s 格式符，从参数中获取字符串，计算其长度，然后将其复制到目标缓冲区中；对于 %d 格式符，从参数中获取整数，将其转换为字符串，然后复制到目标缓冲区中。</p><p>在复制字符串时，会检查缓冲区是否足够大，若不足则返回 -1。</p><p>循环结束后，添加字符串终止符 \0 到目标缓冲区的末尾。</p><p>最后，释放可变参数列表并返回写入目标缓冲区的字符数量（不包括终止符）。如果参数不匹配或缓冲区不足，也返回 -1。</p><ol start="2"><li><p>函数源代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">safe_sprintf</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">size_t</span> sizeOfBuffer, <span class="type">const</span> <span class="type">char</span>* format, ...)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">NULL</span> || sizeOfBuffer == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 参数无效</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">va_list args;</span><br><span class="line"><span class="built_in">va_start</span>(args, format);</span><br><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;  <span class="comment">// 记录写入字符的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*format != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 处理格式化字符串中的普通字符</span></span><br><span class="line"><span class="keyword">if</span> (*format != <span class="string">&#x27;%&#x27;</span> &amp;&amp; i &lt; sizeOfBuffer - <span class="number">1</span>) &#123;</span><br><span class="line">buffer[i++] = *format;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(format + <span class="number">1</span>) == <span class="string">&#x27;s&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 %s 格式符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="built_in">va_arg</span>(args, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计算字符串长度</span></span><br><span class="line"><span class="keyword">if</span> (str == <span class="string">&quot;-1&quot;</span>) &#123;</span><br><span class="line"><span class="comment">//参数不匹配</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (str[len] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + len &lt; sizeOfBuffer) &#123;</span><br><span class="line"><span class="comment">// 复制字符串到缓冲区</span></span><br><span class="line"><span class="type">size_t</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">buffer[i + j] = str[j];</span><br><span class="line">&#125;</span><br><span class="line">i += len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 缓冲区不足</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否能容纳整个字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动 format 指针到 %s 后面</span></span><br><span class="line">format += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(format + <span class="number">1</span>) == <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理 %d 格式符</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> num = <span class="built_in">va_arg</span>(args, <span class="type">long</span> <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配足够的内存来存储整数的字符串表示</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];  <span class="comment">// 调整大小以适应你的需要</span></span><br><span class="line"><span class="built_in">sprintf_s</span>(str, <span class="built_in">sizeof</span>(str), <span class="string">&quot; %d&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查参数是否匹配</span></span><br><span class="line"><span class="keyword">if</span> (str==<span class="string">&quot;-1&quot;</span>) &#123;</span><br><span class="line"><span class="comment">// 参数不匹配</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串长度</span></span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否能容纳整个字符串</span></span><br><span class="line"><span class="keyword">if</span> (i + len &lt; sizeOfBuffer) &#123;</span><br><span class="line"><span class="comment">// 复制字符串到缓冲区</span></span><br><span class="line"><span class="type">size_t</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">buffer[i + j] = str[j];</span><br><span class="line">&#125;</span><br><span class="line">i += len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 缓冲区不足</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">format += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 未知的格式化符号</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">++format;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在字符串末尾添加终止符</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; sizeOfBuffer) &#123;</span><br><span class="line">buffer[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 缓冲区不足</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;  <span class="comment">// 返回写入字符的数量（不包括终止符）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Normal output example:\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">safe_sprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;Hello, %s%d!&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">1111</span>, <span class="string">&quot;-1&quot;</span>);<span class="comment">//正常输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Formatted string: %s\n&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error occurred: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Example of Scalable Buffer:\n&quot;</span>);</span><br><span class="line">result = <span class="built_in">safe_sprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;Helloooooooooooooooooooooooooooooooooooooooo, %s%d!&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">11111</span>, <span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Formatted string: %s\n&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error occurred: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Example of viewing stack content:\n&quot;</span>);</span><br><span class="line">result = <span class="built_in">safe_sprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;Hello, %s%d%s%s%s!&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">11111</span>, <span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Formatted string: %s\n&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error occurred: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Memory Overwrite Example:\n&quot;</span>);</span><br><span class="line">result = <span class="built_in">safe_sprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;Hello, %s%d%s!&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">11111</span>, <span class="string">&quot;Memory Overwrite Memory Overwrite Memory Overwrite&quot;</span>, <span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Formatted string: %s\n&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error occurred: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>运行结果需要截图证明</p></li></ol><p><img src="D:\my_data\blog\zyhblog-img\wps111.jpg" alt="img"> </p><p>运行结果</p><p><img src="D:\my_data\blog\zyhblog-img\wps112.jpg" alt="img"> </p><p>测试样例</p><p>实验中第一次输出成功；</p><p>第二次验证可伸展的缓冲区和程序崩溃，报错中断；</p><p>第三次验证查看栈内容，报错中断；</p><p>第二次验证内容覆写，报错中断；</p>]]></content>
    
    
    <summary type="html">本次实现的sprintf函数需要实现以下功能，不会产生缓冲区溢出，不能被格式字符串控制输出内容，实现安全的变参</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="软件安全" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="软件安全实验" scheme="https://zhangyuanhe.top/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>软件安全作业一——安全的strcpy_s函数</title>
    <link href="https://zhangyuanhe.top/2023/12/31/Information_Security_Experiment/software_security/SSH1/"/>
    <id>https://zhangyuanhe.top/2023/12/31/Information_Security_Experiment/software_security/SSH1/</id>
    <published>2023-12-30T20:00:00.000Z</published>
    <updated>2024-01-17T14:42:19.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详述函数编写思路和流程"><a href="#详述函数编写思路和流程" class="headerlink" title="详述函数编写思路和流程"></a>详述函数编写思路和流程</h1><p>本次实现的strcpy_s函数需要实现以下功能：</p><p>a) 不会产生缓冲区溢出</p><p>b) 不产生无结尾的字符串</p><p>c) 不意外截断字符串</p><p>因此需要对输入字符串进行判断。</p><p>定义符号：</p><table><thead><tr><th>RSIZE_MAX</th><th>栈空间大小</th></tr></thead><tbody><tr><td>s1</td><td>待复制空间</td></tr><tr><td>s1max</td><td>待复制字符串长度</td></tr><tr><td>s2</td><td>输入字符串</td></tr><tr><td>s1len</td><td>允许复制长度</td></tr></tbody></table><p>对于需求a：需要比对s1max和RSIZE_MAX的大小，即比较申请的复制空间是否超出缓冲区限制，如果s1max &gt; RSIZE_MAX就会发生栈溢出。</p><p>对于需求b和c:需要使得s1max &gt; s1len，否则会发生空结尾错误或发生截断。如果s1max &#x3D; s1len则没有给最后一位空值留出空间，发生空结尾错误。如果s1max &lt; s1len会发生截断。</p><h1 id="函数源代码"><a href="#函数源代码" class="headerlink" title="函数源代码"></a>函数源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">errno_t</span> <span class="title">strcpy_s</span><span class="params">(<span class="type">char</span> *s1, <span class="type">rsize_t</span> s1max, <span class="type">const</span> <span class="type">char</span> *s2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s1 == <span class="literal">NULL</span> || s2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 无效的参数</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s1max &gt; RSIZE_MAX) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// s1max 超过了允许的最大值</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> s1len = <span class="built_in">strlen</span>(s2); <span class="comment">// 查找s2的长度，不超过s1max</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s1len == s1max) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// s2的长度与s1max相同，发生空结尾错误</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s1len &lt; s1max) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(s1, s2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 复制成功</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>; <span class="comment">// s2的长度超过了s1max，会导致截断</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果需要截图证明（3种典型错误）"><a href="#运行结果需要截图证明（3种典型错误）" class="headerlink" title="运行结果需要截图证明（3种典型错误）"></a>运行结果需要截图证明（3种典型错误）</h1><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps110.jpg" alt="img"> </p><p>实验中第一次复制成功；</p><p>第二次字符串长于复制空间，会被截断；</p><p>第三次字符串长度&#x3D;复制空间长度，发生空结尾错误；</p><p>最后一次申请的复制空间大于缓冲区空间（20），因此会发生缓冲区溢出。</p>]]></content>
    
    
    <summary type="html">本次实现的strcpy_s函数需要实现以下功能，不会产生缓冲区溢出，不产生无结尾的字符串，不意外截断字符串</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="软件安全" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="软件安全实验" scheme="https://zhangyuanhe.top/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>编译原理Lab5——编写symtab_ll.c</title>
    <link href="https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Lab5/"/>
    <id>https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Lab5/</id>
    <published>2023-11-19T21:00:00.000Z</published>
    <updated>2024-01-17T14:39:06.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、 实验内容"></a>一、 实验内容</h1><p>1.编写symtab_ll.c </p><p>2.使用 python 代码进行测试</p><h1 id="二、-实验过程"><a href="#二、-实验过程" class="headerlink" title="二、 实验过程"></a>二、 实验过程</h1><p> 编写symtab_ll.c </p><p>1） 初始化:<br>初始化时需要分配一个新的结构体节点，并将内容置零，‘next’初始化为NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">symtab *symtab_init()&#123;</span><br><span class="line">    symtab *self = malloc(sizeof(symtab));</span><br><span class="line">    memset(self, &#x27;\0&#x27;, sizeof(symtab));</span><br><span class="line">    self-&gt;next = NULL;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2） 插入:<br>将新条目插入到链表中，需要遍历链表，检查给定的键是否已经存在。如果不存在，它创建一个新节点，用提供的键和值初始化其条目，并将其追加到链表的末尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int symtab_insert(symtab *self, char *key, VAL_T value)&#123;</span><br><span class="line">    symtab *ptr = self;</span><br><span class="line">    while(ptr-&gt;next != NULL)&#123;</span><br><span class="line">        if(strcmp(ptr-&gt;entry.key, key) == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    symtab *node = malloc(sizeof(symtab));</span><br><span class="line">    memset(node, &#x27;\0&#x27;, sizeof(symtab));</span><br><span class="line">    entry_init(&amp;node-&gt;entry, key, value);</span><br><span class="line">    node-&gt;next = NULL;</span><br><span class="line">    ptr-&gt;next = node;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3） 查找:<br>查找给定键，先遍历链表，如果找到键，就返回相应的值；否则返回 -1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VAL_T symtab_lookup(symtab *self, char *key)&#123;</span><br><span class="line">    symtab *ptr = self;</span><br><span class="line">    while(ptr != NULL)&#123;</span><br><span class="line">        if(strcmp(ptr-&gt;entry.key, key) == 0)</span><br><span class="line">            return ptr-&gt;entry.value;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4） 删除:<br>从符号表中移除给定键对应的条目，遍历链表，找到匹配的键后删除相应的节点，并释放相关的内存。如果成功删除，则返回 1；否则返回 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int symtab_remove(symtab *self, char *key)&#123;</span><br><span class="line">    symtab *ptr = self, *tmp;</span><br><span class="line">    while(ptr-&gt;next != NULL) &#123;</span><br><span class="line">        if(strcmp(ptr-&gt;next-&gt;entry.key, key) == 0)&#123;</span><br><span class="line">            tmp = ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next = ptr-&gt;next-&gt;next;</span><br><span class="line">            free(tmp);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、-测试结果"><a href="#三、-测试结果" class="headerlink" title="三、 测试结果"></a>三、 测试结果</h1><p>Test.py运行成功</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps19-1705500415918-1.jpg" alt="img"> </p>]]></content>
    
    
    <summary type="html">编译原理实验，编写symtab_ll.c</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>编译原理Lab4——实现错误检测</title>
    <link href="https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Lab4/"/>
    <id>https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Lab4/</id>
    <published>2023-11-19T20:00:00.000Z</published>
    <updated>2024-01-17T14:39:19.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、 实验内容"></a>一、 实验内容</h1><ol><li>实现错误检测，并使程序继续运行</li></ol><h1 id="二、-实验过程"><a href="#二、-实验过程" class="headerlink" title="二、 实验过程"></a>二、 实验过程</h1><ol><li>运行未实现功能的代码，可以看见错误点没有返回信息</li><li>编写syntax.y文件，进行error处理</li></ol><p>syntax.y</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&quot;lex.yy.c&quot;</span></span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">()</span></span>;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token LC RC LB RB COLON COMMA</span><br><span class="line">%token STRING NUMBER</span><br><span class="line">%token TRUE FALSE VNULL</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">Json:</span><br><span class="line">      Value</span><br><span class="line">    | LB Values RB COMMA error &#123; <span class="built_in">puts</span>(<span class="string">&quot;Comma after the close, recovered&quot;</span>); &#125;</span><br><span class="line">    | LB Values RB RB error &#123; <span class="built_in">puts</span>(<span class="string">&quot;Extra close, recovered&quot;</span>); &#125;</span><br><span class="line">    | LC Members RC Values error &#123; <span class="built_in">puts</span>(<span class="string">&quot;Extra value after close, recovered&quot;</span>); &#125;</span><br><span class="line">    ;</span><br><span class="line">Value:</span><br><span class="line">      Object</span><br><span class="line">    | Array</span><br><span class="line">    | STRING</span><br><span class="line">    | NUMBER &#123;<span class="keyword">if</span>($<span class="number">1</span>==<span class="number">0</span>) &#123;<span class="built_in">yyerror</span>();i++;<span class="built_in">puts</span>(<span class="string">&quot;Numbers cannot have leading zeroes, recovered&quot;</span>);&#125;&#125;</span><br><span class="line">    | TRUE</span><br><span class="line">    | FALSE</span><br><span class="line">    | VNULL</span><br><span class="line">    ;</span><br><span class="line">Object:</span><br><span class="line">      LC RC</span><br><span class="line">    | LC Members RC</span><br><span class="line">    ;</span><br><span class="line">Members:</span><br><span class="line">      Member</span><br><span class="line">    | Member COMMA RC error &#123; <span class="built_in">puts</span>(<span class="string">&quot;Extra comma, recovered&quot;</span>); &#125;</span><br><span class="line">    | Member COMMA Members</span><br><span class="line">    ;</span><br><span class="line">Member:</span><br><span class="line">      STRING COLON Value</span><br><span class="line">    | STRING Value error &#123; <span class="built_in">puts</span>(<span class="string">&quot;Missing colon, recovered&quot;</span>); &#125;</span><br><span class="line">    | STRING COLON COLON Value error &#123; <span class="built_in">puts</span>(<span class="string">&quot;Double colon, recovered&quot;</span>); &#125;</span><br><span class="line">    | STRING COMMA Values error &#123; <span class="built_in">puts</span>(<span class="string">&quot;Comma instead of colon, recovered&quot;</span>); &#125;</span><br><span class="line">    | error &#123; <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;Comma instead if closing brace, recovered&quot;</span>);i++; &#125;&#125;</span><br><span class="line">    ;</span><br><span class="line">Array:</span><br><span class="line">      LB RB</span><br><span class="line">    | LB Values RB</span><br><span class="line">    | LB Values error &#123; <span class="built_in">puts</span>(<span class="string">&quot;Unclosed array, recovered&quot;</span>); &#125;</span><br><span class="line">    | LB Values RC error &#123; <span class="built_in">puts</span>(<span class="string">&quot;mismatch, recovered&quot;</span>); &#125;</span><br><span class="line">    | COMMA Values error &#123; <span class="built_in">puts</span>(<span class="string">&quot;&lt;-- missing value, recovered&quot;</span>); &#125;</span><br><span class="line">    ;</span><br><span class="line">Values:</span><br><span class="line">      Value</span><br><span class="line">    | Value COMMA Values</span><br><span class="line">    | Value COLON Values error&#123; <span class="built_in">puts</span>(<span class="string">&quot;Colon instead of comma, recovered&quot;</span>); &#125;</span><br><span class="line">    | COMMA error &#123; <span class="built_in">puts</span>(<span class="string">&quot;double extra comma, recovered&quot;</span>); &#125;</span><br><span class="line">    | Value COMMA error &#123; <span class="built_in">puts</span>(<span class="string">&quot;extra comma, recovered&quot;</span>); &#125;</span><br><span class="line">    ;</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;syntax error: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Usage: %s &lt;file_path&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(yyin = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">yyparse</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>运行指令，实现成功</li></ol><p>没有程序运行的warning警告，说明没有s&#x2F;r或者r&#x2F;r冲突<br><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps17-1705500268928-1.jpg" alt="img"><br>运行结果如下<br><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps18-1705500268928-2.jpg" alt="img"></p><h1 id="三、-代码解释"><a href="#三、-代码解释" class="headerlink" title="三、 代码解释"></a>三、 代码解释</h1><p>Json中部分差错处理:</p><p>  LB Values RB COMMA error { puts(“Comma after the close, recovered”); }</p><p>在大括号后匹配到“，”进入这一语句</p><p>  LB Values RB RB error { puts(“Extra close, recovered”); }</p><p>如果匹配到两个大括号发生这一错误</p><p>  LC Members RC Values error { puts(“Extra value after close, recovered”); }</p><p>在大括号后匹配到其他value值，进入这一语句</p><p>Value中部分差错处理:</p><p>  NUMBER {if($1&#x3D;&#x3D;0) {yyerror();i++;puts(“Numbers cannot have leading zeroes, recovered”);}}</p><p>NUMBER为零表面无法直接进行错误处理，因此读入时进行判断，如果为零在执行错误处理操作</p><p>Members中部分差错处理:</p><p>  Member COMMA RC error { puts(“Extra comma, recovered”); }</p><p>对于数据中的额外逗号进行处理</p><p>Member中部分差错处理:</p><p>  STRING Value error { puts(“Missing colon, recovered”); }</p><p>对分号丢失进行匹配处理</p><p>  STRING COLON COLON Value error { puts(“Double colon, recovered”); }</p><p>对双分号进行匹配处理</p><p>  STRING COMMA Values error { puts(“Comma instead of colon, recovered”); }</p><p>如果‘，’代替了‘；’进行匹配处理</p><p>  error { if(i&#x3D;&#x3D;0){puts(“Comma instead if closing brace, recovered”);i++; }}</p><p>这里处理的是‘，’替代了结束符，由于这一语句不好表现，其他错误处理又能完全进行匹配，所以这里直接用error进行匹配</p><p>Array:</p><p>  LB Values error { puts(“Unclosed array, recovered”); }</p><p>进行array丢失处理</p><p>  LB Values RC error { puts(“mismatch, recovered”); }</p><p>返回错误处理</p><p>  COMMA Values error { puts(“&lt;– missing value, recovered”); }</p><p>如果两逗号之间无数值说明丢失数值，但为和双逗号进行区分，找到区别之处在于，数值丢失后，后一逗号之后还有value值</p><p>Values:</p><p>  Value COLON Values error{ puts(“Colon instead of comma, recovered”); }</p><p>同上，符号写错</p><p>  COMMA error { puts(“double extra comma, recovered”); }</p><p>如语句后又单独匹配到‘，’说明有双逗号</p><p>  Value COMMA error { puts(“extra comma, recovered”); }</p><p>值后又有逗号，说明出现额外逗号</p><h1 id="四、-遇到困难和解决办法"><a href="#四、-遇到困难和解决办法" class="headerlink" title="四、 遇到困难和解决办法"></a>四、 遇到困难和解决办法</h1><ol><li>在编写过程中经常出现warning冲突警告，需要合理调整语句所在位置才能消除。</li></ol><p>​</p>]]></content>
    
    
    <summary type="html">编译原理实验，实现错误检测</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>编译原理Lab3——实现Bison与Flex的交互</title>
    <link href="https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Lab3/"/>
    <id>https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Lab3/</id>
    <published>2023-11-19T19:00:00.000Z</published>
    <updated>2024-01-17T14:39:12.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、 实验内容"></a>一、 实验内容</h1><ol><li>实现Bison与Flex的交互</li><li>编码实现Bison实验</li></ol><h1 id="二、-实验过程"><a href="#二、-实验过程" class="headerlink" title="二、 实验过程"></a>二、 实验过程</h1><p> Bison与Flex的交互</p><ol><li>在docker环境中进入cale所在文件目录</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps14-1705500170639-1.jpg" alt="img"></p><ol start="2"><li>根据指令运行代码，实现运算功能</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps15-1705500170639-2.jpg" alt="img"></p><p><em><strong>*编码实现Bison实验*</strong></em></p><p>编写实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax.y</span><br><span class="line"></span><br><span class="line">1. %&#123; </span><br><span class="line">2. #include&quot;lex.yy.c&quot; </span><br><span class="line">3. ***\*int\**** result=1; </span><br><span class="line">4. ***\*void\**** yyerror(***\*const\**** ***\*char\**** *s)&#123;result = 0;&#125; </span><br><span class="line">5. %&#125; </span><br><span class="line">6. %token LP RP LB RB LC RC </span><br><span class="line">7. %% </span><br><span class="line">8. String: %empty  </span><br><span class="line">9. | String RestOfString </span><br><span class="line">10. ; </span><br><span class="line">11. RestOfString: LP String RP </span><br><span class="line">12. | LB String RB </span><br><span class="line">13. | LC String RC </span><br><span class="line">14. | String String </span><br><span class="line">15. ; </span><br><span class="line">16. %% </span><br><span class="line">17. </span><br><span class="line"></span><br><span class="line">**18.** ***\*int\**** validParentheses(***\*char\**** *expr)&#123; </span><br><span class="line"></span><br><span class="line">19. yy_scan_string(expr); </span><br><span class="line">20. yyparse(); </span><br><span class="line">21. ***\*return\**** result; </span><br><span class="line">22. &#125; </span><br></pre></td></tr></table></figure><p>运行指令，实现成功</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps16-1705500170639-3.jpg" alt="img"></p><h1 id="三、-遇到困难和解决办法"><a href="#三、-遇到困难和解决办法" class="headerlink" title="三、 遇到困难和解决办法"></a>三、 遇到困难和解决办法</h1><ol><li>编写代码是return值一直受%empty 影响，如果想要通过String String{$$&#x3D; $1 &amp;&amp; $2}实现会返回错误结果。应该更改其他实现方法。</li></ol>]]></content>
    
    
    <summary type="html">编译原理实验，实现Bison与Flex的交互</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>编译原理Lab2——了解词法分析器生成器Lex并进行使用</title>
    <link href="https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Lab2/"/>
    <id>https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Lab2/</id>
    <published>2023-11-19T18:00:00.000Z</published>
    <updated>2024-01-17T14:38:56.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、 实验内容"></a>一、 实验内容</h1><ol><li>了解词法分析器生成器Lex并进行使用</li><li>学习Lex程序的结构</li></ol><h1 id="二、-实验过程"><a href="#二、-实验过程" class="headerlink" title="二、 实验过程"></a>二、 实验过程</h1><p>1.运行wc程序示例 </p><p>（1）启动docker环境，进入实验目录</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps5-1705500056790-1.jpg" alt="img"> </p><p>（2）运行wc目标，并和Linux自带wc命令进行比较</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps6-1705500056790-2.jpg" alt="img"> </p><p>从以上结果可以看出，自主实现的wc命令比Linux分出的词更多。</p><p>（3）区别分析</p><p>在自主实现的wc语句中使用以下语句进行分词</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps7-1705500056790-3.jpg" alt="img"> </p><p>当 Lex 分析器遇到一个或多个字母字符（即一个单词）时，它会增加 words 变量的计数，并且使用 strlen(yytext) 来计算这个单词的长度，并将结果累加到 chars 变量上。这就是以字母字符为单词的语义划分方式，而不考虑单词之间的标点符号或空格。因此只有遇到完整单词之后就会计数器加一。</p><p>而在Linux的wc指令中通过以下代码进行单词计数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">count_words</span> <span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">enum</span> &#123; NEWLINE_STATE, WORD_STATE, SPACE_STATE, ENDOFWORD_STATE &#125; state;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="comment">/* States.  */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">switch</span> (c)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line"></span><br><span class="line">   state = NEWLINE_STATE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line"></span><br><span class="line">   state = SPACE_STATE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">   state = WORD_STATE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (state == NEWLINE_STATE)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (c != EOF)</span><br><span class="line"></span><br><span class="line">​    ++linecount;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (state == SPACE_STATE)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (last_word_state == WORD_STATE)</span><br><span class="line"></span><br><span class="line">​    ++wordcount;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> last_word_state = state;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码中 count_words 函数使用一个有限状态自动机来处理文本字符，根据字符类型划分单词。当遇到空格字符（包括空格和制表符）时，它将从单词状态切换到空格状态，并递增单词计数。</p><p>因此二者分词方式上存在区别，统计词数也有所不同。</p><p>3.Flex标识符练习</p><p>（1）进入目录文件夹，执行操作指令</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps8-1705500056790-4.jpg" alt="img"> </p><p>（2）观察执行结果</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps9-1705500056790-6.jpg" alt="img"> </p><p>发现输出中的行号与令牌的行号不匹配</p><p>（3）查看源代码进行更改</p><p>检查发现在输出语句中调用的行号未使用递增，导致输出行号错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;line %d: %s\n&quot;</span>, lines, yytext);</span><br></pre></td></tr></table></figure><p>对其进行更改从而实现行号的更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> identifier_line = <span class="number">1</span>; <span class="comment">// 初始化为第一行</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#123;letter_&#125;(&#123;letter_&#125;|&#123;digit&#125;)* &#123; </span><br><span class="line"></span><br><span class="line">  identifiers++; </span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;line %d: %s\n&quot;</span>, identifier_line, yytext); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\n &#123; </span><br><span class="line"></span><br><span class="line">  identifier_line++; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）更新后重新进行编译执行</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps10-1705500056790-5.jpg" alt="img"> </p><p>（5）关键代码分析</p><p>%{ … %} 部分：这部分包含了在词法分析器中使用的宏定义和全局变量的声明。</p><p>正则表达式定义：在 letter、letter_ 和 digit 部分定义了正则表达式片段，分别用于匹配字母、字母或下划线、和数字。</p><p>%% 部分：这是Lex规则的主体部分，其中定义了词法分析规则。</p><p>int main(int argc, char **argv) 函数：这是程序的入口点。代码能够识别文本文件中的标识符并输出它们的行号和文本。</p><p>4.ipaddr练习</p><p>（1）尝试直接输出，发现报错</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps11-1705500056791-7.jpg" alt="img"> </p><p>（2）更改代码，编写正则表达式</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps12-1705500056791-8.jpg" alt="img"> </p><p>（3）检查输出结果</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps13-1705500056791-9.jpg" alt="img"> </p><h1 id="三、-遇到困难和解决办法"><a href="#三、-遇到困难和解决办法" class="headerlink" title="三、 遇到困难和解决办法"></a>三、 遇到困难和解决办法</h1><ol><li>docker打开时出错，需要更改指令重新实现，具体如下</li></ol><p>管理员身份打开命令行工具  netsh winsock reset</p><p>就可以重新打开docker,如果不成功，再重启电脑就好了。可以就不用重启了。</p>]]></content>
    
    
    <summary type="html">编译原理实验，了解词法分析器生成器Lex并进行使用</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>编译原理Project2——编写语义分析</title>
    <link href="https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Project2/"/>
    <id>https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Project2/</id>
    <published>2023-11-19T18:00:00.000Z</published>
    <updated>2024-01-17T14:39:28.227Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Project 2: 语义分析</strong></p><p>在Project 2中，你将继续构建BUPT编程语言（BPL）编译器的功能，专注于语义分析阶段。在前一个项目中完成词法和语法分析后，你已经能够生成语法有效的BPL程序的语法树。现在，语义分析阶段将确保程序有一个明确的定义，即验证程序的逻辑正确性，例如变量是否已声明、类型是否匹配等。</p><ol><li><p><strong>语义分析</strong>:</p><ul><li><strong>作用</strong>：语义分析主要确保程序中的所有声明和表达式在逻辑上是有意义和合法的，包括类型检查、变量声明、函数调用等。</li><li><strong>实现方式</strong>：不同于前一个项目中的工具辅助（如Flex和Bison），在这一阶段，你需要手动编写代码来实现语义分析，这可能是实现BPL编译器中最费力的部分。你需要设计各种数据结构（如符号表和数据类型表示）并仔细考虑它们最合适的实现方式。</li></ul></li><li><p><strong>符号表</strong>:</p><ul><li><strong>概述</strong>：符号表是映射名字到其关联信息的数据结构。在语义分析过程中，编译器将不断更新表中的信息以反映作用域内的内容。符号表的两个典型操作是插入和查找特定符号。</li><li><strong>实现</strong>：可以使用各种抽象数据类型来实现符号表，包括链表、二叉搜索树和哈希表。每种数据结构在空间&#x2F;时间复杂性和实现难度方面有所不同。你可以选择适合你需求的数据结构。</li></ul></li><li><p><strong>作用域检查</strong>:</p><ul><li><strong>概述</strong>：作用域检查是确定程序中的标识符是否在该位置可访问的过程。你可以使用不同的方法来实现支持作用域的符号表，比如命令式单一表方法或功能式独立表方法。</li><li><strong>实现</strong>：可以采用单一全局表，每个作用域内的符号在退出时移除；或者使用作用域栈，每个新的作用域开启一个新的符号表，并在作用域关闭时将其弹出。</li></ul></li><li><p><strong>类型检查</strong>:</p><ul><li><strong>类型系统</strong>：在编程语言中，类型是一组值和在这些值上操作的集合。BPL有两类数据类型：基本类型（由硬件直接提供，如int、char和float）和派生类型（由基本类型或派生类型聚合而成，如数组、结构体等）。</li><li><strong>类型等价性</strong>：如何确定两个类型是否等价？对于基本类型，问题很简单，例如int只等价于int。对于派生类型，事情就复杂多了。通常有两种类型等价性：命名等价性和结构等价性。命名等价性考虑类型的名称，而结构等价性考虑类型的结构。</li><li><strong>派生类型表示</strong>：实现层面上，代表原始类型使用常量就足够了。对于派生类型，例如数组和结构体，表示它们就比较复杂了。常见的技术是存储定义类型的基本信息为多级链表。</li></ul></li><li><p><strong>项目要求</strong>:</p><ul><li><strong>输入格式</strong>：与上一个项目相同，即执行文件<code>bplc</code>接受表示BPL程序路径的单个命令行参数。对于语义上合法的BPL程序，你的语义分析器不应该产生任何输出信息；否则，应该打印出有意义的错误信息。</li><li><strong>错误检测</strong>：你的分析器应该能够检测到一系列的语义错误，如未定义变量的使用、类型不匹配、函数调用参数不匹配等，并能够报告错误类型和行号。</li></ul></li></ol><p>通过这个项目，你将学习如何实现一个编译器的语义分析阶段，这是编译器理解程序并检测错误的关键环节。这个阶段需要对语言的类型系统、作用域规则和其他语义规则有深入的理解。</p><p>lex.l</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&quot;syntax.tab.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> MAX_ID_SIZE 256 </span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> line = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Head</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> terminal;</span><br><span class="line">        <span class="type">char</span> type[<span class="number">200</span>];</span><br><span class="line">        <span class="type">char</span> id[<span class="number">200</span>];</span><br><span class="line">        <span class="type">char</span> value_type[<span class="number">200</span>];   <span class="comment">//用于标记EXP的类型</span></span><br><span class="line">        <span class="type">int</span> rvalue;           <span class="comment">//用于标记是否是右值</span></span><br><span class="line">        <span class="type">int</span> lineno;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Head</span>* child;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Head</span>* next;</span><br><span class="line">    &#125;Node;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Head</span>* <span class="built_in">create_Node</span>(<span class="type">int</span> terminal,<span class="type">char</span>* type, <span class="type">char</span>* id, Node* child,Node* next,<span class="type">int</span> lineno);</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">create_Node</span><span class="params">(<span class="type">int</span> terminal, <span class="type">char</span>* type, <span class="type">char</span>* id, Node* child, Node* next, <span class="type">int</span> lineno)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node* newNode = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Memory allocation error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        newNode-&gt;terminal = terminal;</span><br><span class="line">        newNode-&gt;lineno = (lineno == <span class="number">0</span> &amp;&amp; child != <span class="literal">NULL</span>) ? child-&gt;lineno : lineno;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (type != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(newNode-&gt;type, type, <span class="built_in">sizeof</span>(newNode-&gt;type) - <span class="number">1</span>);</span><br><span class="line">            newNode-&gt;type[<span class="built_in">sizeof</span>(newNode-&gt;type) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode-&gt;type[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (id != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(newNode-&gt;id, id, <span class="built_in">sizeof</span>(newNode-&gt;id) - <span class="number">1</span>);</span><br><span class="line">            newNode-&gt;id[<span class="built_in">sizeof</span>(newNode-&gt;id) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode-&gt;id[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        newNode-&gt;child = child;</span><br><span class="line">        newNode-&gt;next = next;</span><br><span class="line">        newNode-&gt;rvalue = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_tree</span><span class="params">(Node* root, <span class="type">int</span> depth)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于非空节点，进行缩进处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(root-&gt;type, <span class="string">&quot;empty&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印终端节点（叶子节点）的信息</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;terminal == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, root-&gt;type);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对特定类型的节点，打印额外的信息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(root-&gt;type, <span class="string">&quot;ID&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(root-&gt;type,<span class="string">&quot;TYPE&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">                <span class="built_in">strcmp</span>(root-&gt;type, <span class="string">&quot;INT&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(root-&gt;type,<span class="string">&quot;FLOAT&quot;</span>) == <span class="number">0</span> || </span><br><span class="line">                <span class="built_in">strcmp</span>(root-&gt;type, <span class="string">&quot;CHAR&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;: %s&quot;</span>, root-&gt;id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(root-&gt;type, <span class="string">&quot;empty&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对于非终端且非空节点，打印节点类型和所在行号</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s (%d)\n&quot;</span>, root-&gt;type, root-&gt;lineno);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归打印子节点，增加缩进深度</span></span><br><span class="line">        <span class="built_in">print_tree</span>(root-&gt;child, depth + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归打印兄弟节点，保持当前缩进深度</span></span><br><span class="line">        <span class="built_in">print_tree</span>(root-&gt;next, depth);</span><br><span class="line">    &#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%option noyywrap</span><br><span class="line"></span><br><span class="line">int_        [<span class="number">0</span><span class="number">-9</span>]+|<span class="number">0</span>x[<span class="number">0</span><span class="number">-9</span>a-fA-F]+</span><br><span class="line">float_      [<span class="number">0</span><span class="number">-9</span>]+<span class="string">&quot;.&quot;</span>[<span class="number">0</span><span class="number">-9</span>]+</span><br><span class="line">id_         [a-zA-Z_][a-zA-Z0<span class="number">-9</span>_]*</span><br><span class="line">char_       \<span class="string">&#x27;.\&#x27;</span>|\<span class="string">&#x27;\\x[0-9a-fA-F]&#123;2&#125;\&#x27;</span></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"><span class="string">&quot;int&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;TYPE&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> TYPE; &#125;</span><br><span class="line"><span class="string">&quot;float&quot;</span>               &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;TYPE&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> TYPE; &#125;</span><br><span class="line"><span class="string">&quot;char&quot;</span>                &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;TYPE&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> TYPE; &#125;</span><br><span class="line"><span class="string">&quot;struct&quot;</span>              &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;STRUCT&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> STRUCT; &#125;</span><br><span class="line"><span class="string">&quot;if&quot;</span>                  &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;IF&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> IF; &#125;</span><br><span class="line"><span class="string">&quot;else&quot;</span>                &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;ELSE&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> ELSE; &#125;</span><br><span class="line"><span class="string">&quot;while&quot;</span>               &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;WHILE&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> WHILE; &#125;</span><br><span class="line"><span class="string">&quot;return&quot;</span>              &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;RETURN&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> RETURN; &#125;</span><br><span class="line">&#123;int_&#125;              &#123;yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;INT&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> INT;&#125;</span><br><span class="line">&#123;float_&#125;             &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;FLOAT&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> FLOAT; &#125;</span><br><span class="line">&#123;id_&#125;               &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;ID&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> ID; &#125;</span><br><span class="line">&#123;char_&#125;             &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;CHAR&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> CHAR; &#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;DOT&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> DOT; &#125;</span><br><span class="line"><span class="string">&quot;;&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;SEMI&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> SEMI; &#125;</span><br><span class="line"><span class="string">&quot;,&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;COMMA&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> COMMA; &#125;</span><br><span class="line"><span class="string">&quot;=&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;ASSIGN&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> ASSIGN; &#125;</span><br><span class="line"><span class="string">&quot;&lt;&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;LT&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> LT; &#125;</span><br><span class="line"><span class="string">&quot;&gt;&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;GT&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> GT; &#125;</span><br><span class="line"><span class="string">&quot;&lt;=&quot;</span>                &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;LE&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> LE; &#125;</span><br><span class="line"><span class="string">&quot;&gt;=&quot;</span>                &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;GE&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> GE; &#125;</span><br><span class="line"><span class="string">&quot;!=&quot;</span>                &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;NE&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> NE; &#125;</span><br><span class="line"><span class="string">&quot;==&quot;</span>                &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;EQ&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> EQ; &#125;</span><br><span class="line"><span class="string">&quot;+&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;PLUS&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> PLUS; &#125;</span><br><span class="line"><span class="string">&quot;-&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;MINUS&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> MINUS; &#125;</span><br><span class="line"><span class="string">&quot;*&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;MUL&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> MUL; &#125;</span><br><span class="line"><span class="string">&quot;/&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;DIV&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> DIV; &#125;</span><br><span class="line"><span class="string">&quot;&amp;&amp;&quot;</span>                &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;AND&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> AND; &#125;</span><br><span class="line"><span class="string">&quot;||&quot;</span>                &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;OR&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> OR; &#125;</span><br><span class="line"><span class="string">&quot;!&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;NOT&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> NOT; &#125;</span><br><span class="line"><span class="string">&quot;(&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;LP&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> LP; &#125;</span><br><span class="line"><span class="string">&quot;)&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;RP&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> RP; &#125;</span><br><span class="line"><span class="string">&quot;[&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;LB&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> LB; &#125;</span><br><span class="line"><span class="string">&quot;]&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;RB&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> RB; &#125;</span><br><span class="line"><span class="string">&quot;&#123;&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;LC&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> LC; &#125;</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span>                 &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;RC&quot;</span>,yytext,<span class="literal">NULL</span>,<span class="literal">NULL</span>,line);<span class="keyword">return</span> RC; &#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;/*&quot;</span>([^*]|[*][^/]|[*][*]+[^*/])*<span class="string">&quot;*/&quot;</span>  &#123;<span class="comment">/* ignore comments */</span>&#125;</span><br><span class="line">[ \t\r]+            &#123;<span class="comment">/* ignore whitespace */</span>&#125;</span><br><span class="line"><span class="string">&quot;\n&quot;</span>    &#123;line++;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>x([<span class="number">0</span><span class="number">-9</span>a-fA-F]|[g-zG-Z])+     &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;ILLEGAL_HEX_INT&quot;</span>, yytext, <span class="literal">NULL</span>, <span class="literal">NULL</span>, line); <span class="keyword">return</span> ILLEGAL_HEX_INT; &#125;</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]&#123;id_&#125;          &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;ILLEGAL_ID&quot;</span>, yytext, <span class="literal">NULL</span>, <span class="literal">NULL</span>, line); <span class="keyword">return</span> ILLEGAL_ID; &#125;</span><br><span class="line"><span class="string">&#x27;\\x.*&#x27;</span>                        &#123; yylval.node=<span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;ILLEGAL_CHAR&quot;</span>, yytext, <span class="literal">NULL</span>, <span class="literal">NULL</span>, line); <span class="keyword">return</span> ILLEGAL_CHAR; &#125;</span><br><span class="line">.                   &#123; yylval.node = <span class="built_in">create_Node</span>(<span class="number">1</span>,<span class="string">&quot;ILLEGAL&quot;</span>, yytext, <span class="literal">NULL</span>, <span class="literal">NULL</span>, line); <span class="keyword">return</span> ILLEGAL; &#125;</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>syntax.y</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lex.yy.c&quot;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myhead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Node* root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect_to_next</span><span class="params">(<span class="type">int</span> next_num, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next_num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有节点或参数数量为负，不执行任何操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    va_list valist;</span><br><span class="line">    <span class="built_in">va_start</span>(valist, next_num); </span><br><span class="line"></span><br><span class="line">    Node* temp = <span class="built_in">va_arg</span>(valist, Node*); <span class="comment">// 获取第一个节点</span></span><br><span class="line">    Node* prev = temp; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; next_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="built_in">va_arg</span>(valist, Node*); <span class="comment">// 获取下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">            prev-&gt;next = temp; </span><br><span class="line">        &#125;</span><br><span class="line">        prev = temp; <span class="comment">// 更新</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">        temp-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">va_end</span>(valist); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> is_in_function=<span class="literal">false</span>;<span class="comment">//标记当前是否在函数体内部，如果不是，则不允许定义变量</span></span><br><span class="line">    <span class="type">char</span> *current_function_name;<span class="comment">//标记当前所在的函数名</span></span><br><span class="line">    <span class="type">bool</span> index_error=<span class="literal">false</span>; <span class="comment">//标记数组下标是否出错</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find_compst_return</span><span class="params">(Node *Compst, <span class="type">char</span> *expected_type)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_nested_statements</span><span class="params">(Node *stmt, <span class="type">char</span> *expected_type)</span></span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 结构体操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_vardec</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;child-&gt;next) &#123;</span><br><span class="line">            <span class="comment">// 如果子节点没有next成员，则不是数组类型</span></span><br><span class="line">            <span class="built_in">add_dec</span>(node-&gt;child-&gt;id, last_type, node-&gt;lineno);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果子节点有next成员，则为数组类型</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">add_dec</span>(node-&gt;child-&gt;child-&gt;id, <span class="string">&quot;array&quot;</span>, node-&gt;lineno)) &#123;</span><br><span class="line">                <span class="built_in">add_array</span>(node-&gt;child-&gt;child-&gt;id, last_type, node-&gt;lineno);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_ExtDecList</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理当前变量声明</span></span><br><span class="line">        <span class="built_in">insert_vardec</span>(node-&gt;child);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;child-&gt;next) &#123;</span><br><span class="line">            <span class="comment">// 如果存在多个变量声明（逗号分隔），递归处理余下的声明</span></span><br><span class="line">            <span class="built_in">insert_ExtDecList</span>(node-&gt;child-&gt;next-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_struct_member_deflist</span><span class="params">(Node* node, <span class="type">char</span>* struct_name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//用于处理struct内部的成员声明</span></span><br><span class="line">        <span class="comment">//node为DefList</span></span><br><span class="line">        <span class="comment">//struct_name为结构体名</span></span><br><span class="line">        <span class="keyword">if</span>(!node||!node-&gt;child)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* temp=node-&gt;child;</span><br><span class="line">        <span class="comment">//temp即Def</span></span><br><span class="line">        Node* temp2=temp-&gt;child;</span><br><span class="line">        <span class="comment">//temp2即Specifier</span></span><br><span class="line">        <span class="comment">//char* type=temp2-&gt;child-&gt;id;</span></span><br><span class="line">        <span class="type">char</span> *type;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(temp2-&gt;child-&gt;type,<span class="string">&quot;TYPE&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不是结构体</span></span><br><span class="line">            type=temp2-&gt;child-&gt;id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//是结构体</span></span><br><span class="line">            type=temp2-&gt;child-&gt;child-&gt;next-&gt;id;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *temp3=temp-&gt;child-&gt;next;</span><br><span class="line">        <span class="comment">//temp3即DecList</span></span><br><span class="line">        <span class="keyword">while</span>(temp3)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* temp4=temp3-&gt;child;</span><br><span class="line">            <span class="comment">//temp4即Dec</span></span><br><span class="line">            Node* temp5=temp4-&gt;child;</span><br><span class="line">            <span class="comment">//temp5即VarDec</span></span><br><span class="line">            <span class="keyword">if</span>(temp5-&gt;child-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//不是数组</span></span><br><span class="line">                <span class="built_in">add_struct_member</span>(struct_name,temp5-&gt;child-&gt;id,type,temp5-&gt;lineno);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//是数组</span></span><br><span class="line">                <span class="built_in">add_struct_member</span>(struct_name,temp5-&gt;child-&gt;child-&gt;id,<span class="string">&quot;array&quot;</span>,temp5-&gt;lineno);</span><br><span class="line">                <span class="built_in">add_array</span>(temp5-&gt;child-&gt;child-&gt;id,type,temp5-&gt;lineno);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp3-&gt;child-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Dec COMMA DecList</span></span><br><span class="line">                temp3=temp3-&gt;child-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Dec</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;child)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Def DefList</span></span><br><span class="line">            <span class="built_in">add_struct_member_deflist</span>(node-&gt;child-&gt;next,struct_name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Def</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 函数参数和变量插入 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_function_args</span><span class="params">(<span class="type">char</span> *func_name, Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果节点为空，没有更多的变量需要处理，返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理当前的ParamDec节点</span></span><br><span class="line">        Node *param = node-&gt;child;</span><br><span class="line">        Node *specifier = param-&gt;child;</span><br><span class="line">        Node *vardec = specifier-&gt;next;</span><br><span class="line">        <span class="type">char</span> *type = specifier-&gt;child-&gt;id; <span class="comment">// 获取类型</span></span><br><span class="line">        <span class="type">char</span> *name = vardec-&gt;child-&gt;id;    <span class="comment">// 获取变量名</span></span><br><span class="line">        <span class="comment">// 为简单起见，此处假设参数是非数组类型</span></span><br><span class="line">        <span class="built_in">add_func_args</span>(func_name, name, type, param-&gt;lineno);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果存在COMMA，说明后面还有参数，递归处理后续的VarList</span></span><br><span class="line">        Node *nextParam = node-&gt;child-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (nextParam != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(nextParam-&gt;type, <span class="string">&quot;COMMA&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">insert_function_args</span>(func_name, nextParam-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_func_variables</span><span class="params">(Node *Dec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果不在函数内部或输入节点为空，则不需要处理</span></span><br><span class="line">        <span class="keyword">if</span> (!is_in_function || Dec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在函数体内部</span></span><br><span class="line">        Node *VarDec = Dec-&gt;child;</span><br><span class="line">        <span class="type">char</span> *var_name;</span><br><span class="line">        <span class="type">char</span> *var_type;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否为数组类型</span></span><br><span class="line">        <span class="keyword">if</span> (VarDec-&gt;child-&gt;next) &#123;</span><br><span class="line">            <span class="comment">// 处理数组类型的变量</span></span><br><span class="line">            var_name = VarDec-&gt;child-&gt;child-&gt;id;</span><br><span class="line">            var_type = <span class="string">&quot;array&quot;</span>;</span><br><span class="line">            <span class="built_in">add_func_variables</span>(current_function_name, var_name, var_type, VarDec-&gt;lineno);</span><br><span class="line">            <span class="built_in">add_array</span>(var_name, last_type, VarDec-&gt;lineno);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理普通变量</span></span><br><span class="line">            var_name = VarDec-&gt;child-&gt;id;</span><br><span class="line">            var_type = last_type;</span><br><span class="line">            <span class="built_in">add_func_variables</span>(current_function_name, var_name, var_type, VarDec-&gt;lineno);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查赋值语句并验证类型匹配</span></span><br><span class="line">        Node *Assign = VarDec-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (Assign &amp;&amp; <span class="built_in">strcmp</span>(Assign-&gt;type, <span class="string">&quot;ASSIGN&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            Node *Exp = Assign-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(Exp-&gt;value_type, <span class="string">&quot;error&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(Exp-&gt;value_type, last_type) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error type 5 at line %d: Type mismatched for assignment\n&quot;</span>, Exp-&gt;lineno);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 表达式检查 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_type</span><span class="params">(Node *exp, <span class="type">const</span> <span class="type">char</span> *expected_type, <span class="type">int</span> error_type, <span class="type">int</span> lineno)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(exp-&gt;value_type, <span class="string">&quot;error&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 类型已经是错误，之前的步骤中已经报错，此处不再重复。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expected_type != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(exp-&gt;value_type, expected_type) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type %d at line %d: Type mismatched for operands\n&quot;</span>, error_type, lineno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_single_arithmetic_exp</span><span class="params">(Node *exp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查单个Exp的类型是否为int或者float</span></span><br><span class="line">        <span class="built_in">check_type</span>(exp, <span class="literal">NULL</span>, <span class="number">7</span>, exp-&gt;lineno);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(exp-&gt;value_type, <span class="string">&quot;int&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(exp-&gt;value_type, <span class="string">&quot;float&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 7 at line %d: Type mismatched for operands, expected int or float\n&quot;</span>, exp-&gt;lineno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_single_logical_exp</span><span class="params">(Node *exp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查单个Exp的类型是否为int</span></span><br><span class="line">        <span class="built_in">check_type</span>(exp, <span class="string">&quot;int&quot;</span>, <span class="number">7</span>, exp-&gt;lineno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_exp_arithmetic_symbols</span><span class="params">(Node *exp1, Node *exp2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设算术运算只能由int或float类型的变量进行</span></span><br><span class="line">        <span class="built_in">check_type</span>(exp1, <span class="literal">NULL</span>, <span class="number">7</span>, exp1-&gt;lineno);</span><br><span class="line">        <span class="built_in">check_type</span>(exp2, <span class="literal">NULL</span>, <span class="number">7</span>, exp2-&gt;lineno);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(exp1-&gt;value_type, <span class="string">&quot;int&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(exp1-&gt;value_type, <span class="string">&quot;float&quot;</span>) != <span class="number">0</span>) || </span><br><span class="line">            (<span class="built_in">strcmp</span>(exp2-&gt;value_type, <span class="string">&quot;int&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(exp2-&gt;value_type, <span class="string">&quot;float&quot;</span>) != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 7 at line %d: Type mismatched for operands, expected int or float\n&quot;</span>, exp1-&gt;lineno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(exp1-&gt;value_type, exp2-&gt;value_type) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 7 at line %d: Type mismatched for operands, expected same type\n&quot;</span>, exp1-&gt;lineno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_exp_logical_symbols</span><span class="params">(Node *exp1, Node *exp2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设逻辑运算只能由int类型的变量进行</span></span><br><span class="line">        <span class="built_in">check_type</span>(exp1, <span class="string">&quot;int&quot;</span>, <span class="number">7</span>, exp1-&gt;lineno);</span><br><span class="line">        <span class="built_in">check_type</span>(exp2, <span class="string">&quot;int&quot;</span>, <span class="number">7</span>, exp2-&gt;lineno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_exp_assign</span><span class="params">(Node *exp1, Node *exp2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于检查赋值语句左右两边的类型是否匹配</span></span><br><span class="line">        <span class="built_in">check_type</span>(exp1, <span class="literal">NULL</span>, <span class="number">6</span>, exp1-&gt;lineno);</span><br><span class="line">        <span class="built_in">check_type</span>(exp2, <span class="literal">NULL</span>, <span class="number">5</span>, exp2-&gt;lineno);</span><br><span class="line">        <span class="keyword">if</span> (exp1-&gt;rvalue) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 6 at line %d: rvalue on the left side of assignment operator\n&quot;</span>, exp1-&gt;lineno);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(exp1-&gt;value_type, exp2-&gt;value_type) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 5 at line %d: Type mismatched for assignment\n&quot;</span>, exp1-&gt;lineno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_Exp_with_specific_type</span><span class="params">(Node *Exp, <span class="type">char</span> *expected_type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于检查Exp的类型是否为expected_type</span></span><br><span class="line">        <span class="built_in">check_type</span>(Exp, expected_type, <span class="number">7</span>, Exp-&gt;lineno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_Def</span><span class="params">(Node *Def)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// expected_type 为定义的类型</span></span><br><span class="line">        <span class="type">char</span> *expected_type = last_type;</span><br><span class="line">        Node *DecList = Def-&gt;child-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环处理定义列表中的所有声明</span></span><br><span class="line">        <span class="keyword">while</span> (DecList) &#123;</span><br><span class="line">            Node *Dec = DecList-&gt;child;</span><br><span class="line">            Node *VarDec = Dec-&gt;child;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果存在赋值（ASSIGN），检查表达式（Exp）的类型是否匹配</span></span><br><span class="line">            Node *Assign = VarDec-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (Assign &amp;&amp; <span class="built_in">strcmp</span>(Assign-&gt;type, <span class="string">&quot;ASSIGN&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                Node *Exp = Assign-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(Exp-&gt;value_type, <span class="string">&quot;error&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(Exp-&gt;value_type, expected_type) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error type 5 at line %d: Type mismatched for assignment\n&quot;</span>, Exp-&gt;lineno);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动到下一个声明，如果存在</span></span><br><span class="line">            DecList = (Dec-&gt;next &amp;&amp; <span class="built_in">strcmp</span>(Dec-&gt;next-&gt;type, <span class="string">&quot;COMMA&quot;</span>) == <span class="number">0</span>) ? Dec-&gt;next-&gt;next : <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置节点的值为右值 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_rvalue</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            node-&gt;rvalue = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置节点的类型</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_EXP_value_type</span><span class="params">(Node *node, <span class="type">char</span> *type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node &amp;&amp; type) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(node-&gt;value_type, type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 函数参数和返回类型检查 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_func_return_type</span><span class="params">(Node* Compst, <span class="type">char</span> *expected_type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_in_function || Compst == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不在函数内部或者Compst为空，则不需要处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归检查函数体中的返回语句</span></span><br><span class="line">        <span class="built_in">find_compst_return</span>(Compst, expected_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find_compst_return</span><span class="params">(Node *Compst, <span class="type">char</span> *expected_type)</span> </span>&#123;</span><br><span class="line">        Node *stmtlist = Compst-&gt;child-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (stmtlist &amp;&amp; stmtlist-&gt;child) &#123;</span><br><span class="line">            Node *stmt = stmtlist-&gt;child;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stmt-&gt;child-&gt;type, <span class="string">&quot;RETURN&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                Node *exp = stmt-&gt;child-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (exp &amp;&amp; <span class="built_in">strcmp</span>(exp-&gt;value_type, expected_type) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(exp-&gt;value_type, <span class="string">&quot;error&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error type 8 at line %d: The return type mismatched\n&quot;</span>, exp-&gt;lineno);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stmt-&gt;child-&gt;type, <span class="string">&quot;CompSt&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">find_compst_return</span>(stmt-&gt;child, expected_type);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理可能嵌套的结构，如if-else和while语句</span></span><br><span class="line">                <span class="built_in">check_nested_statements</span>(stmt, expected_type);</span><br><span class="line">            &#125;</span><br><span class="line">            stmtlist = stmtlist-&gt;next ? stmtlist-&gt;next-&gt;child : <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_nested_statements</span><span class="params">(Node *stmt, <span class="type">char</span> *expected_type)</span> </span>&#123;</span><br><span class="line">        Node *head = stmt-&gt;child;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(head-&gt;type, <span class="string">&quot;Stmt&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(head-&gt;child-&gt;type, <span class="string">&quot;CompSt&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">find_compst_return</span>(head-&gt;child, expected_type);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(head-&gt;child-&gt;type, <span class="string">&quot;RETURN&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    Node *exp = head-&gt;child-&gt;next;</span><br><span class="line">                    <span class="keyword">if</span> (exp &amp;&amp; <span class="built_in">strcmp</span>(exp-&gt;value_type, expected_type) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(exp-&gt;value_type, <span class="string">&quot;error&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Error type 8 at line %d: The return type mismatched\n&quot;</span>, exp-&gt;lineno);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_func_args</span><span class="params">(<span class="type">char</span> *func_name, Node *Args, <span class="type">int</span> arg_index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找函数定义</span></span><br><span class="line">        <span class="type">int</span> func_index;</span><br><span class="line">        <span class="keyword">for</span>(func_index = <span class="number">0</span>; func_index &lt; def_num; func_index++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(def[func_index].name, func_name) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到函数，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(func_index == def_num) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Node *current_arg = Args-&gt;child;</span><br><span class="line">        <span class="comment">// 检查参数个数和类型是否匹配</span></span><br><span class="line">        <span class="keyword">if</span>(arg_index &lt; def[func_index].arg_num) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(current_arg-&gt;value_type, def[func_index].args[arg_index].type) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error type 9 at line %d: Unmatched argument type for Function \&quot;%s\&quot;\n&quot;</span>, current_arg-&gt;lineno, func_name);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 9 at line %d: Too many arguments for Function \&quot;%s\&quot;\n&quot;</span>, current_arg-&gt;lineno, func_name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归检查下一个参数，如果存在</span></span><br><span class="line">        <span class="keyword">if</span>(current_arg-&gt;next) &#123;</span><br><span class="line">            <span class="built_in">check_func_args</span>(func_name, current_arg-&gt;next-&gt;next, arg_index + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arg_index + <span class="number">1</span> &lt; def[func_index].arg_num) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 9 at line %d: Too few arguments for Function \&quot;%s\&quot;\n&quot;</span>, current_arg-&gt;lineno, func_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_func_without_args</span><span class="params">(<span class="type">char</span> *func_name, <span class="type">int</span> lineno)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找函数定义</span></span><br><span class="line">        <span class="type">int</span> func_index;</span><br><span class="line">        <span class="keyword">for</span>(func_index = <span class="number">0</span>; func_index &lt; def_num; func_index++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(def[func_index].name, func_name) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到函数，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(func_index == def_num) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(def[func_index].arg_num != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 9 at line %d: Function \&quot;%s\&quot; expects no arguments\n&quot;</span>, lineno, func_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 数组操作检查 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check_exp_array</span><span class="params">(Node *array_exp, Node *index_exp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果下标或数组表达式的类型已经是错误，不再进行检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(index_exp-&gt;value_type, <span class="string">&quot;error&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(array_exp-&gt;value_type, <span class="string">&quot;error&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否应用了下标操作符到非数组类型的变量上</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(array_exp-&gt;value_type, <span class="string">&quot;array&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 10 at line %d: Indexing operator ([...]) applied to non-array variable \&quot;%s\&quot;.\n&quot;</span>, array_exp-&gt;lineno, array_exp-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查下标是否为整型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(index_exp-&gt;value_type, <span class="string">&quot;int&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 12 at line %d: Array index is not an integer.\n&quot;</span>, index_exp-&gt;lineno);</span><br><span class="line">            index_error = <span class="literal">true</span>; <span class="comment">// 确保外部标记了存在下标错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">find_array_elem_type</span><span class="params">(Node *exp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到数组的ID节点</span></span><br><span class="line">        Node *id = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (exp-&gt;child &amp;&amp; !found) &#123;</span><br><span class="line">            exp = exp-&gt;child;</span><br><span class="line">            Node *temp = exp;</span><br><span class="line">            <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(temp-&gt;type, <span class="string">&quot;ID&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    id = temp;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在定义中查找匹配的数组并返回其元素类型</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, id-&gt;id) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> def[i].elem_type;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果没有找到匹配的定义，返回NULL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 结构体成员检查 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check_exp_structure</span><span class="params">(Node *structure_exp, Node *member_id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果表达式类型有错误，则不再检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(structure_exp-&gt;value_type, <span class="string">&quot;error&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(member_id-&gt;value_type, <span class="string">&quot;error&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否为结构体</span></span><br><span class="line">        <span class="type">bool</span> is_structure_found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dec_num &amp;&amp; !is_structure_found; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dec[i].name, structure_exp-&gt;value_type) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dec[i].type, <span class="string">&quot;structure&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error type 13 at line %d: Illegal member access on non-structure variable \&quot;%s\&quot;\n&quot;</span>, </span><br><span class="line">                        structure_exp-&gt;lineno, structure_exp-&gt;id);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                is_structure_found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到对应的结构体定义，则报错</span></span><br><span class="line">        <span class="keyword">if</span> (!is_structure_found) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 13 at line %d: Illegal member access on non-structure variable \&quot;%s\&quot;\n&quot;</span>, </span><br><span class="line">                structure_exp-&gt;lineno, structure_exp-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查结构体内是否有该成员</span></span><br><span class="line">        <span class="type">char</span> *type = <span class="built_in">find_structure_member_type</span>(structure_exp-&gt;value_type, member_id-&gt;id);</span><br><span class="line">        <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 14 at line %d: Structure &#x27;%s&#x27; has no member named &#x27;%s&#x27;\n&quot;</span>, </span><br><span class="line">                structure_exp-&gt;lineno, structure_exp-&gt;value_type, member_id-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 函数调用检查 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check_if_func_exist</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> lineno)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先检查全局声明是否包含该名称</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dec_num; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dec[i].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 名称匹配，检查是否为函数类型</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dec[i].type, <span class="string">&quot;function&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error type 11 at Line %d: &#x27;%s&#x27; is not a function name.\n&quot;</span>, lineno, name);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来检查当前函数内部是否有同名的参数或局部声明</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, current_function_name) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查参数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; def[i].arg_num; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].args[j].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Error type 11 at Line %d: &#x27;%s&#x27; is a parameter, not a function.\n&quot;</span>, lineno, name);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检查局部声明</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; def[i].dec_num; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].dec[j].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].dec[j].type, <span class="string">&quot;function&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;Error type 11 at Line %d: &#x27;%s&#x27; is not a function name.\n&quot;</span>, lineno, name);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果前面的检查都没有返回，意味着函数未定义</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error type 2 at Line %d: Function \&quot;%s\&quot; is invoked without definition.\n&quot;</span>, lineno, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 变量检查 */</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">check_exp_id</span><span class="params">(Node *id)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> *type = <span class="string">&quot;error&quot;</span>; <span class="comment">// 默认类型为 &quot;error&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先在全局声明中检索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dec_num; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dec[i].name, id-&gt;id) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> dec[i].type; <span class="comment">// 找到匹配，返回对应类型</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再检查是否为某个结构体定义的成员</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; def[i].dec_num; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].dec[j].name, id-&gt;id) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> def[i].dec[j].type; <span class="comment">// 找到匹配，返回对应类型</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后检查是否为当前函数的参数或局部变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, current_function_name) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查参数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; def[i].arg_num; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].args[j].name, id-&gt;id) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> def[i].args[j].type; <span class="comment">// 找到匹配，返回对应类型</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检查局部变量</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; def[i].dec_num; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].dec[j].name, id-&gt;id) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> def[i].dec[j].type; <span class="comment">// 找到匹配，返回对应类型</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果标识符未定义并且处于函数内部，则打印错误信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(type, <span class="string">&quot;error&quot;</span>) == <span class="number">0</span> &amp;&amp; is_in_function) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 1 at line %d: Undefined variable \&quot;%s\&quot;.\n&quot;</span>, id-&gt;lineno, id-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> type; <span class="comment">// 如果没有找到匹配的声明，返回 &quot;error&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%<span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>     num;</span><br><span class="line">    <span class="type">char</span>*   str;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Head</span>* node; <span class="comment">/*&quot;struct&quot; is indispensable*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%right ASSIGN</span><br><span class="line">%left OR</span><br><span class="line">%left AND</span><br><span class="line">%left LT LE GT GE NE EQ</span><br><span class="line">%left PLUS MINUS</span><br><span class="line">%left MUL DIV</span><br><span class="line">%right NOT NEGATIVE</span><br><span class="line">%nonassoc LC RC LB RB LP RP DOT</span><br><span class="line"></span><br><span class="line">%token &lt;node&gt; ID INT FLOAT CHAR STRUCT RETURN IF ELSE WHILE PLUS MINUS MUL DIV AND OR LT LE GT GE NE EQ NOT ASSIGN TYPE LP RP LB RB LC RC SEMI COMMA DOT ILLEGAL ILLEGAL_ID ILLEGAL_HEX_INT ILLEGAL_CHAR</span><br><span class="line"></span><br><span class="line">%type &lt;node&gt; Program ExtDefList ExtDef ExtDecList Specifier StructSpecifier VarDec FunDec VarList ParamDec CompSt StmtList Stmt DefList Def DecList Dec Exp Args</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">Program: ExtDefList &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Program&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);root=$$;&#125;</span><br><span class="line"></span><br><span class="line">ExtDefList: ExtDef ExtDefList  &#123;<span class="built_in">connect_to_next</span>(<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">2</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDefList&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">          | <span class="comment">/* empty */</span>         &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;empty&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">100</span>);&#125;</span><br><span class="line"></span><br><span class="line">ExtDef: Specifier ExtDecList SEMI   &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDef&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">insert_ExtDecList</span>($<span class="number">2</span>);&#125;</span><br><span class="line">      | Specifier ExtDecList error  &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing semicolon &#x27;;&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;lineno);&#125;</span><br><span class="line">      | Specifier SEMI              &#123;<span class="built_in">connect_to_next</span>(<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">2</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDef&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">      | Specifier FunDec CompSt     &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDef&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="keyword">if</span>(is_in_function)&#123;<span class="built_in">set_func_return_type</span>(current_function_name,$<span class="number">1</span>-&gt;child-&gt;id);<span class="built_in">check_func_return_type</span>($<span class="number">3</span>,$<span class="number">1</span>-&gt;child-&gt;id);&#125;is_in_function=<span class="literal">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">ExtDecList: VarDec                      &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDecList&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">           | VarDec COMMA ExtDecList    &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDecList&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">Specifier: TYPE                         &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Specifier&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">set_last_type</span>($<span class="number">1</span>-&gt;id);&#125;</span><br><span class="line">          | StructSpecifier             &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Specifier&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">StructSpecifier: STRUCT ID LC DefList RC    &#123;<span class="built_in">connect_to_next</span>(<span class="number">5</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>,$<span class="number">5</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;StructSpecifier&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="keyword">if</span>(<span class="built_in">add_dec</span>($<span class="number">2</span>-&gt;id,<span class="string">&quot;structure&quot;</span>,$<span class="number">2</span>-&gt;lineno)&amp;&amp;<span class="built_in">add_func_or_struct</span>($<span class="number">2</span>-&gt;id,$<span class="number">2</span>-&gt;lineno,<span class="string">&quot;structure&quot;</span>))&#123;<span class="built_in">add_struct_member_deflist</span>($<span class="number">4</span>,$<span class="number">2</span>-&gt;id);&#125;&#125;</span><br><span class="line">               | STRUCT ID                  &#123;<span class="built_in">connect_to_next</span>(<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">2</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;StructSpecifier&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">set_last_type</span>($<span class="number">2</span>-&gt;id);&#125;</span><br><span class="line"></span><br><span class="line">VarDec: ID                              &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;VarDec&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">       | ILLEGAL_ID error               &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type A at line %d: illegal identifier &#x27;%s&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;lineno,$<span class="number">1</span>-&gt;id);&#125;</span><br><span class="line">       | VarDec LB INT RB               &#123;<span class="built_in">connect_to_next</span>(<span class="number">4</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;VarDec&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">FunDec: ID LP VarList RP                &#123;<span class="built_in">connect_to_next</span>(<span class="number">4</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;FunDec&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="keyword">if</span>(<span class="built_in">add_dec</span>($<span class="number">1</span>-&gt;id,<span class="string">&quot;function&quot;</span>,$<span class="number">1</span>-&gt;lineno)&amp;&amp;<span class="built_in">add_func_or_struct</span>($<span class="number">1</span>-&gt;id,$<span class="number">1</span>-&gt;lineno,<span class="string">&quot;function&quot;</span>))&#123;<span class="built_in">insert_function_args</span>($<span class="number">1</span>-&gt;id,$<span class="number">3</span>);current_function_name=$<span class="number">1</span>-&gt;id;is_in_function=<span class="literal">true</span>;&#125; <span class="keyword">else</span>&#123;is_in_function=<span class="literal">false</span>;&#125;&#125;</span><br><span class="line">       | ID LP RP                       &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;FunDec&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="keyword">if</span>(<span class="built_in">add_dec</span>($<span class="number">1</span>-&gt;id,<span class="string">&quot;function&quot;</span>,$<span class="number">1</span>-&gt;lineno)&amp;&amp;<span class="built_in">add_func_or_struct</span>($<span class="number">1</span>-&gt;id,$<span class="number">1</span>-&gt;lineno,<span class="string">&quot;function&quot;</span>))&#123;current_function_name=$<span class="number">1</span>-&gt;id;is_in_function=<span class="literal">true</span>;&#125; <span class="keyword">else</span>&#123;is_in_function=<span class="literal">false</span>;&#125;&#125;</span><br><span class="line">       | ID LP VarList error            &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing closing symbols &#x27;)&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;lineno);&#125;  </span><br><span class="line">       | ID LP error                    &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing closing symbols &#x27;)&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;lineno);&#125; </span><br><span class="line"></span><br><span class="line">VarList: ParamDec COMMA VarList         &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;VarList&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">        | ParamDec                      &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;VarList&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">ParamDec: Specifier VarDec              &#123;<span class="built_in">connect_to_next</span>(<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">2</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;ParamDec&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">CompSt: LC DefList StmtList RC          &#123;<span class="built_in">connect_to_next</span>(<span class="number">4</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;CompSt&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">StmtList: Stmt StmtList                 &#123;<span class="built_in">connect_to_next</span>(<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">2</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;StmtList&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">         |Stmt Def StmtList error       &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: definition after statement\n&quot;</span>, $<span class="number">2</span>-&gt;lineno);&#125;</span><br><span class="line">         | <span class="comment">/* empty */</span>                  &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;empty&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">100</span>);&#125;</span><br><span class="line"></span><br><span class="line">Stmt: Exp SEMI                          &#123;<span class="built_in">connect_to_next</span>(<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">2</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">    | CompSt                            &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">    | RETURN Exp SEMI                   &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">    | RETURN Exp error                  &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing semicolon &#x27;;&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;lineno);&#125;     </span><br><span class="line">    | IF LP Exp RP Stmt                 &#123;<span class="built_in">connect_to_next</span>(<span class="number">5</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>,$<span class="number">5</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">    | IF LP Exp RP Stmt ELSE Stmt       &#123;<span class="built_in">connect_to_next</span>(<span class="number">7</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>,$<span class="number">5</span>,$<span class="number">6</span>,$<span class="number">7</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">    | WHILE LP Exp RP Stmt              &#123;<span class="built_in">connect_to_next</span>(<span class="number">5</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>,$<span class="number">5</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">DefList: Def DefList                    &#123;<span class="built_in">connect_to_next</span>(<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">2</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;DefList&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">        | <span class="comment">/* empty */</span>                   &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;empty&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">100</span>);&#125;</span><br><span class="line"></span><br><span class="line">Def: Specifier DecList SEMI             &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Def&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_Def</span>($$);&#125;</span><br><span class="line">    | Specifier DecList error           &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing semicolon &#x27;;&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;lineno);&#125;</span><br><span class="line"></span><br><span class="line">DecList: Dec                            &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;DecList&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">        | Dec COMMA DecList             &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;DecList&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">Dec: VarDec                             &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Dec&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">insert_func_variables</span>($$);&#125;</span><br><span class="line">    | VarDec ASSIGN Exp                 &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Dec&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">insert_func_variables</span>($$);&#125;</span><br><span class="line"></span><br><span class="line">Exp: Exp ASSIGN Exp                     &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_assign</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;int&quot;</span>);&#125;</span><br><span class="line">    | Exp AND Exp                       &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_logical_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;int&quot;</span>);&#125;</span><br><span class="line">    | Exp OR Exp                        &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_logical_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;int&quot;</span>);&#125;    </span><br><span class="line">    | Exp LT Exp                        &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_logical_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;int&quot;</span>);&#125;    </span><br><span class="line">    | Exp LE Exp                        &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_logical_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;int&quot;</span>);&#125;    </span><br><span class="line">    | Exp GT Exp                        &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_logical_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;int&quot;</span>);&#125;</span><br><span class="line">    | Exp GE Exp                        &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_logical_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;int&quot;</span>);&#125;</span><br><span class="line">    | Exp NE Exp                        &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_logical_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;int&quot;</span>);&#125;</span><br><span class="line">    | Exp EQ Exp                        &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_logical_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;int&quot;</span>);&#125;</span><br><span class="line">    | Exp PLUS Exp                      &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_arithmetic_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,$<span class="number">1</span>-&gt;value_type);&#125;</span><br><span class="line">    | Exp MINUS Exp                     &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_arithmetic_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,$<span class="number">1</span>-&gt;value_type);&#125;</span><br><span class="line">    | Exp MUL Exp                       &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_arithmetic_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,$<span class="number">1</span>-&gt;value_type);&#125;</span><br><span class="line">    | Exp DIV Exp                       &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_exp_arithmetic_symbols</span>($<span class="number">1</span>,$<span class="number">3</span>);<span class="built_in">set_rvalue</span>($$);<span class="built_in">set_EXP_value_type</span>($$,$<span class="number">1</span>-&gt;value_type);&#125;</span><br><span class="line">    | LP Exp RP                         &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">strcpy</span>($$-&gt;value_type,$<span class="number">2</span>-&gt;value_type);$$-&gt;rvalue=$<span class="number">2</span>-&gt;rvalue;&#125;    <span class="comment">//(b)</span></span><br><span class="line">    | LP Exp error                      &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing closing symbols &#x27;)&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;lineno);&#125;</span><br><span class="line">    | MINUS Exp                         &#123;<span class="built_in">connect_to_next</span>(<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">2</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_single_arithmetic_exp</span>($<span class="number">2</span>);$$-&gt;rvalue=$<span class="number">2</span>-&gt;rvalue;<span class="built_in">set_EXP_value_type</span>($$,$<span class="number">2</span>-&gt;value_type);&#125;</span><br><span class="line">    | NOT Exp                           &#123;<span class="built_in">connect_to_next</span>(<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">2</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">check_single_logical_exp</span>($<span class="number">2</span>);$$-&gt;rvalue=$<span class="number">2</span>-&gt;rvalue;<span class="built_in">set_EXP_value_type</span>($$,$<span class="number">2</span>-&gt;value_type);&#125;</span><br><span class="line">    | ID LP Args RP                     &#123;<span class="built_in">connect_to_next</span>(<span class="number">4</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="keyword">if</span>(<span class="built_in">check_if_func_exist</span>($<span class="number">1</span>-&gt;id,$<span class="number">1</span>-&gt;lineno))&#123;<span class="built_in">check_func_args</span>($<span class="number">1</span>-&gt;id,$<span class="number">3</span>,<span class="number">0</span>);<span class="built_in">set_EXP_value_type</span>($$,<span class="built_in">find_func_return_type</span>($<span class="number">1</span>-&gt;id));&#125; <span class="keyword">else</span>&#123;<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;error&quot;</span>);&#125;&#125;         <span class="comment">//调用函数a(...)</span></span><br><span class="line">    | ID LP Args error                  &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing closing symbols &#x27;)&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;lineno);&#125;</span><br><span class="line">    | ID LP RP                          &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="keyword">if</span>(<span class="built_in">check_if_func_exist</span>($<span class="number">1</span>-&gt;id,$<span class="number">1</span>-&gt;lineno))&#123;<span class="built_in">check_func_without_args</span>($<span class="number">1</span>-&gt;id,$<span class="number">1</span>-&gt;lineno);<span class="built_in">set_EXP_value_type</span>($$,<span class="built_in">find_func_return_type</span>($<span class="number">1</span>-&gt;id));&#125; <span class="keyword">else</span>&#123;<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;error&quot;</span>);&#125;&#125;    <span class="comment">//调用函数，无参数</span></span><br><span class="line">    | Exp LB Exp RB                     &#123;<span class="built_in">connect_to_next</span>(<span class="number">4</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="keyword">if</span>(<span class="built_in">check_exp_array</span>($<span class="number">1</span>,$<span class="number">3</span>))&#123;<span class="keyword">if</span>(index_error)&#123;<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;None&quot;</span>);index_error=<span class="literal">false</span>;&#125;<span class="keyword">else</span>&#123;<span class="built_in">set_EXP_value_type</span>($$,<span class="built_in">find_array_elem_type</span>($<span class="number">1</span>));&#125;&#125;<span class="keyword">else</span>&#123;<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;error&quot;</span>);&#125;&#125;     <span class="comment">//数组访问a[...]</span></span><br><span class="line">    | Exp DOT ID                        &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="keyword">if</span>(<span class="built_in">check_exp_structure</span>($<span class="number">1</span>,$<span class="number">3</span>))&#123;<span class="built_in">set_EXP_value_type</span>($$,<span class="built_in">find_structure_member_type</span>($<span class="number">1</span>-&gt;value_type,$<span class="number">3</span>-&gt;id));&#125;<span class="keyword">else</span>&#123;<span class="built_in">strcpy</span>($$-&gt;value_type,<span class="string">&quot;None&quot;</span>);&#125;&#125;    <span class="comment">//结构体</span></span><br><span class="line">    | ID                                &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">set_EXP_value_type</span>($$,<span class="built_in">check_exp_id</span>($<span class="number">1</span>));&#125;</span><br><span class="line">    | INT                               &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;int&quot;</span>);$$-&gt;rvalue=<span class="number">1</span>;&#125;</span><br><span class="line">    | FLOAT                             &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;float&quot;</span>);$$-&gt;rvalue=<span class="number">1</span>;&#125;</span><br><span class="line">    | CHAR                              &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">set_EXP_value_type</span>($$,<span class="string">&quot;char&quot;</span>);$$-&gt;rvalue=<span class="number">1</span>;&#125;</span><br><span class="line">    | ILLEGAL error                     &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type A at line %d: unknown lexeme &#x27;%s&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;lineno,$<span class="number">1</span>-&gt;id);&#125;</span><br><span class="line">    | ILLEGAL_HEX_INT error             &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type A at line %d: illegal hexadecimal integer &#x27;%s&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;lineno,$<span class="number">1</span>-&gt;id);&#125;</span><br><span class="line">    | ILLEGAL_CHAR error                &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type A at line %d: illegal hex_character &#x27;%s&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;lineno,$<span class="number">1</span>-&gt;id);&#125;</span><br><span class="line">    | Exp ILLEGAL Exp error             &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type A at line %d: illegal operator &#x27;%s&#x27;\n&quot;</span>, $<span class="number">2</span>-&gt;lineno,$<span class="number">2</span>-&gt;id);&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">Args: Exp COMMA Args                    &#123;<span class="built_in">connect_to_next</span>(<span class="number">3</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>);$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Args&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line">     | Exp                              &#123;$$=<span class="built_in">create_Node</span>(<span class="number">0</span>,<span class="string">&quot;Args&quot;</span>,<span class="string">&quot;&quot;</span>,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;Syntax error at line %d: %s\n&quot;, line, s);</span></span><br><span class="line">    <span class="comment">//printf(&quot;Error type B at line &quot;);</span></span><br><span class="line">    flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Usage: %s &lt;file_path&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(yyin = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">yyparse</span>();</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//print_tree(root,0);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    printf(&quot;\ntables:\n&quot;);</span></span><br><span class="line"><span class="comment">    //打印符号表</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;dec_num;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%s %s\n&quot;,dec[i].name,dec[i].type);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    //打印定义表</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;def_num;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%s \n&quot;,def[i].name);</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;def[i].arg_num;j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            printf(&quot;%s %s\n&quot;,def[i].args[j].name,def[i].args[j].type);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;def[i].dec_num;j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            printf(&quot;%s %s\n&quot;,def[i].dec[j].name,def[i].dec[j].type);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        printf(&quot;return_type:%s\n&quot;,def[i].return_type);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">FLEX=flex</span><br><span class="line">BISON=bison</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: bplc clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">bplc: bin/bplc</span></span><br><span class="line"></span><br><span class="line"><span class="section">bin/bplc: bin myhead.o syntax.tab.o</span></span><br><span class="line"><span class="variable">$(CC)</span> -o bin/bplc myhead.o syntax.tab.o -lfl -ly</span><br><span class="line"></span><br><span class="line"><span class="section">myhead.o: myhead.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c myhead.cpp -o myhead.o</span><br><span class="line"></span><br><span class="line"><span class="section">syntax.tab.o: syntax.tab.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c syntax.tab.c -o syntax.tab.o</span><br><span class="line"></span><br><span class="line"><span class="section">syntax.tab.c: syntax.y lex.yy.c</span></span><br><span class="line"><span class="variable">$(BISON)</span> -t -d syntax.y</span><br><span class="line"></span><br><span class="line"><span class="section">lex.yy.c: lex.l</span></span><br><span class="line"><span class="variable">$(FLEX)</span> lex.l</span><br><span class="line"></span><br><span class="line"><span class="section">bin:</span></span><br><span class="line">mkdir bin</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">@rm -f lex.yy.c syntax.tab.* ./bin/* *.o</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>bplc_test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DATA = pathlib.Path(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jsonparser_output</span>(<span class="params">json_file</span>):</span><br><span class="line">    out = subprocess.check_output([<span class="string">&#x27;./bin/bplc&#x27;</span>, json_file])</span><br><span class="line">    <span class="keyword">return</span> out.decode().strip()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_jsonchecker_fail_syntaxonly</span>():</span><br><span class="line">    data = DATA</span><br><span class="line">    <span class="keyword">for</span> bplfile <span class="keyword">in</span> data.glob(<span class="string">&#x27;*.bpl&#x27;</span>):</span><br><span class="line">        out = jsonparser_output(bplfile)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;For file <span class="subst">&#123;bplfile.name&#125;</span>:&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(out)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;#&#x27;</span>*<span class="number">80</span>)</span><br><span class="line">        subfolder_name = <span class="string">&quot;out&quot;</span></span><br><span class="line">        temp=bplfile.name[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">        file_name = <span class="string">f&quot;./<span class="subst">&#123;subfolder_name&#125;</span>/&quot;</span>+temp+<span class="string">&quot;.out&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># check_jsonchecker_fail_withlexical()</span></span><br><span class="line">check_jsonchecker_fail_syntaxonly()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>myhead.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYHEAD_H_  <span class="comment">// 防止头文件重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  <span class="comment">// 允许C++调用C语言代码</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体，用于描述变量声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];  <span class="comment">// 变量名</span></span><br><span class="line">    <span class="type">char</span> type[<span class="number">100</span>];  <span class="comment">// 变量类型</span></span><br><span class="line">&#125; declare;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体，用于描述复杂类型的定义，包括数组、结构体和函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];          <span class="comment">// 名称</span></span><br><span class="line">    <span class="type">char</span> elem_type[<span class="number">100</span>];     <span class="comment">// 对于数组类型，表示元素的类型</span></span><br><span class="line">    declare dec[<span class="number">100</span>];        <span class="comment">// 存储结构体成员或函数内部变量</span></span><br><span class="line">    <span class="type">char</span> return_type[<span class="number">100</span>];   <span class="comment">// 对于函数类型，表示返回值类型</span></span><br><span class="line">    declare args[<span class="number">100</span>];       <span class="comment">// 对于函数，存储参数列表</span></span><br><span class="line">    <span class="type">int</span> arg_num;             <span class="comment">// 函数参数的数量</span></span><br><span class="line">    <span class="type">int</span> dec_num;             <span class="comment">// dec数组中的元素数量</span></span><br><span class="line">&#125; definition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> declare dec[<span class="number">100</span>];     <span class="comment">// 全局变量表</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> dec_num;          <span class="comment">// 全局变量数目</span></span><br><span class="line"><span class="keyword">extern</span> definition def[<span class="number">100</span>];  <span class="comment">// 复杂类型定义数组</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> def_num;          <span class="comment">// 复杂类型定义数目</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> last_type[<span class="number">100</span>];  <span class="comment">// 上一次定义的类型名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_last_type</span><span class="params">(<span class="type">char</span> *type)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add_dec</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *type, <span class="type">int</span> lineno)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_array</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *elem_type, <span class="type">int</span> lineno)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add_func_or_struct</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> lineno, <span class="type">char</span> *type)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_func_and_struct_dec</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *dec_name, <span class="type">char</span> *type)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">find_id_type</span><span class="params">(<span class="type">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">declare* <span class="title">find_func_or_struct_dec</span><span class="params">(<span class="type">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">find_func_return_type</span><span class="params">(<span class="type">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_struct_member</span><span class="params">(<span class="type">char</span> *struct_name, <span class="type">char</span> *member_name, <span class="type">char</span> *member_type, <span class="type">int</span> lineno)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_func_args</span><span class="params">(<span class="type">char</span> *func_name, <span class="type">char</span> *arg_name, <span class="type">char</span> *arg_type, <span class="type">int</span> lineno)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_func_variables</span><span class="params">(<span class="type">char</span> *func_name, <span class="type">char</span> *variable_name, <span class="type">char</span> *variable_type, <span class="type">int</span> lineno)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">find_structure_member_type</span><span class="params">(<span class="type">char</span> *struct_name, <span class="type">char</span> *member_name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_func_return_type</span><span class="params">(<span class="type">char</span> *func_name, <span class="type">char</span> *return_type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* MYHEAD_H_ */</span></span></span><br></pre></td></tr></table></figure><p>myhead.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myhead.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line">declare dec[<span class="number">100</span>];<span class="comment">//定义的变量表</span></span><br><span class="line"><span class="type">int</span> dec_num=<span class="number">0</span>;<span class="comment">//定义的变量数目</span></span><br><span class="line">definition def[<span class="number">100</span>];<span class="comment">//定义的array,struct,function</span></span><br><span class="line"><span class="type">int</span> def_num=<span class="number">0</span>;<span class="comment">//定义的array,struct,function数目</span></span><br><span class="line"><span class="type">char</span> last_type[<span class="number">100</span>];<span class="comment">//最后一次定义的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_last_type</span><span class="params">(<span class="type">char</span> *type)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(last_type, type);  <span class="comment">// 直接复制类型名称到 last_type</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add_dec</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *type, <span class="type">int</span> lineno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查变量是否已经被定义过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dec_num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dec[i].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据已存在变量类型区分错误类型</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *errorType =</span><br><span class="line">                <span class="built_in">strcmp</span>(dec[i].type, <span class="string">&quot;function&quot;</span>) == <span class="number">0</span> ? <span class="string">&quot;function&quot;</span> :</span><br><span class="line">                <span class="built_in">strcmp</span>(dec[i].type, <span class="string">&quot;structure&quot;</span>) == <span class="number">0</span> ? <span class="string">&quot;structure&quot;</span> :</span><br><span class="line">                <span class="string">&quot;variable&quot;</span>;</span><br><span class="line">            <span class="type">int</span> errorTypeCode = <span class="built_in">strcmp</span>(errorType, <span class="string">&quot;function&quot;</span>) == <span class="number">0</span> ? <span class="number">4</span> :</span><br><span class="line">                                <span class="built_in">strcmp</span>(errorType, <span class="string">&quot;structure&quot;</span>) == <span class="number">0</span> ? <span class="number">15</span> :</span><br><span class="line">                                <span class="number">3</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type %d at Line %d: Redefined %s \&quot;%s\&quot;.\n&quot;</span>, errorTypeCode, lineno, errorType, name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的定义</span></span><br><span class="line">    <span class="built_in">strcpy</span>(dec[dec_num].name, name);</span><br><span class="line">    <span class="built_in">strcpy</span>(dec[dec_num].type, type);</span><br><span class="line">    dec_num++;  <span class="comment">// 增加定义计数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_array</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *elem_type, <span class="type">int</span> lineno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查数组是否已经被定义过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type 3 at Line %d: Redefined variable \&quot;%s\&quot;.\n&quot;</span>, lineno, name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的数组定义</span></span><br><span class="line">    <span class="built_in">strcpy</span>(def[def_num].name, name);</span><br><span class="line">    <span class="built_in">strcpy</span>(def[def_num].elem_type, elem_type);</span><br><span class="line">    def[def_num].dec_num = <span class="number">0</span>;  <span class="comment">// 初始化数组内部变量计数为0</span></span><br><span class="line">    def_num++;  <span class="comment">// 增加定义计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add_func_or_struct</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> lineno, <span class="type">char</span> *type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否已经定义过同名的函数或结构体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 错误处理，根据类型输出不同的错误信息</span></span><br><span class="line">            <span class="type">int</span> errorTypeCode = <span class="built_in">strcmp</span>(type, <span class="string">&quot;function&quot;</span>) == <span class="number">0</span> ? <span class="number">4</span> : <span class="number">15</span>;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *typeText = <span class="built_in">strcmp</span>(type, <span class="string">&quot;function&quot;</span>) == <span class="number">0</span> ? <span class="string">&quot;function&quot;</span> : <span class="string">&quot;structure&quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error type %d at Line %d: Redefined %s \&quot;%s\&quot;.\n&quot;</span>, errorTypeCode, lineno, typeText, name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的函数或结构体定义</span></span><br><span class="line">    <span class="built_in">strcpy</span>(def[def_num].name, name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(type, <span class="string">&quot;function&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        def[def_num].arg_num = <span class="number">0</span>; <span class="comment">// 为函数初始化参数数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    def[def_num].dec_num = <span class="number">0</span>; <span class="comment">// 初始化成员或局部变量数量</span></span><br><span class="line">    def_num++; <span class="comment">// 增加定义计数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_func_and_struct_dec</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *dec_name, <span class="type">char</span> *type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找并为特定的函数或结构体添加成员定义</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(def[i].dec[def[i].dec_num].name, dec_name);</span><br><span class="line">            <span class="built_in">strcpy</span>(def[i].dec[def[i].dec_num].type, type);</span><br><span class="line">            def[i].dec_num++; <span class="comment">// 更新成员计数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">find_id_type</span><span class="params">(<span class="type">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历变量表，查找匹配的变量类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dec_num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dec[i].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dec[i].type; <span class="comment">// 返回找到的变量类型</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 找不到时返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">declare* <span class="title">find_func_or_struct_dec</span><span class="params">(<span class="type">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历定义列表，寻找匹配的函数或结构体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> def[i].dec; <span class="comment">// 找到后返回其声明数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 未找到返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">find_func_return_type</span><span class="params">(<span class="type">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历定义列表，寻找匹配的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> def[i].return_type; <span class="comment">// 找到后返回其返回类型</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 未找到返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_struct_member</span><span class="params">(<span class="type">char</span> *struct_name, <span class="type">char</span> *member_name, <span class="type">char</span> *member_type, <span class="type">int</span> lineno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历定义列表以查找指定的结构体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, struct_name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查成员是否已经定义在结构体中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; def[i].dec_num; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].dec[j].name, member_name) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error type 15 at Line %d: Redefined field \&quot;%s\&quot;.\n&quot;</span>, lineno, member_name);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 找到重复定义，报错并退出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将新成员添加到结构体定义中</span></span><br><span class="line">            <span class="built_in">strcpy</span>(def[i].dec[def[i].dec_num].name, member_name);</span><br><span class="line">            <span class="built_in">strcpy</span>(def[i].dec[def[i].dec_num].type, member_type);</span><br><span class="line">            def[i].dec_num++; <span class="comment">// 更新成员数量</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 成功添加后退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_func_args</span><span class="params">(<span class="type">char</span> *func_name, <span class="type">char</span> *arg_name, <span class="type">char</span> *arg_type, <span class="type">int</span> lineno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历定义列表以查找指定的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, func_name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查参数是否已经定义在函数中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; def[i].arg_num; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].args[j].name, arg_name) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error type 3 at Line %d: Redefined variable \&quot;%s\&quot;.\n&quot;</span>, lineno, arg_name);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 找到重复定义，报错并退出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将新参数添加到函数定义中</span></span><br><span class="line">            <span class="built_in">strcpy</span>(def[i].args[def[i].arg_num].name, arg_name);</span><br><span class="line">            <span class="built_in">strcpy</span>(def[i].args[def[i].arg_num].type, arg_type);</span><br><span class="line">            def[i].arg_num++; <span class="comment">// 更新参数数量</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 成功添加后退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_func_variables</span><span class="params">(<span class="type">char</span> *func_name, <span class="type">char</span> *variable_name, <span class="type">char</span> *variable_type, <span class="type">int</span> lineno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历已定义列表以查找指定函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, func_name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 在找到的函数中遍历检查是否存在同名变量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; def[i].dec_num; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].dec[j].name, variable_name) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error type 3 at Line %d: Redefined variable \&quot;%s\&quot;.\n&quot;</span>, lineno, variable_name);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 发现重复定义，报错并退出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若未发现重复定义，则添加新变量</span></span><br><span class="line">            <span class="built_in">strcpy</span>(def[i].dec[def[i].dec_num].name, variable_name);</span><br><span class="line">            <span class="built_in">strcpy</span>(def[i].dec[def[i].dec_num].type, variable_type);</span><br><span class="line">            def[i].dec_num++; <span class="comment">// 更新变量数量</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 添加成功后退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">find_structure_member_type</span><span class="params">(<span class="type">char</span> *struct_name, <span class="type">char</span> *member_name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历定义列表查找指定结构体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, struct_name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 在找到的结构体中遍历检查是否存在指定成员</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; def[i].dec_num; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].dec[j].name, member_name) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> def[i].dec[j].type; <span class="comment">// 找到成员，返回其类型</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 指定成员不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 指定结构体不存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_func_return_type</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历已定义列表以查找指定函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(def[i].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(def[i].return_type, type); <span class="comment">// 找到函数，设置返回类型</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 设置成功后退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">将继续构建BUPT编程语言（BPL）编译器的功能，专注于语义分析阶段</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>编译原理Lab1——编写链表功能代码</title>
    <link href="https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Lab1/"/>
    <id>https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Lab1/</id>
    <published>2023-11-19T17:00:00.000Z</published>
    <updated>2024-01-17T14:39:33.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、 实验内容"></a>一、 实验内容</h1><p>1.配置 docker 环境</p><p>2.编写链表功能代码</p><p>3.使用 python 代码进行测试</p><h1 id="二、-实验过程"><a href="#二、-实验过程" class="headerlink" title="二、 实验过程"></a>二、 实验过程</h1><ol><li>安装 docker</li></ol><p>1）查询电脑配置，根据说明在 Windows10 系统下安装 docker</p><p>2）安装好后进行换源</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps1-1705499901047-1.png" alt="img"> </p><p>3）配置 docker-compose，导入作业文件</p><ol start="2"><li>链表代码实现</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps2-1705499901047-2.png" alt="img"> </p><p>根据需求实现功能代码，详见源码</p><ol start="3"><li>进入 docker 环境，编译 c 程序，进行验证</li></ol><p>1）找到程序位置 cd mnt&#x2F;Workspace&#x2F;lab1&#x2F;</p><p>2）编译 c 程序 make libll</p><p>3）进行检验 python3 ll_test.py</p><h1 id="三、-测试结果"><a href="#三、-测试结果" class="headerlink" title="三、 测试结果"></a>三、 测试结果</h1><p>Docker 搭建结果</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps3.png" alt="img"> </p><p>程序校验结果</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps4-1705499901047-3.png" alt="img"> </p><h1 id="四、-遇到困难和解决办法"><a href="#四、-遇到困难和解决办法" class="headerlink" title="四、 遇到困难和解决办法"></a>四、 遇到困难和解决办法</h1><ol><li>docker 搭建下载速度慢问题：直接更换国内源进行下载</li><li>在运行 docker环境时要更换管理员权限，否则无法进行操作</li></ol>]]></content>
    
    
    <summary type="html">编译原理实验，编写链表功能代码</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>编译原理Project1——编写词法分析和语法分析</title>
    <link href="https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Project1/"/>
    <id>https://zhangyuanhe.top/2023/11/20/Information_Security_Experiment/Compilation_principle/CP_Project1/</id>
    <published>2023-11-19T17:00:00.000Z</published>
    <updated>2024-01-17T14:39:01.199Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Project 1: 词法分析和语法分析</strong></p><p>在这个项目中，你将为BUPT编程语言（BPL）实现一个编译器的词法分析器和语法分析器。BPL是一种类C的编程语言，它去除了C标准中的大多数高级特性，比如宏和指针。项目的目标是编译BPL程序到MIPS32汇编代码。以下是关于词法分析和语法分析部分的详细说明。</p><p><strong>1. 词法分析 (Lexical Analysis)</strong>:</p><ul><li><strong>Flex工具</strong>: 你将使用GNU Flex生成词法分析器。Flex是一个快速的词法分析器生成器。你需要指定要匹配的令牌模式和对每个令牌应用的操作。Flex会将这些规格转换成一个NFA，然后将它转换成一个等价的DFA，并尽可能地最小化这个自动机，最终生成实现词法分析器的C代码。</li><li><strong>Flex编码</strong>: 在使用Flex时，你将使用正则表达式来定义模式，并使用C代码来定义动作。你将编写.lex文件，并通过Flex生成一个C源文件，该文件包含一个实现所有规则和相应动作的有限自动机。</li><li><strong>Flex特性</strong>: Flex还提供了一些有用的特性，如行号记录（yylineno）、输入和输出函数（input()和unput()），以及更多用于控制词法分析过程的函数。</li></ul><p><strong>2. 语法分析 (Syntax Analysis)</strong>:</p><ul><li><strong>Bison工具</strong>: 你将使用GNU Bison生成语法分析器。Bison是一个解析器生成器，你提供一个文法规范的输入，Bison将生成一个LALR(1)解析器来识别该文法的句子。这个解析器接受来自Flex的输入令牌流，以识别指定的上下文无关文法。</li><li><strong>Bison编码</strong>: 类似于Flex，Bison的源代码也包含可选的声明、定义和用户例程部分。你将为每个产生式关联一个动作，这允许你在使用该产生式进行规约时执行任何处理。你需要定义文法的每个非终结符，为每个规则指定优先级和结合性，并设置用于在词法分析器和解析器之间通信的全局变量。</li><li><strong>Bison特性</strong>: Bison还提供了一些高级特性，如符号位置信息、错误恢复和冲突解决机制等。这些特性可以帮助你更有效地实现语法分析器，并提供更稳健的错误处理和更精确的语法分析。</li></ul><p><strong>项目要求</strong>:</p><ul><li>你需要实现一个解析器，它接受单个命令行参数（BPL文件路径），并输出语法有效的BPL程序的语法树或报告代码中存在的所有词法&#x2F;语法错误。</li><li>你的解析器应该能够识别未定义字符或标记、结构非法等词法和语法错误，并为语法有效的BPL程序打印出其语法树。</li><li>你可以实现其他功能，如单行&#x2F;多行注释、宏预处理器、文件包含、for语句等。</li></ul><p>通过这个项目，你将学会如何使用现代的编译器工具（Flex和Bison）来自动化词法分析和语法分析过程，从而更深入地理解编译器前端的工作原理。同时，这也是构建编译器其他部分（如语义分析、中间代码生成、目标代码生成等）的基础。</p><p>lex.l</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;syntax.tab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Head</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> is_end;</span><br><span class="line">    <span class="type">char</span> type[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> id[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> line;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Head</span> *child;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Head</span> *brother;</span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Head</span> *<span class="built_in">new_Node</span>(<span class="type">int</span> is_end, <span class="type">char</span> *type, <span class="type">char</span> *id,<span class="type">int</span> line, Node *child, Node *brother);</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">new_Node</span><span class="params">(<span class="type">int</span> is_end,<span class="type">char</span>* type, <span class="type">char</span>* id, <span class="type">int</span> line, Node* child,Node* brother)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (!newNode) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Memory allocation error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;is_end = is_end;</span><br><span class="line">    <span class="keyword">if</span>(line==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newNode-&gt;line=child-&gt;line;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        newNode-&gt;line=line;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(newNode-&gt;type,type);</span><br><span class="line">    <span class="keyword">if</span> (id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(newNode-&gt;id,id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        newNode-&gt;id[<span class="number">0</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;child = child;</span><br><span class="line">    newNode-&gt;brother = brother;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_tree</span><span class="params">(Node* result,<span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(result-&gt;type,<span class="string">&quot;empty&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;line;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(result-&gt;is_end==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,result-&gt;type);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(result-&gt;type,<span class="string">&quot;ID&quot;</span>)==<span class="number">0</span>||<span class="built_in">strcmp</span>(result-&gt;type,<span class="string">&quot;TYPE&quot;</span>)==<span class="number">0</span>||<span class="built_in">strcmp</span>(result-&gt;type,<span class="string">&quot;INT&quot;</span>)==<span class="number">0</span>||</span><br><span class="line">        <span class="built_in">strcmp</span>(result-&gt;type,<span class="string">&quot;FLOAT&quot;</span>)==<span class="number">0</span>||<span class="built_in">strcmp</span>(result-&gt;type,<span class="string">&quot;CHAR&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;: %s&quot;</span>,result-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(result-&gt;type,<span class="string">&quot;empty&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s (%d)\n&quot;</span>,result-&gt;type,result-&gt;line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print_tree</span>(result-&gt;child,line+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print_tree</span>(result-&gt;brother,line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> line = <span class="number">1</span>;</span><br><span class="line">%&#125;</span><br><span class="line">%option noyywrap</span><br><span class="line"></span><br><span class="line">word_int        [<span class="number">0</span><span class="number">-9</span>]+|<span class="number">0</span>x[<span class="number">0</span><span class="number">-9</span>a-fA-F]+</span><br><span class="line">word_float      [<span class="number">0</span><span class="number">-9</span>]+<span class="string">&quot;.&quot;</span>[<span class="number">0</span><span class="number">-9</span>]+</span><br><span class="line">word_id         [a-zA-Z_][a-zA-Z0<span class="number">-9</span>_]*</span><br><span class="line">word_char       \<span class="string">&#x27;.\&#x27;</span>|\<span class="string">&#x27;\\x[0-9a-fA-F]&#123;2&#125;\&#x27;</span></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"><span class="string">&quot;int&quot;</span>                   &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;TYPE&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> TYPE; &#125;</span><br><span class="line"><span class="string">&quot;float&quot;</span>                 &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;TYPE&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> TYPE; &#125;</span><br><span class="line"><span class="string">&quot;char&quot;</span>                  &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;TYPE&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> TYPE; &#125;</span><br><span class="line"><span class="string">&quot;struct&quot;</span>                &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;STRUCT&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> STRUCT; &#125;</span><br><span class="line"><span class="string">&quot;if&quot;</span>                    &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;IF&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> IF; &#125;</span><br><span class="line"><span class="string">&quot;else&quot;</span>                  &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;ELSE&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> ELSE; &#125;</span><br><span class="line"><span class="string">&quot;while&quot;</span>                 &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;WHILE&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> WHILE; &#125;</span><br><span class="line"><span class="string">&quot;return&quot;</span>                &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;RETURN&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> RETURN; &#125;</span><br><span class="line">&#123;word_int&#125;              &#123;yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;INT&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> INT;&#125;</span><br><span class="line">&#123;word_id&#125;               &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;ID&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> ID; &#125;</span><br><span class="line">&#123;word_char&#125;             &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;CHAR&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> CHAR; &#125;</span><br><span class="line">&#123;word_float&#125;            &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;FLOAT&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> FLOAT; &#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;DOT&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> DOT; &#125;</span><br><span class="line"><span class="string">&quot;;&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;SEMI&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> SEMI; &#125;</span><br><span class="line"><span class="string">&quot;,&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;COMMA&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> COMMA; &#125;</span><br><span class="line"><span class="string">&quot;=&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;ASSIGN&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> ASSIGN; &#125;</span><br><span class="line"><span class="string">&quot;&lt;&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;LT&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> LT; &#125;</span><br><span class="line"><span class="string">&quot;&gt;&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;GT&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> GT; &#125;</span><br><span class="line"><span class="string">&quot;&lt;=&quot;</span>                    &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;LE&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> LE; &#125;</span><br><span class="line"><span class="string">&quot;&gt;=&quot;</span>                    &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;GE&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> GE; &#125;</span><br><span class="line"><span class="string">&quot;!=&quot;</span>                    &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;NE&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> NE; &#125;</span><br><span class="line"><span class="string">&quot;==&quot;</span>                    &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;EQ&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> EQ; &#125;</span><br><span class="line"><span class="string">&quot;+&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;PLUS&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> PLUS; &#125;</span><br><span class="line"><span class="string">&quot;-&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;MINUS&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> MINUS; &#125;</span><br><span class="line"><span class="string">&quot;*&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;MUL&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> MUL; &#125;</span><br><span class="line"><span class="string">&quot;/&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;DIV&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> DIV; &#125;</span><br><span class="line"><span class="string">&quot;&amp;&amp;&quot;</span>                    &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;AND&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> AND; &#125;</span><br><span class="line"><span class="string">&quot;||&quot;</span>                    &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;OR&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> OR; &#125;</span><br><span class="line"><span class="string">&quot;!&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;NOT&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> NOT; &#125;</span><br><span class="line"><span class="string">&quot;(&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;LP&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> LP; &#125;</span><br><span class="line"><span class="string">&quot;)&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;RP&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> RP; &#125;</span><br><span class="line"><span class="string">&quot;[&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;LB&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> LB; &#125;</span><br><span class="line"><span class="string">&quot;]&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;RB&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> RB; &#125;</span><br><span class="line"><span class="string">&quot;&#123;&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;LC&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> LC; &#125;</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span>                     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;RC&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="keyword">return</span> RC; &#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;//&quot;</span>.*$                 &#123; <span class="comment">/* ignore comments */</span> &#125;</span><br><span class="line"><span class="string">&quot;/*&quot;</span>([^*]|[*][^/]|[*][*]+[^*/])*<span class="string">&quot;*/&quot;</span>    &#123; <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(yytext); i++) <span class="keyword">if</span> (yytext[i] == <span class="string">&#x27;\n&#x27;</span>) line++; &#125;</span><br><span class="line">[ \t\r]+                &#123; <span class="comment">/* ignore whitespace */</span> &#125;</span><br><span class="line"><span class="string">&quot;\n&quot;</span>    &#123;line++;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>x([<span class="number">0</span><span class="number">-9</span>a-fA-F]|[g-zG-Z])+     &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;ILLEGAL_HEX_INT&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="keyword">return</span> ILLEGAL_HEX_INT; &#125;</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]&#123;word_id&#125;          &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;ILLEGAL_ID&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="keyword">return</span> ILLEGAL_ID; &#125;</span><br><span class="line"><span class="string">&#x27;\\x.*&#x27;</span>                 &#123; yylval.node=<span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;ILLEGAL_CHAR&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="keyword">return</span> ILLEGAL_CHAR; &#125;</span><br><span class="line">.                       &#123; yylval.node = <span class="built_in">new_Node</span>(<span class="number">1</span>,<span class="string">&quot;ILLEGAL&quot;</span>,yytext,line,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="keyword">return</span> ILLEGAL; &#125;</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>syntax.y</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lex.yy.c&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">()</span></span>;</span><br><span class="line">    Node* result=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%<span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Head</span>* node; <span class="comment">/*&quot;struct&quot; is indispensable*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%token &lt;node&gt; ID INT FLOAT CHAR STRUCT RETURN IF ELSE WHILE PLUS MINUS MUL DIV AND OR LT LE GT GE NE EQ NOT ASSIGN TYPE LP RP LB RB LC RC SEMI COMMA DOT ILLEGAL ILLEGAL_ID ILLEGAL_HEX_INT ILLEGAL_CHAR</span><br><span class="line">%type &lt;node&gt; Program ExtDefList ExtDef ExtDecList Specifier StructSpecifier VarDec FunDec VarList ParamDec CompSt StmtList Stmt DefList Def DecList Dec Exp Args</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">Program: ExtDefList &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Program&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);result=$$;&#125;</span><br><span class="line"></span><br><span class="line">ExtDefList: ExtDef ExtDefList  &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDefList&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">          | <span class="comment">/* empty */</span>         &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;empty&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">100</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">ExtDef: Specifier ExtDecList SEMI   &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDef&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">      | Specifier ExtDecList error  &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing semicolon &#x27;;&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;line);&#125;</span><br><span class="line">      | Specifier SEMI              &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDef&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">      | Specifier FunDec CompSt     &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDef&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">ExtDecList: VarDec                      &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDecList&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">           | VarDec COMMA ExtDecList    &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;ExtDecList&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">Specifier: TYPE                         &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Specifier&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">          | StructSpecifier             &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Specifier&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">StructSpecifier: STRUCT ID LC DefList RC    &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$<span class="number">3</span>-&gt;brother = $<span class="number">4</span>;$<span class="number">4</span>-&gt;brother = $<span class="number">5</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;StructSpecifier&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">               | STRUCT ID                  &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;StructSpecifier&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">VarDec: ID                              &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;VarDec&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">       | ILLEGAL_ID error               &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type A at line %d: illegal identifier &#x27;%s&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;line,$<span class="number">1</span>-&gt;id);&#125;</span><br><span class="line">       | VarDec LB INT RB               &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$<span class="number">3</span>-&gt;brother = $<span class="number">4</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;VarDec&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">FunDec: ID LP VarList RP                &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$<span class="number">3</span>-&gt;brother = $<span class="number">4</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;FunDec&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">       | ID LP RP                       &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;FunDec&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">       | ID LP VarList error            &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing closing symbols &#x27;)&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;line);&#125;  </span><br><span class="line">       | ID LP error                    &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing closing symbols &#x27;)&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;line);&#125; </span><br><span class="line"></span><br><span class="line">VarList: ParamDec COMMA VarList         &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;VarList&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">        | ParamDec                      &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;VarList&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">ParamDec: Specifier VarDec              &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;ParamDec&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">CompSt: LC DefList StmtList RC          &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$<span class="number">3</span>-&gt;brother = $<span class="number">4</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;CompSt&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">StmtList: Stmt StmtList                 &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;StmtList&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">         |Stmt Def StmtList error       &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: definition after statement\n&quot;</span>, $<span class="number">2</span>-&gt;line);&#125;</span><br><span class="line">         | <span class="comment">/* empty */</span>                  &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;empty&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">100</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">Stmt: Exp SEMI                          &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | CompSt                            &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | RETURN Exp SEMI                   &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | RETURN Exp error                  &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing semicolon &#x27;;&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;line);&#125;     </span><br><span class="line">    | IF LP Exp RP Stmt                 &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$<span class="number">3</span>-&gt;brother = $<span class="number">4</span>;$<span class="number">4</span>-&gt;brother = $<span class="number">5</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | IF LP Exp RP Stmt ELSE Stmt       &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$<span class="number">3</span>-&gt;brother = $<span class="number">4</span>;$<span class="number">4</span>-&gt;brother = $<span class="number">5</span>;$<span class="number">5</span>-&gt;brother = $<span class="number">6</span>;$<span class="number">6</span>-&gt;brother = $<span class="number">7</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | WHILE LP Exp RP Stmt              &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$<span class="number">3</span>-&gt;brother = $<span class="number">4</span>;$<span class="number">4</span>-&gt;brother = $<span class="number">5</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Stmt&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">DefList: Def DefList                    &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;DefList&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">        | <span class="comment">/* empty */</span>                   &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;empty&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">100</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">Def: Specifier DecList SEMI             &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Def&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Specifier DecList error           &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing semicolon &#x27;;&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;line);&#125;</span><br><span class="line"></span><br><span class="line">DecList: Dec                            &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;DecList&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">        | Dec COMMA DecList             &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;DecList&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">Dec: VarDec                             &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Dec&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | VarDec ASSIGN Exp                 &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Dec&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">Exp: Exp ASSIGN Exp                     &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Exp AND Exp                       &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Exp OR Exp                        &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;    </span><br><span class="line">    | Exp LT Exp                        &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;    </span><br><span class="line">    | Exp LE Exp                        &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;    </span><br><span class="line">    | Exp GT Exp                        &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Exp GE Exp                        &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Exp NE Exp                        &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Exp EQ Exp                        &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Exp PLUS Exp                      &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Exp MINUS Exp                     &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Exp MUL Exp                       &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Exp DIV Exp                       &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | LP Exp RP                         &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | LP Exp error                      &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing closing symbols &#x27;)&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;line);&#125;</span><br><span class="line">    | MINUS Exp                         &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | NOT Exp                           &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;  </span><br><span class="line">    | ID LP Args RP                     &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$<span class="number">3</span>-&gt;brother = $<span class="number">4</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | ID LP Args error                  &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type B at line %d: missing closing symbols &#x27;)&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;line);&#125;</span><br><span class="line">    | ID LP RP                          &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Exp LB Exp RB                     &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$<span class="number">3</span>-&gt;brother = $<span class="number">4</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | Exp DOT ID                        &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | ID                                &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | INT                               &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | FLOAT                             &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | CHAR                              &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Exp&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">    | ILLEGAL error                     &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type A at line %d: illegal character &#x27;%s&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;line,$<span class="number">1</span>-&gt;id);&#125;</span><br><span class="line">    | ILLEGAL_HEX_INT error             &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type A at line %d: illegal hexadecimal integer &#x27;%s&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;line,$<span class="number">1</span>-&gt;id);&#125;</span><br><span class="line">    | ILLEGAL_CHAR error                &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type A at line %d: illegal hex_character &#x27;%s&#x27;\n&quot;</span>, $<span class="number">1</span>-&gt;line,$<span class="number">1</span>-&gt;id);&#125;</span><br><span class="line">    | Exp ILLEGAL Exp error             &#123;<span class="built_in">printf</span>(<span class="string">&quot;Error type A at line %d: illegal operator &#x27;%s&#x27;\n&quot;</span>, $<span class="number">2</span>-&gt;line,$<span class="number">2</span>-&gt;id);&#125;</span><br><span class="line"></span><br><span class="line">Args: Exp COMMA Args                    &#123;$<span class="number">1</span>-&gt;brother = $<span class="number">2</span>;$<span class="number">2</span>-&gt;brother = $<span class="number">3</span>;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Args&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line">     | Exp                              &#123;$$=<span class="built_in">new_Node</span>(<span class="number">0</span>,<span class="string">&quot;Args&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,$<span class="number">1</span>,<span class="literal">NULL</span>);&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Usage: %s &lt;file_path&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(yyin = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">yyparse</span>();</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print_tree</span>(result,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">FLEX=flex</span><br><span class="line">BISON=bison</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">.lex: lex.l</span></span><br><span class="line"><span class="variable">$(FLEX)</span> lex.l</span><br><span class="line"><span class="section">.syntax: syntax.y</span></span><br><span class="line"><span class="variable">$(BISON)</span> -t -d syntax.y</span><br><span class="line"><span class="section">bplc: .lex .syntax</span></span><br><span class="line"><span class="variable">$(CC)</span> syntax.tab.c -lfl -ly -o bplc.out</span><br><span class="line">@mkdir bin</span><br><span class="line">touch bin/bplc</span><br><span class="line">@chmod +x bin/bplc</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">@rm -f lex.yy.c syntax.tab.* *.out</span><br><span class="line">@rm -rf bin/</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: bplc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>bplc_test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DATA = pathlib.Path(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jsonparser_output</span>(<span class="params">json_file</span>):</span><br><span class="line">    out = subprocess.check_output([<span class="string">&#x27;./bplc.out&#x27;</span>, json_file])</span><br><span class="line">    <span class="keyword">return</span> out.decode().strip()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_jsonchecker_fail_syntaxonly</span>():</span><br><span class="line">    data = DATA</span><br><span class="line">    <span class="keyword">for</span> bplfile <span class="keyword">in</span> data.glob(<span class="string">&#x27;*.bpl&#x27;</span>):</span><br><span class="line">        out = jsonparser_output(bplfile)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;For file <span class="subst">&#123;bplfile.name&#125;</span>:&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(out)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span>*<span class="number">60</span>)</span><br><span class="line">        subfolder_name = <span class="string">&quot;out&quot;</span></span><br><span class="line">        temp=bplfile.name[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">        file_name = <span class="string">f&quot;./<span class="subst">&#123;subfolder_name&#125;</span>/&quot;</span>+temp+<span class="string">&quot;.out&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># check_jsonchecker_fail_withlexical()</span></span><br><span class="line">check_jsonchecker_fail_syntaxonly()</span><br></pre></td></tr></table></figure><p>README.md</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># project1实验说明</span></span><br><span class="line"></span><br><span class="line">该项目中完成了词法分析器和语法分析器的编写，可以通过终端指令实现bplc的编译和运行。</span><br><span class="line"></span><br><span class="line"><span class="section">## 生成`bplc.out`文件</span></span><br><span class="line"></span><br><span class="line">生成指令</span><br><span class="line"></span><br><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">make bplc</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">成功运行后会反馈以下信息</span><br><span class="line"></span><br><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">flex lex.1</span></span><br><span class="line"><span class="code">bison -t -d syntax.y</span></span><br><span class="line"><span class="code">syntax.y: warning: 241 shift/reduce conflicts [-Wconflicts-sr]</span></span><br><span class="line"><span class="code">gcc syntax.tab.c -1f1 -ly -o bplc.out</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">并在根目录下生成<span class="code">`bplc.out`</span>文件</span><br><span class="line"></span><br><span class="line"><span class="section">## 运行编译检测功能</span></span><br><span class="line"></span><br><span class="line">执行python指令一键运行</span><br><span class="line"></span><br><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">python3 bplc_test.py</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">运行结果会在终端反馈生成树和报错信息，并将每个文件的反馈信息以<span class="code">`.out`</span>的形式保存在<span class="code">`\out`</span>目录下</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">将为BUPT编程语言（BPL）实现一个编译器的词法分析器和语法分析器</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="编译原理" scheme="https://zhangyuanhe.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>网络安全实验五——IDS入侵检测</title>
    <link href="https://zhangyuanhe.top/2023/11/03/Information_Security_Experiment/network_security/NS7/"/>
    <id>https://zhangyuanhe.top/2023/11/03/Information_Security_Experiment/network_security/NS7/</id>
    <published>2023-11-02T23:00:00.000Z</published>
    <updated>2024-01-17T14:41:49.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><ol><li>在linux平台建立基于Snort的IDS。</li><li>在部署Snort的本机建立规则，实现对DoS攻击、Nmap扫描和SSH连接的检测。</li><li>针对heartbleed漏洞的攻击的检测实验。（选做）</li></ol><h1 id="二、-实验环境"><a href="#二、-实验环境" class="headerlink" title="二、*实验环境*"></a><strong>二、</strong><em><strong>*实验环境*</strong></em></h1><p>实验1：</p><p>服务器：kali</p><p>客户机：kali</p><p>软件：snort</p><h1 id="三、-实验过程与结果"><a href="#三、-实验过程与结果" class="headerlink" title="三、*实验过程与结果*"></a><strong>三、</strong><em><strong>*实验过程与结果*</strong></em></h1><p><em><strong>*安装Snort*</strong></em></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps132.jpg" alt="img"> </p><p>修改默认配置</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps133.jpg" alt="img"> </p><p>在部署Snort的本机建立规则，实现对DoS攻击、Nmap扫描和SSH连接的检测<br>主机互相ping通<br><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps134.jpg" alt="img"></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps135.jpg" alt="img"> </p><p><em><strong>*Snort检测DoS（syn flood）攻击*</strong></em></p><p>Snort&#x2F;rules目录下的local.rules文件中，设置如下规则：</p><p>alert tcp any any -&gt;  $HOME_NET 80 (msg:”DoS attack”; flags:S; threshold:type threshold, track by_dst, count 100, seconds 60; sid:2000003)</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps136.jpg" alt="img"> </p><p>打开snort.conf，注释掉</p><p>include $RULE_PATH&#x2F;icmp-info.rules（608行）</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps137.jpg" alt="img"> </p><p>之后启动snort</p><p>sudo snort -c &#x2F;etc&#x2F;snort&#x2F;snort.conf -A fast -l &#x2F;var&#x2F;log&#x2F;snort -i eth0</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps138.jpg" alt="img"> </p><p>使用另一台kali使用hping3攻击（在dos实验中使用过的）</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps139.jpg" alt="img"> </p><p>在日志中查看检测报告(cat &#x2F;var&#x2F;log&#x2F;snort&#x2F;alert)：</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps140.jpg" alt="img"> </p><p><em><strong>*Snort检测nmap扫描*</strong></em></p><p>以nmap NULL扫描为例：</p><p>同理在local.rules中写下如下规则：</p><p>alert tcp $EXTERNAL_NET any -&gt; $HOME_NET any (msg:”Nmap Null PortScan!”; flags:0;  threshold:type both,track by_dst,count 20,seconds 60; sid:10000012; rev:1;)<br><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps141.jpg" alt="img"></p><p>nmap NULL扫描是nmap秘密扫描的一种，相对比较隐蔽，通过向目标主机端口发送标志位flags为0的包进行扫描。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps142.jpg" alt="img"> </p><p>使用kali中的nmap对主机进行NULL扫描。查看snort报警信息。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps143.jpg" alt="img"> </p><p>Snort检测ssh连接</p><p>首先将两台机器（可以是主机和虚拟机）的ssh服务开启。</p><p>kali开启ssh服务命令：sudo &#x2F;etc&#x2F;init.d&#x2F;ssh start</p><p>查看服务状态：sudo systemctl status ssh</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps144.jpg" alt="img"> </p><p>之后自主编写规则local.rules，检测ssh连接行为。</p><p>alert TCP any any -&gt;$HOME_NET 22 ( msg:“ssh connection”; sid:100000003)</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps145.jpg" alt="img"> </p><p>成功链接</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps146.jpg" alt="img"> </p><p>连接成功日志</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps147.jpg" alt="img"> </p><p><em><strong>*选做实验*</strong></em></p><p>借鉴网络扫描实验中对Heartbleed漏洞的利用</p><p>启动docker环境，启动待攻击网站</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps148.jpg" alt="img"> </p><p>同样在kali中使用msf，msf在进行到“exploit“时投放攻击载荷实现攻击。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps149.jpg" alt="img"> </p><p>自主编写规则实现针对Heartbleed漏洞攻击的检测</p><p>分析包结构可知，控制0x18、0x03、0x01和倒数2比特的0x01后只要0xffff位的内容大于0x0003位的内容则发出警告</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps150.jpg" alt="img"> </p><p>报告中要说明自定义规则的意义。</p><p>alert tcp any any -&gt; $HOME_NET 8443 (msg:”Heartbleed Attack”;  content:”|18 03 01 00 03 01 ff ff|”;  sid:1000001; rev:1;)</p><p>攻击成功</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps151.jpg" alt="img"> </p><h1 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h1><p>Snort是一个领先的开源网络入侵预防和检测系统。这个软件主要用来监测网络流量，以便发现潜在的不良数据包、恶意活动，和网络攻击。Snort基于规则来分析网络数据，并且有能力进行实时流量分析及包日志记录。在本次实验中使用Snort并自定义规则实现了对DoS攻击、Nmap扫描、SSH连接和heartbleed漏洞攻击的检测。</p><p>通过实验可以看出，Snort可以对多种多样的攻击实现检测和警报，但是使用Snort进行网络监测和攻击检测需要合理配置规则来识别不同类型的恶意流量。要有效地实施这些检测，网络管理员需要定期更新Snort规则，并适当调整规则的阈值（thresholds）和条件以匹配网络环境的特点。还需要定期查看Snort的日志和警报来评估潜在的威胁，并根据需要调整规则的严格性。</p>]]></content>
    
    
    <summary type="html">在部署Snort的本机建立规则，实现对DoS攻击、Nmap扫描和SSH连接的检测。</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="网络安全" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="网络安全实验" scheme="https://zhangyuanhe.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
</feed>
