<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZYH&#39;s blog</title>
  
  
  <link href="https://zhangyuanhe.top/atom.xml" rel="self"/>
  
  <link href="https://zhangyuanhe.top/"/>
  <updated>2023-08-04T10:07:27.112Z</updated>
  <id>https://zhangyuanhe.top/</id>
  
  <author>
    <name>Charmes</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MD5加密程序解flag</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL2/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL2/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:27.112Z</updated>
    
    <content type="html"><![CDATA[<p>****问题-1：****找到开头“This program cannot be run …” 这个字符串的内存起始地址（即字符串的指针），并准确计算该字符串的长度；</p><p>1.运行程序寻找字符串位置</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps8-1691140040878-1.jpg" alt="img"> </p><ol start="2"><li>打开IDA寻找字符串</li></ol><p>发现无法找到目标字符串<br><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps9-1691140040878-2.jpg" alt="img"><br>3.通过for fun找到主函数，查看伪代码。</p><p>分析得知各功能实现应%S所实现的内容。</p><p>从而定位其地址<em><strong>*0x40004E*</strong></em></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps10-1691140040878-4.jpg" alt="img"> </p><p>4.将程序放入010Editor找到相应位置，然后数字节。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps11-1691140040878-3.jpg" alt="img"> </p><p>共计****44****个字节</p><p>****问题-2：****需要结合具体的加密操作逻辑，说明所发现的加密算法。</p><ol><li>由第一个子函数可知，输入的字符串长度有固定要求。</li></ol><p>输入内容被保存在byte_407444。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps12-1691140040878-6.jpg" alt="img"> </p><p>且长度必须为9.</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps13-1691140040878-5.jpg" alt="img"> </p><p>2.打开第二个子函数，可以看见其中并无加密转码操作，还是在确认输入内容的范围。</p><p>3.在第三个函数</p><p>首先在18行有一次混淆交换</p><p>随后有sub_40210C(Str1, (int)byte_407444, 5)说明进行了另一种交换</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps14-1691140040878-7.jpg" alt="img"> </p><p>进入发现是将byte_407444的前五个字符进行MD5加密。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps15-1691140040879-9.jpg" alt="img"> </p><p>随后密文Str1与Str2进行比较</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps16-1691140040879-13.jpg" alt="img"> </p><p>4.根据以上推断，可知flag经过一次加密后，前五位经MD5加密后与Str2进行比较，后四位直接进行比较。</p><p>根据MD5要求写出脚本</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps17-1691140040879-10.jpg" alt="img"> </p><p>得到密文为<em><strong>*K502G32Z2*</strong></em></p><p>5.在解密第一层加密方法，这是一个类仿射加密</p><p>范思宇：通过dbg按顺序尝试各个字符的对应关系，从而一一对照找到原flag。</p><p>例如输入123456789，就可得知对应密文为0BEHKNQTW。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps18-1691140040878-8.jpg" alt="img"> </p><p>依次类推，可以推出原文为<em><strong>*5M1LE_L0L*</strong></em></p><p>张原赫：找到初次转码后密文的储存位置</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps19-1691140040879-14.jpg" alt="img"> </p><p>更改存储内容继续运行</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps20-1691140040879-12.jpg" alt="img"> </p><p>得到结果。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps21-1691140040879-11.jpg" alt="img"> </p><p>不足：该方法可以得到结果但是无法拿到flag。</p><p>所以使用脚本进行转换</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps22-1691140040879-15.jpg" alt="img"> </p><p>得到flag。</p>]]></content>
    
    
    <summary type="html">对MD5加密的exe文件进行解密</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>花指令及加密算法程序解flag</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL3/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL3/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:31.804Z</updated>
    
    <content type="html"><![CDATA[<p><strong>实验过程：</strong></p><p>这里0040105E指向转跳到401060+1，而401060又有转跳指令，说明这里指令存在错误，有花指令。并且是<em><strong>*jmp型花指令*</strong></em></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps23-1691140202258-5.jpg" alt="img"> </p><p>更改401060的前两个字符为90。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps24-1691140202258-1.jpg" alt="img"> </p><p>改完后可以按空格查看流程图。说明更改正确。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps25-1691140202258-4.jpg" alt="img"> </p><p>流程图中这里有一个add的单独指令，怀疑存在问题</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps26-1691140202258-2.jpg" alt="img"> </p><p>检查原指令栈情况，发现后续栈有问题</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps27-1691140202258-3.jpg" alt="img"> </p><p>将add esp，30 h  Nop掉</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps28-1691140202258-6.jpg" alt="img"> </p><p>在这里可以看出来将buffer数组每一位都异或1Dh(加密)</p><p>加密后将将command也就是下一层加密代码的地址压入栈</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps29-1691140202258-10.jpg" alt="img"> </p><p>编辑解密脚本</p><p>#include &lt;idc.idc&gt;</p><p>static xor_setp1(){</p><p>  auto addr &#x3D; 0x00403054;  &#x2F;&#x2F;这里填入要解密字节串的起始地址</p><p>  auto i &#x3D; 0;</p><p>  for(i&#x3D;0;addr+i&lt;0x004030DF;i++)  &#x2F;&#x2F;循环结束的条件为字节串的结束地址</p><p>  {</p><p>​    PatchByte(addr+i,Byte(addr+i)^0x1D);  &#x2F;&#x2F;异或的数字根据情况修改</p><p>  }</p><p>}</p><p>static main()</p><p>{</p><p>​xor_setp1();</p><p>}</p><p>进行解密</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps30-1691140202258-7.jpg" alt="img"> </p><p>按快捷键C将字符串转换为汇编语言</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps31-1691140202258-9.jpg" alt="img"> </p><p>保存成新文件后打开，寻找加密模块</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps32-1691140202259-12.jpg" alt="img"> </p><p>其中a1为输入字符串。</p><p>If语句中解出第三位为a，四、七位为i，第八位为n，十一位为o</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps33-1691140202258-8.jpg" alt="img"> </p><p>while函数进行判断</p><p>“,VEJ”和a2^a1[x]做比对</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps34-1691140202259-11.jpg" alt="img"> </p><p>找到a2内容</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps35-1691140202259-14.jpg" alt="img"><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps36-1691140202259-15.jpg" alt="img"> </p><p>追踪到a2就是1D，解出密钥a1[0]&#x3D;1 a1[2]&#x3D;K a1[6]&#x3D;X a1[10]&#x3D;W</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps37-1691140202259-13.jpg" alt="img"> </p><p>在main函数中找到一个异常处理</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps38-1691140202259-17.jpg" alt="img"> </p><p>在except中可以看到转跳函数</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps39-1691140202259-16.jpg" alt="img"> </p><p>因此需要触发异常</p><p>异常为除零异常，当输入为12位时触发</p><p>进入异常后F5查看伪代码</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps40-1691140202259-18.jpg" alt="img"> </p><p>得知byte_4031D5是输入的一部分</p><p>要求输入第二位、第六位、第十位为“_”</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps41-1691140202259-19.jpg" alt="img"> </p><p>byte_4031E1 &#x3D; ‘_’+‘_’+‘_’&#x3D;1D（取低两位）</p><p>这也是之前用1D异或的原因</p><p>解得输入应为1_Kai_Xin_Wo</p><p><em><strong>*问题-1*</strong></em><em><strong>*：程序中一共有2处花指令干扰，分别是哪一种类型的花指令？*</strong></em></p><p><em><strong>*– 提示：结合动态调试，查看出现异常处的实际执行流程&#x2F;跳转情况；判断是不是为”永恒跳转“*</strong></em></p><p>第一处是jmp型花指令</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps42-1691140202259-20.jpg" alt="img">第二处是栈干扰指令</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps43-1691140202259-24.jpg" alt="img"> </p><p><em><strong>*问题-2*</strong></em><em><strong>*：程序中一共有两处异常处理，分别是哪一种？*</strong></em></p><p><em><strong>*– 提示：x32dbg 动态调试除零异常时，可通过在寄存器窗口修改除数对应的寄存器的值为0，来无条件触发*</strong></em></p><p><em><strong>*– 提示：注意审视对 SEH 的潜在 “惯性思维”，认为 它一定是“除零”，以及程序核心功能就一定藏 exception 处理里*</strong></em></p><p>第一处是除零异常</p><p>可以再try块中看到特征idiv语句</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps44-1691140202259-21.jpg" alt="img"> </p><p>第二处是判断输入异常</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps45-1691140202259-22.jpg" alt="img"> </p><p><em><strong>*问题-3*</strong></em><em><strong>*：程序使用了何种加密算法？在程序中总共使用了几次？各自用于实现什么目的？*</strong></em></p><p>使用了异或加密</p><ol><li>在主函数中对buffer加密</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps46-1691140202259-23.jpg" alt="img"> </p><p>实现对反编译的干扰，无法直接读取汇编代码内容</p><ol start="2"><li>在处理输入flag时进行加密</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps47-1691140202259-25.jpg" alt="img"> </p><p><em><strong>*问题-4*</strong></em><em><strong>*：画出程序的算法流程图，给出输入正确f FLAG 时的 CMD 运行窗口截图*</strong></em></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps48-1691140202259-26.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps49-1691140202259-27.jpg" alt="img"> </p>]]></content>
    
    
    <summary type="html">通过源码取消花指令，再进入异常处理破解加密算法</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>二进制编辑修改</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL1/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL1/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:16.883Z</updated>
    
    <content type="html"><![CDATA[<ol><li>第一次打开exe文件发现乱码，是因为编辑语言错误。</li><li>打开控制面板，调节语言。</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps1-1691139848774-2.jpg" alt="img"> </p><ol start="3"><li>可以正常打开源文件</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps2-1691139848773-1.jpg" alt="img"> </p><ol start="4"><li>使用010Editir另存源文件</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps3-1691139848774-5.jpg" alt="img"> </p><ol start="5"><li>找到要修改的位置</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps4-1691139848774-3.jpg" alt="img"> </p><ol start="6"><li>找到更改代码</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps5-1691139848774-4.jpg" alt="img"> </p><ol start="7"><li>完成修改</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps6-1691139848774-6.jpg" alt="img"> </p><ol start="8"><li>保存后运行程序，实验成功</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps7-1691139848774-7.jpg" alt="img"> </p>]]></content>
    
    
    <summary type="html">对exe程序文件进行二进制修改，从而改变原文内容</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>23年汇编期末考试答案（个人答案）</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL4/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL4/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:37.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-题目1-本题20"><a href="#一-题目1-本题20" class="headerlink" title="(一) 题目1 (本题20&#96;)"></a><strong>(一)</strong> 题目1 (本题20&#96;)</h1><p>（前3步分析过程不停的掉到坑里，有好多分析是无用的，请简略看）</p><p>1.查看exe文件运行情况</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps50.jpg" alt="img"> </p><p>2.ida分析，查看结构图有无报红花指令报错，找main0，F5看伪代码</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps51.jpg" alt="img"> </p><ol start="3"><li>密钥必须为18位</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps52-1691140441091-1.jpg" alt="img"> </p><ol start="4"><li>发现有一个除零异常，先不管往后看</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps53-1691140441091-3.jpg" alt="img"> </p><ol start="5"><li>看见加密模块，解析加密算法</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps54-1691140441091-2.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps55-1691140441091-5.jpg" alt="img"> </p><p>依照次加密循环，只需将加密后密文加密两次就可以得到明文。</p><p>及efabcdgh-&gt;cdefabgh-&gt;abcdefgh。</p><ol start="6"><li>回头看异常处理部分，动调看一下处理情况</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps56-1691140441091-4.jpg" alt="img"> </p><p>发现处理完后并不会回到程序继续运行，因此加密函数并不会使用主函数的后续功能，说明前面推导错误浪费了时间，真的模块在异常处理当中。</p><ol start="7"><li>找到除零异常位置4012139</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps57-1691140441091-6.jpg" alt="img"> </p><ol start="8"><li>在x32中下断点</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps58-1691140441091-7.jpg" alt="img"> </p><p>随便输入18位输入数据，动调找seh链，转跳到断点后看seh模块</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps59-1691140441091-8.jpg" alt="img"> </p><p>401005为自己设定的异常处理，回到ida找该处理模块。其他的异常不用管</p><ol start="9"><li>追入模块内部</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps60-1691140441091-11.jpg" alt="img"> </p><p>追入sub_401020</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps61-1691140441091-13.jpg" alt="img"> </p><p>发现真正的加密模块。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps62-1691140441091-9.jpg" alt="img"> </p><p>&amp;3是和0011做异或，0x0C&#x3D;0000 1100,0xF0&#x3D;11110000所以有对每位char型的8比特值进行二进制操作</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps63-1691140441091-14.jpg" alt="img"> </p><p>按道理只需要将密文迭代三次可以得到原flag</p><p>10.byte_429A30就是密文信息</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps64-1691140441091-10.jpg" alt="img"> </p><p>复制密文信息  D5 96 C4 F6 07 45 57 77 76 E5 F6 48 47 F7 48 17</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps65-1691140441091-12.jpg" alt="img"> </p><p>11.下断点开始动调</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps66-1691140441091-18.jpg" alt="img"> </p><p>修改输入信息为密文</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps67-1691140441091-15.jpg" alt="img"> </p><p>步进后得到第一次加密结果 密文1：5D D9 9C 6F E0 A4 75 B7 B7 BE 00 C5 C5 10 95 92</p><ol start="12"><li>重复以上步骤2次</li></ol><p>密文2：75 AD B9 87 1E 6A E7 BB FB DC 00 C5 C5 10 95 92</p><p>明文：57 BA EB A8 82 F6 7E 8C C0 5E 00 C5 C5 10 95 92</p><ol start="13"><li>解不出来。原来是落下一步，还要先和序列号相加，前面的计算又浪费了</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps68-1691140441091-17.jpg" alt="img"> </p><p>那就手算吧</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps69-1691140441091-16.jpg" alt="img"> </p><p>根据加密过程可知逆运算需要：</p><p>高两位右移6位，中两位右移2位，低四位左移5位</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps70-1691140441091-19.jpg" alt="img"> </p><p>得到明文 57 65 41 6C 6C 4C 6F 76 65 52 65 76 65 72 73 65</p><p>小工具助我一臂之力：WeAllLoveReverse</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps71-1691140441092-23.jpg" alt="img"> </p><ol start="14"><li>得到flag：WeAllLoveReverseXX，后两位任意</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps72-1691140441092-22.jpg" alt="img"> </p><h1 id="二-题目2-本题20"><a href="#二-题目2-本题20" class="headerlink" title="(二) 题目2 (本题20&#96;)"></a><strong>(二)</strong> 题目2 (本题20&#96;)</h1><p>1.查看exe文件运行情况</p><p>2.ida分析，查看结构图有无报红花指令报错，找main0，F5看伪代码，将比对数按R更改成字符</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps73-1691140441092-25.jpg" alt="img"> </p><p>可以看出来是一个a*x+b的仿射加密，但是区间范围改成了A~Y，是魔改的仿射。</p><p>其中a&#x3D;2,b&#x3D;7</p><ol start="3"><li>找到密文Str2</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps74-1691140441092-20.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps75-1691140441092-21.jpg" alt="img"> </p><p>密文是 HIPHSFUPSU</p><ol start="4"><li>放入破译脚本中进行破解</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps76-1691140441092-28.jpg" alt="img"> </p><p>得到flag：ANEASYTEST</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps77-1691140441092-27.jpg" alt="img"> </p><h1 id="三-题目3-本题20"><a href="#三-题目3-本题20" class="headerlink" title="(三) 题目3 (本题20&#96;)"></a><strong>(三)</strong> 题目3 (本题20&#96;)</h1><p>1.查看exe文件运行情况</p><p>2.ida分析，查看结构图有无报红花指令报错，找main0，F5看伪代码</p><p>看不见输入函数部分，但是有个sub_401005</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps78-1691140441092-24.jpg" alt="img"> </p><p>追入sub_401005查看发生了什么</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps79-1691140441092-26.jpg" alt="img"> </p><p>继续追</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps80-1691140441092-30.jpg" alt="img"> </p><p>可以看出来这是一个文件的hook并不影响代码，因为考试原因不详细分析，知道这个函数实现了字符串输入，并最终把字符串传入了内存Str</p><ol start="3"><li>分析加密部分</li></ol><p>Str为输入内容</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps81-1691140441092-29.jpg" alt="img"> </p><p>实现了两次异或加密。最后与密文相比对，其中输入必须为10字符。</p><p>由于异或的加解密相同，不管异或多少次，都可以用密文通过运行得到明文。</p><ol start="4"><li>抓密文去喽</li></ol><p>格式不对？AU快捷键改一下</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps82-1691140441092-31.jpg" alt="img"> </p><p>抓到密文 RhSrppYzw,</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps83-1691140441092-33.jpg" alt="img"> </p><ol start="5"><li>下断点开始计算明文，上图中断点已下好，断点下载比对加密后明文和密文的位置，运行到这里就已经加好密了</li></ol><p>动调输入密文，断点处查看内存中的加密结果就是明文</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps84-1691140441092-34.jpg" alt="img"> </p><ol start="6"><li>抓到明文 IsHackBad?</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps85-1691140441092-32.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps86-1691140441092-35.jpg" alt="img"> </p><ol start="7"><li>验证</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps87-1691140441092-36.jpg" alt="img"> </p><h1 id="四-题目4-本题20"><a href="#四-题目4-本题20" class="headerlink" title="(四) 题目4 (本题20&#96;)"></a><strong>(四)</strong> 题目4 (本题20&#96;)</h1><p>1.查看exe文件运行情况</p><p>2.ida分析，查看结构图有无报红花指令报错，找main0，F5看伪代码</p><p>很明显的结构，输入固定8位，经算法后比对结果。那么算法就在sub_40100F或sub_401032中</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps88-1691140441092-37.jpg" alt="img"> </p><ol start="3"><li>追入sub_40100F找加密算法</li></ol><p>函数很复杂，一层套一层，感觉不想简单的加密，应该属于DES&#x2F;MD5&#x2F;RC4&#x2F;SHA当中的了</p><p>开始找特征值，看见有48，还有Src[48]，很像DES的加密密钥嗷</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps89-1691140441092-39.jpg" alt="img"> </p><ol start="4"><li>追入sub_401032找加密算法</li></ol><p>都是和48位密钥的操作，判断是des</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps90-1691140441092-41.jpg" alt="img"> </p><ol start="5"><li>尝试动调对密码加密得到flag但是失败了，不过找到了密文</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps91-1691140441092-38.jpg" alt="img"> </p><p>密文为42 AC 43 D3 F1 44 B1 36</p><p>可以看出来V7就是密钥</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps92-1691140441092-40.jpg" alt="img"> </p><ol start="6"><li>不能偷懒，还是用脚本老老实实破解吧</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps93-1691140441092-42.jpg" alt="img"> </p><p>破解flag 1_L0V5_@</p><ol start="7"><li>验证</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps94-1691140441092-43.jpg" alt="img"> </p><h1 id="五-题目5-本题20"><a href="#五-题目5-本题20" class="headerlink" title="(五) 题目5 (本题20&#96;)"></a><strong>(五)</strong> 题目5 (本题20&#96;)</h1><ol><li>查看exe文件运行情况</li></ol><p>这道题还多了个提示，看起来应该很复杂</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps95-1691140441092-45.jpg" alt="img"> </p><ol start="2"><li>ida分析，查看结构图有无报红花指令报错，找main0，F5看伪代码</li></ol><p>都是定义信息，看来加密内容应该在三个sub函数当中</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps96-1691140441092-46.jpg" alt="img"> </p><ol start="3"><li>从sub_401028开始看</li></ol><p>该函数说明输入必须为6位，并返回了一个新函数，输入内容在主函数中为Source，不再是Str</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps97-1691140441092-44.jpg" alt="img"> </p><ol start="4"><li>追入sub_40100A</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps98-1691140441092-48.jpg" alt="img"> </p><p>这一步实现了一个置换，让Str即初始输入变成逆序，返回结果result&#x3D;3</p><ol start="5"><li>看函数sub_40100F</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps99-1691140441092-50.jpg" alt="img"> </p><p>给Str传入输入信息，但是只传了前四位，就是原flag的后四位</p><ol start="6"><li>继续追入</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps100-1691140441092-47.jpg" alt="img"> </p><p>似曾相识的结构，追入函数查看</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps101-1691140441092-49.jpg" alt="img"> </p><p>这不是sha256的密钥输入嘛</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps102-1691140441092-51.jpg" alt="img"> </p><p>可以判定第二个函数是对明文进行加密了</p><ol start="7"><li>继续看第三个函数sub_401014，追入查看</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps103-1691140441092-53.jpg" alt="img"> </p><p>原来就是比对结果</p><p>Big_Numbers3_42AA30是hash的散列密钥 这么长的密钥串，更加确定是sha，md5的128位没有这么长</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps104-1691140441092-52.jpg" alt="img"> </p><ol start="8"><li>破解脚本，启动！</li></ol><p>感谢老师的工具和提示</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps105-1691140441092-54.jpg" alt="img"> </p><ol start="9"><li>分析以上过程，可知flag为6位，后四位是逆序的love，前两为随意小写字母</li></ol><p>得到flag xxevol</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps106.jpg" alt="img"> </p>]]></content>
    
    
    <summary type="html">五道期末考试题作答解析</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>包用包对的汇编破译小脚本</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL5/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL5/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:42.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="放射加密"><a href="#放射加密" class="headerlink" title="放射加密"></a>放射加密</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">affine_decrypt</span>(<span class="params">ciphertext, a, b, dictionary</span>):</span><br><span class="line">    decrypted = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> ciphertext:</span><br><span class="line"></span><br><span class="line">        char_index = dictionary.index(char)</span><br><span class="line">        <span class="comment"># 计算字符的模逆</span></span><br><span class="line">        char_inverse = mod_inverse(a, <span class="built_in">len</span>(dictionary))</span><br><span class="line">        <span class="comment"># 应用仿射解密公式</span></span><br><span class="line">        decrypted_char_index = (char_inverse * (char_index - b)) % <span class="built_in">len</span>(dictionary)</span><br><span class="line">        decrypted += dictionary[decrypted_char_index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decrypted</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a, m</span>):</span><br><span class="line">    <span class="comment"># 扩展欧几里得算法求模逆</span></span><br><span class="line">    g, x, _ = extended_gcd(a, m)</span><br><span class="line">    <span class="keyword">if</span> g == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> x % m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extended_gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> b, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gcd, x, y = extended_gcd(b % a, a)</span><br><span class="line">        <span class="keyword">return</span> gcd, y - (b // a) * x, x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义字典</span></span><br><span class="line">dictionary = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXY&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入密文和仿射加密的参数</span></span><br><span class="line">ciphertext = <span class="string">&quot;HIPHSFUPSU&quot;</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plaintext = affine_decrypt(ciphertext, a, b, dictionary)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;明文:&quot;</span>, plaintext)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ASCII转码"><a href="#ASCII转码" class="headerlink" title="ASCII转码"></a>ASCII转码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hex_values = <span class="string">&quot;0x10, 0x2C, 0x02, 0xFC, 0xFB, 0x3B, 0x0D, 0x73, 0x6E, 0xBC, 0xB9, 0xA7, 0x6F, 0x2F &quot;</span></span><br><span class="line"></span><br><span class="line">hex_values_list = hex_values.split(<span class="string">&quot;, &quot;</span>)</span><br><span class="line"></span><br><span class="line">ascii_values = [<span class="built_in">int</span>(hex_value[:-<span class="number">1</span>], <span class="number">16</span>) <span class="keyword">for</span> hex_value <span class="keyword">in</span> hex_values_list]</span><br><span class="line"></span><br><span class="line">ascii_chars = [<span class="built_in">chr</span>(ascii_value) <span class="keyword">for</span> ascii_value <span class="keyword">in</span> ascii_values]</span><br><span class="line"></span><br><span class="line">ascii_representation = <span class="string">&#x27;&#x27;</span>.join(ascii_chars)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ASCII representation:&quot;</span>, ascii_representation)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">byte_sequence = <span class="string">b&quot;\x10\x2C\x02\xFC\xFB\x3B\x0D\x73\x6E\xBC\xB9\xA7\x6F\x2F&quot;</span></span><br><span class="line">string_representation = byte_sequence.decode(<span class="string">&#x27;ascii&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串表示:&quot;</span>, string_representation)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="des"><a href="#des" class="headerlink" title="des"></a>des</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.ciphers <span class="keyword">import</span> Cipher, algorithms, modes</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.backends <span class="keyword">import</span> default_backend</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hex_to_int</span>(<span class="params">hex_str</span>):</span><br><span class="line">    hex_str = hex_str.replace(<span class="string">&quot;h&quot;</span>, <span class="string">&quot;&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(hex_str, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">des_decrypt</span>(<span class="params">ciphertext, key</span>):</span><br><span class="line">    backend = default_backend()</span><br><span class="line">    cipher = Cipher(algorithms.TripleDES(key), modes.ECB(), backend=backend)</span><br><span class="line">    decryptor = cipher.decryptor()</span><br><span class="line">    plaintext = decryptor.update(ciphertext) + decryptor.finalize()</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line">ciphertext_str = <span class="string">&quot;42h,ACh,43h,D3h,F1h,44h,B1h,36h,&quot;</span></span><br><span class="line">key_str = <span class="string">&quot;23h, 24h, 31h, 32h, 2Ah, 26h, 5Eh, 29h,&quot;</span></span><br><span class="line"></span><br><span class="line">ciphertext_bytes = <span class="built_in">bytearray</span>(hex_to_int(x) <span class="keyword">for</span> x <span class="keyword">in</span> re.findall(<span class="string">r&#x27;[0-9a-fA-F]+&#x27;</span>, ciphertext_str))</span><br><span class="line">key_bytes = <span class="built_in">bytearray</span>(hex_to_int(x) <span class="keyword">for</span> x <span class="keyword">in</span> re.findall(<span class="string">r&#x27;[0-9a-fA-F]+&#x27;</span>, key_str))</span><br><span class="line"></span><br><span class="line">plaintext = des_decrypt(ciphertext_bytes, key_bytes)</span><br><span class="line">plaintext_str = plaintext.decode()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密后的明文:&quot;</span>, plaintext_str)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">md5_hash = <span class="string">&quot;23d4a52c56357cb705137656744dc055&quot;</span>       <span class="comment">#散列值</span></span><br><span class="line">plaintext_length = <span class="number">4</span>                               <span class="comment">#明文长度</span></span><br><span class="line">charset = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>      <span class="comment">#字典 ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 abcdefghijklmnopqrstuvwxyz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成所有可能的明文组合</span></span><br><span class="line">combinations = itertools.product(charset, repeat=plaintext_length)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试每个明文组合并进行MD5散列计算</span></span><br><span class="line"><span class="keyword">for</span> combination <span class="keyword">in</span> combinations:</span><br><span class="line">    plaintext = <span class="string">&quot;&quot;</span>.join(combination)</span><br><span class="line">    md5 = hashlib.md5(plaintext.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查计算的MD5散列值是否与给定的散列值匹配</span></span><br><span class="line">    <span class="keyword">if</span> md5 == md5_hash:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;解密成功！明文为:&quot;</span>, plaintext)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未找到匹配的明文。&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_decrypt</span>(<span class="params">ciphertext, key</span>):</span><br><span class="line">    S = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    decrypted = <span class="built_in">bytearray</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化S盒</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + S[i] + key[i % <span class="built_in">len</span>(key)]) % <span class="number">256</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解密数据</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> ciphertext:</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line">        k = S[(S[i] + S[j]) % <span class="number">256</span>]</span><br><span class="line">        decrypted.append(byte ^ k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decrypted</span><br><span class="line"></span><br><span class="line">ciphertext_str = <span class="string">&quot;1Bh, 0CAh, 0AEh, 0EFh, 1Eh, 95h, 4Bh, 0C2h, 0D5h, 0E3h, 33h, 76h, 4Fh, 0F9h, 4Fh, 0D2h, 0FCh, 60h&quot;</span></span><br><span class="line">ciphertext_bytes = <span class="built_in">bytearray</span>(<span class="built_in">int</span>(<span class="keyword">match</span>.group(<span class="number">1</span>), <span class="number">16</span>) <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> re.finditer(<span class="string">r&quot;([0-9A-Fa-f]+)h&quot;</span>, ciphertext_str))</span><br><span class="line"></span><br><span class="line">key_str = <span class="string">&quot;52h, 43h, 34h, 6Bh, 65h, 79h&quot;</span></span><br><span class="line">key_bytes = <span class="built_in">bytearray</span>(<span class="built_in">int</span>(<span class="keyword">match</span>.group(<span class="number">1</span>), <span class="number">16</span>) <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> re.finditer(<span class="string">r&quot;([0-9A-Fa-f]+)h&quot;</span>, key_str))</span><br><span class="line"></span><br><span class="line">plaintext = rc4_decrypt(ciphertext_bytes, key_bytes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密后的明文:&quot;</span>, plaintext.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="SHA256"><a href="#SHA256" class="headerlink" title="SHA256"></a>SHA256</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">hash_value = <span class="string">&quot;45c6c64ffd31a750bcb2e150519f1963e5424bafd380637cff33075c25d35334&quot;</span></span><br><span class="line">plaintext_length = <span class="number">4</span></span><br><span class="line">charset = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>  <span class="comment">#字典 ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 abcdefghijklmnopqrstuvwxyz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_combinations</span>(<span class="params">length, charset</span>):</span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> charset:</span><br><span class="line">            <span class="keyword">for</span> combination <span class="keyword">in</span> generate_combinations(length - <span class="number">1</span>, charset):</span><br><span class="line">                <span class="keyword">yield</span> char + combination</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> combination <span class="keyword">in</span> generate_combinations(plaintext_length, charset):</span><br><span class="line">    hashed_combination = hashlib.sha256(combination.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">if</span> hashed_combination == hash_value:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Plaintext found:&quot;</span>, combination)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="XOR-异或"><a href="#XOR-异或" class="headerlink" title="XOR 异或"></a>XOR 异或</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">plaintext = <span class="string">&quot;61h, 62h, 63h, 64h, 65h, 66h, 67h, 31h, 32h, 33h&quot;</span></span><br><span class="line">ciphertext = <span class="string">&quot;28h, 3Dh, 24h, 54h, 0Ah, 12h, 38h, 7Ah, 57h, 4Ah&quot;</span></span><br><span class="line"></span><br><span class="line">plaintext = plaintext.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">ciphertext = ciphertext.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext)):</span><br><span class="line">    hex_plain = re.sub(<span class="string">r&#x27;[^0-9a-fA-F]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, plaintext[i])</span><br><span class="line">    hex_cipher = re.sub(<span class="string">r&#x27;[^0-9a-fA-F]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, ciphertext[i])</span><br><span class="line">    decrypted = <span class="built_in">int</span>(hex_plain, <span class="number">16</span>) ^ <span class="built_in">int</span>(hex_cipher, <span class="number">16</span>)</span><br><span class="line">    result.append(<span class="built_in">chr</span>(decrypted))</span><br><span class="line"></span><br><span class="line">output = <span class="string">&quot;&quot;</span>.join(result)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">包括MD5、RC4、des等各种解密手段，并且支持自定义</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言基础代码解读</title>
    <link href="https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL6/"/>
    <id>https://zhangyuanhe.top/2023/08/04/Information_Security_Experiment/assembler_language/AL6/</id>
    <published>2023-08-04T01:00:00.000Z</published>
    <updated>2023-08-04T10:07:47.866Z</updated>
    
    <content type="html"><![CDATA[<p>8080汇编手册数据传输指令</p><p>──────────────────────────────</p><p>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据。</p><h1 id="1。-通用数据传送指令。"><a href="#1。-通用数据传送指令。" class="headerlink" title="1。 通用数据传送指令。"></a><strong>1。 通用数据传送指令。</strong></h1><p>MOV 传送字或字节。</p><p>MOVSX 先符号扩展，再传送。</p><p>MOVZX 先零扩展，再传送。</p><p>PUSH 把字压入堆栈。</p><p>POP 把字弹出堆栈。</p><p>PUSHA 把AX，CX，DX，BX，SP，BP，SI，DI依次压入堆栈。</p><p>POPA 把DI，SI，BP，SP，BX，DX，CX，AX依次弹出堆栈。</p><p>PUSHAD 把EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI依次压入堆栈。</p><p>POPAD 把EDI，ESI，EBP，ESP，EBX，EDX，ECX，EAX依次弹出堆栈。</p><p>BSWAP 交换32位寄存器里字节的顺序</p><p>XCHG 交换字或字节。( 至少有一个操作数为寄存器，段寄存器不可作为操作数)</p><p>CMPXCHG 比较并交换操作数。( 第二个操作数必须为累加器AL&#x2F;AX&#x2F;EAX )</p><p>XADD 先交换再累加。( 结果在第一个操作数里 )</p><p>XLAT 字节查表转换。</p><p>── BX 指向一张 256 字节的表的起点， AL 为表的索引值 (0-255，即</p><p>0-FFH); 返回 AL 为查表结果。 ( [BX+AL]-&gt;AL )</p><p>2。 输入输出端口传送指令。</p><p>IN I&#x2F;O端口输入。 ( 语法: IN 累加器， {端口号│DX} )</p><p>OUT I&#x2F;O端口输出。 ( 语法: OUT {端口号│DX}，累加器 )</p><p>输入输出端口由立即方式指定时， 其范围是 0-255; 由寄存器 DX 指定时，</p><p>其范围是 0-65535。</p><p>3。 目的地址传送指令。</p><p>LEA 装入有效地址。</p><p>例: LEA DX，string ;把偏移地址存到DX。</p><p>LDS 传送目标指针，把指针内容装入DS。</p><p>例: LDS SI，string ;把段地址:偏移地址存到DS:SI。</p><p>LES 传送目标指针，把指针内容装入ES。</p><p>例: LES DI，string ;把段地址:偏移地址存到ES:DI。</p><p>LFS 传送目标指针，把指针内容装入FS。</p><p>例: LFS DI，string ;把段地址:偏移地址存到FS:DI。</p><p>LGS 传送目标指针，把指针内容装入GS。</p><p>例: LGS DI，string ;把段地址:偏移地址存到GS:DI。</p><p>LSS 传送目标指针，把指针内容装入SS。</p><p>例: LSS DI，string ;把段地址:偏移地址存到SS:DI。</p><p>4。 标志传送指令。</p><p>LAHF 标志寄存器传送，把标志装入AH。</p><p>SAHF 标志寄存器传送，把AH内容装入标志寄存器。</p><p>PUSHF 标志入栈。</p><p>POPF 标志出栈。</p><p>PUSHD 32位标志入栈。</p><p>POPD 32位标志出栈。</p><h1 id="二、算术运算指令"><a href="#二、算术运算指令" class="headerlink" title="二、算术运算指令"></a><strong>二、算术运算指令</strong></h1><p>──────────────────────────────</p><p>ADD 加法。</p><p>ADC 带进位加法。</p><p>INC 加 1。</p><p>AAA 加法的ASCII码调整。</p><p>DAA 加法的十进制调整。</p><p>SUB 减法。</p><p>SBB 带借位减法。</p><p>DEC 减 1。</p><p>NEC 求反(以 0 减之)。</p><p>CMP 比较。(两操作数作减法，仅修改标志位，不回送结果)。</p><p>AAS 减法的ASCII码调整。</p><p>DAS 减法的十进制调整。</p><p>MUL 无符号乘法。</p><p>IMUL 整数乘法。</p><p>以上两条，结果回送AH和AL(字节运算)，或DX和AX(字运算)，</p><p>AAM 乘法的ASCII码调整。</p><p>DIV 无符号除法。</p><p>IDIV 整数除法。</p><p>以上两条，结果回送:</p><p>商回送AL，余数回送AH， (字节运算);</p><p>或 商回送AX，余数回送DX， (字运算)。</p><p>AAD 除法的ASCII码调整。</p><p>CBW 字节转换为字。 (把AL中字节的符号扩展到AH中去)</p><p>CWD 字转换为双字。 (把AX中的字的符号扩展到DX中去)</p><p>CWDE 字转换为双字。 (把AX中的字符号扩展到EAX中去)</p><p>CDQ 双字扩展。 (把EAX中的字的符号扩展到EDX中去)</p><h1 id="三、逻辑运算指令"><a href="#三、逻辑运算指令" class="headerlink" title="三、逻辑运算指令"></a><strong>三、逻辑运算指令</strong></h1><p>────────────────────────────</p><p>AND 与运算。</p><p>OR 或运算。</p><p>XOR 异或运算。</p><p>NOT 取反。</p><p>TEST 测试。(两操作数作与运算，仅修改标志位，不回送结果)。</p><p>SHL 逻辑左移。</p><p>SAL 算术左移。(&#x3D;SHL)</p><p>SHR 逻辑右移。</p><p>SAR 算术右移。(&#x3D;SHR)</p><p>ROL 循环左移。</p><p>ROR 循环右移。</p><p>RCL 通过进位的循环左移。</p><p>RCR 通过进位的循环右移。</p><p>以上八种移位指令，其移位次数可达255次。</p><p>移位一次时， 可直接用操作码。 如 SHL AX，1。</p><p>移位&gt;1次时， 则由寄存器CL给出移位次数。</p><p>如 MOV CL，04</p><p>SHL AX，CL</p><h1 id="四、串指令"><a href="#四、串指令" class="headerlink" title="四、串指令"></a><strong>四、串指令</strong></h1><p>───────────────────────────</p><p>DS:SI 源串段寄存器 :源串变址。</p><p>ES:DI 目标串段寄存器:目标串变址。</p><p>CX 重复次数计数器。</p><p>AL&#x2F;AX 扫描值。</p><p>D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量。</p><p>Z标志 用来控制扫描或比较操作的结束。</p><p>MOVS 串传送。</p><p>( MOVSB 传送字符。 MOVSW 传送字。 MOVSD 传送双字。 )</p><p>CMPS 串比较。</p><p>( CMPSB 比较字符。 CMPSW 比较字。 )</p><p>SCAS 串扫描。</p><p>把AL或AX的内容与目标串作比较，比较结果反映在标志位。</p><p>LODS 装入串。</p><p>把源串中的元素(字或字节)逐一装入AL或AX中。</p><p>( LODSB 传送字符。 LODSW 传送字。 LODSD 传送双字。 )</p><p>STOS 保存串。</p><p>是LODS的逆过程。</p><p>REP 当CX&#x2F;ECX&lt;&gt;0时重复。</p><p>REPE&#x2F;REPZ 当ZF&#x3D;1或比较结果相等，且CX&#x2F;ECX&lt;&gt;0时重复。</p><p>REPNE&#x2F;REPNZ 当ZF&#x3D;0或比较结果不相等，且CX&#x2F;ECX&lt;&gt;0时重复。</p><p>REPC 当CF&#x3D;1且CX&#x2F;ECX&lt;&gt;0时重复。</p><p>REPNC 当CF&#x3D;0且CX&#x2F;ECX&lt;&gt;0时重复。</p><h1 id="五、程序转移指令"><a href="#五、程序转移指令" class="headerlink" title="五、程序转移指令"></a><strong>五、程序转移指令</strong></h1><p>──────────────────────────</p><p>1&gt;无条件转移指令 (长转移)</p><p>JMP 无条件转移指令</p><p>CALL 过程调用</p><p>RET&#x2F;RETF过程返回。</p><p>2&gt;条件转移指令 (短转移，-128到+127的距离内)</p><p>( 当且仅当(SF XOR OF)&#x3D;1时，OP1 JA&#x2F;JNBE 不小于或不等于时转移。</p><p>JAE&#x2F;JNB 大于或等于转移。</p><p>JB&#x2F;JNAE 小于转移。</p><p>JBE&#x2F;JNA 小于或等于转移。</p><p>以上四条，测试无符号整数运算的结果(标志C和Z)。</p><p>JG&#x2F;JNLE 大于转移。</p><p>JGE&#x2F;JNL 大于或等于转移。</p><p>JL&#x2F;JNGE 小于转移。</p><p>JLE&#x2F;JNG 小于或等于转移。</p><p>以上四条，测试带符号整数运算的结果(标志S，O和Z)。</p><p>JE&#x2F;JZ 等于转移。</p><p>JNE&#x2F;JNZ 不等于时转移。</p><p>JC 有进位时转移。</p><p>JNC 无进位时转移。</p><p>JNO 不溢出时转移。</p><p>JNP&#x2F;JPO 奇偶性为奇数时转移。</p><p>JNS 符号位为 “0” 时转移。</p><p>JO 溢出转移。</p><p>JP&#x2F;JPE 奇偶性为偶数时转移。</p><p>JS 符号位为 “1” 时转移。</p><p>3&gt;循环控制指令(短转移)</p><p>LOOP CX不为零时循环。</p><p>LOOPE&#x2F;LOOPZ CX不为零且标志Z&#x3D;1时循环。</p><p>LOOPNE&#x2F;LOOPNZ CX不为零且标志Z&#x3D;0时循环。</p><p>JCXZ CX为零时转移。</p><p>JECXZ ECX为零时转移。</p><p>4&gt;中断指令</p><p>INT 中断指令</p><p>INTO 溢出中断</p><p>IRET 中断返回</p><p>5&gt;处理器控制指令</p><p>HLT 处理器暂停， 直到出现中断或复位信号才继续。</p><p>WAIT 当芯片引线TEST为高电平时使CPU进入等待状态。</p><p>ESC 转换到外处理器。</p><p>LOCK 封锁总线。</p><p>NOP 空操作。</p><p>STC 置进位标志位。</p><p>CLC 清进位标志位。</p><p>CMC 进位标志取反。</p><p>STD 置方向标志位。</p><p>CLD 清方向标志位。</p><p>STI 置中断允许位。</p><p>CLI 清中断允许位。</p><h1 id="六、伪指令"><a href="#六、伪指令" class="headerlink" title="六、伪指令"></a><strong>六、伪指令</strong></h1><p>───────────────────────────</p><p>DW 定义字(2字节)。</p><p>PROC 定义过程。</p><p>ENDP 过程结束。</p><p>SEGMENT 定义段。</p><p>ASSUME 建立段寄存器寻址。</p><p>ENDS 段结束。</p><p>END 程序结束。</p><h1 id="一-机械码-又称机器码"><a href="#一-机械码-又称机器码" class="headerlink" title="一.机械码,又称机器码."></a><strong>一.机械码,又称机器码.</strong></h1><p>ultraedit打开,编辑exe文件时你会看到</p><p>许许多多的由0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F组成的数码,这些数码</p><p>就是机器码.</p><p>修改程序时必须通过修改机器码来修改exe文件.</p><h1 id="二-需要熟练掌握的全部汇编知识-只有这么多"><a href="#二-需要熟练掌握的全部汇编知识-只有这么多" class="headerlink" title="二.需要熟练掌握的全部汇编知识(只有这么多)"></a><strong>二.需要熟练掌握的全部汇编知识(只有这么多)</strong></h1><p>不大容易理解,可先强行背住,混个脸儿熟,以后慢慢的就理解了</p><p>cmp a,b 比较a与b</p><p>mov a,b 把b的值送给a</p><p>ret 返回主程序</p><p>nop 无作用,英文“no operation”的简写，意思是“do nothing”(机器码90)***机器码的含义参看上面</p><p>(解释:ultraedit打开编辑exe文件时你看到90,等同于汇编语句nop)</p><p>call 调用子程序</p><p>je 或jz 若相等则跳(机器码74 或0F84)</p><p>jne或jnz 若不相等则跳(机器码75或0F85)</p><p>jmp 无条件跳(机器码EB)</p><p>jb 若小于则跳</p><p>ja 若大于则跳</p><p>jg 若大于则跳</p><p>jge 若大于等于则跳</p><p>jl 若小于则跳</p><p>jle 若小于等于则跳</p><p>pop 出栈</p><p>push 压栈</p><h1 id="三-常见修改-机器码"><a href="#三-常见修改-机器码" class="headerlink" title="三.常见修改(机器码)"></a>三.常见修改(机器码)</h1><p>74&#x3D;&gt;75 74&#x3D;&gt;90 74&#x3D;&gt;EB</p><p>75&#x3D;&gt;74 75&#x3D;&gt;90 75&#x3D;&gt;EB</p><p>jnz-&gt;nop</p><p>75-&gt;90(相应的机器码修改)</p><p>jnz -&gt; jmp</p><p>75 -&gt; EB(相应的机器码修改)</p><p>jnz -&gt; jz</p><p>75-&gt;74 (正常) 0F 85 -&gt; 0F 84(特殊情况下,有时,相应的机器码修改)</p><h1 id="四-两种不同情况的不同修改方法"><a href="#四-两种不同情况的不同修改方法" class="headerlink" title="四.两种不同情况的不同修改方法"></a>四.两种不同情况的不同修改方法</h1><p>1.修改为jmp</p><p>je(jne,jz,jnz) &#x3D;&gt;jmp相应的机器码EB （出错信息向上找到的第一个跳转）jmp的作用是绝对跳，无条件跳，从而跳过下面的出错信息</p><p>xxxxxxxxxxxx 出错信息，例如：注册码不对，sorry,未注册版不能…，”Function Not Avaible in Demo” 或 “Command Not Avaible” 或 “Can’t save in Shareware&#x2F;Demo”等 （我们希望把它跳过，不让它出现）</p><p>。。。</p><p>。。。</p><p>xxxxxxxxxxxx 正确路线所在</p><p>2.修改为nop</p><p>je(jne,jz,jnz) &#x3D;&gt;nop相应的机器码90 （正确信息向上找到的第一个跳转） nop的作用是抹掉这个跳转，使这个跳转无效，失去作用，从而使程序顺利来到紧跟其后的正确信息处</p><p>xxxxxxxxxxxx 正确信息，例如：注册成功，谢谢您的支持等（我们希望它不被跳过，让它出现，程序一定要顺利来到这里）</p><p>。。。</p><p>。。。</p><p>xxxxxxxxxxxx 出错信息（我们希望不要跳到这里，不让它出现）它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据. </p><ol><li>通用数据传送指令.</li></ol><p>MOV 传送字或字节. </p><p>MOVSX 先符号扩展,再传送. </p><p>MOVZX 先零扩展,再传送. </p><p>PUSH 把字压入堆栈. </p><p>POP 把字弹出堆栈. </p><p>PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. </p><p>POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. </p><p>PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. </p><p>POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. </p><p>BSWAP 交换32位寄存器里字节的顺序 </p><p>XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)</p><p>CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL&#x2F;AX&#x2F;EAX )</p><p>XADD 先交换再累加.( 结果在第一个操作数里 )</p><p>XLAT 字节查表转换. </p><p>── BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即 </p><p>0-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL )</p><ol start="2"><li>输入输出端口传送指令.</li></ol><p>IN I&#x2F;O端口输入. ( 语法: IN 累加器, {端口号│DX} )</p><p>OUT I&#x2F;O端口输出. ( 语法: OUT {端口号│DX},累加器 )</p><p>输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,</p><p>其范围是 0-65535.</p><ol start="3"><li>目的地址传送指令.</li></ol><p>LEA 装入有效地址. </p><p>例: LEA DX,string ;把偏移地址存到DX. </p><p>LDS 传送目标指针,把指针内容装入DS. </p><p>例: LDS SI,string ;把段地址:偏移地址存到DS:SI. </p><p>LES 传送目标指针,把指针内容装入ES. </p><p>例: LES DI,string ;把段地址:偏移地址存到ESI. </p><p>LFS 传送目标指针,把指针内容装入FS. </p><p>例: LFS DI,string ;把段地址:偏移地址存到FSI. </p><p>LGS 传送目标指针,把指针内容装入GS. </p><p>例: LGS DI,string ;把段地址:偏移地址存到GSI. </p><p>LSS 传送目标指针,把指针内容装入SS. </p><p>例: LSS DI,string ;把段地址:偏移地址存到SSI. </p><ol start="4"><li>标志传送指令.</li></ol><p>LAHF 标志寄存器传送,把标志装入AH. </p><p>SAHF 标志寄存器传送,把AH内容装入标志寄存器. </p><p>PUSHF 标志入栈. </p><p>POPF 标志出栈. </p><p>PUSHD 32位标志入栈. </p><p>POPD 32位标志出栈. </p><h1 id="二、算术运算指令-1"><a href="#二、算术运算指令-1" class="headerlink" title="二、算术运算指令"></a>二、算术运算指令</h1><p>─────────────────────────────────────── </p><p>ADD 加法. </p><p>ADC 带进位加法. </p><p>INC 加 1.</p><p>AAA 加法的ASCII码调整. </p><p>DAA 加法的十进制调整. </p><p>SUB 减法. </p><p>SBB 带借位减法. </p><p>DEC 减 1.</p><p>NEC 求反(以 0 减之). </p><p>CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). </p><p>AAS 减法的ASCII码调整. </p><p>DAS 减法的十进制调整. </p><p>MUL 无符号乘法. </p><p>IMUL 整数乘法. </p><p>以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算),</p><p>AAM 乘法的ASCII码调整. </p><p>DIV 无符号除法. </p><p>IDIV 整数除法. </p><p>以上两条,结果回送:</p><p>商回送AL,余数回送AH, (字节运算); </p><p>或 商回送AX,余数回送DX, (字运算). </p><p>AAD 除法的ASCII码调整. </p><p>CBW 字节转换为字. (把AL中字节的符号扩展到AH中去)</p><p>CWD 字转换为双字. (把AX中的字的符号扩展到DX中去)</p><p>CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去)</p><p>CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去)</p><h1 id="三、逻辑运算指令-1"><a href="#三、逻辑运算指令-1" class="headerlink" title="三、逻辑运算指令"></a>三、逻辑运算指令</h1><p>─────────────────────────────────────── </p><p>AND 与运算. </p><p>OR 或运算. </p><p>XOR 异或运算. </p><p>NOT 取反. </p><p>TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). </p><p>SHL 逻辑左移. </p><p>SAL 算术左移.(&#x3D;SHL)</p><p>SHR 逻辑右移. </p><p>SAR 算术右移.(&#x3D;SHR)</p><p>ROL 循环左移. </p><p>ROR 循环右移. </p><p>RCL 通过进位的循环左移. </p><p>RCR 通过进位的循环右移. </p><p>以上八种移位指令,其移位次数可达255次. </p><p>移位一次时, 可直接用操作码. 如 SHL AX,1.</p><p>移位&gt;1次时, 则由寄存器CL给出移位次数. </p><p>如 MOV CL,04</p><p>SHL AX,CL </p><h1 id="四、串指令-1"><a href="#四、串指令-1" class="headerlink" title="四、串指令"></a>四、串指令</h1><p>─────────────────────────────────────── </p><p>DS:SI 源串段寄存器 :源串变址. </p><p>ESI 目标串段寄存器:目标串变址. </p><p>CX 重复次数计数器. </p><p>AL&#x2F;AX 扫描值. </p><p>D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. </p><p>Z标志 用来控制扫描或比较操作的结束. </p><p>MOVS 串传送. </p><p>( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )</p><p>CMPS 串比较. </p><p>( CMPSB 比较字符. CMPSW 比较字. )</p><p>SCAS 串扫描. </p><p>把AL或AX的内容与目标串作比较,比较结果反映在标志位. </p><p>LODS 装入串. </p><p>把源串中的元素(字或字节)逐一装入AL或AX中. </p><p>( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )</p><p>STOS 保存串. </p><p>是LODS的逆过程. </p><p>REP 当CX&#x2F;ECX&lt;&gt;0时重复. </p><p>REPE&#x2F;REPZ 当ZF&#x3D;1或比较结果相等,且CX&#x2F;ECX&lt;&gt;0时重复. </p><p>REPNE&#x2F;REPNZ 当ZF&#x3D;0或比较结果不相等,且CX&#x2F;ECX&lt;&gt;0时重复. </p><p>REPC 当CF&#x3D;1且CX&#x2F;ECX&lt;&gt;0时重复. </p><p>REPNC 当CF&#x3D;0且CX&#x2F;ECX&lt;&gt;0时重复. </p><h1 id="五、程序转移指令-1"><a href="#五、程序转移指令-1" class="headerlink" title="五、程序转移指令"></a>五、程序转移指令</h1><p>─────────────────────────────────────── </p><p>1&gt;无条件转移指令 (长转移)</p><p>JMP 无条件转移指令 </p><p>CALL 过程调用 </p><p>RET&#x2F;RETF过程返回. </p><p>2&gt;条件转移指令 (短转移,-128到+127的距离内)</p><p>( 当且仅当(SF XOR OF)&#x3D;1时,OP1&lt;OP2 )</p><p>JA&#x2F;JNBE 不小于或不等于时转移. </p><p>JAE&#x2F;JNB 大于或等于转移. </p><p>JB&#x2F;JNAE 小于转移. </p><p>JBE&#x2F;JNA 小于或等于转移. </p><p>以上四条,测试无符号整数运算的结果(标志C和Z). </p><p>JG&#x2F;JNLE 大于转移. </p><p>JGE&#x2F;JNL 大于或等于转移. </p><p>JL&#x2F;JNGE 小于转移. </p><p>JLE&#x2F;JNG 小于或等于转移. </p><p>以上四条,测试带符号整数运算的结果(标志S,O和Z). </p><p>JE&#x2F;JZ 等于转移. </p><p>JNE&#x2F;JNZ 不等于时转移. </p><p>JC 有进位时转移. </p><p>JNC 无进位时转移. </p><p>JNO 不溢出时转移. </p><p>JNP&#x2F;JPO 奇偶性为奇数时转移. </p><p>JNS 符号位为 “0” 时转移. </p><p>JO 溢出转移. </p><p>JP&#x2F;JPE 奇偶性为偶数时转移. </p><p>JS 符号位为 “1” 时转移. </p><p>3&gt;循环控制指令(短转移)</p><p>LOOP CX不为零时循环. </p><p>LOOPE&#x2F;LOOPZ CX不为零且标志Z&#x3D;1时循环. </p><p>LOOPNE&#x2F;LOOPNZ CX不为零且标志Z&#x3D;0时循环. </p><p>JCXZ CX为零时转移. </p><p>JECXZ ECX为零时转移. </p><p>4&gt;中断指令 </p><p>INT 中断指令 </p><p>INTO 溢出中断 </p><p>IRET 中断返回 </p><p>5&gt;处理器控制指令 </p><p>HLT 处理器暂停, 直到出现中断或复位信号才继续. </p><p>WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. </p><p>ESC 转换到外处理器. </p><p>LOCK 封锁总线. </p><p>NOP 空操作. </p><p>STC 置进位标志位. </p><p>CLC 清进位标志位. </p><p>CMC 进位标志取反. </p><p>STD 置方向标志位. </p><p>CLD 清方向标志位. </p><p>STI 置中断允许位. </p><p>CLI 清中断允许位. </p><h1 id="六、伪指令-1"><a href="#六、伪指令-1" class="headerlink" title="六、伪指令"></a>六、伪指令</h1><p>─────────────────────────────────────── </p><p>DW 定义字(2字节). </p><p>PROC 定义过程. </p><p>ENDP 过程结束. </p><p>SEGMENT 定义段. </p><p>ASSUME 建立段寄存器寻址. </p><p>ENDS 段结束. </p><p>END 程序结束</p>]]></content>
    
    
    <summary type="html">对常见语言进行解释，便于后续阅读源码</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="汇编语言" scheme="https://zhangyuanhe.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>鲁棒图像感知哈希实验</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS1/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS1/</id>
    <published>2023-08-02T09:00:00.000Z</published>
    <updated>2023-08-02T09:52:10.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 *实验目的*"></a><strong>一、</strong> <em><strong>*实验目的*</strong></em></h1><p>了解鲁棒性内容感知哈希技术的基本特点，设计并实现基于 DCT 的鲁棒性图 </p><p>像感知哈希。了解鲁棒性内容感知哈希技术在数字内容保护中的作用，掌握基于 </p><p>鲁棒性感知哈希的内容保护方法</p><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 *实验内容*"></a><strong>二、</strong> <em><strong>*实验内容*</strong></em></h1><p>本实验实现一种基于视觉特性的图像感知哈希算法，可通过密钥控制哈希序 </p><p>列，保证安全性。</p><h1 id="三、-系统整体描述和分功能描述"><a href="#三、-系统整体描述和分功能描述" class="headerlink" title="三、 *系统整体描述和分功能描述*"></a><strong>三、</strong> <em><strong>*系统整体描述和分功能描述*</strong></em></h1><h2 id="系统整体描述"><a href="#系统整体描述" class="headerlink" title="*系统整体描述*"></a><em><strong>*系统整体描述*</strong></em></h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps23.jpg" alt="img"> </p><p>​    </p><h2 id="分功能描述"><a href="#分功能描述" class="headerlink" title="*分功能描述*"></a><em><strong>*分功能描述*</strong></em></h2><p>1）读入两幅图像，对图像做预处理</p><p>用到的函数rgb2gray()</p><p><a href="#buiz8mj-1-I">I</a> &#x3D; rgb2gray(<a href="#buiz8mj-1-RGB">RGB</a>) 将真彩色图像 RGB 转换为灰度图像 I。rgb2gray 函数通过消除色调和饱和度信息，同时保留亮度，来将 RGB 图像转换为灰度图。</p><p>2） 对标准化图像进行 8*8 子块划分</p><p>用到的函数imresize(Picture1,[64,64])</p><p><a href="#d124e713495">B</a> &#x3D; imresize(<a href="#d124e712839">A</a>,<a href="#d124e712884">scale</a>) 返回图像 B，它是将 A 的长宽大小缩放图像 scale 倍之后的图像。输入图像 A 可以是灰度图像、RGB 图像、二值图像或分类图像。</p><p>3） 依次对各子块进行二维离散余弦变换</p><p>用到的函数(Picture1,[8 8],fun)</p><p>对图像进行分块处理</p><p>4)通过密钥伪随机生成服从标准正态的、的 64*64 矩阵</p><p>用到的函数randn(‘state’,key)</p><p>返回一个从标准正态分布中得到的随机标量。</p><p>5）用高斯低通滤波器进行迭代滤波</p><p>用到的函数 fspecial(‘gaussian’)</p><p>创建具有指定 type 的二维滤波器</p><p>Y &#x3D; cell(1,Hashlen);</p><h1 id="四、-实验步骤、结果及分析"><a href="#四、-实验步骤、结果及分析" class="headerlink" title="四、 *实验步骤、结果及分析*"></a><strong>四、</strong> <em><strong>*实验步骤、结果及分析*</strong></em></h1><ol><li>读入两幅图像，对图像做预处理：如果读入的是彩色图像，将其转换为</li></ol><p>灰度图像（rgb2gray）；在灰度图像中利用差值方式将图像重采样为 64*64 </p><p>的标准化图表示（imresize） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Picture1 = rgb2gray(Picture1);  </span><br><span class="line">Picture2 = rgb2gray(Picture2); </span><br></pre></td></tr></table></figure><ol start="2"><li><p>对标准化图像进行 8<em>8 子块划分，将标准化图像划分为（64</em>64）&#x2F;（8*8）&#x3D;64 个子块，依次对各子块进行二维离散余弦变换1,1）置为 0； </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">% 对标准化图像进行 8*8 子块划分 </span><br><span class="line">Picture1 = imresize(Picture1,[64,64]); </span><br><span class="line">Picture2 = imresize(Picture2,[64,64]); </span><br><span class="line">% 依次对各子块进行二维离散余弦变换 </span><br><span class="line">fun = @dct2; </span><br><span class="line">Picture1 = blkproc(Picture1,[8 8],fun); </span><br><span class="line">Picture2 = blkproc(Picture2,[8 8],fun); </span><br><span class="line">% 并依次将各分块的 DC 系数，即（1,1）置为 0 </span><br><span class="line">Picture1(1,1) = 0; </span><br><span class="line">Picture2(1,1) = 0; </span><br></pre></td></tr></table></figure></li><li><p>生成 N 个 64*64 伪随机矩阵：首先通过密钥伪随机生成服从标准正态的、</p></li></ol><p>的 64*64 矩阵（randn(‘state’,key)，randn），然后用高斯低通滤波器 </p><p>进行迭代滤波（K&#x3D;fspecial(‘gaussian’); Y&#x3D;filter2(K,Y);） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">% 通过密钥伪随机生成服从标准正态的、的 64*64 矩阵 </span><br><span class="line">randn(&#x27;state&#x27;,key); </span><br><span class="line">N = cell(1,Hashlen); </span><br><span class="line">% 用高斯低通滤波器进行迭代滤波 </span><br><span class="line">K = fspecial(&#x27;gaussian&#x27;); </span><br><span class="line">Y = cell(1,Hashlen); </span><br><span class="line">for i = 1:Hashlen </span><br><span class="line"></span><br><span class="line">N&#123;i&#125; = randn(64); </span><br><span class="line">Y&#123;i&#125; = filter2(K,N&#123;i&#125;); </span><br><span class="line">end </span><br></pre></td></tr></table></figure><ol start="4"><li><p>设 DCT 敏感度矩阵 m，对矩阵 m 进行周期延拓得到大小为 64 ×64 的矩阵 M ,并将其每个元素作为 Ic 的对应位置频率系数在特征值计算中的权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% DCT敏感度矩阵m,周期延拓至64*64 </span><br><span class="line">m = [ </span><br><span class="line">71.43 99.01 86.21 60.24 41.67 29.16 20.88 15.24; </span><br><span class="line">99.01 68.97 75.76 65.79 50.00 36.90 27.25 20.28; </span><br><span class="line">86.21 75.76 44.64 38.61 33.56 27.47 21.74 17.01; </span><br><span class="line">60.24 65.79 38.61 26.53 21.98 18.87 15.92 13.16; </span><br><span class="line">41.67 50.00 33.56 21.98 16.26 13.14 11.48 9.83; </span><br><span class="line">29.16 36.90 27.47 18.87 13.14 10.40 8.64 7.40; </span><br><span class="line">20.88 27.25 21.74 15.92 11.48 8.64 6.90 5.78; </span><br><span class="line">15.24 20.28 17.01 13.16 9.83 7.40 5.78 4.73]; </span><br><span class="line">% 矩阵m进行周期延拓得到大小为64 ×64 的矩阵M </span><br><span class="line">M = repmat(m,8,8); </span><br><span class="line">P1_Hash = ones(1,Hashlen); </span><br><span class="line">P2_Hash = ones(1,Hashlen); </span><br></pre></td></tr></table></figure></li><li><p>取第一个伪随机矩阵，计算如果 YN &lt;0，则 H(n)&#x3D;0，反之则 H(n)&#x3D;1； </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">% 对Hashlen个伪随机矩阵遍历计算</span><br><span class="line">for k = 1:Hashlen</span><br><span class="line">    P1_sum = 0;</span><br><span class="line">    P2_sum = 0;</span><br><span class="line">    for i = 1:64</span><br><span class="line">        for j = 1:64</span><br><span class="line">            P1_sum = P1_sum + Picture1(i,j) * Y&#123;k&#125;(i,j) * M(i,j);</span><br><span class="line">            P2_sum = P2_sum + Picture2(i,j) * Y&#123;k&#125;(i,j) * M(i,j);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    if P1_sum &lt; 0</span><br><span class="line">        P1_Hash(k) = 0;</span><br><span class="line">    end</span><br><span class="line">    if P2_sum &lt; 0</span><br><span class="line">        P2_Hash(k) = 0;</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>循环第 5 步，直到将所有的 N 个 64*64 伪随机矩阵都计算完，最终生成</p></li></ol><p>一个 N 比特的 Hash 向量 </p><ol start="7"><li>比较两幅图像 hash 向量的汉明距离 dis，设定一个合适的阈值 tau，如</li></ol><p>果 dis&lt;tau，则两幅图像内容一致；反之则是内容不同的两幅图像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% 汉明距离</span><br><span class="line">dis = norm((P1_Hash-P2_Hash)/2*sqrt(norm(P1_Hash)*norm(P2_Hash)));</span><br></pre></td></tr></table></figure><ol start="8"><li>以 DemoImages 中的图片为测试集，分析实验结果。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% 与阈值比较</span><br><span class="line">if tau &lt; dis</span><br><span class="line">    ds = &#x27;不相似&#x27;;</span><br><span class="line">else</span><br><span class="line">    ds = &#x27;相似&#x27;;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>9.测试Tau和Hashlen的合理值</p><p>Hashlen所影响的是数据的精度，在合理范围内略微降低可以加快运行速率。</p><p>当Hashlen&#x3D;100时跑数据较快，从而固定Hashlen&#x3D;100，调试tau值。</p><p>Tau取值范围为（0,1）从而开始多次测试选取合适数值。</p><p>Tau&#x3D;0.5，结果正确，且多次试验稳定。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps24.jpg" alt="img"> </p><h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a><strong>实验结果及分析</strong></h2><p>运行脚本，对样本库进行比对</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps25.jpg" alt="img"> </p><p>比对结束后输出结果，结果正确</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps26.jpg" alt="img"> </p><h1 id="五、-实验中遇到的问题及改正的方法"><a href="#五、-实验中遇到的问题及改正的方法" class="headerlink" title="五、 *实验中遇到的问题及改正的方法*"></a><strong>五、</strong> <em><strong>*实验中遇到的问题及改正的方法*</strong></em></h1><p>1.不同版本的matlab支持的灰度处理函数不一样，需要选取对应版本的函数。</p>]]></content>
    
    
    <summary type="html">设计并实现基于 DCT 的鲁棒性图像感知哈希。了解鲁棒性内容感知哈希技术在数字内容保护中的作用，掌握基于鲁棒性感知哈希的内容保护方法</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数学建模实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>GAN 的生成器产生图片及换脸检测</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS2/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS2/</id>
    <published>2023-08-02T09:00:00.000Z</published>
    <updated>2023-08-02T09:55:46.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 *实验目的*"></a><strong>一、</strong> <em><strong>*实验目的*</strong></em></h1><p>（1） 掌握在 WINDOWS 下安装和使用 GAN 图片生成系统、换脸检测系统 </p><p>（2） 掌握 GAN 图片生成系统主要功能模块、换脸检测系统主要功能模块 </p><p>（3） GAN 图片生成系统的原理、换脸检测系统的原理</p><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 *实验内容*"></a><strong>二、</strong> <em><strong>*实验内容*</strong></em></h1><p>（1） 分析并调试 GAN 图片生成系统程序主要功能模块、换脸检测系统程序主要功能模块 </p><p>（2） 选取实验数据集 </p><p>（3） 运行 WINDOWS 下的 GAN 图片生成系统、换脸检测系统 </p><p>（4） 用 GAN 图片生成系统对实验数据集进行图片生成实验 </p><p>（5） 用换脸检测系统对实验数据集进行换脸检测实验</p><h1 id="三、-系统整体描述和分功能描述"><a href="#三、-系统整体描述和分功能描述" class="headerlink" title="三、 *系统整体描述和分功能描述*"></a><strong>三、</strong> <em><strong>*系统整体描述和分功能描述*</strong></em></h1><h2 id="系统整体描述"><a href="#系统整体描述" class="headerlink" title="*系统整体描述*"></a><em><strong>*系统整体描述*</strong></em></h2><p>DCGAN系统：</p><p>通过GAN来生成生成图片</p><p>Deepfakes CNN-Detection系统：</p><p>通过CNN算法对图像进行鉴别，辨别是否是伪造信息。</p><p>​    </p><h2 id="分功能描述"><a href="#分功能描述" class="headerlink" title="*分功能描述*"></a><em><strong>*分功能描述*</strong></em></h2><p>1）生成头像算法训练</p><p>建立图像样本库，用Python在动漫素材相关网站爬取或使用网络上已有的数据集，按照固定比例划分训练集和测试集，并对样本进行标准化处理，使图像大小保持，每一张图片拥有唯一ID。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps27.jpg" alt="img"> </p><p>其次，选择深度卷积网络，实现目标特征提取以及图像分类。使用Visdom实现训练过程的可视化，通过控制学习率、迭代次数、训练比例等参数，设置多组对照实验，观察实验结果并利用测试集进行多次测试。</p><p> python main.py train –gpu –vis&#x3D;False</p><p>2）生成动漫头像</p><p>使用训练好的生成模型，进行头像生成（说明文件给出的代码有误）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py generate --nogpu --vis=False --netd-path=checkpoints/netd_200.pth --netg-path=checkpoints/netg_200.pth --gen-img=result.png --gen-num=64</span><br></pre></td></tr></table></figure><p>3）检测功能，检测一张照片真伪</p><p>读取到照片后进行检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python demo.py -f examples/real.png -m weights/blur_jpg_prob0.5.pth</span><br></pre></td></tr></table></figure><p>4）批量检测功能</p><p>读取照片集进行检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py --name blur_jpg_prob0.5 --blur_prob 0.5 --blur_sig 0.0,3.0 --jpg_prob 0.5 --jpg_method cv2,pil --jpg_qual 30,100 --dataroot ./dataset/ --classes airplane,bird,bicycle,boat,bottle,bus,car,cat,cow,chair,diningtable,dog,person,pottedplant,motorbike,tvmonitor,train,sheep,sofa,horse</span><br></pre></td></tr></table></figure><h1 id="四、-实验步骤、结果及分析"><a href="#四、-实验步骤、结果及分析" class="headerlink" title="四、 *实验步骤、结果及分析*"></a><strong>四、</strong> <em><strong>*实验步骤、结果及分析*</strong></em></h1><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="*实验步骤*"></a><em><strong>*实验步骤*</strong></em></h2><p><strong>1.</strong> <em><strong>*安装PYcharm后配置环境*</strong></em></p><p>在命令行安装<a href="https://pytorch.org/">PyTorch</a></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps28.jpg" alt="img"> </p><p>安装其他支持文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps29.jpg" alt="img"> </p><p><strong>2.</strong> <em><strong>*准备数据*</strong></em></p><p>在老师给的压缩包中已经包含了准备好的数据。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps30.jpg" alt="img"> </p><p><strong>3.</strong> <em><strong>*通过已有数据进行训练*</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py train --gpu --vis=False</span><br></pre></td></tr></table></figure><p>这个过程比较慢，可以尝试使用训练好的数据（已在压缩包中给出）</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps31.jpg" alt="img"> </p><p>或者选择自己跑数据训练</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps32.jpg" alt="img"><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps33.jpg" alt="img"> </p><p><strong>4.</strong> <em><strong>*训练完成后即可生成图片*</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py generate --nogpu --vis=False --netd-path=checkpoints/netd_200.pth --netg-path=checkpoints/netg_200.pth --gen-img=result.png --gen-num=64</span><br></pre></td></tr></table></figure><p>生成结果会储存在DCGAN文件夹下，可根据修改日期看出是新生成的图片。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps34.jpg" alt="img"> </p><p>生成结果如下</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps35.jpg" alt="img"> </p><p>第一个实验到此结束。</p><p><strong>5.</strong> <em><strong>*配置Deepfakes CNN-Detection实验环境*</strong></em></p><p>基本不用发生更改，在第一次配置时已经完成</p><p><strong>6.</strong> <em><strong>*尝试运行一张图片，并检测真假*</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python demo.py -f examples/real.png -m weights/blur_jpg_prob0.5.pth</span><br><span class="line"></span><br><span class="line">python demo.py -f examples/fake.png -m weights/blur_jpg_prob0.5.pth</span><br></pre></td></tr></table></figure><p>其中真照片运行结果如下</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps36.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps37.jpg" alt="img"> </p><p>其中假照片运行结果如下</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps38.jpg" alt="img"> </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps39.jpg" alt="img"> </p><p>尝试运行数据集检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python demo_dir.py -d examples/realfakedir -m weights/blur_jpg_prob0.5.pth</span><br></pre></td></tr></table></figure><p>尝试跑自己的数据集，效果并不好（已在后文中说明）</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps40.jpg" alt="img"> </p><p>跑老师给的数据集（airplane）</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps41.jpg" alt="img"> </p><ol start="7"><li>对数据集进行检测</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python eval.py --no_crop --batch_size 1</span><br></pre></td></tr></table></figure><p>实验二结束。</p><h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a><strong>实验结果及分析</strong></h2><ol><li>在实验一中进行多次实验，可以看出每次生成结果都不同。</li></ol><p>但仿真程度都不是很高</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps42.jpg" alt="img"> <img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps43.jpg" alt="img"> <img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps44.jpg" alt="img"></p><p>2.在实验二的单张检测中可以尝试对实验一的生成图片进行检测。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps45.jpg" alt="img"> </p><p>首先对总生成结果进行检测，由于其中元素较多识别出错，程旭认为其为真实图片。</p><p>但从中截取一幅生成图片进行检测，这次检测结果正确。</p><p>说明可以正确检验真伪。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps46.jpg" alt="img"> </p><p>3.使用另一种权重进行实验</p><p>对比实验可以看出二者之间的差别，0.1版本的准确度更高一些</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps47.jpg" alt="img"> </p><p>4.对数据集进行检验</p><p>老师给的数据集过大，因此在检测时选取了一个比对的数据集。</p><p>对airplane数据集进行测试，测试成功。准确率很高</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps48.jpg" alt="img"> </p><h1 id="五、-实验中遇到的问题及改正的方法"><a href="#五、-实验中遇到的问题及改正的方法" class="headerlink" title="五、 *实验中遇到的问题及改正的方法*"></a><strong>五、</strong> <em><strong>*实验中遇到的问题及改正的方法*</strong></em></h1><ol><li>在安装其他支持文件时经常安装失败，这里可以提供三种安装方法</li></ol><p>首先尝试直接使用命令pip install -r requirements.txt安装，如报连接失败错误可以尝试挂梯子再次链接。</p><p>其次可以尝试在Pycharm中单个添加。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps49.jpg" alt="img"> </p><p>如果上述方法都不可行，只能在官网或镜像站逐一下载，最后将其手动安装。</p><p>2.老师给的数据集过大，因此在检测时选取了一个deepfake人脸生成比对的数据集。</p><p>在测试前准备选取一真一假两张照片进行单张实验观察结果。由于deepfake技术效果比较好，比对结果显示为二者都为真的概率比较高。</p><p>这两张图片为：其中左图为真</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps50.png" alt="img">df0.jpg   <img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps51.png" alt="img">df1.jpg</p><p>进行检测的结果显示</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps52.jpg" alt="img"> </p><p>虽可以看出伪造成分，但无法证明右图为伪造图片。</p><p>其后更改算法权重为另一版本，效果略有升高。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps53.jpg" alt="img"> </p><p>但仍然达到不了50%以上，无法证明图片为伪造。</p>]]></content>
    
    
    <summary type="html">运行 WINDOWS 下的 GAN 图片生成系统、换脸检测系统；用换脸检测系统对实验数据集进行换脸检测实验</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>垃圾邮件过滤系统</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS3/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS3/</id>
    <published>2023-08-02T09:00:00.000Z</published>
    <updated>2023-08-02T09:57:46.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 *实验目的*"></a><strong>一、</strong> <em><strong>*实验目的*</strong></em></h1><p>（1） 掌握在 WINDOWS 下安装和使用垃圾邮件过滤系统 </p><p>（2） 掌握垃圾邮件过滤系统主要功能模块 </p><p>（3） 文本内容过滤的原理</p><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 *实验内容*"></a><strong>二、</strong> <em><strong>*实验内容*</strong></em></h1><p>（1） 分析并调试垃圾邮件过滤系统程序主要功能模块 </p><p>（2） 选取实验数据集 </p><p>（3） 运行 WINDOWS 下的垃圾邮件过滤系统 </p><p>（4） 用垃圾邮件过滤系统对实验数据集进行过滤实验</p><h1 id="三、-系统整体描述和分功能描述"><a href="#三、-系统整体描述和分功能描述" class="headerlink" title="三、 *系统整体描述和分功能描述*"></a><strong>三、</strong> <em><strong>*系统整体描述和分功能描述*</strong></em></h1><h2 id="系统整体描述"><a href="#系统整体描述" class="headerlink" title="*系统整体描述*"></a><em><strong>*系统整体描述*</strong></em></h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps54.jpg" alt="img"> </p><p>​    </p><h2 id="分功能描述"><a href="#分功能描述" class="headerlink" title="*分功能描述*"></a><em><strong>*分功能描述*</strong></em></h2><p>1）预测结果</p><p>首先要获得词典。如果列表中的词已在词典中，则加1，否则添加进去。通过计算每个文件中p(s|w)来得到对分类影响最大的15个词。随后计算贝叶斯概率，再计算预测结果正确率。</p><p>用到自定义函数</p><p>SpamEmailBayes()</p><p>2）计算贝叶斯概率</p><p> 计算在已知词向量$w&#x3D;(w_1,w_2,…,w_n)$的条件下求包含该词向量邮件是否为垃圾邮件的概率</p><p>用到的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calBayes</span>(<span class="params">self, wordList, spamdict, normdict</span>):</span><br><span class="line">  ps_w = <span class="number">1</span></span><br><span class="line">  ps_n = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> word, prob <span class="keyword">in</span> wordList.items():</span><br><span class="line">    <span class="built_in">print</span>(word + <span class="string">&quot;/&quot;</span> + <span class="built_in">str</span>(prob))</span><br><span class="line">    ps_w *= (prob)</span><br><span class="line">    ps_n *= (<span class="number">1</span> - prob)</span><br><span class="line">  p = ps_w / (ps_w + ps_n)</span><br><span class="line">  \<span class="comment">#     print(str(ps_w)+&quot;////&quot;+str(ps_n))</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><p>3）通过计算每个文件中p(s|w)来得到对分类影响最大的15个词</p><p>用到的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getTestWords</span>(<span class="params">self, testDict, spamDict, normDict, normFilelen, spamFilelen</span>):</span><br><span class="line">  wordProbList = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> word, num <span class="keyword">in</span> testDict.items():</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">in</span> spamDict.keys() <span class="keyword">and</span> word <span class="keyword">in</span> normDict.keys():</span><br><span class="line">      \<span class="comment"># 该文件中包含词个数</span></span><br><span class="line">      pw_s = spamDict[word] / spamFilelen</span><br><span class="line">      pw_n = normDict[word] / normFilelen</span><br><span class="line">      ps_w = pw_s / (pw_s + pw_n)</span><br><span class="line">      wordProbList.setdefault(word, ps_w)</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">in</span> spamDict.keys() <span class="keyword">and</span> word <span class="keyword">not</span> <span class="keyword">in</span> normDict.keys():</span><br><span class="line">      pw_s = spamDict[word] / spamFilelen</span><br><span class="line">      pw_n = <span class="number">0.01</span></span><br><span class="line">      ps_w = pw_s / (pw_s + pw_n)</span><br><span class="line">      wordProbList.setdefault(word, ps_w)</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> spamDict.keys() <span class="keyword">and</span> word <span class="keyword">in</span> normDict.keys():</span><br><span class="line">      pw_s = <span class="number">0.01</span></span><br><span class="line">      pw_n = normDict[word] / normFilelen</span><br><span class="line">      ps_w = pw_s / (pw_s + pw_n)</span><br><span class="line">      wordProbList.setdefault(word, ps_w)</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> spamDict.keys() <span class="keyword">and</span> word <span class="keyword">not</span> <span class="keyword">in</span> normDict.keys():</span><br><span class="line">      \<span class="comment"># 若该词不在脏词词典中，概率设为0.4</span></span><br><span class="line">      wordProbList.setdefault(word, <span class="number">0.4</span>)</span><br><span class="line">  <span class="built_in">sorted</span>(wordProbList.items(), key=<span class="keyword">lambda</span> d: d[<span class="number">1</span>], reverse=<span class="literal">True</span>)[<span class="number">0</span>:<span class="number">15</span>]</span><br><span class="line">  <span class="keyword">return</span> (wordProbList)</span><br></pre></td></tr></table></figure><h1 id="四、-实验步骤、结果及分析"><a href="#四、-实验步骤、结果及分析" class="headerlink" title="四、 *实验步骤、结果及分析*"></a><strong>四、</strong> <em><strong>*实验步骤、结果及分析*</strong></em></h1><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="*实验步骤*"></a><em><strong>*实验步骤*</strong></em></h2><p>1.配置相应实验环境</p><p>不报错即可</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps55.jpg" alt="img"> </p><p>2.运行成功</p><p>显示准确度为0.951530612244898</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps56.jpg" alt="img"> </p><p>实验结果及分析</p><p>运行后会返回关键词出现频率等信息</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps57.jpg" alt="img"> </p><p>最后返回本次运行的准确率</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps58.jpg" alt="img"> </p><h1 id="五、-实验中遇到的问题及改正的方法"><a href="#五、-实验中遇到的问题及改正的方法" class="headerlink" title="五、 *实验中遇到的问题及改正的方法*"></a><strong>五、</strong> <em><strong>*实验中遇到的问题及改正的方法*</strong></em></h1><p>本次实验未遇到操作问题</p>]]></content>
    
    
    <summary type="html">了解文本内容过滤的原理，在 WINDOWS 下安装和使用垃圾邮件过滤系统</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>图像差分隐私保护方案实验</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS4/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS4/</id>
    <published>2023-08-02T09:00:00.000Z</published>
    <updated>2023-08-02T10:02:27.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 *实验目的*"></a><strong>一、</strong> <em><strong>*实验目的*</strong></em></h1><p>了解差分隐私技术的基本特点，设计并实现基于离散傅立叶变换（DFT）的图像差分隐私保护算法。了解差分隐私技术在数字内容保护中的作用，掌握基于差分隐私的内容隐私保护方法。</p><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 *实验内容*"></a><strong>二、</strong> <em><strong>*实验内容*</strong></em></h1><p>本实验实现一种基于离散傅立叶变换的图像差分隐私保护算法，可通过隐私预算控制噪声规模，保证隐私安全性，具体过程如下：</p><ol><li>读入一幅图像，对图像做预处理：如果读入的是彩色图像，将其转换为灰度图像（rgb2gray）；在灰度图像中利用差值方式将图像重采样为128*128的标准化图表示（imresize）IM；</li><li>对标准化图像IM进行离散傅立叶变换，得到离散傅立叶变换矩阵FIM；</li><li>对离散傅立叶变换矩阵FIM，选取其前k×k个DFT系数，计算给定隐私预算<code>ε</code>时的拉普拉斯机制的参数<code>λ</code>的最小值，以确定拉普拉斯机制需要添加的噪声；</li><li>对离散傅立叶变换矩阵FIM，采样一组概率p，在参数<code>λ</code>最小时，计算相应的噪声值，以及融合噪声后的FIM’；</li><li>对于FIM和FIM’，分别输入PCA+SVM的人脸识别程序中进行人脸识别分类预测。</li><li>给出整个数据集上，人脸识别分类预测的准确率(Accuracy，测试集中分类器正确分类的样本数与总样本数之比)。</li><li>以LFW中随机80%的图片为训练集，剩余为测试集，分析实验结果。</li><li>关于实验报告</li></ol><p>（1）关于<code>ε</code>的选取，是一个经验值，其选取依据是根据测试集的准确率决定，给出选取过程。</p><p>（2）关于k的选取，k值越大噪声越大,隐私安全性越强，但对人脸识别任务的鲁棒性会降低,因而需设定合适的k值，以满足隐私保护的人脸图像在识别精度和隐私性之间的折衷，给出选取过程。</p><h1 id="三、-系统整体描述和分功能描述"><a href="#三、-系统整体描述和分功能描述" class="headerlink" title="三、 *系统整体描述和分功能描述*"></a><strong>三、</strong> <em><strong>*系统整体描述和分功能描述*</strong></em></h1><h2 id="系统整体描述"><a href="#系统整体描述" class="headerlink" title="*系统整体描述*"></a><em><strong>*系统整体描述*</strong></em></h2><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps63.jpg" alt="img"> </p><p>​    </p><h2 id="分功能描述"><a href="#分功能描述" class="headerlink" title="*分功能描述*"></a><em><strong>*分功能描述*</strong></em></h2><p>1）图像做预处理</p><p>如果是彩色图像，转换为灰度图像</p><p>将图像重采样为128×128的标准化图像</p><p>用到的函数：def preprocess_image(image)</p><p>2）对图像做离散傅立叶变换</p><p>对图像做离散傅立叶变换，并将结果移动到中心</p><p>选取中心的k×k个系数，并返回它们的幅度和相位</p><p>用到的函数：def dft_image(image)</p><p>3）生成一个服从标准均匀分布的随机数组</p><p>根据拉普拉斯分布的逆变换公式，计算噪声值</p><p>用到的函数：def laplace_noise(shape, b)</p><p>4）对离散傅立叶变换的系数添加拉普拉斯噪声，并还原图像</p><p>根据给定的隐私预算，计算拉普拉斯机制的参数b的最小值</p><p>采样一组概率p，决定是否添加噪声</p><p>计算相应的噪声值，并添加到幅度上</p><p>将幅度和相位合并为复数矩阵</p><p>进行逆离散傅立叶变换</p><p>取实部作为还原后的图像</p><p>用到的函数：def idft_image(magnitude_k, phase_k)</p><p>5）读取数据集中的图像，并返回一个列表和一个标签数组</p><p>遍历数据集中的每个文件夹，每个文件夹代表一个类别</p><p>将文件夹的名字转换为整数作为标签遍历每个文件夹中的每个图像文件</p><p>对图像做预处理</p><p>将图像添加到列表中</p><p>将标签添加到数组中</p><p>用到的函数：def read_dataset(path)</p><p>6）将图像列表转换为特征矩阵，并返回一个训练集和一个测试集</p><p> 将图像列表转换为特征矩阵，每个图像的DFT系数作为一行</p><p>将幅度矩阵展平为一维数组</p><p>利用sklearn的train_test_split函数，按照给定的比例划分训练集和测试集</p><p>用到的函数：def split_dataset(images, labels, test_ratio&#x3D;0.2)</p><p>7）利用PCA和SVM进行人脸识别，并返回准确率</p><p>利用sklearn的PCA模块，对特征矩阵进行降维，保留95%的方差</p><p>利用sklearn的SVM模块，对降维后的特征进行分类，使用线性核函数和默认参数 </p><p>利用sklearn的metrics模块，计算分类的准确率</p><p>用到的函数：def face_recognition(X_train, X_test, y_train, y_test)</p><h1 id="四、-实验步骤、结果及分析"><a href="#四、-实验步骤、结果及分析" class="headerlink" title="四、 *实验步骤、结果及分析*"></a><strong>四、</strong> <em><strong>*实验步骤、结果及分析*</strong></em></h1><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="*实验步骤*"></a><em><strong>*实验步骤*</strong></em></h2><ol><li>下载win10虚拟机</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps64.jpg" alt="img"> </p><ol start="2"><li>开机后安装conda</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps65.jpg" alt="img"> </p><p>Conda安装好后检查版本</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps66.jpg" alt="img"> </p><p>配置好conda和pycharm</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps67.jpg" alt="img"> </p><p>因为环境配置出现了一些问题，没有使用已给的检测模型，自己进行编写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一些常量</span></span><br><span class="line">k = <span class="number">10</span> <span class="comment"># 选取前k×k个DFT系数</span></span><br><span class="line">p = <span class="number">0.5</span> <span class="comment"># 采样概率</span></span><br><span class="line">epsilon = <span class="number">0.1</span> <span class="comment"># 隐私预算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，对图像做预处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess_image</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 如果是彩色图像，转换为灰度图像</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(image.shape) == <span class="number">3</span>:</span><br><span class="line">        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 将图像重采样为128×128的标准化图像</span></span><br><span class="line">    image = cv2.resize(image, (<span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，对图像做离散傅立叶变换，并选取前k×k个系数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dft_image</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 对图像做离散傅立叶变换，并将结果移动到中心</span></span><br><span class="line">    f = np.fft.fft2(image)</span><br><span class="line">    fshift = np.fft.fftshift(f)</span><br><span class="line">    <span class="comment"># 选取中心的k×k个系数，并返回它们的幅度和相位</span></span><br><span class="line">    rows, cols = fshift.shape</span><br><span class="line">    crow, ccol = rows//<span class="number">2</span>, cols//<span class="number">2</span></span><br><span class="line">    fshift_k = fshift[crow-k//<span class="number">2</span>:crow+k//<span class="number">2</span>, ccol-k//<span class="number">2</span>:ccol+k//<span class="number">2</span>]</span><br><span class="line">    magnitude_k = np.<span class="built_in">abs</span>(fshift_k)</span><br><span class="line">    phase_k = np.angle(fshift_k)</span><br><span class="line">    <span class="keyword">return</span> magnitude_k, phase_k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义laplace_noise函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">laplace_noise</span>(<span class="params">shape, b</span>):</span><br><span class="line">    <span class="comment"># 生成一个服从标准均匀分布的随机数组</span></span><br><span class="line">    u = np.random.uniform(-<span class="number">0.5</span>, <span class="number">0.5</span>, size=shape)</span><br><span class="line">    <span class="comment"># 根据拉普拉斯分布的逆变换公式，计算噪声值</span></span><br><span class="line">    noise = -b * np.sign(u) * np.log(<span class="number">1</span> - <span class="number">2</span> * np.<span class="built_in">abs</span>(u))</span><br><span class="line">    <span class="keyword">return</span> noise</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，对离散傅立叶变换的系数添加拉普拉斯噪声，并还原图像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">idft_image</span>(<span class="params">magnitude_k, phase_k</span>):</span><br><span class="line">    <span class="comment"># 根据给定的隐私预算，计算拉普拉斯机制的参数b的最小值</span></span><br><span class="line">    b_min = magnitude_k.size / epsilon</span><br><span class="line">    <span class="comment"># 采样一组概率p，决定是否添加噪声</span></span><br><span class="line">    mask = np.random.binomial(<span class="number">1</span>, p, size=magnitude_k.shape)</span><br><span class="line">    <span class="comment"># 计算相应的噪声值，并添加到幅度上</span></span><br><span class="line">    noise = np.random.laplace(<span class="number">0</span>, b_min, size=magnitude_k.shape)</span><br><span class="line">    magnitude_k_noisy = magnitude_k + mask * noise</span><br><span class="line">    <span class="comment"># 将幅度和相位合并为复数矩阵</span></span><br><span class="line">    complex_k_noisy = magnitude_k_noisy * np.exp(<span class="number">1j</span> * phase_k)</span><br><span class="line">    <span class="comment"># 进行逆离散傅立叶变换</span></span><br><span class="line">    image_noisy = np.fft.ifft2(complex_k_noisy)</span><br><span class="line">    <span class="comment"># 取实部作为还原后的图像</span></span><br><span class="line">    image_noisy = np.real(image_noisy)</span><br><span class="line">    <span class="keyword">return</span> image_noisy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，读取数据集中的图像，并返回一个列表和一个标签数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_dataset</span>(<span class="params">path</span>):</span><br><span class="line">    images = [] <span class="comment"># 存储图像的列表</span></span><br><span class="line">    labels = [] <span class="comment"># 存储标签的数组</span></span><br><span class="line">    <span class="keyword">for</span> folder <span class="keyword">in</span> os.listdir(path): <span class="comment"># 遍历数据集中的每个文件夹，每个文件夹代表一个类别</span></span><br><span class="line">        label = <span class="built_in">int</span>(folder) <span class="comment"># 将文件夹的名字转换为整数作为标签</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(os.path.join(path, folder)): <span class="comment"># 遍历每个文件夹中的每个图像文件</span></span><br><span class="line">            image = cv2.imread(os.path.join(path, folder, file)) <span class="comment"># 读取图像文件</span></span><br><span class="line">            image = preprocess_image(image) <span class="comment"># 对图像做预处理</span></span><br><span class="line">            images.append(image) <span class="comment"># 将图像添加到列表中</span></span><br><span class="line">            labels.append(label) <span class="comment"># 将标签添加到数组中</span></span><br><span class="line">    <span class="keyword">return</span> images, np.array(labels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，将图像列表转换为特征矩阵，并返回一个训练集和一个测试集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_dataset</span>(<span class="params">images, labels, test_ratio=<span class="number">0.2</span></span>):</span><br><span class="line">    <span class="comment"># 将图像列表转换为特征矩阵，每个图像的DFT系数作为一行</span></span><br><span class="line">    features = []</span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> images:</span><br><span class="line">        magnitude_k, phase_k = dft_image(image)</span><br><span class="line">        feature = magnitude_k.flatten() <span class="comment"># 将幅度矩阵展平为一维数组</span></span><br><span class="line">        features.append(feature)</span><br><span class="line">    features = np.array(features)</span><br><span class="line">    <span class="comment"># 利用sklearn的train_test_split函数，按照给定的比例划分训练集和测试集</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=test_ratio, random_state=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, X_test, y_train, y_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，利用PCA和SVM进行人脸识别，并返回准确率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">face_recognition</span>(<span class="params">X_train, X_test, y_train, y_test</span>):</span><br><span class="line">    <span class="comment"># 利用sklearn的PCA模块，对特征矩阵进行降维，保留95%的方差</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">    pca = PCA(n_components=<span class="number">0.95</span>)</span><br><span class="line">    pca.fit(X_train)</span><br><span class="line">    X_train_pca = pca.transform(X_train)</span><br><span class="line">    X_test_pca = pca.transform(X_test)</span><br><span class="line">    <span class="comment"># 利用sklearn的SVM模块，对降维后的特征进行分类，使用线性核函数和默认参数</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">    svm = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">    svm.fit(X_train_pca, y_train)</span><br><span class="line">    y_pred = svm.predict(X_test_pca)</span><br><span class="line">    <span class="comment"># 利用sklearn的metrics模块，计算分类的准确率</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line">    accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line">    <span class="keyword">return</span> accuracy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取数据集中的图像和标签</span></span><br><span class="line">    images = []</span><br><span class="line">    labels = []</span><br><span class="line"></span><br><span class="line">    dataset_path = <span class="string">r&#x27;C:\data\study\second_done\number_safe\exercise4\lfwp\Abel_Pacheco&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(dataset_path):</span><br><span class="line">        image_path = os.path.join(dataset_path, filename)</span><br><span class="line">        label = filename.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 使用文件名作为图像标签</span></span><br><span class="line">        image = cv2.imread(image_path)  <span class="comment"># 读取图像</span></span><br><span class="line">        images.append(image)</span><br><span class="line">        labels.append(label)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分训练集和测试集，按照80%和20%的比例</span></span><br><span class="line">    X_train, X_test, y_train, y_test = split_dataset(images, labels, test_ratio=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对测试集中的每个图像，添加拉普拉斯噪声，并还原为图像</span></span><br><span class="line">    images_noisy = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_test)):</span><br><span class="line">        image = X_test[i]  <span class="comment"># 原始图像</span></span><br><span class="line">        magnitude_k, phase_k = dft_image(image)  <span class="comment"># DFT系数</span></span><br><span class="line">        image_noisy = idft_image(magnitude_k, phase_k)  <span class="comment"># 带噪声的图像</span></span><br><span class="line">        images_noisy.append(image_noisy)</span><br><span class="line">    images_noisy = np.array(images_noisy)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分训练集和测试集，使用带噪声的图像作为测试集，按照80%和20%的比例</span></span><br><span class="line">    X_train_noisy, X_test_noisy, y_train_noisy, y_test_noisy = split_dataset(images_noisy, labels, test_ratio=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行人脸识别，分别使用原始图像和带噪声的图像，并打印准确率</span></span><br><span class="line">    accuracy_original = face_recognition(X_train, X_test, y_train, y_test)</span><br><span class="line">    accuracy_noisy = face_recognition(X_train_noisy, X_test_noisy, y_train_noisy, y_test_noisy)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;人脸识别分类预测的准确率为:&#123;:.2f&#125;%&#x27;</span>.<span class="built_in">format</span>(accuracy_original * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 读取数据集中的图像和标签</span></span><br><span class="line">    <span class="comment"># images, labels = read_dataset(&#x27;dataset&#x27;)</span></span><br><span class="line">    <span class="comment"># # 划分训练集和测试集，按照80%和20%的比例</span></span><br><span class="line">    <span class="comment"># X_train, X_test, y_train, y_test = split_dataset(images, labels, test_ratio=0.2)</span></span><br><span class="line">    <span class="comment"># # 对测试集中的每个图像，添加拉普拉斯噪声，并还原为图像</span></span><br><span class="line">    <span class="comment"># images_noisy = []</span></span><br><span class="line">    <span class="comment"># for i in range(len(X_test)):</span></span><br><span class="line">    <span class="comment">#     image = images[i] # 原始图像</span></span><br><span class="line">    <span class="comment">#     magnitude_k, phase_k = dft_image(image) # DFT系数</span></span><br><span class="line">    <span class="comment">#     image_noisy = idft_image(magnitude_k, phase_k) # 带噪声的图像</span></span><br><span class="line">    <span class="comment">#     images_noisy.append(image_noisy)</span></span><br><span class="line">    <span class="comment"># images_noisy = np.array(images_noisy)</span></span><br><span class="line">    <span class="comment"># # 划分训练集和测试集，使用带噪声的图像作为测试集，按照80%和20%的比例</span></span><br><span class="line">    <span class="comment"># X_train_noisy, X_test_noisy, y_train_noisy, y_test_noisy = split_dataset(images_noisy, labels, test_ratio=0.2)</span></span><br><span class="line">    <span class="comment"># # 进行人脸识别，分别使用原始图像和带噪声的图像，并打印准确率</span></span><br><span class="line">    <span class="comment"># accuracy_original = face_recognition(X_train, X_test, y_train, y_test)</span></span><br><span class="line">    <span class="comment"># accuracy_noisy = face_recognition(X_train_noisy, X_test_noisy, y_train_noisy, y_test_noisy)</span></span><br><span class="line">    <span class="comment"># print(&#x27;原始图像的人脸识别准确率为：&#123;:.2f&#125;%&#x27;.format)</span></span><br></pre></td></tr></table></figure><h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a><strong>实验结果及分析</strong></h2><p>对检测图片集进行运行</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps68.jpg" alt="img"> </p><p>运行一段时间后反馈运行结果</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps69.jpg" alt="img"> </p><p>可以看见反馈结果精准</p>]]></content>
    
    
    <summary type="html">设计并实现基于离散傅立叶变换（DFT）的图像差分隐私保护算法。</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>面向内容保护的区块链系统实验</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS5/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/digital_content_security/DCS5/</id>
    <published>2023-08-02T09:00:00.000Z</published>
    <updated>2023-08-02T10:50:35.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 *实验目的*"></a><strong>一、</strong> <em><strong>*实验目的*</strong></em></h1><p>（1） 掌握在Linux下安装和使用版权保护区块链系统</p><p>（2） 掌握版权保护区块链系统主要功能模块</p><p>（3） 区块链的原理</p><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 *实验内容*"></a><strong>二、</strong> <em><strong>*实验内容*</strong></em></h1><p>（1） 分析并调试版权保护区块链系统程序主要功能模块</p><p>（2） 选取测试实验数据（txt文本、mp3音频、jpg图像）</p><p>（3） 运行Linux下的版权保护区块链系统</p><p>（4） 用版权保护区块链系统对实验测试数据提取版权信息进行不重复的上链。</p><h1 id="三、-系统整体描述和分功能描述"><a href="#三、-系统整体描述和分功能描述" class="headerlink" title="三、 *系统整体描述和分功能描述*"></a><strong>三、</strong> <em><strong>*系统整体描述和分功能描述*</strong></em></h1><h2 id="系统整体描述"><a href="#系统整体描述" class="headerlink" title="*系统整体描述*"></a><em><strong>*系统整体描述*</strong></em></h2><p>BitRights系统实现了基于区块链的数字版权保护概念验证。用户上传媒体文件，并永久声明其作品的所有权。网络上的任何人都可以查看已发表的作品并验证作者的正确性。此外，系统会检测上传作品与已发表作品是否过于相似，并进行禁止。目前支持音频、图像和文本文件。</p><p>每当用户上传文件时，一个新的区块就会被添加到区块链中。该块包含作品的标题、作者、下载文件的路径&#x2F;链接、文件的哈希值、作者的公钥、时间戳和前一个块的哈希值。其中使用文件的散列而不是原始数据来保持块大小较小。同时其中包含的公钥可以使作者知道相应的密钥，从而证明所有权。与任何区块链一样，前一个区块的哈希值允许用户验证该链是否未被篡改。</p><p>​    </p><h2 id="分功能描述"><a href="#分功能描述" class="headerlink" title="*分功能描述*"></a><em><strong>*分功能描述*</strong></em></h2><p>1）Blockchain上链</p><p>用来实现整个系统中所有交易数据的网络的概念。包含了一系列方法和属性，用于管理和操作区块链。该类可以包括创建新的区块、添加交易数据到区块链、验证区块的有效性、搜索特定的交易等功能。</p><p>2）verify_block(self, block)</p><p>这段代码通过迭代self.chain中的每个块来验证新块block的原创性。它首先检查新块和每个先前块的genre是否相同。然后，根据genre的类型执行相应的检查。</p><p>如果genre为Audio，则调用ac.calc_accuracy函数计算新块和先前块音频文件的相似度得分score。如果相似度得分大于0.9，表示新块的音频文件与先前块的音频文件相似度过高，返回0表示验证失败。</p><p>如果genre为Text，则调用tc.check_text_similarity函数检查新块和先前块文本文件的相似度得分score。如果相似度得分小于100，表示新块的文本文件与先前块的文本文件相似度过低，返回0表示验证失败。</p><p>如果genre为Image，则调用ic.calc_accuracy函数计算新块和先前块图像文件的相似度得分score。如果相似度得分小于0.4，表示新块的图像文件与先前块的图像文件相似度过低，返回0表示验证失败。</p><p>3）lookup(self, transaction)</p><p>这段代码通过迭代 self.chain 中的每个块来查找与给定交易数据 transaction 相关的先前块。它首先检查每个先前块的 genre 是否与给定交易的 genre 相同。然后，根据 genre 的类型执行相应的检查。</p><p>如果 genre 为 Audio，则调用 ac.calc_accuracy 函数计算给定交易的音频文件与先前块音频文件之间的相似度得分 score。如果相似度得分大于0.9，表示给定交易的音频文件与先前块的音频文件相似度过高，直接返回该先前块。</p><p>如果 genre 为 Text，则调用 tc.check_text_similarity 函数检查给定交易的文本文件与先前块文本文件之间的相似度得分 score。如果相似度得分小于100，表示给定交易的文本文件与先前块的文本文件相似度过低，直接返回该先前块。</p><p>如果 genre 为 Image，则调用 ic.calc_accuracy 函数计算给定交易的图像文件与先前块图像文件之间的相似度得分 score。如果相似度得分小于0.4，表示给定交易的图像文件与先前块的图像文件相似度过低，直接返回该先前块。</p><p>4）upload()</p><p>检查请求中是否包含名为 contentFile 的文件。如果没有该文件，返回一个带有错误信息的 JSON 响应。</p><p>接下来从请求中获取 contentFile 文件，并将其存储在变量 file 中。</p><p>根据请求中的 action 值进行不同的操作。如果 action 是 “lookup”，表示进行查找操作。它将上传的文件保存在临时文件夹中，并构建一个包含了文件的信息的字典 lookup_media。然后，调用 blockchain.lookup 方法来查找与该文件相关的先前块。如果找不到匹配的先前块，响应中的 unique 属性将为 True，表示该文件是唯一的。如果找到了匹配的先前块，响应中的 unique 属性将为 False，同时返回匹配的块信息和一条附加消息。</p><p>如果 action 是 “publish”，表示进行发布操作，即将文件添加到区块链中。</p><p>如果 action 不是 “lookup” 也不是 “publish”，则默认将文件保存到上传文件夹中。</p><p>最后，根据不同的响应结果，使用 jsonify 方法将响应转换为 JSON 格式，并返回 HTTP 状态码 200 表示成功。</p><h1 id="四、-实验步骤、结果及分析"><a href="#四、-实验步骤、结果及分析" class="headerlink" title="四、 *实验步骤、结果及分析*"></a><strong>四、</strong> <em><strong>*实验步骤、结果及分析*</strong></em></h1><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="*实验步骤*"></a><em><strong>*实验步骤*</strong></em></h2><ol><li>打开kali虚拟机</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps70.jpg" alt="img"> </p><ol start="2"><li>检查python版本号</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps71.jpg" alt="img"> </p><ol start="3"><li>sh文件内容运行失败，选择手动运行</li></ol><p>下载virtualenv</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps72.jpg" alt="img"> </p><p>再次运行install.sh</p><p>下载还是失败，挂一下清华源</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps73.jpg" alt="img"> </p><p>再次尝试，下载的很快</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps74.jpg" alt="img"> </p><p>但python版本不对，和软件包不兼容。</p><p>改用Anaconda，放弃编译环境了。</p><p>安装Anaconda</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps75.jpg" alt="img"> </p><p>安装完成</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps76.jpg" alt="img"> </p><p>随后再环境中安装软件包。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps77.jpg" alt="img"> </p><p>4.安装差不多了，仍然有安不上的</p><p>先运行一下程序试试</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps78.jpg" alt="img"><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps79.jpg" alt="img"> </p><p>安装报错所需要的文件包</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps80.jpg" alt="img"><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps81.jpg" alt="img"> </p><p>对于较为麻烦的image-match选择直接从github下载源文件安装</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps82.jpg" alt="img"> </p><p>5.程序运行成功</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps83.jpg" alt="img"> </p><p>可以打开网页界面</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps84.jpg" alt="img"> </p><p>但后续发现需要使用gpg生成密钥</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps85.jpg" alt="img"> </p><p>6.再去安装gpg</p><p>升级apt</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps86.jpg" alt="img"> </p><p>安装gog后生成密钥</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps87.jpg" alt="img"> </p><p>设置密码12345678</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps88.jpg" alt="img"> </p><p>证书生成完毕</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps89.jpg" alt="img"> </p><p>输入密钥</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps90.jpg" alt="img"> </p><p>上传成功</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps91.jpg" alt="img"> </p><h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a><strong>实验结果及分析</strong></h2><p>1.在实验过程基础上又上传了一个mp3文件</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps92.jpg" alt="img"> </p><p>此时可以在uploads文件夹下看见上传的文件</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps93.jpg" alt="img"> </p><p>通过view Blochain也可以看见上传的文件</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps94.jpg" alt="img"> </p><p>2.此时在上传一张蒙娜丽莎</p><p>先通过lookup检测，可以看见没有相似文件</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps95.jpg" alt="img"> </p><p>在进行上传</p><p>3.在尝试上传蒙娜丽莎2</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps96.jpg" alt="img"> </p><p>检测会报错，说已有相似图片。说明功能成功</p><p>（显示有点问题）已有功能图片显示在这里</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps97.jpg" alt="img"> </p><p>4.以上过程说明实验成功</p><p>证明了用版权保护区块链系统可以对实验测试数据实现提取版权信息进行不重复的上链。</p><h1 id="五、-实验中遇到的问题及改正的方法"><a href="#五、-实验中遇到的问题及改正的方法" class="headerlink" title="五、 *实验中遇到的问题及改正的方法*"></a><strong>五、</strong> <em><strong>*实验中遇到的问题及改正的方法*</strong></em></h1><ol><li>下载sh中文件会出错</li></ol><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps98.jpg" alt="img"> </p><p>可以手动运行一步步下载。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps99.jpg" alt="img"> </p><p>2.安装时报错</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps100.jpg" alt="img"> </p><p>读代码知道要先按numpy 1.16.3,直接上清华源</p><p>pip install -U numpy&#x3D;&#x3D;1.16.3 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps101.jpg" alt="img"> </p><p>还是报错，选择用pycharm解决</p><p>安装pycharm</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps102.jpg" alt="img"> </p><p>重新配置了一下环境，再安装软件包</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps103.jpg" alt="img"> </p><ol start="2"><li>配置环境需要python3.6的版本</li></ol><p>需要重新安装python再配置环境</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps104.jpg" alt="img"> </p><p>3.升级apt的时候报错</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps105.jpg" alt="img"> </p><p>需要安装</p><p>apt install binutils</p>]]></content>
    
    
    <summary type="html">掌握在Linux下安装和使用版权保护区块链系统,并调用版权保护区块链系统主要功能模块</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字内容安全实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>工厂原料分配问题</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/mathematics_modeling/MM2/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/mathematics_modeling/MM2/</id>
    <published>2023-08-02T08:00:00.000Z</published>
    <updated>2023-08-02T09:35:37.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>某工厂需要利用三种原材料（分别记为1、2、3）混合调配出三种不同的产品（甲、乙、丙）。具体材料要求及产品利润如下表所示。请建立数学模型，为该厂安排生产规划，使其利润最大。</p></blockquote><p><img src="D:\my_data\blog\zyhblog-img\image-20230802173413762.png" alt="image-20230802173413762"></p><h2 id="1-具体变量说明；"><a href="#1-具体变量说明；" class="headerlink" title="1.具体变量说明；"></a>1.具体变量说明；</h2><p>Xij为i原材料向j产品提供的数量，i&#x3D;1,2,3为三个验材料名称，j&#x3D;1,2,3分别为甲乙丙三个产品。</p><h1 id="2-具体优化模型建立过程；"><a href="#2-具体优化模型建立过程；" class="headerlink" title="2.具体优化模型建立过程；"></a>2.具体优化模型建立过程；</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAX=-15*x11-30*x12-40*x13+25*x21+10*x22+15*x31-10*x33</span><br><span class="line">x11+x12+x13&lt;=100</span><br><span class="line">x21+x22+x23&lt;=100</span><br><span class="line">x31+x32+x33&lt;=60</span><br><span class="line">-X11+x21+x31&lt;0</span><br><span class="line">-x11+3*x21-x31&lt;0</span><br><span class="line">-3*X12+x22+x32&lt;0</span><br><span class="line">-x12+x22-x32&lt;0</span><br></pre></td></tr></table></figure><h1 id="3-打印相应程序代码；"><a href="#3-打印相应程序代码；" class="headerlink" title="3.打印相应程序代码；"></a>3.打印相应程序代码；</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">C= [15 30 40 -25 -10 0 -15 0 10];</span><br><span class="line">A= [-1 0 0 1 0 0 1 0 0;-1 0 0 3 0 0 -1 0 0;</span><br><span class="line">  0 -3 0 0 1 0 0 1 0;0 -1 0 0 1 0 0 -1 0;</span><br><span class="line">  1 1 1 0 0 0 0 0 0;0 0 0 1 1 1 0 0 0;</span><br><span class="line">  0 0 0 0 0 0 1 1 1];</span><br><span class="line">b= [0;0;0;0;100;100;60];</span><br><span class="line">Aeq= [];</span><br><span class="line">beq= [];</span><br><span class="line">LB= zeros(9,1);</span><br><span class="line">UB= [];</span><br><span class="line">[x,fval]= linprog(C,A,b,Aeq,beq,LB,UB);</span><br></pre></td></tr></table></figure><h1 id="4-给出模型结果，并对应返回问题给出问题的解答。"><a href="#4-给出模型结果，并对应返回问题给出问题的解答。" class="headerlink" title="4.给出模型结果，并对应返回问题给出问题的解答。"></a>4.给出模型结果，并对应返回问题给出问题的解答。</h1><p>结果x&#x3D;[100;0;0;50;0;0;50;0;0]   fval&#x3D;-500</p><p>生产的三种原材料全部供给到产品甲获利最多，比例为2:1:1，获利500元。</p>]]></content>
    
    
    <summary type="html">某工厂需原料混合调配三种产品）。建立数学模型，为该厂安排生产规划，使其利润最大。</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数学建模实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数学建模实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>建立SIR模型预测疫情走势</title>
    <link href="https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/mathematics_modeling/MM1/"/>
    <id>https://zhangyuanhe.top/2023/08/02/Information_Security_Experiment/mathematics_modeling/MM1/</id>
    <published>2023-08-02T07:00:00.000Z</published>
    <updated>2023-08-02T09:29:11.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>近年来，各种全新的传染病层出不穷，还有许多曾经被人类消灭和控制住的传染病也发生变异，再次出现在人们的视野中。这些流行病、传染病对我们造成的袭击事件时有出现，且都造成了程度不一的社会影响。现如今我们正面临着严峻的传染病威胁，在这种情况下如何最大限度的控制疫情，研究疫情走势，从而进行经济和民生调控，降低疫情对人们生活的影响，成为了一个十分重要的课题。流行病学模型分析正是对这一问题的主要解决方案，他可以有效对疫情形势走势进行预测，并提供有利的健康策略和科学措施。</p><p>在长期的科学研究中，人们在对传染病模型的研究中以微分方程为基本研究工具基于不同的假设发展出了SI, SIS和SIR模型等较为成熟的理论,这些理论都有助于我们对流行病学发展进行深入分析，从而预测出更为科学的结论。</p><p>在此，本文便对一些科学分析模型进行了研究与实践，并对主要的SIR模型加以深化，观察其预测结果并得出一系列结论。</p><h2 id="1-模型的建立"><a href="#1-模型的建立" class="headerlink" title="1 模型的建立"></a><strong>1 模型的建立</strong></h2><h3 id="1-1-基本假设"><a href="#1-1-基本假设" class="headerlink" title="1.1 基本假设"></a>1.1 <strong>基本假设</strong></h3><p>在疾病传染期内考察地区的总人数不变, 记为N。</p><p>人群分为：</p><p>S为易感者 (Susceptible)，指未得病者，但缺乏免疫能力，容易受到感染的人群；</p><p>E为暴露者 (Exposed)，指接触过感染者，但暂时无传播能力，处于潜伏期的人群；</p><p>I为感染者 (Infective)，指染上传染病的患者，可以传播给 S 类成员；</p><p>R为免疫者 (Recovered)，指具有一定强度免疫力的人，不会因接触I类成员而感染。</p><h3 id="1-2-常用模型"><a href="#1-2-常用模型" class="headerlink" title="1.2 常用模型"></a>1.2 <strong>常用模型</strong></h3><p>1）SI模型</p><p>SI模型只考虑易感者和感染者，易感者会因接触不断被感染。</p><p>其微分方程为：</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps1-1690963839564-4.jpg" alt="img"> </p><p>其中<img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps2-1690963839564-2.jpg" alt="img">为感染率。</p><p>2）SIS模型 </p><p>该模型依然只考虑易感者和感染者，感染者得到治疗后会恢复成易感者，且恢复后依然可能得病。</p><p>其微分方程为：</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps3-1690963839564-3.jpg" alt="img"> </p><p>其中<img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps4-1690963839564-1.jpg" alt="img">为感染率，<img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps5-1690963839564-5.jpg" alt="img">为治愈率。</p><p>3）SIR模型</p><p>该模型最为常见且普遍。考虑易感者、感染者与康复者，其中感染者接受治疗成为康复者，康复者因为得到抗体不会再成为易感者。</p><p>其微分方程为：</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps6-1690963839566-6.jpg" alt="img"> </p><p>其中<img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps7-1690963839566-9.jpg" alt="img">为感染率，<img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps8-1690963839566-10.jpg" alt="img">为治愈率。</p><p>4）SIRS模型</p><p>该模型考虑易感者、感染者与康复者，其中康复者获得抗体能够抵抗一段时间，长时间后抗体浓度下降会成为易感者。</p><p>其微分方程为：</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps9-1690963839566-7.jpg" alt="img"> </p><p>其中<img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps10-1690963839566-11.jpg" alt="img">为感染率，<img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps11-1690963839566-8.jpg" alt="img">为治愈率，<img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps12-1690963839566-12.jpg" alt="img">为复感率。</p><p>5）SEIR模型</p><p>该模型考虑易感者、潜伏者、感染者与康复者，其中易感人群感染后会经历一段时间潜伏期才会爆发。</p><h3 id="1-3-模型实现"><a href="#1-3-模型实现" class="headerlink" title="1.3 模型实现"></a>1.3 <strong>模型实现</strong></h3><p>对上述四种模型进行评估测试，都以0.1%感染率作为起始数据，初始治愈率设定为0.02%。在统一标准下进行数据测试。</p><p>SI模型</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps13-1690963839566-13.jpg" alt="img"> </p><p>SI模型运行结果为所有人都被感染。</p><p>SIS模型</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps14-1690963839566-14.jpg" alt="img"> </p><p>该模型最后感染人口和健康人口趋于平衡，达到动态平衡。</p><p>SIR模型</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps15-1690963839566-18.jpg" alt="img"> </p><p>通过波动调整，最后达到群体免疫。</p><p>SIRS模型</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps16-1690963839566-17.jpg" alt="img"> </p><p>波动后，最后达到动态平衡。</p><h3 id="1-4模型总结"><a href="#1-4模型总结" class="headerlink" title="1.4模型总结"></a><strong>1.4模型总结</strong></h3><p>通过对四种模型进行对比，可以看出SIR模型对现阶段突发性疫情有最准确的拟合效果。可以更加真实的反映出传染病疫情的发展趋势。</p><p>相比于SI模型，SIR模型能够更好地考虑康复因素，即感染者在一段时间后可能康复并具有免疫力，这使得SIR模型更能够准确地描述真实的疾病传播情况。</p><p>相比于SIS模型，SIR模型考虑了康复因素，这使得SIR模型能够更好地描述疾病在人群中的传播和扩散，特别是在长期时间尺度上。而SIS模型则认为感染者没有获得免疫力，因此该模型更适用于描述一些短暂的疾病流行。</p><p>相比于SIRS模型，SIR模型将免疫力获得和失去过程简化为了一次性事件，这样使得模型更加简单易懂，且更适用于描述病毒一次性感染后获得永久免疫力的情况。而SIRS模型则认为康复者可能会失去免疫力，需要重新变为易感者，这使得该模型更适用于描述疾病传播周期较长的情况。</p><p>此外SIR模型更加适用于大规模流行病，由于SIR模型考虑了康复因素和免疫力获得和失去过程，因此它更适合于描述大规模流行病的传播。在大规模流行病中，康复者人数占总感染人数的比例可能很高，因此需要一个能够反映康复者影响的模型。</p><p>总之，SIR模型可以对流行病疫情发展趋势进行最好的拟合，反映出最为真实的影响。</p><h2 id="2-基于SIR模型对新冠疫情走势进行探讨"><a href="#2-基于SIR模型对新冠疫情走势进行探讨" class="headerlink" title="2 基于SIR模型对新冠疫情走势进行探讨"></a><strong>2 基于SIR模型对新冠疫情走势进行探讨</strong></h2><h3 id="2-1通过SIR模型建模并实现与现实情况对比"><a href="#2-1通过SIR模型建模并实现与现实情况对比" class="headerlink" title="2.1通过SIR模型建模并实现与现实情况对比"></a><strong>2.1通过SIR模型建模并实现与现实情况对比</strong></h3><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps17-1690963839566-15.jpg" alt="img">SIR模型计算</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps18-1690963839566-19.jpg" alt="img"></h3><p>主要模型运用过程</p><h3 id="2-2对比结果"><a href="#2-2对比结果" class="headerlink" title="2.2对比结果"></a><strong>2.2对比结果</strong></h3><p>导入北京2020.1~2020.3的新冠疫情感染数据绘制图像如下</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps19-1690963839566-16.jpg" alt="img"><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps20-1690963839566-20.jpg" alt="img"> </p><p>导入英国2020.2~2020.3的新冠疫情感染数据绘制图像如下</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps21-1690963839566-21.jpg" alt="img"><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps22.jpg" alt="img"> </p><p>以上两组数据左图为每日感染人数，右图为治愈总人数。其中红线为真实值，蓝线为SIR模型推测结果。</p><h3 id="2-3结果分析"><a href="#2-3结果分析" class="headerlink" title="2.3结果分析"></a><strong>2.3结果分析</strong></h3><p>排除客观检测和数据收集不全等因素，由上表两组对比数据可以看出。</p><p>中国北京的推测曲线先有高峰期随后下降。这是由于根据数据推测，北京人口基数大，疫情传播迅速。但事实情况确实我们的发展曲线较为缓和。这是由于有利的疫情封控防护措施所导致的结果。因此由于感染人数较少，右图中的治愈曲线也相对较低，但总趋势与推测趋势相同。</p><p>下图中的英国采用的是全民免疫的野蛮发展策略，因此可以看见真实曲线与推测相吻合，说明推测较为成功。也证明SIR模型的推测具有一定的准确性。</p><h2 id="3-问题回答"><a href="#3-问题回答" class="headerlink" title="3 问题回答"></a><strong>3 问题回答</strong></h2><h3 id="3-1-一种疾病从出现到大规模流行再到遏制，其间三种人群关于时间的函数一般是不同的。例如在早期，感染人数可能大致呈指数增长；到后期，感染人数渐渐趋于0。初步建立的SIR模型是无法表示这种变化的。请读者阅读系列文献，思考改变哪些参数才能表现这种变化？"><a href="#3-1-一种疾病从出现到大规模流行再到遏制，其间三种人群关于时间的函数一般是不同的。例如在早期，感染人数可能大致呈指数增长；到后期，感染人数渐渐趋于0。初步建立的SIR模型是无法表示这种变化的。请读者阅读系列文献，思考改变哪些参数才能表现这种变化？" class="headerlink" title="3.1****一种疾病从出现到大规模流行再到遏制，其间三种人群关于时间的函数一般是不同的。例如在早期，感染人数可能大致呈指数增长；到后期，感染人数渐渐趋于0。初步建立的SIR模型是无法表示这种变化的。请读者阅读系列文献，思考改变哪些参数才能表现这种变化？"></a><strong>3.1****一种疾病从出现到大规模流行再到遏制，其间三种人群关于时间的函数一般是不同的。例如在早期，感染人数可能大致呈指数增长；到后期，感染人数渐渐趋于0。初步建立的SIR模型是无法表示这种变化的。请读者阅读系列文献，思考改变哪些参数才能表现这种变化？</strong></h3><p>可以更改的参数大约有一下几项：</p><p>β（传染率）：在疫情不同时期，人们的防护意识不同，社交活动范围也会发生变化，传染率可能会随时间推移降低。</p><p>γ（恢复率）：随着时间的推移，越来越多的人可能会因为治愈或死亡而从感染者群体中移除，因此恢复率也会随之增加。</p><p>μ（死亡率）：死亡率也可能会随着时间的推移而发生变化。在疫情初期，由于疾病的不确定性和缺乏有效的治疗手段，死亡率可能会比较高；而到了后期，随着医疗技术和治疗手段的不断进步，死亡率可能会逐渐降低。</p><p>N（总人口数）：在疫情初期，由于社交活动频繁和人员流动性较高，可能会有大量的人进入或离开某个地区，导致总人口数发生变化。</p><p>D（疾病持续时间）：在疫情初期，由于疾病的不确定性和缺乏有效的治疗手段，可能会有很多人长期感染；而到了后期，随着治疗手段的不断进步，感染者的平均恢复时间可能会逐渐缩短。</p><h3 id="3-2感染和治愈都是需要时间的。在无免疫力者转变为感染者和感染者转变为免疫者的过程中，出现了两类中间人群，他们分别具有那些不同的传染特性？试结合文献，在传统模型中加入这种因素。"><a href="#3-2感染和治愈都是需要时间的。在无免疫力者转变为感染者和感染者转变为免疫者的过程中，出现了两类中间人群，他们分别具有那些不同的传染特性？试结合文献，在传统模型中加入这种因素。" class="headerlink" title="3.2感染和治愈都是需要时间的。在无免疫力者转变为感染者和感染者转变为免疫者的过程中，出现了两类中间人群，他们分别具有那些不同的传染特性？试结合文献，在传统模型中加入这种因素。"></a><strong>3.2感染和治愈都是需要时间的。在无免疫力者转变为感染者和感染者转变为免疫者的过程中，出现了两类中间人群，他们分别具有那些不同的传染特性？试结合文献，在传统模型中加入这种因素。</strong></h3><p>SIR模型是忽略中间状态的一种模型，如果需要考虑中间状态。则需要将原本的I类人群更改为E类和I类。其中E类表示处于潜伏期的人群，他们已经感染了病毒，但尚未表现出明显的症状。I类则表示已经表现出症状的感染者。根据这一规律，可以使用之前提到的SEIR模型。</p><h3 id="3-3疫情的发生通常是一点爆发、扩散四周的，是否有可能是多点爆发呢？在多点爆发的情况下，疾病的扩散速度是否也是成倍增加呢？什么因素限制了疾病传播几乎无限的加快？"><a href="#3-3疫情的发生通常是一点爆发、扩散四周的，是否有可能是多点爆发呢？在多点爆发的情况下，疾病的扩散速度是否也是成倍增加呢？什么因素限制了疾病传播几乎无限的加快？" class="headerlink" title="3.3疫情的发生通常是一点爆发、扩散四周的，是否有可能是多点爆发呢？在多点爆发的情况下，疾病的扩散速度是否也是成倍增加呢？什么因素限制了疾病传播几乎无限的加快？"></a><strong>3.3疫情的发生通常是一点爆发、扩散四周的，是否有可能是多点爆发呢？在多点爆发的情况下，疾病的扩散速度是否也是成倍增加呢？什么因素限制了疾病传播几乎无限的加快？</strong></h3><p>疫情可以由单个感染者引起的一点爆发，然后扩散到周围的人群中。随后引发多点爆发的情况。</p><p>在多点爆发的情况下，疾病的扩散速度有可能会成倍增加。但受制于诸多因素，最终会放缓增长趋势。这其中包括感染源的数量、人群密度、人口总量等。</p><p>总的来说，控制措施、人口总量和人们的行为都影响着疫情的传播速率，他们限制着疫情不会无限传播。</p><h3 id="3-4传染病与卫生统计学强调人的作用。假如人的防疫工作效果可以被量化，那么这种效果主要体现在模型的哪些变量上呢？这些变量对于疾病未来的趋势的影响程度是一样的吗？"><a href="#3-4传染病与卫生统计学强调人的作用。假如人的防疫工作效果可以被量化，那么这种效果主要体现在模型的哪些变量上呢？这些变量对于疾病未来的趋势的影响程度是一样的吗？" class="headerlink" title="3.4传染病与卫生统计学强调人的作用。假如人的防疫工作效果可以被量化，那么这种效果主要体现在模型的哪些变量上呢？这些变量对于疾病未来的趋势的影响程度是一样的吗？"></a><strong>3.4传染病与卫生统计学强调人的作用。假如人的防疫工作效果可以被量化，那么这种效果主要体现在模型的哪些变量上呢？这些变量对于疾病未来的趋势的影响程度是一样的吗？</strong></h3><p>主要会体现在模型中的β（传染率）、γ（恢复率）和μ（死亡率）当中。</p><p>不同变量对于疾病未来趋势的影响程度必然是不是一样的。在早期阶段，感染率影响程度较大；后期阶段，治愈率和死亡率可能会占更大比重，因为随着时间的推移，越来越多的人可能被感染并且需要接受治疗。</p><h3 id="3-5-疫情防控就像一场赛跑，如果不能在疾病造成无法恢复的损失之前组织起有效的防卫，一个物种可能会迎来电影中的那种末日结局。从模型上看，是否存在某些结点，在决定抗疫结果中有着尤其关键的重要意义？"><a href="#3-5-疫情防控就像一场赛跑，如果不能在疾病造成无法恢复的损失之前组织起有效的防卫，一个物种可能会迎来电影中的那种末日结局。从模型上看，是否存在某些结点，在决定抗疫结果中有着尤其关键的重要意义？" class="headerlink" title="3.5****疫情防控就像一场赛跑，如果不能在疾病造成无法恢复的损失之前组织起有效的防卫，一个物种可能会迎来电影中的那种末日结局。从模型上看，是否存在某些结点，在决定抗疫结果中有着尤其关键的重要意义？"></a><strong>3.5****疫情防控就像一场赛跑，如果不能在疾病造成无法恢复的损失之前组织起有效的防卫，一个物种可能会迎来电影中的那种末日结局。从模型上看，是否存在某些结点，在决定抗疫结果中有着尤其关键的重要意义？</strong></h3><p>存在着这样的节点。</p><p>在感染者快速增长时：如果在此时能够及时采取有效的防疫措施，可以有效遏制疫情的传播，减缓增长速率，放缓防控压力。</p><p>在感染后期趋于平缓时：及时推广疫苗接种，并在适当的时间点实施疫苗接种，可以有效提高群体免疫水平，从而减少大面积复阳的风险。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a><strong>4 总结</strong></h2><h3 id="4-1建模分析"><a href="#4-1建模分析" class="headerlink" title="4.1建模分析"></a><strong>4.1建模分析</strong></h3><p>本次建模只是建立了一个较为基础的模型，可以满足较为基本的流行病学分析计算。但是对于较为复杂，外界影响因素较多的事件进行分析时会显得无法拟合。其他未考虑到的影响因素也应该对其进行数学转化，将其纳入考虑范围。同时面对不同的传染病问题。也应该根据该病特点进行特性化分析，从而采用各位合适的模型。</p><h3 id="4-2改进方向"><a href="#4-2改进方向" class="headerlink" title="4.2改进方向"></a><strong>4.2改进方向</strong></h3><p>本次建模也还有待改进，在设定传染率时，需要根据一定数据推算传染率，再将其手动填入计算过程当中。这一推算过程可能会受到样本容量影响，导致信息误差大，从而导致计算拟合度低。</p><p>数学模型虽然较为单一死板，与其相比真实情况往往会收到多重因素影响。但是如果能够周全考虑各种因素，就可以通过数学建模模拟出更为准确的发展情况。通过不断对模型进行更新升级，就可以用数学的方法解决许多生活中的常见问题，将数学真正应用起来。</p>]]></content>
    
    
    <summary type="html">本文对一些科学分析模型进行了研究与实践，并对主要的SIR模型加以深化，观察其预测结果并得出一系列结论。</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数学建模实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数学建模实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>北邮网安大类课程介绍（21级）</title>
    <link href="https://zhangyuanhe.top/2023/07/31/BUPT_note/BUPT01/"/>
    <id>https://zhangyuanhe.top/2023/07/31/BUPT_note/BUPT01/</id>
    <published>2023-07-31T13:00:00.000Z</published>
    <updated>2023-08-04T10:04:19.060Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如有补充或想说的，欢迎在评论区评论。我会及时填补各课程信息~</p></blockquote><p>由于网安院建院时间较短，培养方案还在不断更改，每一届的同学所学课程的顺序都有可能发生变化，以下内容仅供参考。本人平时成绩一般，主要靠考前突击，奉劝大家平时还是要好好学习，期末突击不可靠。</p><p>部分文件资料放在百度网盘，往年试卷可能比较旧（小卖部卖的现在也很旧），不过还有一定参考性。</p><blockquote><p>Tip 如果链接过期请使用各种方式联系，我会在收到邮件的第一时间更新!</p></blockquote><p><a href="https://pan.baidu.com/s/1M7wABOKXXhquss3x8mYc2g?pwd=6666"><em>百度网盘提取链接</em></a></p><h1 id="大一上"><a href="#大一上" class="headerlink" title="大一上"></a>大一上</h1><p>大一上的课可以说的相当的少，好好感受下快乐的大学生活吧。</p><h1 id="大学生心理健康"><a href="#大学生心理健康" class="headerlink" title="大学生心理健康"></a>大学生心理健康</h1><p>这门课比较水，没留下什么文件，最后应该是考察不是考试。可以轻松通过，绩点占比也不多。</p><h1 id="计算导论与程序设计"><a href="#计算导论与程序设计" class="headerlink" title="计算导论与程序设计"></a>计算导论与程序设计</h1><p>快乐寄导，主要学习的是c语言，难度不大非常基础，好像讲到了链表和文件处理，后面就没再讲。建议好好学习，可以为以后的其他语言学习打下很好的基础。课上留的都是oj的题好像，多做几遍就明白了，不要不做作业。我的oj题放在CSDN里面了，有需要可以查阅。此外还可以做一些简单的洛谷题。期末考试是机考和笔试，机考考到指针，笔试范围稍微大点，其中笔试分值较高，主要是方便老师捞人。</p><ol><li>CSDN可以自行搜索习题答案，我的答案应该在这里（不太记得了）<a href="https://blog.csdn.net/weixin_62495164/category_11517327.html"> 简单的c语言基础 <em>呆呆水獭</em>-CSDN博客</a></li><li>百度网盘有部分oj例题</li><li>百度网盘有21级ppt</li></ol><h1 id="网络空间安全导论"><a href="#网络空间安全导论" class="headerlink" title="网络空间安全导论"></a>网络空间安全导论</h1><p>印象不是很深了，主要将网安的基础知识，像科普一样也没有作业。最后会有考试，但是很容易通过。</p><h1 id="思想道德修养与法律基础"><a href="#思想道德修养与法律基础" class="headerlink" title="思想道德修养与法律基础"></a>思想道德修养与法律基础</h1><p>每学期都会有一门政治类课程，一共四学期。但是思修是不会闭卷考试的，最后应该是写论文结课。课程中间会有一些调研类的作业，找好组员一起去完成叭（如果合得来的话，这个整治小组可能会一直贯穿四门政治课，主要还是看组员的个人意愿）。</p><ol><li>百度网盘：21级期末考试要求、课程期间本组实践作业</li></ol><h1 id="高等数学A-上"><a href="#高等数学A-上" class="headerlink" title="高等数学A(上)"></a>高等数学A(上)</h1><p>大一魔鬼课！难度指数级增长，前面学的很容易，但一定要把基础打好，不然越学越不会。高数上的期中考试有时候会出的很难，让大家都不及格，主要是为了让刚入学的同学加强重视好好学习。期中考试占比低无伤大雅，期末好好考试就可以了。作业一定要认真做，把题型摸透，不要到了考试的时候还有没见过的题型。</p><ol><li>百度网盘：一些数学公式</li><li>百度网盘-学长流传：高等数学试题集_14103538：北邮出品，历年真题。</li><li>百度网盘-学长流传：其他pdf版的早年间考题，都是老师发的。</li><li>百度网盘-学长流传：高数（上）老师手写笔记。</li><li>百度网盘-学长流传：重积分和曲线曲面积分.jpg 线性代数</li></ol><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><p>又一大难点，也是要平时好好做作业、多做题。考前看一看往年例题。</p><ol><li>百度网盘：课件ppt、复习课（讨论课）讲案</li><li>百度网盘-学长流传：线代绿皮书，北邮出品，历年真题。题型和位置都是一样的！</li><li>百度网盘-学长流传：2018-2019线性代数期末考试A卷。</li></ol><h1 id="大一下"><a href="#大一下" class="headerlink" title="大一下"></a>大一下</h1><p>课程开始多起来了，但是我们赶上了疫情，由于线上教学，好多课程的考核都降低了难度。</p><h1 id="数字逻辑与数字系统"><a href="#数字逻辑与数字系统" class="headerlink" title="数字逻辑与数字系统"></a>数字逻辑与数字系统</h1><p>这门课东西还是比较多的，但是考试题型比较固定，就考那些东西。平时把作业看懂就行了，有时候会感觉作业看上去和上课将的不太一样，这是正常现象。</p><p>实验和考试无关，能做出来就行。唯一不好就是实验赶上了期末周，要合理分配时间。</p><ol><li>百度网盘：课件ppt</li><li>百度网盘：21级期中考试卷子</li><li>百度网盘：我的复习笔记</li><li>百度网盘：实验报告书</li><li>百度网盘-学长流传：期中-2020.pptx，期中原题，按照去年前年的题来看，会有祖传题。</li><li>百度网盘-学长流传：带书签-数字逻辑学习辅导11529796，很好的刷题练习册，从中找做错的题型多练几道。</li><li>百度网盘-学长流传：课件，非常好的ppt。</li><li>百度网盘-学长流传：实验，很完整的整理出来了。</li><li>懒得去百度网盘找实验可以直接看我发在博客里的<a href="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/">数字逻辑实验报告</a></li></ol><h1 id="C-高级语言程序设计"><a href="#C-高级语言程序设计" class="headerlink" title="C++高级语言程序设计"></a>C++高级语言程序设计</h1><p>选修课，可以在c++，Java，python中三选一。课程太难，和c的重合度比较高，多讲到了链表部分。给分也还可以，学期中有小组作业，期末好像是手写代码。强度不是很高，推荐选。</p><ol><li>百度网盘：作业代码、课件ppt、小组作业代码</li><li>CSDN：部分作业代码已上传，可直接查看<a href="https://blog.csdn.net/weixin_62495164/category_11755373.html">c++从入门到入坟</a></li></ol><h1 id="JAVA高级语言程序设计"><a href="#JAVA高级语言程序设计" class="headerlink" title="JAVA高级语言程序设计"></a>JAVA高级语言程序设计</h1><p>这三门课开始放在一起说吧，java应该是大二上学习，整体思路上可以用c的学习思路进行学习，难度适中。据说给分比较高，但是我的不是很高，所以请大家自行考量。</p><ol><li>百度网盘：作业代码、实验代码、课件ppt</li><li>CSDN：部分作业代码已上传，可直接查看<a href="https://blog.csdn.net/weixin_62495164/category_12033379.html">Java从入门到入土</a></li></ol><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>这门课我没选，是大二下学习。以上三门课是至少选一门学习（培养方案可能会改）。</p><p>python听室友说是有实验写爬虫脚本，期末卷子考试。要是有基础学起来应该不难。在后续的各种代码应用中python确实是用到最多的。我现在（到大二结束）偶尔还会见到c++，Java是学完没再见过。脚本基本都是python的，不过也不需要看懂，能配环境用就行。所以有兴趣的同学建议可以直接学python。</p><h1 id="网络空间安全导论实践"><a href="#网络空间安全导论实践" class="headerlink" title="网络空间安全导论实践"></a>网络空间安全导论实践</h1><p>印象不深了，好像是做了一堆虚拟平台上的实验。期末也没考试，略过略过~</p><ol><li>百度网盘：实验报告</li><li>可以直接查看实验报告：<a href="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/">分类：网络安全实验 | ZYH’s blog (zhangyuanhe.top)</a></li></ol><h1 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h1><p>纯英语授课，有一点痛苦。知识点涵盖范围相当大，杂而不难，把几个关键的算法和理论记住就可以了，经常会考，期中考完了期末可能会再考一遍。前半学期相对轻松，难度小同时和数字逻辑有重复部分，会给人感觉好几门课在讲一毛一样的东西。考前复习一下就可以。</p><ol><li>百度网盘：教材电子版</li><li>百度网盘：课件ppt，期中考试卷，作业</li><li>百度网盘-学长流传：早年间的卷子</li></ol><h1 id="中国近现代史纲要"><a href="#中国近现代史纲要" class="headerlink" title="中国近现代史纲要"></a>中国近现代史纲要</h1><p>历史内容比较多，比四门政治课好理解的。期末考试写一个读书报告+论文（疫情原因）就完事了。学期里会有小组作业和近代史实践课的实践作业。</p><ol><li>百度网盘：小组作业、期末论文题目</li><li>百度网盘-学长流传：复习资料（注意可能会有改版）</li></ol><h1 id="习近平新时代中国特色社会主义思想概论"><a href="#习近平新时代中国特色社会主义思想概论" class="headerlink" title="习近平新时代中国特色社会主义思想概论"></a>习近平新时代中国特色社会主义思想概论</h1><p>以前是开卷考试，我们因为疫情改成了论文，但以后也可能改成闭卷考试。虽然可能没有闭卷考，但还是最好多少听一些，因为大二下的毛中特里面还会有习思想的内容，上课会略过不讲，但是期末可能会考一两道题。</p><ol><li>百度网盘：课件ppt、期中期末题目</li></ol><h1 id="高等数学A-下"><a href="#高等数学A-下" class="headerlink" title="高等数学A(下)"></a>高等数学A(下)</h1><p>高数的延续，好好学吧。（高数老师好像收手写作业，不交电子版）</p><ol><li>百度网盘：笔记、一些习题</li></ol><h1 id="大学物理C"><a href="#大学物理C" class="headerlink" title="大学物理C"></a>大学物理C</h1><p>大物。。。   名字摆在这了</p><p> 考试中大部分以电磁学为主，更像是微积分应用的感觉，考前应试那就多背二级结论和电磁的模型，写在张纸上背下来很管用。期末考试受疫情影响我们是闭卷全选择，但是大物会出原题，多看作业和往年题。大物语速超级快，讲的内容也快，最好上完课在过一遍、</p><ol><li>百度网盘：笔记、课件ppt</li><li>百度网盘-学长流传：早年间大物期末试题</li></ol><h1 id="物理实验A"><a href="#物理实验A" class="headerlink" title="物理实验A"></a>物理实验A</h1><p>挺复杂的，老容易出问题。受设备型号不同影响大有时候不知道该干什么。看着视频照着做吧</p><ol><li>b站：李传国老师，有很多视频实验一模一样，照做就可以<a href="https://space.bilibili.com/477710704">物理老师李传国的个人空间_哔哩哔哩_bilibili</a></li><li>百度网盘：一些实验报告</li></ol><h1 id="大二上"><a href="#大二上" class="headerlink" title="大二上"></a>大二上</h1><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>比较重要的一门专业课，学的内容不会有教材里的那么多，主要是前面的内容，后面大概率略讲也不会考。学的时候以概念方法为主，不是很注重代码实现，期末考试也是闭卷，有个别代码要手写。</p><ol><li>百度网盘：课件ppt、作业和答案</li><li>百度网盘-学长流传：一些复习资料</li></ol><h1 id="计算机组成与系统结构"><a href="#计算机组成与系统结构" class="headerlink" title="计算机组成与系统结构"></a>计算机组成与系统结构</h1><p>作为专业课也很重要，但是不会很难，属于比较好过的，作业也不多。就是会有实验，仪器操作复杂，要跟着说明来做。</p><ol><li>百度网盘：课件ppt、作业和答案、实验报告</li></ol><h1 id="信息安全数学基础"><a href="#信息安全数学基础" class="headerlink" title="信息安全数学基础"></a>信息安全数学基础</h1><p>非常头大的一门课，讲的非常数学，上课听的人也不多。想听要坐前排认真听，很容易走神听不进去。上课疯狂灌概念知识点。不过考试还算友善，我们好像是开卷了，但是历年应该是闭卷的。归纳题型总结，学得多考的少。</p><ol><li>百度网盘：课件ppt、作业和答案、期末卷子</li><li>百度网盘-学长流传：期末卷子、知识点</li></ol><h1 id="信息安全心理学"><a href="#信息安全心理学" class="headerlink" title="信息安全心理学"></a>信息安全心理学</h1><p>科普性的课，不多解释，期末是论文。但是助教签到比较严</p><h1 id="马克思主义基本原理概论"><a href="#马克思主义基本原理概论" class="headerlink" title="马克思主义基本原理概论"></a>马克思主义基本原理概论</h1><p>在树洞没封的时候，没到秋季学期期末都可以看见有大批痛苦孩子在背马原。所以准备好期末闭卷考试吧。会有一些小组作业，不难。</p><ol><li>百度网盘：小组作业</li></ol><h1 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h1><p>有点小麻烦，属于理科课程，我们老师上课时手写板书没有ppt，有点痛苦但是讲的很细。期末闭卷考试，还会有一个小论文作业，关于生活中概率论与数理统计。概率论与数理统计习题全解指南这本书挺好，作业答案解析上面都有。</p><ol><li>百度网盘：作业、复习资料</li><li>百度网盘-学长流传：早年间期末试题</li><li>百度网盘-学长流传：概率论与数理统计习题全解指南</li><li>b站：宋浩速通概率论，<a href="https://www.bilibili.com/video/BV1ot411y7mU/">《概率论与数理统计》教学视频全集</a></li></ol><h1 id="大二下"><a href="#大二下" class="headerlink" title="大二下"></a>大二下</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>老师很好，讲的知识很多，填鸭式讲解得慢慢理解。好在期末考试比较简单，不会挂科。开学会写一篇小论文，期末闭卷考试。</p><ol><li>b站：速通流必备<a href="https://www.bilibili.com/video/BV1YE411D7nH/?share_source=copy_web">王道计算机考研</a></li><li>百度网盘：小论文、课件、作业</li><li>百度网盘-学长流传：早年间的卷子、实验（我们好像都没做过）</li></ol><h1 id="数据库技术与应用"><a href="#数据库技术与应用" class="headerlink" title="数据库技术与应用"></a>数据库技术与应用</h1><p>讲的是数据库的各种知识，考试的时候还是SQL考的比较多。教学用的是SQL server，不要用mySQL，不然作业都不好做。是可以考前突击出来的课，但是每年考题变化还是不小的。</p><ol><li>百度网盘：笔记、课件、作业、实验</li><li>百度网盘-学长流传：早年间的卷子</li></ol><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>挺重要的一门课，会按五层结构一层一层讲，考前疯狂背协议和每层的功能。期末考试比较难，每年都是，但是题型还算固定。会有实验要做</p><ol><li>b站：速通流必备[王道计算机考研](<a href="https://www.bilibili.com/video/BV19E411D78Q/?vd_source=845dacbec2fc56dd00bc736f8d842991">王道计算机考研 计算机网络_</a></li><li>百度网盘：笔记、课件、作业</li><li>百度网盘-学长流传：早年间的卷子、实验（我们好像都没做过）</li><li>实验可以直接看博客：<a href="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/">分类：计算机网络实验 </a></li></ol><h1 id="汇编语言与逆向工程"><a href="#汇编语言与逆向工程" class="headerlink" title="汇编语言与逆向工程"></a>汇编语言与逆向工程</h1><p>非常实验的一门课，上课讲的都逆向工程的方法。期末是开卷闭网考试，5道逆向题目，每个都是获取flag并简单说明下如何解题。还是需要看应试技巧，期末题目不是按难易排序的。考的知识点还算固定，复习考试范围就可以。</p><ol><li>百度网盘：解题思路、ppt、练习题、作业题</li><li>百度网盘-学长流传：视频资料、一些工具</li><li>博客准备开一个板块放逆向的内容，以后可能会放链接</li><li><a href="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">分类：汇编语言 | ZYH’s blog (zhangyuanhe.top)</a></li></ol><h1 id="现代密码学"><a href="#现代密码学" class="headerlink" title="现代密码学"></a>现代密码学</h1><p>经典专业课+1，从古典密码一直到现代加密通信。要记的东西不少，学起来有点痛苦。考试题目偏理论，闭卷考试。</p><ol><li>百度网盘：ppt、笔记、作业题</li><li>百度网盘-学长流传：教材电子版</li></ol><h1 id="数字内容安全"><a href="#数字内容安全" class="headerlink" title="数字内容安全"></a>数字内容安全</h1><p>科普类课程，但是有闭卷考试，主要靠考前画的知识点用几个小时突击。最后一个月会有实验，实验比较复杂而且每一届好像不太一样。</p><ol><li>百度网盘：ppt、实验报告</li><li><a href="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/">分类：数字内容安全实验 | ZYH’s blog (zhangyuanhe.top)</a></li></ol><h1 id="毛泽东思想和中国特色社会主义理论体系概论"><a href="#毛泽东思想和中国特色社会主义理论体系概论" class="headerlink" title="毛泽东思想和中国特色社会主义理论体系概论"></a>毛泽东思想和中国特色社会主义理论体系概论</h1><p>毛中特，最后一门政治课，会画大题考点，重点看这几个考点就够了。有小组作业，还有实践调研。每节课同学自愿报名上台点评热点新闻，期末有一定加分。</p><ol><li>百度网盘：实践作业、小组作业、思维导图</li></ol><h1 id="数学建模与模拟"><a href="#数学建模与模拟" class="headerlink" title="数学建模与模拟"></a>数学建模与模拟</h1><p>限选课之一，相较于另外两门，这一个算是最友善的。没有期末考试，讲的内容也能够理解。需要使用matlab工具。</p><ol><li>百度网盘：作业、课件</li><li><a href="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AE%9E%E9%AA%8C/">分类：数学建模实验 | ZYH’s blog (zhangyuanhe.top)</a></li></ol><h1 id="公选课"><a href="#公选课" class="headerlink" title="公选课"></a>公选课</h1><p>公选课属于自行选修课程，最后不会算在保研排名中，无法靠公选课拉绩点哦！</p><h2 id="中国古建筑文化与鉴赏（在线课程）"><a href="#中国古建筑文化与鉴赏（在线课程）" class="headerlink" title="中国古建筑文化与鉴赏（在线课程）"></a>中国古建筑文化与鉴赏（在线课程）</h2><p>非常水的智慧树网课，很好通过。期末是在线考试选择题，可以在网上查到成套的往年题，一边考试一边借鉴就可。智慧树一般开课比较晚，会比正常学期完一个月左右，不要着急。</p><h2 id="趣味密码学"><a href="#趣味密码学" class="headerlink" title="趣味密码学"></a>趣味密码学</h2><p>这门课当时也是线上课，听的不是很认真。不过建议大家在大一上或者下可以选课听一听，对大二的现代密码学有一些帮助。最后的考核是开卷5道笔答题，可以搜到。</p><h2 id="大学美学"><a href="#大学美学" class="headerlink" title="大学美学"></a>大学美学</h2><p>分数相当高，网课讲解像讲故事一样，期末论文或者开卷考试，非常水。</p><h2 id="敏捷与精益开发（双创）"><a href="#敏捷与精益开发（双创）" class="headerlink" title="敏捷与精益开发（双创）"></a>敏捷与精益开发（双创）</h2><p>一门经营管理类的创新课，听着还比较有意思，基本没有小作业，没有考试。用来当双创分还是可以的</p><h2 id="食品安全（在线课程）"><a href="#食品安全（在线课程）" class="headerlink" title="食品安全（在线课程）"></a>食品安全（在线课程）</h2><p>水课啦~和古建筑一样，智慧树听一听就完事。别忘了做期末考试的题哦</p>]]></content>
    
    
    <summary type="html">记录学过的各门课程，供学弟学妹参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://zhangyuanhe.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://zhangyuanhe.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>http、smtp抓包及分析实验</title>
    <link href="https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/computer_network/CN1/"/>
    <id>https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/computer_network/CN1/</id>
    <published>2023-07-30T01:00:00.000Z</published>
    <updated>2023-07-31T14:33:55.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-实验内容"><a href="#一-实验内容" class="headerlink" title="一 实验内容"></a>一 实验内容</h1><p>1） 使用 Wireshark 软件捕获 HTTP 消息，分析其消息头，理解 HTTP 的通信原理； </p><p>2） 使用 Wireshark 软件捕获一次从客户端发送 Email 的过程，分析 SMTP 消息，理解 Email 系统中 </p><p>发送邮件的通信原理； </p><p>3）使用 Telnet 软件访问 Email 服务器，输入 SMTP 命令与 Email 服务器交互，理解 SMTP 的通信 </p><p>过程和 Base64 编码的概念。 </p><h1 id="二-实验报告"><a href="#二-实验报告" class="headerlink" title="二 实验报告"></a>二 实验报告</h1><p><strong>任务：</strong>本次实验主要通过Wireshark进行抓包，并对数据进行分析。随后使用Telnet访问Email 服务器。详细内容见实验内容部分。</p><p><strong>实验环境：</strong>win10系统、wireshark软件、telnet服务</p><p><strong>实验步骤：</strong></p><p>1下载并打开wireshark</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps1-1690805315179-1.jpg" alt="img"> </p><p>2 启动 Wireshark，选择捕获接口为联网的本机网卡（本地连接或 WLAN），设置合适的捕获过滤器：对于 HTTP 消息，设置捕获过滤器为 tcp port 80</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps2-1690805315179-2.jpg" alt="img"> </p><p>3 开始抓包后，访问<a href="http://www.xinhuanet.com,网页全部显示后停止捕获./">www.xinhuanet.com，网页全部显示后停止捕获。</a></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps3-1690805315179-6.jpg" alt="img"> </p><p>4 筛选显示http协议</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps4-1690805315179-8.jpg" alt="img"> </p><p>5 分析捕获到的消息</p><p>网页请求的 Get 消息</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps5-1690805315179-3.jpg" alt="img"> </p><p>返回的 200 OK 应答消息</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps6-1690805315179-4.jpg" alt="img"> </p><p>6 进行SMTP实验，下载Foxmail，配置发件服务器</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps7-1690805315179-5.jpg" alt="img"> </p><p>7 启动 Wireshark，选择捕获接口为联网的本机网卡（本地连接或 WLAN），设置合适的捕获过滤器：对于 SMTP 消息，设置捕获过滤器为 tcp port 25</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps8-1690805315179-7.jpg" alt="img"> </p><p>8 给自己发送邮件，捕获到协议数据</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps9-1690805315179-9.jpg" alt="img"> </p><p>9 停止捕获，分析数据</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps10-1690805315179-10.jpg" alt="img"> </p><p>10 进行邮件服务器交互实验</p><p>远程链接主机</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps11-1690805315179-11.jpg" alt="img"> </p><p>11 输入用户名和授权码，登录成功</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps12-1690805315179-12.jpg" alt="img"> </p><p>12 发送邮件成功并收到邮件</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps13-1690805315179-13.jpg" alt="img"> </p><p>HTTP 协议分析 </p><p>1） 根据捕获到的消息，对照讲义和教材，理解 HTTP 的功能和通信过程。</p><p>功能：建立客户端和服务器之间的连接，传输数据；定义客户端和服务器之间传输的数据格式；支持客户端向服务器请求数据，以及服务器向客户端提供数据；持不同类型的数据传输，如文本、图像、视频等；支持客户端和服务器之间的认证和安全性</p><p>通信过程：</p><p>建立连接：客户端与服务器之间通过 TCP&#x2F;IP 协议建立连接。</p><p>发送请求：客户端发送一个 HTTP 请求到服务器。</p><p>处理请求：服务器接收到客户端请求后，处理请求并返回一个响应消息给客户端。</p><p>关闭连接：在完成请求和响应之后，客户端和服务器之间的连接会被关闭。</p><p>2） 观察 HTTP 请求&#x2F;应答消息的各字段及消息头的内容，自己查找资料理解各消息头的功能，列表总结请求消息和应答消息中各字段及各消息头的功能及现有值的含义。 </p><table><thead><tr><th>来源</th><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>网页请求的 Get 消息</td><td>[Expert Info (Chat&#x2F;sequence): GET &#x2F; HTTP&#x2F;1.1\r\n]</td><td>请求行</td></tr><tr><td>Host: <a href="http://www.xinhuanet.comlrin/">www.xinhuanet.comlrin</a></td><td>请求将要发送到的服务器主机名和端口号</td><td></td></tr><tr><td>User-Agent: Mozilla&#x2F;5.0</td><td>用户代理</td><td></td></tr><tr><td>Accept-Language: zh-CN,zh</td><td>通告哪些语言客户端是能够理解</td><td></td></tr><tr><td>Cookie:wdcid&#x3D;622352bc440b3475:arialoadData&#x3D;false:wdlast&#x3D;1680080588\nin</td><td>保持用户的登录状态</td><td></td></tr><tr><td>Connection: keep-alive</td><td>对 HTTP 连接进行说明</td><td></td></tr><tr><td>Cache-Control: max-age&#x3D;0</td><td>关于缓存的响应头</td><td></td></tr><tr><td>\r\n</td><td>表示消息结束</td><td></td></tr><tr><td>返回的 200 OK 应答消息</td><td>HTTP&#x2F;1.1 200 0K\r\n</td><td>状态行</td></tr><tr><td>Date: Wed，29 Mar 2923 99:06:18 GMT</td><td>消息发送的时间</td><td></td></tr><tr><td>Content-Length: 22611</td><td>告知数据的长度</td><td></td></tr><tr><td>Content-Tvpe: text&#x2F;html;charset&#x3D;utf-8</td><td>内容类型</td><td></td></tr><tr><td>Connection: keep-alive</td><td>对 HTTP 连接进行说明</td><td></td></tr><tr><td>Vary: Accept-Encoding</td><td>响应头部信息</td><td></td></tr><tr><td>Content-Encoding: gzip</td><td>对实体内容进行压缩编码</td><td></td></tr><tr><td>X-Cache: HIT from x-s-V-30\</td><td>代理动作</td><td></td></tr><tr><td>Accept-Ranges: bvtes</td><td>由服务器使用以通告其支持部分请求的标志物</td><td></td></tr><tr><td>\r\n</td><td>表示消息结束</td><td></td></tr></tbody></table><h1 id="三-SMTP-协议分析"><a href="#三-SMTP-协议分析" class="headerlink" title="三 SMTP 协议分析"></a>三 SMTP 协议分析</h1><p>1） 根据捕获到的消息，对照讲义和教材，理解 SMTP 的功能和通信过程。</p><p>功能：1 发送电子邮件。SMTP协议定义了如何将邮件从发件人传输到收件人的过程，包括邮件格式、编码方式、协议命令和参数等。</p><p>2 转发电子邮件。SMTP协议不仅可以将邮件从发送者传输到接收者，也可以将邮件从一个SMTP服务器传输到另一个SMTP服务器，实现邮件的转发功能。</p><p>通信过程</p><p>邮件客户端向SMTP服务器发送连接请求；</p><p>SMTP服务器对连接请求进行确认，并欢迎邮件客户端；</p><p>邮件客户端发送邮件发送者的地址、收件人的地址以及邮件内容等信息给SMTP服务器；</p><p>SMTP服务器接收到邮件信息并进行处理；</p><p>SMTP服务器尝试将邮件传送给收件人所在的服务器；</p><p>收件人所在的SMTP服务器接收到邮件并进行处理；</p><p>SMTP服务器向邮件客户端发送邮件状态代码，表示邮件发送是否成功；</p><p>邮件客户端关闭与SMTP服务器的连接。</p><p>2） 观察 SMTP 命令消息和响应状态码，自己查资料理解命令和状态码的功能，并画出一次完整通信过程所对应的消息序列图。 </p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps14-1690805315179-14.jpg" alt="img"> </p><p>由抓包可知，流程图为：</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps15-1690805315179-15.jpg" alt="img"> </p><h1 id="四-实验结论和实验心得"><a href="#四-实验结论和实验心得" class="headerlink" title="四 实验结论和实验心得"></a>四 实验结论和实验心得</h1><p>问题1：虚拟机中不知道哪个是正在传输数据</p><p>解决把所有接口都选上</p><p>问题2：实验三无法完成一直报错:</p><p>解决：要在邮箱开启相应smtp服务，输入密码时输入授权时的编码</p><p>心得：本次实验让我更加了解了计算机网络，深入了解计算机网络典型的应用层协议——HTTP 和 SMTP。</p>]]></content>
    
    
    <summary type="html">使用 Wireshark 软件捕获 HTTP/SMTP 消息，分析其消息头</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="计算机网络实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="计算机网络实验" scheme="https://zhangyuanhe.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>支持Web Mail的SMTP邮件服务器</title>
    <link href="https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/computer_network/CN2/"/>
    <id>https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/computer_network/CN2/</id>
    <published>2023-07-30T01:00:00.000Z</published>
    <updated>2023-07-31T14:34:02.724Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="一-实验内容"><a href="#一-实验内容" class="headerlink" title="一 实验内容"></a>一 实验内容</h1><ol><li>作为 Web 服务器，接收浏览器的 TCP 连接请求， 接收 HTTP 命令和邮件数据，将邮件保存在文件中；</li><li>作为SMTP 客户端，建立到实际邮件服务器的TCP 连接，发送 SMTP 命令，将保存的邮件发送给实际邮件服 务器；</li><li>提供发件人和收件人 Email 地址格式检查功能，例 如 下 列 邮 件 地 址 是 错 误 的 ：  chengli ，  chengli@ ， bupt.edu.cn，  … .</li><li>提供邮件差错报告，要求处理两种差错：收件人不 存在、邮件超过规定长度，将差错报告转发给发件人；</li><li>支持一封邮件多个接收者，要求接收者属于不同的 域 (如 bupt.edu.cn、163.com、qq.com, … ) ；</li><li>在命令行窗口显示通信的主要过程，包括：通信对 端的 IP 地址和端口号；发送的消息 (或状态码) 、接收的 消息 (或状态码) 、</li><li>可选功能：支持 SSL 安全连接。</li></ol></blockquote><h1 id="一、实验内容和实验环境描述"><a href="#一、实验内容和实验环境描述" class="headerlink" title="一、实验内容和实验环境描述"></a>一、实验内容和实验环境描述</h1><h2 id="1-实验任务"><a href="#1-实验任务" class="headerlink" title="1.实验任务"></a>1.实验任务</h2><p>1 ) 作为 Web 服务器，接收浏览器的 TCP 连接请求，接收 HTTP 命令和邮 件数据，将邮件保存在文件中；</p><ol start="2"><li>作为 SMTP 客户端，建立到实际邮件服务器的 TCP 连接，发送 SMTP 命令，将保存的邮件发送给实际邮件服务器；</li><li>提供发件人和收件人 Email 地址格式检查功能，例如下列邮件地址是错 误的：chengli ，chengli@ ，bupt.edu.cn ，  … .</li><li>提供邮件差错报告，要求处理两种差错：收件人不存在、邮件超过规定 长度，将差错报告转发给发件人；</li><li>支持一封邮件多个接收者，要求接收者属于不同的域 (如 bupt.edu.cn、 163.com、qq.com, … ) ；</li><li>在命令行窗口显示通信的主要过程，包括：通信对端的 IP 地址和端口号； 发送的消息 (或状态码) 、接收的消息 (或状态码) 、</li><li>可选功能：支持 SSL 安全连接。</li></ol><h2 id="2-实验内容"><a href="#2-实验内容" class="headerlink" title="2.实验内容"></a>2.实验内容</h2><p>实验任务是编写一个邮件服务器程序，使用 SocketAPI 进行开发。该程序 需要作为 Web 服务器接收来自浏览器的TCP 连接请求，接收 HTTP 命令和邮 件数据，并将邮件保存在文件中。同时，作为 SMTP 客户端，它还需要建立到 实际邮件服务器的 TCP 连接，发送 SMTP 命令，将保存的邮件代理转发给实际 邮件服务器。</p><p>该实验的主要功能模块包括：</p><p>Web 服务器代理模块：接收浏览器的 TCP 连接请求，解析 HTTP 命令和邮 件数据，并将邮件保存在文件中。在保存邮件数据后，充当SMTP 客户端的角 色，使用SMTP 命令将保存的邮件数据转发到实际邮件服务器。</p><p>SMTP 客户端模块：建立到实际邮件服务器的 TCP 连接，发送 SMTP 命令，</p><p>将保存的邮件发送给实际邮件服务器。</p><p>地址格式检查模块：对发件人和收件人的 Email 地址进行格式检查，确保地 址的正确性。</p><p>差错处理模块：根据实际邮件服务器的响应码，处理差错情况</p><p>多接收者支持模块：支持一封邮件有多个接收者，且这些接收者属于不同的 域。</p><p>通信显示模块：在命令行窗口显示通信的主要过程，包括通信对端的 IP 地 址和端口号，发送的消息 (或状态码) 、接收的消息 (或状态码) 。</p><h2 id="3-实验环境"><a href="#3-实验环境" class="headerlink" title="3.实验环境"></a>3.实验环境</h2><p>操作系统：Windows</p><p>编程语言和库：C++和 Python ，需要安装相应的编译器和 Python 解 释 器 。 并 且 需 要 安 装 所 需 的 第 三 方 库 ，  可 以 使 用 pip  install -r requirements.txt 命令安装。</p><p>网络通信：程序需要与服务器进行 TCP&#x2F;IP 通信，确保网络连接正常， 并且可以访问目标服务器。</p><p>网络信息获取：程序需要获取本地网络信息，确保能够正常获取网卡 和 IP 地址。</p><p>线程支持：程序使用了多线程，确保操作系统支持多线程并设置合适 的线程数。</p><h1 id="二、软件设计"><a href="#二、软件设计" class="headerlink" title="二、软件设计"></a>二、软件设计</h1><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h2><p>C++ 代码中主要有以下结构体&#x2F;类：</p><p>enum class TcpStatus</p><p>这个枚举类定义了TCP 连接的所有状态，其含有如下成员。 OK &#x3D; 0x00,</p><p>Closed &#x3D; 0x01,</p><p>WsaStartupFailed &#x3D; 0xFE,</p><p>GetAddrInfoFailed &#x3D; 0xFD,</p><p>SocketFailed &#x3D; 0xFB,</p><p>ConnServerFailed &#x3D; 0xF7,</p><p>RecvFailed &#x3D; 0xEF,</p><p>SendFailed &#x3D; 0xDF,</p><p>ShutdownFailed &#x3D; 0xBF,</p><p>UnknownError &#x3D; 0xFF,</p><p>class ClientTcp</p><p>这个类对 Winsock 2  提供的 socket 接口进行封装，用于进行客户端的 TCP 连接。其含有如下成员变量。</p><p>WSADATAwsaData;</p><p>SOCKET ConnectSocket;</p><p>struct addrinfo* result, * ptr, hints;</p><p>int iResult;</p><p>char* recvbuf;</p><p>size_t buflen;</p><p>std::function&lt;void(const char*)&gt; log;</p><p>TcpStatus status;</p><p>std::string status_info;</p><p>其中，wsaData ，ConnectSocket ，result ，ptr，hints 用于 socket 的构造， iResult 存储 socket 相关函数的返回值，recvbuf 作为接收 socket 数据的缓冲区， buflen 定义了动态分配缓冲区的长度，log 用于出错时回调输出信息，status ， status_info 用于向上层提供状态信息。</p><p>enum class SmtpReplyCode</p><p>这个枚举类定义了SMTP 所有可能的状态码。其含有如下成员。</p><p>CmdSyntaxErr &#x3D; 500,</p><p>ParamSyntaxErr &#x3D; 501,</p><p>CmdNotImpl &#x3D; 502,</p><p>BadCmdSeq &#x3D; 503,</p><p>ParamNotImpl &#x3D; 504,</p><p>SysStatus &#x3D; 211,</p><p>HelpMsg &#x3D; 214,</p><p>ServiceReady &#x3D; 220,</p><p>ServiceClosing &#x3D; 221,</p><p>ServiceUnavailable &#x3D; 421,</p><p>Completed &#x3D; 250,</p><p>Forward &#x3D; 251,</p><p>UnverifiedAccept &#x3D; 252,</p><p>UnableAccommodateParam &#x3D; 455,</p><p>MailParamNotImpl &#x3D; 555,</p><p>TransientMailboxUnavailable &#x3D; 450,</p><p>PermanentMailboxUnavailable &#x3D; 550,</p><p>ProcessingErr &#x3D; 451,</p><p>UserNotLocal &#x3D; 452,</p><p>InsufficientSysStorage &#x3D; 452,</p><p>ExceededStorageAllocation &#x3D; 552,</p><p>MailboxNotAllowed &#x3D; 553,</p><p>StartingMailInput &#x3D; 354,</p><p>TransactionFailed &#x3D; 554,</p><p>class BasicSmtp</p><p>这个类实现了基础的SMTP 客户端功能。其含有如下成员变量。 ClientTcp* tcp_conn;</p><p>SmtpStatus status;</p><p>SmtpReplyCode reply_code;</p><p>std::string reply_msg;</p><p>std::function&lt;void(const char*)&gt; log &#x3D; NULL;</p><p>std::string info;</p><p>其 中 ，tcp_conn 用于 TCP 连接 ，status 记录 当前 SMTP 连接状态 ， reply_code 与 reply_msg 记录服务器传回的消息，log 回调函数用于日志记录， info 用于与上层模块通信。</p><p>Python 代码中主要有以下类：</p><p>HttpRequestPacket</p><p>用于解析与储存收到的 HTTP 报文。其含有如下成员变量。</p><p>req_line：请求行</p><p>method：HTTP 方法</p><p>req_uri：HTTP 请求地址</p><p>version：HTTP 版本号</p><p>req_header：请求标头</p><p>headers：解析的标头字典</p><p>host：主机地址</p><p>req_data：请求数据</p><h2 id="2-模块结构"><a href="#2-模块结构" class="headerlink" title="2.模块结构"></a>2.模块结构</h2><p>如下图</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps1.png" alt="img"> </p><h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3.算法流程"></a>3.算法流程</h2><p>如上图</p><h2 id="4-主要功能模块的实现要点"><a href="#4-主要功能模块的实现要点" class="headerlink" title="4. 主要功能模块的实现要点"></a>4. 主要功能模块的实现要点</h2><h3 id="4-1-代理"><a href="#4-1-代理" class="headerlink" title="4.1 代理"></a>4.1 代理</h3><p>接收 HTTP 传入请求。对于 HTTP 连接，需要正确转发至目的地。对于 HTTPS 连接，需要为其建立专门的 TCP 连接。检测到疑似为 Webmail 的数据 包 (开头为 “POST <a href="http://mail.qq.com/cgi-bin/compose_send">http://mail.qq.com/cgi-bin/compose_send</a>“) 时，需要启动 后续模块的进程。</p><h3 id="4-2-解析包"><a href="#4-2-解析包" class="headerlink" title="4.2 解析包"></a>4.2 解析包</h3><p>需要对传入的数据包进行解析，得到 Webmail 发送的邮件信息。检查是否 有 关 键 字 段 缺 失 ( 发 件 人 “sendmailname” ，  收 件 人 “To” ，  邮 件 正 文 “content__html”) 。若检查无误，则写入文件，启动后续模块的进程。</p><h3 id="4-3-转发邮件"><a href="#4-3-转发邮件" class="headerlink" title="4.3  转发邮件"></a>4.3  转发邮件</h3><p>4.3.1 BasicSmtp 库的 TCP 客户端服务</p><p>该模块实现了一个基本的 TCP 发送客户端，用于转发电子邮件。以下是每 个功能模块的实现要点的总结：</p><p>构造函数和析构函数：</p><p>构造函数初始化了函数 MailProxy::ClientTcp::ClientTcp。初始化构造一个缓 冲区用来存放接收到的信息，同时又定义 log 变量用来存放错误信息。</p><p>析构函数中释放用来存放接受信息的缓冲区。</p><p>record_error()函数：</p><p>用来封装报错反馈功能，由于每个功能模块基本都有报错的可能，重复撰写 报错功能会占用大量空间，因此将其封装。</p><p>tcp_connect()函数：</p><p>TCP 协议链接函数，首先确保所有字段的初始值为 0 ，指定适用于 IPv4 或 IPv6 的地址，指定套接字类型为流式套接字 (TCP) ，指定使用TCP 协议。</p><p>解析服务器的地址和端口。将解析结果存储在指针中，并返回结果代码，循 环遍历解析结果。</p><p>使用socket 函数根据解析结果创建一个套接字。根据 ptr 指针中的地址族、 套接字类型和协议，创建一个用于连接服务器的套接字。</p><p>与服务器建立连接。</p><p>连接成功，跳出循环，完成 TCP 连接的建立。</p><p>tcp_send()函数：</p><p>向服务器发送数据。</p><p>关闭连接套接字，释放与服务器的 TCP 连接。</p><p>将连接套接字设置为无效的套接字，清理使用 Windows 套接字库的资源。 如果发送失败，会记录错误信息，并进行连接和资源的清理操作。</p><p>tcp_receive()函数：</p><p>从服务器接收数据</p><p>将接收到的数据放入缓冲区。</p><p>如果接收失败，会记录错误信息，并进行连接和资源的清理操作。</p><p>tcp_shutdown()函数：</p><p>检查 ConnectSocket 是否为有效的套接字。如果是有效的套接字，表示存 在一个与服务器建立的 TCP 连接，此函数用于判断是否存在连接并对其进行关 闭。</p><p>关闭连接。</p><p>如果关闭失败，会记录错误信息，并进行连接和资源的清理操作。</p><p>get_received()函数：</p><p>读取 received 的取指中存储的内容。</p><p>get_status()函数：</p><p>读取status 的取指中存储的内容。</p><p>get_status_info()函数：</p><p>读取 status_info 的取指中存储的内容。</p><p>4.3.2 BasicSmtp 库的 SMTP 客户端服务</p><p>实现了一个基本的 SMTP 客户端，用于发送电子邮件。以下是每个功能模 块的实现要点的总结：</p><p>构造函数和析构函数：</p><p>构造函数初始化了一个 MailProxy::ClientTcp 对象，并设置了一个 Lambda 函数作为参数，用于处理 TCP 连接的日志输出。</p><p>析构函数发送 QUIT 命令给 SMTP 服务器，接收响应并关闭 TCP 连接</p><p>smtp_login()函数：</p><p>使用给定的服务器地址、用户名和密码进行 SMTP 登录。</p><p>向 SMTP 服务器发送 EHLO 命令以建立与服务器的连接。</p><p>发送 AUTH LOGIN 命令以进行身份验证。</p><p>将用户名和密码以 base64 编码形式发送给服务器。</p><p>检查每个步骤的响应码和响应消息，根据情况设置 SMTP 状态。</p><p>smtp_send()函数：</p><p>发送电子邮件。</p><p>发送 MAIL FROM 命令以设置发件人。</p><p>发送 RCPT TO 命令以设置收件人 (包括 To、Cc 和 Bcc) 。 发送 DATA 命令以指示开始发送邮件内容。</p><p>构建邮件的头部和正文，并将其以字符串形式发送给服务器。 检查每个步骤的响应码和响应消息，根据情况设置 SMTP 状态。</p><p>smtp_send_raw()函数：</p><p>发送原始的电子邮件数据。</p><p>发送 MAIL FROM 命令以设置发件人。</p><p>发送 RCPT TO 命令以设置收件人。</p><p>发送 DATA 命令以指示开始发送邮件内容。</p><p>将原始数据以字符串形式发送给服务器。</p><p>检查每个步骤的响应码和响应消息，根据情况设置 SMTP 状态。</p><p>check_tcp()函数：</p><p>检查 TCP 连接状态，用于确定 TCP 连接是否正常。</p><p>如果连接状态不是 OK ，设置 SMTP 状态为 TcpErr，表明TCP 连接失败， 并返回 false ，否则返回 true。</p><p>check()函数：</p><p>在检查 TCP 连接状态的基础上，提取 SMTP 响应的响应码和响应消息，并 根据响应码判断 SMTP 状态，用于确定SMTP 是否正常。如果响应码以 4 或 5 开头，设置 SMTP 状态为 SmtpErr 并返回 false ，否则返回 true。</p><p>4.3.3 post 主程序</p><p>实现整个邮件发送流程，包括登录、构建邮件、发送和检查响应等。以下是 每个功能模块实现流程的总结：</p><p>构建邮件对象:  提取原始文件内容，构建邮件信息，把发件人、收件人、抄 送、密送、邮件标题和正文等信息作为参数，并根据这些信息创建一个包含邮件 头和内容的字符串。</p><p>编码登录名和授权码：调用 base64_encode 编码登录名和授权码，使用动 态分配的字符数存放登录名和授权码的 Base64  编码</p><p>SMTP 登录操作:  调用smtp_login 函数用于进行 SMTP 服务器的登录操作。 它接受 SMTP 服务器地址、用户名和密码作为参数，并通过建立 TCP 连接和 发送登录命令来完成登录过程。</p><p>发送邮件:  调用 smtp_send_raw 函数用于邮件发送。它接受邮件内容和 SMTP 服务器实例作为参数，并通过与服务器的交互来发送邮件。发送过程包 括发送邮件数据、处理服务器响应以及检查发送状态等步骤。</p><p>检查响应并处理：通过检查服务器的响应，并根据不同的响应状态进行相应 的处理。如果状态为 SmtpErr，输出 SMTP 错误码和错误信息，并发送反馈。 如果状态为 TcpErr ，输出 TCP 服务错误并退出程序。如果状态正常，输出成 功消息表示邮件发布成功。</p><h1 id="三、实验结果演示及分析"><a href="#三、实验结果演示及分析" class="headerlink" title="三、实验结果演示及分析"></a>三、实验结果演示及分析</h1><h2 id="1-功能测试"><a href="#1-功能测试" class="headerlink" title="1.功能测试"></a>1.功能测试</h2><p>代理服务器端查看主机 IP 地址</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps2.png" alt="img"> </p><p>用户端使用网络代理</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps3-1690805636246-1.jpg" alt="img"> </p><p>代理服务器端开启代理服务器</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps4.png" alt="img"> </p><p>代理服务器端打开 wireshark 抓包</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps5-1690805636246-2.jpg" alt="img"> </p><p>用户端发送文件</p><p>发送文件成功，并实现转发功能</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps6.png" alt="img"> </p><p>代理服务器端可以看到邮件已经发送成功</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps7.png" alt="img"> </p><p>代理服务器端查看抓包，查找 HTTP 协议，可以看见发送邮件的内容。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps8.png" alt="img"> </p><p>代理服务器端查看抓包，查找 SMTP 协议，可以看见发送邮件的通信流程。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps9.png" alt="img"> </p><h2 id="2-差错处理"><a href="#2-差错处理" class="headerlink" title="2. 差错处理"></a>2. 差错处理</h2><h3 id="2-1TCP-差错处理"><a href="#2-1TCP-差错处理" class="headerlink" title="2.1TCP 差错处理"></a>2.1TCP 差错处理</h3><p>在 TCP 层的连接和发送中，主要由 record_error()函数封装报错内容。</p><p>record_error()函数接收参数分别用来保存错误状态、错误信息、错误代码， 并将错误信息记录到日志中。同时将错误信息记录格式化后储存，并作为参数传</p><p>递给 log ，以记录错误信息到日志中，便于在后续进行输出。</p><p>差错内容：</p><p>Winsock 初始化失败：WsaStartupFailed ，若在构造函数时网络编程接口 初始化失败报此内容。</p><p>getaddrinfo 失败：  GetAddrInfoFailed ，若在解析服务器的地址和端口时 失败报此内容。</p><p>Socket 初始化失败：SocketFailed ，若在建立接收解析服务器数据的内存 空间时失败报此内容。</p><p>发送数据失败：SendFailed ，在发送 TCP 协议文件时出现问题报此内容。 接收数据失败：RecvFailed ，在接收 TCP 协议文件时出现问题报此内容。 关闭连接失败：ShutdownFailed ，在关闭 TCP 连接时出现问题报此内容。 未知错误：UnknownError 在流程中出现其他未知错误时报此内容。</p><h3 id="2-2-SMTP-差错处理"><a href="#2-2-SMTP-差错处理" class="headerlink" title="2.2 SMTP 差错处理"></a>2.2 SMTP 差错处理</h3><p>在 SMTP 应用层，SMTP 差错处理的检查函数主要是 check_tcp()和 check()。 实现根据服务器的响应判断是否出现 TCP 错误或 SMTP 错误，并根据情况设置 相应的状态。这样可以根据 SMTP 状态来执行相应的处理逻辑，如输出错误信 息或成功消息。</p><p>针对邮件检验主要是 check_email_addr()函数，对基本的邮件地址验证， 以确保在发送邮件或处理邮件时使用的地址是有效的和合法的</p><p>check_tcp() 函 数 ： 用 于 检 查 TCP 连 接 的 状 态 ， 如 果 连 接 状 态 不 是 TcpStatus::OK ，则将 SMTP 状态设置为 SmtpStatus::TcpErr 并返回 false。</p><p>check()函数：首先通过 tcp_conn-&gt;get_received()获取服务器的响应消息。 然后从响应消息中截取出响应码 code 和响应信息 reply_msg 。将响应码转换为 枚举类型，并将其赋值给 reply_code 成员变量。接下来，根据响应码的第一位 数字判断 SMTP 状态。如果是以 4 或 5 开头的响应码，认为是 SMTP 错误，将 SMTP 状态设置为 SmtpErr 并返回false 。否则，将 SMTP 状态设置为 OK。</p><p>check_email_addr()函数：检查给定的邮件地址是否符合标准的电子邮件地 址格式。通过使用正则表达式来验证邮件地址是否满足特定的模式。该正则表达 式模式包含了电子邮件地址的各个部分，如用户名部分、域名部分等。它对地址 的格式进行了详细的验证，包括以下几个方面：</p><p>用户名部分可以包含字母、数字以及一些特定的符号，如点号、加号、减号、 下划线等。</p><p>域名部分可以是一个 IP 地址，形如 [x.x.x.x] ，也可以是一个域名，形如 example.com。</p><p>域名部分至少包含两个组成部分，如 example.com，而不是仅有一个部分， 如 example。</p><h3 id="2-3-解析包差错处理"><a href="#2-3-解析包差错处理" class="headerlink" title="2.3 解析包差错处理"></a>2.3 解析包差错处理</h3><p>对于格式不正确的包 (例如qq 邮箱保存至草稿箱的数据包) ，停止后续操 作并输出相关信息。</p><h2 id="2-和课堂上学习的-HTTP协议和SMTP-协议相比，-自制程序的不同之处"><a href="#2-和课堂上学习的-HTTP协议和SMTP-协议相比，-自制程序的不同之处" class="headerlink" title="2. 和课堂上学习的 HTTP协议和SMTP 协议相比， 自制程序的不同之处"></a>2. 和课堂上学习的 HTTP协议和SMTP 协议相比， 自制程序的不同之处</h2><p>HTTP 和 SMTP 协议是互联网中常用的协议，用于在网络中传输数据。它 们是通用协议，可以用来传输 Web 页面、 电子邮件等多种数据。而我们自制程 序只是针对特定邮件进行捕捉并转发成 SMTP 协议文件，对于其他 http 文件仅 进行中转功能。</p><p>在学习中，HTTP 和SMTP 协议是已经定义好的协议，有标准规范和实现。 而自制程序并没有封装好，需要定义自己的数据格式、错误捕捉等内容，只能在 tcp 基础上自己进行实现。</p><p>HTTP 和 SMTP 协议是复杂的协议，涉及多个不同的请求和响应类型、头 部字段、状态码等细节。我们的程序根据索要实现的功能需求进行了简化。</p><p>总之，学习 HTTP 和 SMTP 协议是了解和理解互联网通信的基本原理，而 自制程序则需要根据具体需求设计和实现自己的通信逻辑和协议。</p><h2 id="3-和实际的-Webmail-及-SMTP-服务器相比，程序的优点和不足"><a href="#3-和实际的-Webmail-及-SMTP-服务器相比，程序的优点和不足" class="headerlink" title="3. 和实际的 Webmail 及 SMTP 服务器相比，程序的优点和不足"></a>3. 和实际的 Webmail 及 SMTP 服务器相比，程序的优点和不足</h2><p>优点：</p><p>1 ) 我们的程序面向邮件转发而开发，对邮件的接收和转发有详细的过程记 录。可以快速发现出现问题的地方，并且保证了一定的安全性。</p><ol start="2"><li>程序可以根据需求进行快速调节。可以根据想要使用进行转发的邮箱进 行更改，快速实现邮件转发功能，避免第三方软件介入，提高了便利性。</li><li>我们的程序可以随时根据需要进行功能扩展，通过各种语言对功能进行 添加。</li></ol><p>不足之处：</p><p>1 ) SMTP 服务和 HTTP 服务具有一定的复杂性。自制程序可能难以达到与</p><p>专业产品相同的复杂程度和稳定性。</p><ol start="2"><li>SMTP 服务器和 Webmail 应用通常大量的身份验证、加密传输等安全措 施。 自制程序的安全性能相对匮乏，容易被攻击。</li><li>实际的 Webmail 和 SMTP 服务器经过广泛测试和兼容性验证，能够在 不同的操作系统和浏览器上正常运行。我们的程序有一定的兼容性问题，在新平 台上运行时还要适当提前进行配置。</li></ol><p>总体而言，我们的程序具有定制性和灵活性等优点，但在复杂性、安全性和 可用性方面还存在一些挑战。</p><h1 id="四、实验总结和心得体会"><a href="#四、实验总结和心得体会" class="headerlink" title="四、实验总结和心得体会"></a>四、实验总结和心得体会</h1><h2 id="1-实际上机调试时间"><a href="#1-实际上机调试时间" class="headerlink" title="1. 实际上机调试时间"></a>1. 实际上机调试时间</h2><p>TCP 实现部分：4h</p><p>SMTP 实现部分：4h</p><p>接受文件实现部分：6h</p><p>接口对接整体调试：5h</p><p>不同平台调试：4h</p><p>总用时：23h</p><h2 id="2-编程工具方面遇到的问题"><a href="#2-编程工具方面遇到的问题" class="headerlink" title="2. 编程工具方面遇到的问题"></a>2. 编程工具方面遇到的问题</h2><p>1 ) 运行 CMAKE 的工具：想运用 CMAKE 用于管理软件项目的构建过程， 后来发现 Developer PowerShell 提供了一个强大的命令行界面，可以很好实现 CMAKE 相关的任务和操作。它使得配置、构建和调试 CMake 项目变得更加方 柏霓，很好的满足了我们的需求</p><ol start="2"><li>在最后代码汇总是使用的是 mac 系统，并且配置了一些代码库环境。后 续在其他电脑编译运行时需要重新配置环境。并根据 Windows 系统进行调整如 更改 Unicode 编码格式。</li></ol><h2 id="3-编程语言方面遇到的问题"><a href="#3-编程语言方面遇到的问题" class="headerlink" title="3. 编程语言方面遇到的问题"></a>3. 编程语言方面遇到的问题</h2><ol><li>C++的 list 容器使用：list 是与数组或向量等其他容器类型有所不同。 一开始缺少对链表结构的认识，对于迭代器的使用不够熟练，通过文档阅读和时</li></ol><p>间逐渐了解。</p><ol start="2"><li>理解 lamba 函数：对 Lambda 函数的参数传递机制不清楚，不知道如 何传递参数给 Lambda 函数或在 Lambda 函数中使用外部参数。通过阅读使用 Lambda 函数的实际示例和代码片段，以便在实际应用中看到它们的用途和优势。</li></ol><h2 id="4-协议方面遇到的问题"><a href="#4-协议方面遇到的问题" class="headerlink" title="4.协议方面遇到的问题"></a>4.协议方面遇到的问题</h2><p>1 ) SMTP 的标准和规范理解：SMTP 的标准文档使用了大量的技术术语和 符号，理解和记忆这些术语需要一定的时间和实践。并且文档详细描述了协议的 各个方面，包括协议的命令、响应、消息格式、状态码等。描述过于细节，一开 始难以找到关键信息。</p><h2 id="5-通过本次试验，你认为-HTTP-协议和SMTP-协议有哪些不足？有何改进思路？"><a href="#5-通过本次试验，你认为-HTTP-协议和SMTP-协议有哪些不足？有何改进思路？" class="headerlink" title="5. 通过本次试验，你认为 HTTP 协议和SMTP 协议有哪些不足？有何改进思路？"></a>5. 通过本次试验，你认为 HTTP 协议和SMTP 协议有哪些不足？有何改进思路？</h2><h3 id="5-1-不足"><a href="#5-1-不足" class="headerlink" title="5.1 不足"></a>5.1 不足</h3><ol start="5"><li>1.1 HTTP 不足</li></ol><p>明文传输：HTTP 协议默认使用明文传输，容易被窃听和篡改，缺乏安全性。 无状态性：HTTP 协议是无状态的，服务器无法保留客户端的状态信息。</p><p>安全性问题：HTTP 协议本身没有内置的身份验证和授权机制，容易受到中 间人攻击和伪造请求。</p><ol start="5"><li>1.2 SMTP 不足</li></ol><p>明文传输：SMTP 协议默认使用明文传输，邮件内容和身份信息容易被窃听 和篡改。</p><p>垃圾邮件问题：SMTP 协议没有内置的垃圾邮件过滤机制，容易受到垃圾邮 件的滥用。</p><p>可信度和可靠性问题：SMTP 协议的可信度和可靠性较低，邮件可能会丢失、 延迟或被拒绝。</p><p>缺乏身份验证：SMTP 协议没有强制的身份验证机制，允许匿名发送邮件。</p><h3 id="5-2-改进思路"><a href="#5-2-改进思路" class="headerlink" title="5.2 改进思路"></a>5.2 改进思路</h3><p>5.2.1 HTTP 改进</p><p>针对明文传输问题：使用传输层安全性协议 (TLS) 来加密通信，利用对称 加密，客户端和服务器协商一个共享的对称密钥，该对称密钥用于加密和解密数 据。结合非加密服务器持有私钥，用于解密客户端发来的对称密钥，而客户端持 有服务器的公钥，用于加密对称密钥和加密通信内容。 比如现在广泛使用的 HTTPS 协议。</p><p>针对无状态性问题：可以引入会话管理机制，如引入会话标识符来跟踪客户 端状态，减轻服务器负担。 比如服务器在客户端首次请求时创建一个唯一的 Session 标识符，并将该标识符发送给客户端，通常通过 Cookie 进行存储。客 户端在后续的请求中会携带该 Session 标识符，服务器根据标识符查找对应的会 话信息，恢复客户端的状态。</p><p>针对安全性问题：可以引入更强大的身份验证和授权机制，如使用令牌、数 字签名等来确保请求的合法性和安全性。比如在与服务器建立 TLS 连接时，验 证服务器提供的数字证书的有效性和合法性，进行身份认证。</p><p>5.2.2 SMTP 改进</p><p>针对明文传输问题：可以通过使用加密算法来保护数据的机密性和完整性， 如 SMTP over SSL&#x2F;TLS (SMTPS) 等命令来保护通信的安全性。可以在建立 SMTP 连接之后，通过 SSL&#x2F;TLS 协议与服务器进行握手，建立安全的加密通道。</p><p>针对垃圾邮件问题：可以引入更强大的反垃圾邮件技术，如使用黑名单、白 名单、内容过滤等来过滤和拦截垃圾邮件。</p><p>针对可信度和可靠性问题：可以引入更可靠的投递和排队机制，如使用消息 队列或可靠的SMTP 代理来提高邮件的传递率和可靠性。</p><p>针对缺乏身份验证问题：可以引入强制的身份验证机制，如使用 SMTP 认 证或 DKIM 等技术来验证发件人的身份。</p><h2 id="6-实验总结"><a href="#6-实验总结" class="headerlink" title="6. 实验总结"></a>6. 实验总结</h2><p>这个实验加深了我对网络通信和协议的理解，提高了我的编程和软件设计能</p><p>力，培养了我解决问题和进行项目开发的能力，增强团队协作能力，和队友间建 立了深厚的友谊。</p><p>SOCKET 机制方面： 通过实现 TCP 连接和 SMTP 发送功能 ，我们对</p><p>SOCKET 机制有了更深入的理解。学会了如何建立和管理 TCP 连接，如何使用 SOCKET API 进行数据的发送和接收， 以及如何处理连接错误和异常情况。这 使我对网络通信的底层机制有了更全面的了解。</p><p>协议软件设计方面：在实现代理和 SMTP 发送功能的过程中，我们学会了 如何设计和实现协议软件。我们需要考虑协议的各个方面，包括命令和响应的格 式、状态管理、错误处理等，学会了将协议规范转化为可执行的代码，并进行测 试和调试，以确保软件的正确性和稳定性。</p><p>理论学习方面：通过这个实验，我们对网络通信和电子邮件协议的理论知识 有了更深入的了解。我们学习了 TCP&#x2F;IP 协议栈的工作原理，了解了SMTP 协议 的基本原理和命令格式。这使我们能够更好地理解实验中涉及的概念和技术，并 能够将理论知识应用到实际项目中。</p><p>软件工程方面：在实现这个实验的过程中，我们锻炼了软件工程方面的能力， 学会了进行需求分析和设计，合理划分模块和函数，编写可读性和可维护性高的 代码，进行单元测试和集成测试，以及进行错误处理和异常处理。我相信这些软 件工程的技能对于未来发展将会发挥至关重要的作用。</p><p>团队协作方面：在团队中，我们需要进行频繁的沟通与协调，共享信息和进 展，解决问题和取得共识。每个成员负责实现特定的功能模块。我们确保彼此之 间的工作是互相协调和兼容的，并及时进行交流和整合，共同努力找到最佳的解 决方案。让我们进一步认识到团队协作的伟力，增强了团队协作能力。</p>]]></content>
    
    
    <summary type="html">使用Socket API编写一个邮件服务器程序，该程序使用HTTP接收来自浏览器客户端的邮件，并使用SMTP转发到实际的接收邮件服务器的用户邮箱</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="计算机网络实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="计算机网络实验" scheme="https://zhangyuanhe.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>组合逻辑实验报告</title>
    <link href="https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/digital_logic/DL1/"/>
    <id>https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/digital_logic/DL1/</id>
    <published>2023-07-30T01:00:00.000Z</published>
    <updated>2023-07-31T14:34:11.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验一-8421码和格雷码的转换"><a href="#实验一-8421码和格雷码的转换" class="headerlink" title="实验一   8421码和格雷码的转换"></a>实验一   8421码和格雷码的转换</h1><h2 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、 实验内容"></a><strong>一、</strong> 实验内容</h2><p>利用 VHDL 语言设计一个 4 位 8421 码到 4 位格雷码的编码器。 </p><p>使用波形图仿真验证其功能。</p><h2 id="二、-设计过程"><a href="#二、-设计过程" class="headerlink" title="二、 设计过程"></a><strong>二、</strong> 设计过程</h2><p><img src="D:\my_data\blog\zyhblog-img\wps7.jpg" alt="img"> </p><p><img src="D:\my_data\blog\zyhblog-img\wps8.jpg" alt="img"> </p><h2 id="三、-源代码"><a href="#三、-源代码" class="headerlink" title="三、 源代码"></a><strong>三、</strong> 源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">library ieee;</span><br><span class="line">use ieee.std_logic_1164.all;</span><br><span class="line">entity combination1 is</span><br><span class="line">port(a:in std_logic_vector (3 downto 0);</span><br><span class="line">  b:out std_logic_vector (3 downto 0));</span><br><span class="line">end entity combination1;</span><br><span class="line">architecture a of combination1 is</span><br><span class="line">begin </span><br><span class="line">b(0) &lt;= a(0);</span><br><span class="line">b(1) &lt;= a(0) xor a(1); </span><br><span class="line">b(2) &lt;= a(1) xor a(2);</span><br><span class="line">b(3) &lt;= a(2) xor a(3);</span><br><span class="line">end architecture;</span><br></pre></td></tr></table></figure><h2 id="四、-仿真验证与实验结果"><a href="#四、-仿真验证与实验结果" class="headerlink" title="四、 仿真验证与实验结果"></a><strong>四、</strong> 仿真验证与实验结果</h2><p><img src="D:\my_data\blog\zyhblog-img\wps9.jpg" alt="img"> </p><p>由电路可以看出，满足真值表所要求效果。</p><h1 id="实验二-数值比较器"><a href="#实验二-数值比较器" class="headerlink" title="实验二 数值比较器"></a>实验二 数值比较器</h1><h2 id="一、-实验内容-1"><a href="#一、-实验内容-1" class="headerlink" title="一、 实验内容"></a><strong>一、</strong> 实验内容</h2><p>数值比较器是对两个位数相同的二进制数进行比较并判定其大小关系的算术运算电路。 </p><p>使用 if 语句编写对两个 4 位二进制数进行比较的 VHDL 程序，其中 A 和 B 分别是参与比较的两个 4 位二进制数，YA、YB、YC 是用来分别表示 A&gt;B、A&lt;B、A&#x3D;B 的 3 个输出端。 </p><p>使用波形图仿真验证其功能。</p><h2 id="二、-设计过程-1"><a href="#二、-设计过程-1" class="headerlink" title="二、 设计过程"></a><strong>二、</strong> 设计过程</h2><p>设计两个输入变量的比较器，只需将大于等于小于分三种情况输出即可。</p><h2 id="三、-源代码-1"><a href="#三、-源代码-1" class="headerlink" title="三、 源代码"></a><strong>三、</strong> 源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">library ieee;</span><br><span class="line">use ieee.std_logic_1164.all;</span><br><span class="line">entity combination2 is</span><br><span class="line">port(a,b:in std_logic_vector(3 downto 0);</span><br><span class="line">y1,y2,y3:out std_logic);</span><br><span class="line">end entity combination2;</span><br><span class="line">architecture b of combination2 is</span><br><span class="line">begin</span><br><span class="line">process(a,b)</span><br><span class="line">begin</span><br><span class="line">if(a&gt;b)then </span><br><span class="line">y1 &lt;= &#x27;1&#x27;;</span><br><span class="line">y2 &lt;= &#x27;0&#x27;;</span><br><span class="line">y3 &lt;= &#x27;0&#x27;;</span><br><span class="line">elsif(a=b)then</span><br><span class="line">y1 &lt;= &#x27;0&#x27;;</span><br><span class="line">y2 &lt;= &#x27;1&#x27;;</span><br><span class="line">y3 &lt;= &#x27;0&#x27;;</span><br><span class="line">elsif(a&lt;b)then</span><br><span class="line">y1 &lt;= &#x27;0&#x27;;</span><br><span class="line">y2 &lt;= &#x27;0&#x27;;</span><br><span class="line">y3 &lt;= &#x27;1&#x27;;</span><br><span class="line">end if;</span><br><span class="line">end process;</span><br><span class="line">end architecture;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、-仿真验证与实验结果-1"><a href="#四、-仿真验证与实验结果-1" class="headerlink" title="四、 仿真验证与实验结果"></a><strong>四、</strong> 仿真验证与实验结果</h2><p><img src="D:\my_data\blog\zyhblog-img\wps10.jpg" alt="img"> </p><p>为验证实验结果，采用a从0000累加1，b从0000累加4的方法，对比a、b的大小。其中可以观察到，0111|0011时大于端输出1；0100|0100时等于端输出1；0001|0101时小于端，说明实验成功。</p><h1 id="实验三-全加器"><a href="#实验三-全加器" class="headerlink" title="实验三 全加器"></a>实验三 全加器</h1><h2 id="一、实验内容"><a href="#一、实验内容" class="headerlink" title="一、实验内容"></a>一、实验内容</h2><p>把加数、被加数和低位进位逻辑三者加起来的电路称为全加器。其逻辑表达式为 </p><p>Si&#x3D;Ai⊕Bi⊕Ci-1，Ci&#x3D;(Ai⊕Bi)Ci-1+ AiBi。其真值表如下表所示。 </p><p><img src="D:\my_data\blog\zyhblog-img\wps11.jpg" alt="img"> </p><p>根据全加器的电路图和真值表，设计一个 VHDL 程序实现全加器。使用波形图仿真验 </p><p>证其功能</p><h2 id="二、设计过程"><a href="#二、设计过程" class="headerlink" title="二、设计过程"></a>二、设计过程</h2><p>逻辑表达式已经给出，根据给定逻辑表达式设计电路即可。</p><h2 id="三、源代码"><a href="#三、源代码" class="headerlink" title="三、源代码"></a>三、源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">library ieee;</span><br><span class="line">use ieee.std_logic_1164.all;</span><br><span class="line">entity combination3 is</span><br><span class="line">port(a,b,c:in std_logic;</span><br><span class="line">co,so:out std_logic);</span><br><span class="line">end combination3;</span><br><span class="line">architecture a of combination3 is</span><br><span class="line">begin</span><br><span class="line">so&lt;=a xor b xor c;</span><br><span class="line">co&lt;=((a xor b)and c)or(a and b);</span><br><span class="line">end architecture;</span><br></pre></td></tr></table></figure><h2 id="四、-仿真验证与实验结果-2"><a href="#四、-仿真验证与实验结果-2" class="headerlink" title="四、 仿真验证与实验结果"></a><strong>四、</strong> 仿真验证与实验结果</h2><p><img src="D:\my_data\blog\zyhblog-img\wps12.jpg" alt="img"> </p><p>图中各种情况均以表现出来，数值与真值表中相同，说明实验成功。</p><h1 id="实验四-3-线-8线译码器"><a href="#实验四-3-线-8线译码器" class="headerlink" title="实验四  3 线-8线译码器"></a>实验四  3 线-8线译码器</h1><h2 id="一、实验内容-1"><a href="#一、实验内容-1" class="headerlink" title="一、实验内容"></a>一、实验内容</h2><p>译码器是一个多输入、多输出的组合逻辑电路。它的作用是把给定的代码进行“翻译”， </p><p>变成相应的状态，使输出通道中相应的一路有信号输出。译码器在数字系统中有广泛的用途， </p><p>不仅用于代码的转换、终端的数字显示，还用于数据分配、存储器寻址和组合控制信号等， </p><p>不同的功能可选用不同种类的译码器。 </p><p>译码器可分为通用译码器和数码显示译码器两大类，前者又分为变量译码器和代码变换 </p><p>译码器。 </p><p>描述一个 3 线-8 线译码器，使能端为 G1、G2A、G2B，地址选择端为 A[2..0]，输出端 </p><p>为总线 Y。</p><p><img src="D:\my_data\blog\zyhblog-img\wps13.jpg" alt="img"> </p><h2 id="二、设计过程-1"><a href="#二、设计过程-1" class="headerlink" title="二、设计过程"></a>二、设计过程</h2><p>根据给出的真值表，用 case 语句描述电路，利用真值表辅助，使用 VHDL 语言编写出程序。使用波形图仿真验证其功能。</p><h2 id="三、源代码-1"><a href="#三、源代码-1" class="headerlink" title="三、源代码"></a>三、源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">library ieee;</span><br><span class="line">use ieee.std_logic_1164.all;</span><br><span class="line">entity combination4 is</span><br><span class="line">port(G1,G2a,G2b:in std_logic;</span><br><span class="line">A:in std_logic_vector(2 downto 0);</span><br><span class="line">Y:out std_logic_vector(7 downto 0));</span><br><span class="line">end entity combination4;</span><br><span class="line">architecture a of combination4 is</span><br><span class="line">begin</span><br><span class="line">process(A,G1,G2a,G2b)</span><br><span class="line">begin</span><br><span class="line">if(G1=&#x27;1&#x27; and G2a=&#x27;1&#x27; and G2b=&#x27;1&#x27;)then</span><br><span class="line">case A is</span><br><span class="line">when &quot;000&quot;=&gt;Y&lt;=&quot;00000001&quot;;</span><br><span class="line">when &quot;001&quot;=&gt;Y&lt;=&quot;00000010&quot;;</span><br><span class="line">when &quot;010&quot;=&gt;Y&lt;=&quot;00000100&quot;;</span><br><span class="line">when &quot;011&quot;=&gt;Y&lt;=&quot;00001000&quot;;</span><br><span class="line">when &quot;100&quot;=&gt;Y&lt;=&quot;00010000&quot;;</span><br><span class="line">when &quot;101&quot;=&gt;Y&lt;=&quot;00100000&quot;;</span><br><span class="line">when &quot;110&quot;=&gt;Y&lt;=&quot;01000000&quot;;</span><br><span class="line">when &quot;111&quot;=&gt;Y&lt;=&quot;10000000&quot;;</span><br><span class="line">end case;</span><br><span class="line">else</span><br><span class="line">y&lt;=&quot;00000000&quot;;</span><br><span class="line">end if;</span><br><span class="line">end process;</span><br><span class="line">end architecture;</span><br></pre></td></tr></table></figure><h2 id="四、-仿真验证与实验结果-3"><a href="#四、-仿真验证与实验结果-3" class="headerlink" title="四、 仿真验证与实验结果"></a><strong>四、</strong> 仿真验证与实验结果</h2><p><img src="D:\my_data\blog\zyhblog-img\wps14.jpg" alt="img"> </p><p>从波形图可以看出输出Y和输入的三位二进制数一一对应，功能实现。</p><h1 id="实验五表决器"><a href="#实验五表决器" class="headerlink" title="实验五表决器"></a>实验五表决器</h1><h2 id="一、实验内容-2"><a href="#一、实验内容-2" class="headerlink" title="一、实验内容"></a>一、实验内容</h2><p>用 VHDL 语言设计实现一个 4 人表决器，多数人赞成决议表示通过，否则决议不通过。 </p><p>使用波形图仿真验证其功能。</p><h2 id="二、设计过程-2"><a href="#二、设计过程-2" class="headerlink" title="二、设计过程"></a>二、设计过程</h2><p><img src="D:\my_data\blog\zyhblog-img\wps15.jpg" alt="img"> </p><p>得Y&#x3D;A1A2A3+A2A3A4+A1A2A4+A1A3A4+A1A2A3A4</p><h2 id="三、源代码-2"><a href="#三、源代码-2" class="headerlink" title="三、源代码"></a>三、源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">library ieee;</span><br><span class="line">use ieee.std_logic_1164.all;</span><br><span class="line">entity combination5 is</span><br><span class="line">port(A:in std_logic_vector(3 downto 0);</span><br><span class="line">Y:out std_logic);</span><br><span class="line">end combination5;</span><br><span class="line">architecture a of combination5 is</span><br><span class="line">begin</span><br><span class="line">Y&lt;=(A(0) and A(1) and A(2)) or (A(0) and A(1) and A(3)) or (A(0) and A(3) and A(2)) or (A(3) and A(1) and A(2)) or (A(0) and A(1) and A(2) and A(3));</span><br><span class="line">end architecture;</span><br></pre></td></tr></table></figure><h2 id="四、-仿真验证与实验结果-4"><a href="#四、-仿真验证与实验结果-4" class="headerlink" title="四、 仿真验证与实验结果"></a><strong>四、</strong> 仿真验证与实验结果</h2><p><img src="D:\my_data\blog\zyhblog-img\wps16.jpg" alt="img"> </p><p>如图中信号，当输入用两个以上为1时，输出为1，满足题目要求。</p>]]></content>
    
    
    <summary type="html">组合逻辑部分五个实验</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字逻辑" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字逻辑实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>时序逻辑实验报告</title>
    <link href="https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/digital_logic/DL2/"/>
    <id>https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/digital_logic/DL2/</id>
    <published>2023-07-30T01:00:00.000Z</published>
    <updated>2023-07-31T14:34:16.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验一-序列检测器"><a href="#实验一-序列检测器" class="headerlink" title="实验一 序列检测器"></a>实验一 序列检测器</h1><h2 id="一、实验内容"><a href="#一、实验内容" class="headerlink" title="一、实验内容"></a>一、实验内容</h2><p>设计一个序列检测器检测序列 1110010。使用波形图进行仿真（至少要有一个检测成功 </p><p>的波形）。 </p><h2 id="二、设计过程"><a href="#二、设计过程" class="headerlink" title="二、设计过程"></a>二、设计过程</h2><p>每输入一个序列 1110010 则会在输出端输出一个 1，其余时间为 0。 </p><p>首先写出状态转移图，再利用 case 语句，根据状态转移图写出状态的转移及输出。 </p><p>检测序列为七位，所以可以设状态机状态数为 8 个； </p><p>输出信号由当前状态和输入条件决定，设计为 mealy 型状态机或 moore 型状态机，采用 </p><p>异步复位</p><p><img src="D:\my_data\blog\zyhblog-img\wps17.jpg" alt="img"> </p><h2 id="三、源代码"><a href="#三、源代码" class="headerlink" title="三、源代码"></a>三、源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">library ieee;</span><br><span class="line">use ieee.std_logic_1164.all;</span><br><span class="line">use ieee.std_logic_unsigned.all;</span><br><span class="line">entity sequence1 is</span><br><span class="line">port(cl,i,reset:in std_logic;</span><br><span class="line">o: out std_logic);</span><br><span class="line">end sequence1;</span><br><span class="line"></span><br><span class="line">architecture a of sequence1 is</span><br><span class="line">type mytype is (A,B,C,D,E,F,G,H);</span><br><span class="line">signal ty:mytype;</span><br><span class="line">begin</span><br><span class="line">process(cl,reset)</span><br><span class="line">begin</span><br><span class="line">if reset=&#x27;0&#x27; then</span><br><span class="line">ty&lt;=A;</span><br><span class="line">elsif cl&#x27;event and cl=&#x27;1&#x27; then</span><br><span class="line">case ty is</span><br><span class="line">when A=&gt;if i=&#x27;1&#x27; then ty&lt;=B;end if;</span><br><span class="line">when B=&gt;if i=&#x27;1&#x27; then ty&lt;=C;</span><br><span class="line">else ty&lt;=A;end if;</span><br><span class="line">when C=&gt;if i=&#x27;1&#x27; then ty&lt;=D;</span><br><span class="line">else ty&lt;=A;end if;</span><br><span class="line">when D=&gt;if i=&#x27;0&#x27; then ty&lt;=E;</span><br><span class="line">else ty&lt;=B;end if;</span><br><span class="line">when E=&gt;if i=&#x27;0&#x27; then ty&lt;=F;</span><br><span class="line">else ty&lt;=B;end if;</span><br><span class="line">when F=&gt;if i=&#x27;1&#x27; then ty&lt;=G;</span><br><span class="line">else ty&lt;=A;end if;</span><br><span class="line">when G=&gt;if i=&#x27;0&#x27; then ty&lt;=H;</span><br><span class="line">else ty&lt;=B;end if;</span><br><span class="line">when H=&gt;if i=&#x27;1&#x27; then ty&lt;=B;</span><br><span class="line">else ty&lt;=A;end if;</span><br><span class="line">end case;</span><br><span class="line">end if;</span><br><span class="line">end process;</span><br><span class="line">output_p:</span><br><span class="line">process(ty)</span><br><span class="line">begin</span><br><span class="line">case ty is</span><br><span class="line">when H=&gt;o&lt;=&#x27;1&#x27;;</span><br><span class="line">when others=&gt;o&lt;=&#x27;0&#x27;;</span><br><span class="line">end case;</span><br><span class="line">end process;</span><br><span class="line">end architecture;</span><br></pre></td></tr></table></figure><h2 id="四、仿真验证与实验结果"><a href="#四、仿真验证与实验结果" class="headerlink" title="四、仿真验证与实验结果"></a>四、仿真验证与实验结果</h2><p><img src="D:\my_data\blog\zyhblog-img\wps18.jpg" alt="img"> </p><p>从波形图中可以看出输入“1110010”后输出1，当reset为“0”重置时，输出“1”变为“0”。</p><h1 id="实验二-计数器"><a href="#实验二-计数器" class="headerlink" title="实验二 计数器"></a>实验二 计数器</h1><h2 id="一、实验内容-1"><a href="#一、实验内容-1" class="headerlink" title="一、实验内容"></a>一、实验内容</h2><p>计数器是通过电路的状态反映驶入脉冲数目的电路。计数器是应用非常广泛的时序电路， </p><p>按照技术的特点分为二进制计数器、十进制计数器、环形计数器、扭环形计数器等。二进制 </p><p>计数器又分为加计数器、减计数器等。 </p><h2 id="二、设计过程-1"><a href="#二、设计过程-1" class="headerlink" title="二、设计过程"></a>二、设计过程</h2><p>用 VHDL 语言实现计数状态连续的模值为 2N的计数器。这是一个同步清零的 4 为二进 </p><p>制加计数器，其计数的状态是从“0000~1111”进行变化。整个的计数周期是 16 个时钟周期，即 24 个时钟周期。凡是这种技术周期为 2N且对计数状态无特殊要求的计数器，可以通过直接定义 N 位的计数信号和端口，对信号进行加或减操作，而不必进行计数状态的判断和控制。使用波形图进行仿真。</p><h2 id="三、源代码-1"><a href="#三、源代码-1" class="headerlink" title="三、源代码"></a>三、源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">library ieee;</span><br><span class="line">use ieee.std_logic_unsigned.all;</span><br><span class="line">use ieee.std_logic_1164.all;</span><br><span class="line">entity sequence2 is</span><br><span class="line">port(clk:in std_logic;</span><br><span class="line">p:out std_logic;</span><br><span class="line">q:out std_logic_vector(3 downto 0));</span><br><span class="line">end sequence2;</span><br><span class="line">architecture a of sequence2 is</span><br><span class="line">begin</span><br><span class="line">process(clk)</span><br><span class="line">variable x:std_logic_vector(3 downto 0);</span><br><span class="line">begin</span><br><span class="line">if clk&#x27;event and clk=&#x27;1&#x27; then</span><br><span class="line">if x&lt;&quot;1111&quot; then x:=x+1;</span><br><span class="line">else x:=&quot;0000&quot;;</span><br><span class="line">end if;</span><br><span class="line">end if;</span><br><span class="line">if x=&quot;1111&quot; then p&lt;=&#x27;1&#x27;;</span><br><span class="line">else p&lt;=&#x27;0&#x27;;</span><br><span class="line">end if;</span><br><span class="line">q&lt;=x;</span><br><span class="line">end process;</span><br><span class="line">end architecture;</span><br></pre></td></tr></table></figure><p>​</p><h2 id="四、仿真验证与实验结果-1"><a href="#四、仿真验证与实验结果-1" class="headerlink" title="四、仿真验证与实验结果"></a>四、仿真验证与实验结果</h2><p><img src="D:\my_data\blog\zyhblog-img\wps19.jpg" alt="img"> </p><p>实现加一功能，当达到1111时输出为1.</p><h1 id="实验三-8-位寄存器74374"><a href="#实验三-8-位寄存器74374" class="headerlink" title="实验三  8 位寄存器74374"></a>实验三  8 位寄存器74374</h1><h2 id="一、实验内容-2"><a href="#一、实验内容-2" class="headerlink" title="一、实验内容"></a>一、实验内容</h2><p>在数字系统中，寄存器可用来存储一组二进制代码，而触发器具有记忆功能，所以可以 </p><p>用触发器构成寄存器。本实验要求同学们完成 8 位寄存器 74374 的 VHDL 描述。74374 的逻辑框图如下图所示，功能表如下表所示。逻辑框图中 D 为寄存器的 8 位数据输入，Q 位寄存器的 8 位数据输出端，CLK 为时钟信号，OE 为控制信号。从功能表可以看出 OE 为低电平时,在时钟上升沿输入端信号从输出端输出，其他时刻输出保持；而 OE 为高电平时， 输出一直保持为高阻。</p><p><img src="D:\my_data\blog\zyhblog-img\wps20.jpg" alt="img"> </p><h2 id="二、设计过程-2"><a href="#二、设计过程-2" class="headerlink" title="二、设计过程"></a>二、设计过程</h2><p>根据 74374 的逻辑框图和真值表，用 VHDL 语言实现 74374 的功能。并使用波形图进 </p><p>行仿真。</p><h2 id="三、源代码-2"><a href="#三、源代码-2" class="headerlink" title="三、源代码"></a>三、源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">library ieee;</span><br><span class="line">use ieee.std_logic_1164.all;</span><br><span class="line">use ieee.std_logic_unsigned.all;</span><br><span class="line">entity sequence3 is</span><br><span class="line">port(OE,CLK:in std_logic;</span><br><span class="line">D:in std_logic_vector(7 downto 0);</span><br><span class="line">Q:out std_logic_vector(7 downto 0));</span><br><span class="line">end sequence3;</span><br><span class="line">architecture a of sequence3 is</span><br><span class="line">begin</span><br><span class="line">process(CLK,OE,D)</span><br><span class="line">begin</span><br><span class="line">if OE=&#x27;1&#x27; then</span><br><span class="line">Q&lt;=&quot;11111111&quot;;</span><br><span class="line">elsif CLK&#x27;event and CLK=&#x27;1&#x27; then</span><br><span class="line">Q&lt;=D;</span><br><span class="line">end if;</span><br><span class="line">end process;</span><br><span class="line">end architecture;</span><br></pre></td></tr></table></figure><h2 id="四、仿真验证与实验结果-2"><a href="#四、仿真验证与实验结果-2" class="headerlink" title="四、仿真验证与实验结果"></a>四、仿真验证与实验结果</h2><p><img src="D:\my_data\blog\zyhblog-img\wps21.jpg" alt="img"> </p>]]></content>
    
    
    <summary type="html">时序逻辑部分三个实验</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="数字逻辑" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="数字逻辑实验" scheme="https://zhangyuanhe.top/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>c++网络编程传输密文</title>
    <link href="https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/network_attack/NA1/"/>
    <id>https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/network_attack/NA1/</id>
    <published>2023-07-30T01:00:00.000Z</published>
    <updated>2023-08-20T15:07:15.304Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/401296641">了解这几步，教你处理Linux挖矿木马 - 知乎 (zhihu.com)</a></p><p><img src="D:\my_data\blog\zyhblog-img\image-20230820230030521.png" alt="image-20230820230030521"></p><p><img src="D:\my_data\blog\zyhblog-img\image-20230820230112690.png" alt="image-20230820230112690"></p><p><img src="D:\my_data\blog\zyhblog-img\image-20230820230633801.png" alt="image-20230820230633801"><img src="D:\my_data\blog\zyhblog-img\image-20230820230650948.png" alt="image-20230820230650948"><img src="D:\my_data\blog\zyhblog-img\image-20230820230714421.png" alt="image-20230820230714421"></p>]]></content>
    
    
    <summary type="html">使用c/c++进行网络编程，实现两台电脑之间的信息传输</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="网络安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="网络安全实验" scheme="https://zhangyuanhe.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>c++网络编程传输密文</title>
    <link href="https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/network_security/NS1/"/>
    <id>https://zhangyuanhe.top/2023/07/30/Information_Security_Experiment/network_security/NS1/</id>
    <published>2023-07-30T01:00:00.000Z</published>
    <updated>2023-07-31T14:34:25.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-实验内容及原理"><a href="#1-实验内容及原理" class="headerlink" title="1. 实验内容及原理"></a><strong>1.</strong> 实验内容及原理</h1><p>使用c&#x2F;c++进行网络编程，实现两台电脑之间的信息传输</p><h1 id="2-实验环境"><a href="#2-实验环境" class="headerlink" title="2. 实验环境"></a><strong>2.</strong> 实验环境</h1><p><em>（实验拓扑、节点介绍）</em></p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps1-1690797715615-1.jpg" alt="img"> </p><h1 id="3-程序概要设计-或使用的工具介绍"><a href="#3-程序概要设计-或使用的工具介绍" class="headerlink" title="3. 程序概要设计(或使用的工具介绍)"></a><strong>3.</strong> 程序概要设计(或使用的工具介绍)</h1><p>虚拟实验平台、VS编程软件、Xftp传输工具</p><h1 id="4-实验步骤、实验结果、分析"><a href="#4-实验步骤、实验结果、分析" class="headerlink" title="4. 实验步骤、实验结果、分析"></a><strong>4.</strong> 实验步骤、实验结果、分析</h1><p>一：编写两端代码</p><p>发送端代码（client.cpp）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line">\#include &lt;unistd.h&gt;</span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line">\#include &lt;netdb.h&gt;</span><br><span class="line">\#include &lt;sys/types.h&gt;</span><br><span class="line">\#include &lt;sys/socket.h&gt;</span><br><span class="line">\#include &lt;arpa/inet.h&gt;</span><br><span class="line">\#include &lt;string&gt;</span><br><span class="line">\#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  if (argc != 3)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Using:./client ip port\nExample:./client 127.0.0.1 5005\n\n&quot;); return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   // 第1步：创建客户端的socket。</span><br><span class="line">  int sockfd;</span><br><span class="line">  if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) &#123; perror(&quot;socket&quot;); return -1; &#125;</span><br><span class="line"></span><br><span class="line">   // 第2步：向服务器发起连接请求。</span><br><span class="line">  struct hostent* h;</span><br><span class="line">  if ((h = gethostbyname(argv[1])) == 0)  // 指定服务端的ip地址。</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;gethostbyname failed.\n&quot;); close(sockfd); return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  struct sockaddr_in servaddr;</span><br><span class="line">  memset(&amp;servaddr, 0, sizeof(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = htons(atoi(argv[2])); // 指定服务端的通信端口。</span><br><span class="line">  memcpy(&amp;servaddr.sin_addr, h-&gt;h_addr, h-&gt;h_length);</span><br><span class="line">  if (connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) != 0)  // 向服务端发起连接清求。</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;connect&quot;); close(sockfd); return -1;</span><br><span class="line">  &#125;</span><br><span class="line">   char buffer[1024];</span><br><span class="line"> </span><br><span class="line">  // 第3步：与服务端通信，发送一个报文后等待回复，然后再发下一个报文。</span><br><span class="line">  char a[100]=&#123;0&#125;;</span><br><span class="line">  cout &lt;&lt; &quot;please enter the key:&quot;;</span><br><span class="line">  cin.getline(a, 100);</span><br><span class="line">  cout &lt;&lt; &quot;the key is:&quot;&lt;&lt;a;</span><br><span class="line">  int i = 0;</span><br><span class="line">  for (i = 0; i &lt; 100; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    a[i] += 5;</span><br><span class="line">  &#125;</span><br><span class="line">    int iret;</span><br><span class="line">    strcpy(buffer, a);</span><br><span class="line">//    memset(buffer, 0, sizeof(buffer));</span><br><span class="line">    cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    if ((iret = send(sockfd, buffer, strlen(buffer), 0)) &lt;= 0) // 向服务端发送请求报文。</span><br><span class="line">    &#123;</span><br><span class="line">      perror(&quot;send&quot;); //break;</span><br><span class="line">    &#125;</span><br><span class="line">//     printf(&quot;%s\n&quot;, buffer);</span><br><span class="line">     memset(buffer, 0, sizeof(buffer));</span><br><span class="line">    if ((iret = recv(sockfd, buffer, sizeof(buffer), 0)) &lt;= 0) // 接收服务端的回应报文。</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;iret=%d\n&quot;, iret); //break;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;receive:%s\n&quot;, buffer);</span><br><span class="line"></span><br><span class="line">  // 第4步：关闭socket，释放资源。</span><br><span class="line">  close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>接收端代码（servers.cpp）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using:./server port\nExample:./server 5005\n\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第1步：创建服务端的socket。</span></span><br><span class="line">  <span class="type">int</span> listenfd;</span><br><span class="line">  <span class="keyword">if</span> ((listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第2步：把服务端用于通信的地址和端口绑定到socket上。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;   <span class="comment">// 服务端地址信息的数据结构。</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET。</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);      <span class="comment">// 任意ip地址。</span></span><br><span class="line">  <span class="comment">//servaddr.sin_addr.s_addr = inet_addr(&quot;192.168.190.134&quot;); // 指定ip地址。</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));  <span class="comment">// 指定通信端口。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第3步：把socket设置为监听模式。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd, <span class="number">5</span>) != <span class="number">0</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第4步：接受客户端的连接。</span></span><br><span class="line">  <span class="type">int</span> clientfd;          <span class="comment">// 客户端的socket。</span></span><br><span class="line">  <span class="type">int</span> socklen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in); <span class="comment">// struct sockaddr_in的大小</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;  <span class="comment">// 客户端的地址信息。</span></span><br><span class="line">  clientfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, (<span class="type">socklen_t</span>*)&amp;socklen);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;client(%s)has connect.\n&quot;</span>, <span class="built_in">inet_ntoa</span>(clientaddr.sin_addr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第5步：与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;the receive key is:&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iret;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> ((iret = <span class="built_in">recv</span>(clientfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="comment">// 接收客户端的请求报文。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;iret=%d\n&quot;</span>, iret); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      buffer[i] -= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((iret = <span class="built_in">send</span>(clientfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="comment">// 向客户端发送响应结果。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cent:%s\n&quot;</span>, buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第6步：关闭socket，释放资源。</span></span><br><span class="line">  <span class="built_in">close</span>(listenfd); <span class="built_in">close</span>(clientfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二：将编写好的代码通过xftp软件传输到两端的虚拟机中。</p><p>打开接收端虚拟机运行代码，选择合适的端口，我这里使用的是5001。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps2-1690797715615-2.jpg" alt="img"> </p><p>随后进入等待阶段，等待数据传入。</p><p>三：打开发送端虚拟机，同样运行编写好的cpp文件并输入要访问的ip地址和端口</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps3.jpg" alt="img"> </p><p>这样就可以输入要传输的密码了。</p><p>四：输入密码并传输</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps4.jpg" alt="img"><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps5.jpg" alt="img"> </p><p>这时收到接收端返回的ok说明传输成功。</p><p><img src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/wps6.jpg" alt="img"> </p><p>在接收端也可以看见已经被解密的密文。</p><h1 id="5-实现过程中遇到的问题、原因和解决"><a href="#5-实现过程中遇到的问题、原因和解决" class="headerlink" title="5.实现过程中遇到的问题、原因和解决"></a>5.实现过程中遇到的问题、原因和解决</h1><p>编写代码会有困难需要查阅大量相关库文件</p><p>传输信息是容易出错</p><h1 id="6-实验总结"><a href="#6-实验总结" class="headerlink" title="6.实验总结"></a>6.实验总结</h1><p>该实验让我了解了如何使用简易的网络编程，并大概了解了网络编程的原理和TCP协议的三次握手原理。</p>]]></content>
    
    
    <summary type="html">使用c/c++进行网络编程，实现两台电脑之间的信息传输</summary>
    
    
    
    <category term="信安课程实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="网络安全实验" scheme="https://zhangyuanhe.top/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="北邮信安" scheme="https://zhangyuanhe.top/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://zhangyuanhe.top/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="网络安全实验" scheme="https://zhangyuanhe.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
</feed>
