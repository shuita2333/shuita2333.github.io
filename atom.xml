<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZYH&#39;s blog</title>
  
  
  <link href="https://shuita2333.github.io/project/atom.xml" rel="self"/>
  
  <link href="https://shuita2333.github.io/project/"/>
  <updated>2024-07-08T09:03:56.528Z</updated>
  <id>https://shuita2333.github.io/project/</id>
  
  <author>
    <name>Charmes</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pytorch安装全流程</title>
    <link href="https://shuita2333.github.io/project/2024/07/08/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://shuita2333.github.io/project/2024/07/08/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2024-07-08T01:00:00.000Z</published>
    <updated>2024-07-08T09:03:56.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装CUDA"><a href="#一、安装CUDA" class="headerlink" title="一、安装CUDA"></a>一、安装CUDA</h1><h3 id="1-确定是否支持所需的-CUDA-版本"><a href="#1-确定是否支持所需的-CUDA-版本" class="headerlink" title="1.确定是否支持所需的 CUDA 版本"></a>1.确定是否支持所需的 CUDA 版本</h3><p>1.1 终端使用<code>nvidia-smi</code> 右上角即为最高支持版本</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406113619208.png" alt="image-20240406113619208"></p><h3 id="2-下载CUDA"><a href="#2-下载CUDA" class="headerlink" title="2.下载CUDA"></a>2.下载CUDA</h3><p><a href="https://developer.nvidia.com/cuda-downloads">CUDA官方下载地址</a></p><p>2.1 找到对应版本</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406113649698.png" alt="image-20240406113649698"></p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406113701491.png" alt="image-20240406113701491"></p><p>2.2 下载完整文件<br>WIndows -&gt; x86_64 -&gt; 10 -&gt; exe(local)<br>其中 exe(local) 是完整的安装文件，可以离线安装<br>exe(network) 是在线安装</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406113715481.png" alt="image-20240406113715481"></p><h3 id="3-安装-CUDA"><a href="#3-安装-CUDA" class="headerlink" title="3.安装 CUDA"></a>3.安装 CUDA</h3><p>3.1 双击 .exe 文件<br>更改 CUDA 安装时缓存位置（默认为 C盘，不更改也可以，但得与原先安装的 CUDA 的安装缓存位置不同，或者该位置为空）</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406113920494.png" alt="image-20240406113920494"></p><p>3.2 选择自定义安装</p><p>3.3 勾选驱动程序组件<br>由于之前已经安装过 CUDA，此时我们只需要选择 <strong>CUDA</strong> 即可</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406114206693.png" alt="image-20240406114206693"></p><p>3.4 选择安装位置<br>默认安装位置为 C 盘，可以自由选择安装到其他盘，但需要记住安装位置，后期会使用到</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406114859975.png" alt="image-20240406114859975"></p><p>4.环境变量<br>安装 CUDA 时会自动配置环境变量，但如果没有自动配置，则需要手动配置</p><p>4.1 首先打开环境变量<br>右键此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量</p><p>4.2 检查环境变量<br>可以看到在系统变量中多了 CUDA_PATH_V12_1 和 NVCUDASAMPLES12_1_ROOT两个环境变量。如下图：</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406114506433.png" alt="image-20240406114506433"></p><p>系统变量中的 CUDA_PATH 和 NVCUDASAMPLES_ROOT 两个环境变量也发生了改变，从原来的 v11.3 变成了原来的 v12.1。如下图：</p><p>在 Path 中多了两个变量</p><p>4.3 创建环境变量<br>如果没有上述的环境变量，可以根据情况自己添加</p><p>4.3.1 在系统变量中，选择新建</p><p>变量名： CUDA_PATH_V12_1<br>值： D:\CUDA Documentation\NVIDIA GPU Computing Toolkit\CUDA\v12.1（CUDA Documentation 和 CUDA Development 的路径）<br>(12没有下一条)</p><p>变量名： NVCUDASAMPLES12_1_ROOT<br>值： D:\CUDA Documentation\NVIDIA Corporation\CUDA Samples\v12.1（Samples 的路径）</p><p>4.3.2 在系统变量中</p><p>选中 CUDA_PATH ，点击 编辑<br>将值修改为 D:\CUDA Documentation\NVIDIA GPU Computing Toolkit\CUDA\v12.1（CUDA Documentation 和 CUDA Development 的路径）</p><p>选中 NVCUDASAMPLES_ROOT ，点击 编辑<br>将值修改为 D:\CUDA Documentation\NVIDIA Corporation\CUDA Samples\v12.1（Samples 的路径）</p><p>4.3.3 在系统变量的 Path 中，选择新建</p><p>依次加入以下路径：</p><p>CUDA Documentation 和 CUDA Development 的路径下的 bin 文件夹：<br>D:\CUDA Documentation\NVIDIA GPU Computing Toolkit\CUDA\v12.1\bin</p><p>CUDA Documentation 和 CUDA Development 的路径下的 libnvvp 文件夹：<br>D:\CUDA Documentation\NVIDIA GPU Computing Toolkit\CUDA\v12.1\libnvvp</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406115643355.png" alt="image-20240406115643355"></p><h3 id="4-验证安装"><a href="#4-验证安装" class="headerlink" title="4.验证安装"></a>4.验证安装</h3><p>Win + R 打开命令行窗口，输入 nvcc -V，输出 CUDA 版本即为安装成功，如下图：</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406115931285.png" alt="image-20240406115931285"></p><h1 id="二、安装cudnn"><a href="#二、安装cudnn" class="headerlink" title="二、安装cudnn"></a>二、安装cudnn</h1><h3 id="1-下载cudnn"><a href="#1-下载cudnn" class="headerlink" title="1.下载cudnn"></a>1.下载cudnn</h3><p><a href="https://developer.nvidia.com/rdp/cudnn-archive">cudnn官方网址</a></p><p>选择和自己 CUDA 匹配的 cudnn版本下载</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406120201649.png" alt="image-20240406120201649"></p><h3 id="2-替换文件"><a href="#2-替换文件" class="headerlink" title="2.替换文件"></a>2.替换文件</h3><p>2.1 解压文件<br>cudnn下载后是一个压缩包，解压后有以下四个文件：</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406121707784.png" alt="image-20240406121707784"></p><p>2.2 将文件复制到 <strong>D:\CUDA Documentation\NVIDIA GPU Computing Toolkit\CUDA\v12.1（CUDA Documentation 和 CUDA Development 的路径）</strong></p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406121856305.png" alt="image-20240406121856305"></p><h3 id="3-验证cudnn是否安装成功"><a href="#3-验证cudnn是否安装成功" class="headerlink" title="3.验证cudnn是否安装成功"></a>3.验证cudnn是否安装成功</h3><p>复制完后，在当前目录下进入 <strong>extras -&gt; demo_suite</strong>，可以看到有 <strong>bandwidthTest.exe</strong> 和 <strong>deviceQuery.exe</strong></p><p>3.1 输入 <strong>bandwidthTest.exe</strong> 输出下图：</p><p><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406122051482.png" alt="image-20240406122051482"><br>3.2 输入 <strong>deviceQuery.exe</strong>，输出下图：<br><img src="/../../images/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/image-20240406122105572.png" alt="image-20240406122105572"></p><p>至此， 新版本的 CUDA 与 cudnn 安装成功，可以使用该版本的 CUDA 进行 GPU 加速了</p><p>四、切换 CUDA 版本<br>安装完新版本的 CUDA 后，此时运行的环境为新版本的 CUDA，当我们需要切换为其他版本时，仅需要对环境变量进行修改即可</p><p>1.切换版本<br>1.1 在系统变量的 Path 中，上移所需要切换的版本</p><p>将这两行变量置于最上方，并点击确定</p><p>1.2 修改 CUDA_PATH 的值</p><p>选中 CUDA_PATH ，点击 编辑<br>将值修改为 D:\CUDA Documentation\NVIDIA GPU Computing Toolkit\CUDA\v11.2（CUDA Documentation 和 CUDA Development 的路径）</p><p>1.3 修改 NVCUDASAMPLES_ROOT 的值<br>选中 NVCUDASAMPLES_ROOT ，点击 编辑<br>将值修改为 &#x3D;&#x3D; D:\CUDA Documentation\NVIDIA Corporation\CUDA Samples\11.2（Samples 的路径）&#x3D;&#x3D;</p><p>记得添加完后一路点击确定保存！</p><p>2.检查版本是否切换成功<br>Win + R 输入 cmd 打开命令行窗口，输入 nvcc -V</p><h1 id="三、anaconda安装"><a href="#三、anaconda安装" class="headerlink" title="三、anaconda安装"></a>三、anaconda安装</h1><p><a href="https://blog.csdn.net/wyf2017/article/details/118676765">如何在Linux服务器上安装Anaconda（超详细）_linux安装anconda-CSDN博客</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下载</span><br><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2024.02-1-Linux-x86_64.sh</span><br><span class="line">安装</span><br><span class="line">chmod +x Anaconda3-2024.02-1-Linux-x86_64.sh</span><br><span class="line">./Anaconda3-2024.02-1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><h1 id="四、安装pytorch"><a href="#四、安装pytorch" class="headerlink" title="四、安装pytorch"></a>四、安装pytorch</h1><p>在官网比对安装合适版本</p><p><a href="https://pytorch.org/get-started/previous-versions/">Previous PyTorch Versions | PyTorch</a></p>]]></content>
    
    
    <summary type="html">快速安装pytorch环境说明</summary>
    
    
    
    <category term="软件学习" scheme="https://shuita2333.github.io/project/categories/%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="软件学习" scheme="https://shuita2333.github.io/project/tags/%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="程序安装" scheme="https://shuita2333.github.io/project/tags/%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建（14）——SSl证书续期</title>
    <link href="https://shuita2333.github.io/project/2024/07/07/hexo/SSL%E8%AF%81%E4%B9%A6%E7%BB%AD%E6%9C%9F%E6%B5%81%E7%A8%8B/"/>
    <id>https://shuita2333.github.io/project/2024/07/07/hexo/SSL%E8%AF%81%E4%B9%A6%E7%BB%AD%E6%9C%9F%E6%B5%81%E7%A8%8B/</id>
    <published>2024-07-06T16:58:36.000Z</published>
    <updated>2024-07-07T08:35:29.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSL证书续期流程"><a href="#SSL证书续期流程" class="headerlink" title="SSL证书续期流程"></a>SSL证书续期流程</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>登录网站查看免费证书续期流程<br><a href="https://cloud.tencent.com/document/product/400/61353">SSL 证书 免费证书续期流程-购买指南-文档中心-腾讯云 (tencent.com)</a></p><h2 id="申请流程"><a href="#申请流程" class="headerlink" title="申请流程"></a>申请流程</h2><ol><li>打开SSL证书控制台</li><li>申请快速续期</li><li>采用自动DNS校验</li><li>等待证书颁发，需要1天时间</li></ol><h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><ol><li><p>在腾讯云选择最新证书下载，选取Nginx类型下载</p></li><li><p>在本地解压最新的证书压缩包，会有四个文件分别是<br><code>zhangyuanhe.top.csr</code><br><code>zhangyuanhe.top.key</code><br><code>zhangyuanhe.top_bundle.crt</code><br><code>zhangyuanhe.top_bundle.pem</code></p></li><li><p>打开 Filezilla 软件官网下载并安装，它是一个本机 FTP 软件，可以提供与云服务器接发文件的功能。<br>在传输系统中进入<code>/etc/nginx/ssl</code>目录</p></li><li><p>将<code>zhangyuanhe.top_bundle.crt</code>  和<code>zhangyuanhe.top.key</code>复制到<code>/etc/nginx/ssl/</code>目录下，替换旧版本文件</p></li><li><p>返回腾讯云控制台，测试是否有报错，无报错重启服务器</p></li><li><pre><code>sudo sunginx -tsystemctl restart nginx</code></pre></li></ol>]]></content>
    
    
    <summary type="html">由于SSL证书到期，需要进行续期</summary>
    
    
    
    <category term="博客搭建" scheme="https://shuita2333.github.io/project/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://shuita2333.github.io/project/tags/hexo/"/>
    
    <category term="服务器" scheme="https://shuita2333.github.io/project/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Windows文件加密驱动的设计与实现</title>
    <link href="https://shuita2333.github.io/project/2024/06/05/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://shuita2333.github.io/project/2024/06/05/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-06-04T18:00:00.000Z</published>
    <updated>2024-07-10T15:20:22.406Z</updated>
    
    <content type="html"><![CDATA[<p>****摘要：****本项目旨在设计和实现一个基于Windows的文件加密驱动系统，通过透明的加解密机制和远程备份功能，为用户提供高效、安全的文件保护方案。项目的主要成就包括：实现了针对特定进程的透明文件加解密服务，确保数据在存储和传输过程中的安全性；开发了远程备份功能，允许用户将重要文件定期备份到远程服务器，防止数据丢失；优化了系统性能，通过改进接口调用路径和设计缓存机制，提高了系统的响应速度和处理能力；提供了直观友好的用户界面，简化了用户的操作流程；采用TLS&#x2F;SSL等加密协议保障数据传输的安全性，并设计了全面的异常处理机制，确保系统在出现错误时能够正确恢复。未来的发展将集中在扩展功能模块、优化加密算法、增强用户体验、提高系统稳定性和实现跨平台支持，以进一步提升系统的性能、功能和用户体验，为用户的数据保护需求提供全面支持。 </p><p>****关键词：****文件加密驱动；透明加解密；远程备份；Windows 驱动开发；数据安全</p><h1 id="一、-文件驱动简介"><a href="#一、-文件驱动简介" class="headerlink" title="一、 *文件驱动简介*"></a><strong>一、</strong> <em><strong>*文件驱动简介*</strong></em></h1><h2 id="一-1-Windows-驱动开发简介"><a href="#一-1-Windows-驱动开发简介" class="headerlink" title="一.1 *Windows 驱动开发简介*"></a><strong>一.1</strong> <em><strong>*Windows 驱动开发简介*</strong></em></h2><p>Windows 驱动程序是用于操作系统与硬件设备之间进行通信的关键软件组件。它们作为操作系统内核的重要组成部分，通过提供标准化接口，驱动程序允许操作系统及其上的应用程序与各种硬件设备进行交互。这种交互确保了硬件设备能够正确运作，并实现其全部功能。</p><h3 id="（一）-驱动开发概念"><a href="#（一）-驱动开发概念" class="headerlink" title="（一） 驱动开发概念"></a>（一） 驱动开发概念</h3><p>在 Windows 操作系统中，驱动程序可以分为内核模式驱动程序（Kernel-Mode Driver）和用户模式驱动程序（User-Mode Driver）。内核模式驱动程序运行在操作系统的核心层，具有对系统资源的完全访问权限，能够直接与硬件交互。这类驱动程序通常用于对性能和低延迟有严格要求的设备，例如存储设备和网络适配器。用户模式驱动程序则运行在应用程序层，受到操作系统安全模型的限制，访问系统资源和硬件的权限较低，适用于不需要直接硬件访问或高性能的设备，例如某些类型的打印机驱动和 USB 设备驱动。</p><p>Windows 驱动程序的开发通常使用 Windows Driver Kit (WDK)，这是一个包含必要工具、库和文档的开发包。WDK 为开发人员提供了一整套工具，支持编写、编译、测试和调试驱动程序。然而，许多开发人员也在 Visual Studio 环境中进行开发，利用其强大的编辑和调试功能。在 Visual Studio 中，可以通过安装 WDK 插件来增强开发环境，获得驱动开发所需的特定功能。</p><p>开发驱动程序时，编程语言通常选择 C 或 C++，因为这些语言能够提供对底层硬件的高效访问，并允许开发人员精细控制硬件操作。此外，Microsoft 提供了 Windows Driver Frameworks (WDF)，包括 Kernel-Mode Driver Framework (KMDF) 和 User-Mode Driver Framework (UMDF)，帮助简化驱动程序的开发过程。</p><p>驱动程序开发涉及多个步骤，每一步都至关重要。首先，在设计阶段，开发人员需要明确驱动程序的功能和接口，详细考虑驱动程序如何与硬件设备及操作系统交互，确定数据流和控制路径。接下来，在编码阶段，开发人员使用 WDK 和 Visual Studio 编写驱动程序代码，这一步需要遵循 Windows 驱动开发的最佳实践，确保代码的效率和可靠性。</p><p>在测试阶段，开发人员使用多种工具进行测试，包括 WinDbg（Windows 调试器）和 Driver Verifier。WinDbg 是一个强大的调试工具，允许开发人员在内核模式下调试代码，捕捉和分析驱动程序中的错误。Driver Verifier 是一个用于测试和验证驱动程序行为的工具，通过模拟各种压力条件和故障情景来确保驱动程序的稳定性和可靠性。调试是一个反复进行的过程，开发人员需要使用各种调试工具和技术，找出并修复代码中的错误和缺陷，确保驱动程序能够在各种情况下正常运行。</p><p>在驱动程序通过所有测试后，开发人员需要准备驱动程序的部署包，并编写相关文档，帮助用户正确安装和使用驱动程序。此外，驱动程序的维护和更新也是开发周期的一部分，开发人员需要及时修复发现的问题并根据硬件或操作系统的更新进行相应调整。</p><p>总的来说，Windows 驱动程序开发是一个复杂且具有挑战性的过程，需要开发人员具备扎实的编程基础和对硬件的深入理解。通过使用正确的工具和方法，开发人员能够创建稳定、高效的驱动程序，确保硬件设备的最佳性能和兼容性。</p><h3 id="（二）-驱动开发与应用开发的异同"><a href="#（二）-驱动开发与应用开发的异同" class="headerlink" title="（二） 驱动开发与应用开发的异同"></a>（二） 驱动开发与应用开发的异同</h3><p>Windows 驱动开发和应用开发在多个方面存在显著的不同，尤其在开发、测试、部署和发布的全生命周期中更为明显。首先，从权限与访问控制的角度来看，驱动程序通常运行在操作系统的内核模式下，具有较高的权限，可以直接访问硬件资源和系统内存。这种高权限意味着驱动程序可以执行非常底层的操作，例如直接读写设备寄存器、管理内存和处理中断。这种直接访问使得驱动程序开发更为复杂，因为任何错误都可能导致系统崩溃或硬件故障。相比之下，应用程序运行在用户模式下，受到操作系统的严格访问控制，无法直接访问硬件资源和系统内存。应用程序通过操作系统提供的API与硬件进行交互，这种受限访问确保了应用程序错误不会影响整个系统的稳定性。</p><p>在开发工具和环境方面，驱动程序开发需要使用专门的开发工具和环境，例如 Windows Driver Kit (WDK) 和 Visual Studio。WDK 提供了开发、编译、测试和调试驱动程序所需的所有工具和库。此外，驱动程序需要经过严格的签名和验证过程，以确保它们的安全性和稳定性。开发语言通常使用 C 或 C++，以便更好地控制硬件和系统资源。而应用程序开发则使用更广泛的开发工具和环境，例如 .NET Framework、Java SDK 等。应用程序开发工具支持多种高级编程语言，如 Python、Java、C# 等，开发环境和工具更加丰富和友好。应用程序通常不需要进行如此严格的签名和验证。</p><p>在开发过程中，驱动开发和应用开发也有不同的流程。驱动开发的过程包括需求分析、设计、实现、测试和维护。需求分析阶段确定驱动程序需要实现的功能和目标硬件。在设计阶段，开发人员设计驱动程序的架构和接口。在实现阶段，开发人员编写驱动程序代码并进行初步测试。在测试阶段，驱动程序需要经过严格的功能测试、性能测试和稳定性测试，确保在各种条件下都能正常运行。最后，在维护阶段，开发人员需要对驱动程序进行更新和修复已知问题。相比之下，应用程序开发的过程包括需求分析、设计、实现、测试、部署和维护。需求分析阶段确定应用程序的功能和用户需求。在设计阶段，开发人员设计应用程序的架构、用户界面和交互方式。在实现阶段，开发人员编写应用程序代码并进行初步测试。在测试阶段，应用程序需要经过功能测试、性能测试、用户接受测试等，确保应用程序符合用户需求和性能要求。部署阶段，应用程序会被发布到生产环境中供用户使用。最后，在维护阶段，开发人员对应用程序进行更新、修复漏洞和增加新功能。</p><p>测试和调试环节对于驱动开发和应用开发同样重要，但复杂程度有所不同。驱动程序的测试和调试更为复杂和重要。由于驱动程序在内核模式下运行，任何错误都可能导致系统崩溃，因此需要使用专门的调试工具，如 WinDbg。驱动程序还需要通过 Driver Verifier 等工具进行严格的验证，以确保在各种极端条件下的稳定性。测试阶段通常包括单元测试、集成测试和系统测试，确保驱动程序在所有预期的使用场景下都能正常工作。而应用程序的测试和调试通常更为简单，错误的影响范围也较小。开发人员可以使用多种调试工具和环境，如 Visual Studio、Eclipse 等。测试阶段包括单元测试、集成测试、系统测试和用户接受测试。应用程序错误通常不会导致系统崩溃，测试的重点在于功能性、性能和用户体验。</p><p>在部署和发布环节，驱动程序和应用程序也存在显著差异。驱动程序的部署和发布过程非常严格。由于驱动程序直接影响系统的稳定性，必须经过签名和认证过程，以确保其来源可信和没有安全漏洞。驱动程序通常通过操作系统的更新机制或者设备厂商提供的安装包进行部署。发布前，驱动程序需要通过微软的 WHQL（Windows Hardware Quality Labs）认证，以确保其兼容性和可靠性。相比之下，应用程序的部署和发布相对简单灵活。应用程序可以通过多种方式发布，包括应用商店、官方网站下载、企业内部发布等。发布前，应用程序通常需要经过内部测试和用户接受测试，确保没有重大功能缺陷和安全漏洞。发布后的应用程序还可以通过补丁和更新机制进行维护和功能扩展。</p><p>最后，在安全性和稳定性要求方面，驱动程序由于直接与硬件交互，其安全性和稳定性要求极高。任何漏洞都可能被恶意利用，导致严重的系统问题。因此，驱动程序在发布前需要经过严格的测试和认证，确保在各种情况下的稳定性和安全性。而应用程序虽然也需要考虑安全性，但通常不会直接影响系统的核心功能，安全性和稳定性要求相对较低。应用程序开发更多关注数据安全、用户隐私和防止恶意攻击，确保在正常使用下不会出现重大问题。</p><p>综上所述，Windows 驱动开发和应用开发在开发、测试、部署和发布的全生命周期中都有显著的区别。驱动开发更为复杂和严格，要求开发人员具备深厚的操作系统原理和硬件知识。而应用开发更关注用户需求和体验，开发环境和工具更加丰富和友好。</p><h2 id="一-2-Windows-驱动开发体系"><a href="#一-2-Windows-驱动开发体系" class="headerlink" title="一.2 *Windows 驱动开发体系*"></a><strong>一.2</strong> <em><strong>*Windows 驱动开发体系*</strong></em></h2><p>Windows驱动开发体系包括多种类型的驱动程序，每种驱动程序都有其特定的用途和开发方法。</p><h3 id="（一）-Windows-驱动类别"><a href="#（一）-Windows-驱动类别" class="headerlink" title="（一） Windows 驱动类别"></a>（一） Windows 驱动类别</h3><p>Windows驱动程序可以按照不同方法进行分类：</p><h4 id="1）-按运行模式分类"><a href="#1）-按运行模式分类" class="headerlink" title="1） 按运行模式分类"></a>1） <strong>按运行模式分类</strong></h4><p>1、内核态驱动</p><p><strong>l</strong> ****设备驱动程序****：控制和管理硬件设备，如硬盘、键盘、鼠标、显示器和其他外设。它们负责处理设备的低级操作，如数据传输和硬件控制。</p><p><strong>l</strong> ****文件系统驱动程序****：管理文件系统，处理文件的创建、读取、写入、删除等操作。常见的文件系统驱动程序包括NTFS、FAT32等。</p><p><strong>l</strong> ****总线驱动程序****：管理系统总线，如PCI、USB、I2C等，负责检测和配置连接到总线的设备，协调数据传输。</p><p><strong>l</strong> ****选驱动程序****：用于拦截和修改I&#x2F;O请求。筛选驱动程序可以在不同的驱动程序堆栈层次中插入，以增加功能或提供安全性。加密驱动程序、日志记录驱动程序属于此类。</p><p><strong>l</strong> ****微型端口驱动程序****：用于支持特定类型的硬件设备，例如网卡、SCSI适配器等。微型端口驱动程序是微端口驱动程序体系结构的一部分，提供特定硬件的低级操作接口。</p><p>2、用户态驱动</p><p><strong>l</strong> ****UMDF 驱动程序****：基于用户模式驱动框架（User-Mode Driver Framework）的驱动程序，适用于非关键设备，例如便携式设备、传感器、摄像头等。UMDF驱动程序在用户模式下运行，具有较低的系统权限，增强了系统稳定性和安全性。</p><p><strong>l</strong> ****打印驱动程序****：管理打印机设备的驱动程序，包括处理打印作业、管理打印队列、与打印机硬件通信等。打印驱动程序可以在用户模式和内核模式下运行。</p><p><strong>l</strong> ****虚拟设备驱动程序****：用于创建虚拟设备，如虚拟磁盘、虚拟网络适配器等。虚拟设备驱动程序通过模拟物理设备来提供额外的功能或支持特定的软件需求。</p><p>3、****网络驱动程序****：管理网络接口和网络通信，包括以太网驱动程序、无线网络驱动程序、蓝牙驱动程序等。网络驱动程序负责处理数据包的发送和接收、网络协议的实现、网络连接的管理等。</p><p>4、****虚拟化驱动程序****：支持虚拟机和虚拟化技术，如虚拟化平台中的虚拟硬件设备驱动程序。虚拟化驱动程序允许虚拟机与物理硬件进行高效通信，并优化虚拟化性能。</p><p>5、****安全相关驱动程序****：提供安全功能，如防火墙、杀毒软件驱动程序、加密驱动程序等。安全相关驱动程序负责保护系统免受恶意软件攻击、监控和控制网络流量、提供数据加密和解密功能。</p><p>6、****即插即用驱动程序****：支持即插即用设备的驱动程序。即插即用驱动程序能够自动检测新连接的硬件设备，并加载相应的驱动程序，使设备能够立即使用。常见的即插即用设备包括USB设备、热插拔存储设备等。</p><p>7、****音视频驱动程序****：管理音频和视频设备的驱动程序，包括声卡驱动程序、摄像头驱动程序、显示驱动程序等。音视频驱动程序负责处理音频和视频数据的输入和输出、管理多媒体硬件资源、支持多媒体应用的运行。</p><h4 id="2）-按功能分类"><a href="#2）-按功能分类" class="headerlink" title="2） 按功能分类"></a>2） <strong>按功能分类</strong></h4><p><strong>1.</strong> ****设备驱动程序****：控制和管理硬件设备，如硬盘、键盘、鼠标、显示器等，处理低级操作。这些驱动程序直接与硬件交互，负责硬件的初始化、控制和数据传输。例如，硬盘驱动程序管理数据读写操作，键盘驱动程序处理按键输入。</p><p><strong>2.</strong> ****软件驱动程序****：实现特定软件功能，如文件系统驱动程序（NTFS、FAT32）、虚拟设备驱动程序（虚拟磁盘）等。这些驱动程序不直接与硬件交互，而是通过软件提供额外的功能。例如，文件系统驱动程序管理文件和目录结构，虚拟设备驱动程序创建虚拟硬件设备供系统使用。</p><p><strong>3.</strong> ****文件系统驱动程序****：管理文件系统，处理文件操作，如创建、读取、写入、删除等。常见的有NTFS、FAT32。这些驱动程序负责组织和管理存储设备上的数据，确保数据的高效存取和安全性。例如，NTFS驱动程序提供高级文件系统功能，如权限管理和文件压缩。</p><p><strong>4.</strong> ****过滤驱动程序****：拦截和修改I&#x2F;O请求，用于安全、日志记录等目的。如防病毒软件的过滤驱动程序。这些驱动程序可以插入到现有驱动堆栈中，监控和控制数据流。例如，加密过滤驱动程序可以在数据写入磁盘前对其进行加密，防病毒过滤驱动程序可以扫描文件以检测和阻止恶意软件。</p><h4 id="3）-按设备类型分类"><a href="#3）-按设备类型分类" class="headerlink" title="3） 按设备类型分类"></a>3） <strong>按设备类型分类</strong></h4><p><strong>1.</strong> ****输入设备驱动程序****：管理输入设备，如键盘、鼠标、触摸屏等。这些驱动程序处理用户输入并将其传递给操作系统和应用程序。例如，键盘驱动程序负责将按键转换为系统可识别的输入信号。</p><p><strong>2.</strong> ****输出设备驱动程序****：管理输出设备，如显示器、打印机等。显示驱动程序负责渲染图形输出，打印驱动程序管理打印作业。例如，显卡驱动程序负责处理图形渲染和显示输出。</p><p><strong>3.</strong> ****存储设备驱动程序****：管理存储设备，如硬盘、固态硬盘、光驱、U盘等。这些驱动程序负责数据存储和检索操作。例如，SATA驱动程序负责硬盘的读写操作，USB存储驱动程序管理U盘的连接和数据传输。</p><p><strong>4.</strong> ****网络设备驱动程序****：管理网络接口，如以太网适配器、Wi-Fi适配器、蓝牙设备等。它们负责网络通信、数据包传输和网络连接管理。例如，以太网驱动程序处理有线网络连接，Wi-Fi驱动程序管理无线网络通信。</p><p><strong>5.</strong> ****多媒体设备驱动程序****：管理多媒体设备，如声卡、摄像头等。它们处理音频和视频数据的输入和输出，支持多媒体应用的运行。例如，声卡驱动程序处理音频播放和录制，摄像头驱动程序负责视频捕获和传输。</p><h4 id="4）-按开发模型分类"><a href="#4）-按开发模型分类" class="headerlink" title="4） 按开发模型分类"></a>4） <strong>按开发模型分类</strong></h4><p><strong>1.</strong> ****Windows Driver Model（WDM）驱动程序****：兼容Windows 98及以后的操作系统，如通用串行总线（USB）驱动程序、音频驱动程序等。WDM提供了一套标准接口，使驱动程序可以在不同Windows版本间移植。通过WDM，开发者可以编写一次驱动程序，并在多个Windows版本上使用。</p><p><strong>2.</strong> ****Windows Driver Frameworks（WDF）驱动程序****：包括内核模式驱动框架（KMDF）和用户模式驱动框架（UMDF）。KMDF适用于大多数内核模式驱动程序，如存储驱动、网络驱动等。UMDF适用于用户模式驱动程序，如某些USB设备驱动、传感器驱动等。WDF简化了驱动开发，提供了更高的稳定性和安全性。KMDF和UMDF通过抽象复杂的内核接口，使得开发过程更加高效和可靠。</p><h3 id="（二）-Windows-驱动开发工具链"><a href="#（二）-Windows-驱动开发工具链" class="headerlink" title="（二） Windows 驱动开发工具链"></a>（二） Windows 驱动开发工具链</h3><p>开发 Windows 驱动程序需要一套完整的工具链，包括：</p><h4 id="1）-环境层面"><a href="#1）-环境层面" class="headerlink" title="1） 环境层面"></a>1） <strong>环境层面</strong></h4><p><strong>1.</strong> ****Windows Driver Kit (WDK)****：软提供的一套用于开发 Windows 驱动程序的工具和库。WDK 包含了驱动开发所需的头文件、库文件、编译器、文档和示例代码。WDK 提供了全面的驱动开发支持，使开发者能够编写、编译、调试和测试驱动程序。通过 WDK，开发者可以使用 Visual Studio 创建驱动程序项目，配置驱动程序属性，并生成驱动程序二进制文件。此外，WDK 还包括 Driver Verifier 和 Static Driver Verifier 等工具，用于验证驱动程序的稳定性和安全性。</p><p><strong>2.</strong> ****Microsoft Visual Studio****：个综合性的开发环境（IDE），支持多种编程语言。对于驱动开发，Visual Studio 提供了强大的编辑、调试和构建工具。通过与 WDK 的集成，开发者可以在 Visual Studio 中创建和管理驱动项目，使用内置的调试工具进行驱动调试，并通过编译器和链接器生成驱动程序二进制文件。Visual Studio 还支持代码分析、代码重构和性能分析，有助于提高驱动程序的质量和性能。</p><p><strong>3.</strong> <em><strong>*Windows SDK*</strong></em> ：个用于开发 Windows 应用程序和驱动程序的开发工具包。它包含了开发 Windows 平台所需的头文件、库文件、工具和示例代码。Windows SDK 提供了与操作系统和平台相关的 API 和库，使开发者能够编写与操作系统功能紧密集成的代码。Windows SDK 还包括调试工具、性能分析工具和测试工具，帮助开发者提高代码的质量和性能。</p><h4 id="2）-工具层面"><a href="#2）-工具层面" class="headerlink" title="2） 工具层面"></a>2） <strong>工具层面</strong></h4><p><strong>1.</strong> ****DebugView****：个实时监控系统和应用程序的调试输出的工具。它可以捕获来自 DbgPrint 和 OutputDebugString 函数的调试输出，是调试驱动程序和应用程序的有力工具。DebugView 在驱动程序开发过程中尤为重要，因为它可以帮助开发者监控和诊断驱动程序的运行状态，快速定位问题。</p><p><strong>2.</strong> ****WinDbg****：个强大的内核模式和用户模式调试器，广泛用于调试 Windows 操作系统和驱动程序。WinDbg 提供了高级的调试功能，如符号解析、内存转储分析和内核对象检查。它是调试内核模式驱动程序和分析系统崩溃问题的重要工具。WinDbg 支持远程调试、内核调试和用户模式调试，能够处理复杂的调试任务。</p><p><strong>3.</strong> <em><strong>*Driver Verifier*</strong></em> ：indows 操作系统中的一个工具，用于监控和验证驱动程序的行为。它可以检测和报告驱动程序中的常见错误和问题，帮助开发者提高驱动程序的稳定性和可靠性。Driver Verifier 可以模拟各种极端条件和错误情况，确保驱动程序在不同环境下都能正常工作。它可以检测内存泄漏、I&#x2F;O 操作错误和资源冲突等问题。</p><p><strong>4.</strong> <em><strong>*TraceView*</strong></em> ：一个用于查看和分析 ETW（Event Tracing for Windows）跟踪日志的工具。它可以帮助开发者收集和分析驱动程序和系统事件，提供详细的性能和行为分析。TraceView 是性能调优和故障排除的有效工具，能够帮助开发者识别性能瓶颈和系统问题。通过 ETW 跟踪，开发者可以了解驱动程序的执行路径和时间消耗。</p><p><strong>5.</strong> <em><strong>*Visual Studio Code*</strong></em> ：主要用于应用程序开发，但它也可以用于编辑和管理驱动程序代码。通过安装合适的扩展，如 C&#x2F;C++ 扩展和调试工具，开发者可以在 VS Code 中编写、调试和测试驱动程序代码，享受轻量级编辑器的优势。VS Code 提供了强大的代码编辑功能，如语法高亮、代码自动完成和代码片段，有助于提高开发效率。</p><h4 id="3）-代码层面"><a href="#3）-代码层面" class="headerlink" title="3） 代码层面"></a>3） <strong>代码层面</strong></h4><p><strong>1.</strong> ****头文件 (Header Files)****：驱动程序开发中使用的主要头文件包括ntddk.h，wdf.h，wdm.h等。这些头文件定义了开发驱动程序所需的所有数据结构、函数和宏，它们是驱动程序与操作系统内核进行交互的基础。</p><p>l ntddk.h：包含内核模式驱动程序的核心定义和声明。它定义了内核对象、驱动程序入口点、I&#x2F;O 请求包（IRP）处理函数等，提供了开发内核模式驱动程序所需的基本接口。</p><p>l wdf.h：包含 WDF 驱动程序框架的定义和声明。它定义了 WDF 对象模型和 API，帮助开发者使用 WDF 开发内核模式和用户模式驱动程序。WDF 简化了驱动开发过程，提供了更高层次的抽象和封装。</p><p>l wdm.h：包含 Windows 驱动模型（WDM）的定义和声明。它提供了开发 WDM 驱动程序所需的接口和数据结构，支持开发低级别的内核模式驱动程序。</p><p><strong>2.</strong> ****库文件 (Library Files)****：WDK 中提供了多种库文件，例如 ntoskrnl.lib, hal.lib, wdfldr.lib 等。这些库文件包含了驱动程序开发中常用的函数实现，使开发者可以直接调用系统提供的功能。</p><p>l ntoskrnl.lib：内核模式驱动程序常用的库，提供内核服务和功能，如内存管理、进程调度和同步机制。</p><p>l hal.lib：硬件抽象层（HAL）库，提供与硬件相关的低级操作接口，如中断处理、I&#x2F;O 端口操作等。</p><p>l wdfldr.lib：WDF 驱动程序加载器库，提供加载和管理 WDF 驱动程序的功能，如驱动程序初始化、设备创建和对象管理。</p><h3 id="（三）-Windows-驱动开发框架"><a href="#（三）-Windows-驱动开发框架" class="headerlink" title="（三） Windows 驱动开发框架"></a>（三） Windows 驱动开发框架</h3><p>在本项目中，我们主要关注文件系统筛选驱动的开发框架。Windows 文件系统筛选驱动开发框架（File System Filter Driver Development Framework）是用于创建文件系统筛选驱动程序的开发工具和库。文件系统筛选驱动程序可以拦截和修改文件系统的I&#x2F;O操作，用于实现加密、压缩、病毒扫描、文件监控等功能。以下是文件系统筛选驱动开发框架的功能和使用方法。</p><h4 id="1）-功能"><a href="#1）-功能" class="headerlink" title="1） 功能"></a>1） <strong>功能</strong></h4><p><strong>1.</strong> ****I&#x2F;O 请求拦截与处理****：文件系统筛选驱动程序可以拦截文件系统的I&#x2F;O请求，如文件创建、读取、写入、删除等操作。通过拦截I&#x2F;O请求，驱动程序可以在这些操作发生之前、之中或之后进行处理。例如，驱动程序可以在文件写入磁盘之前对其进行加密，或在文件被读取时进行解密。这种功能对于数据安全和隐私保护非常重要，能够有效防止未经授权的访问和数据泄露。</p><p><strong>2.</strong> ****堆栈过滤****：文件系统筛选驱动程序可以作为I&#x2F;O堆栈中的一层，处理上层驱动程序发送的I&#x2F;O请求，并将其传递给下层驱动程序。筛选驱动程序可以修改、拒绝或记录这些I&#x2F;O请求，以实现特定功能。例如，防病毒筛选驱动程序可以扫描文件以检测和阻止恶意软件。堆栈过滤使得驱动程序能够在不改变底层文件系统驱动程序的情况下添加新的功能。</p><p><strong>3.</strong> ****上下文管理****：筛选驱动程序可以为文件、目录、卷等对象分配和管理上下文信息。上下文信息是驱动程序为每个对象维护的特定数据，用于在处理I&#x2F;O请求时存储和检索状态信息。例如，加密驱动程序可以为每个文件分配一个上下文结构，以存储加密密钥和加密状态。上下文管理能够使驱动程序在不同的I&#x2F;O操作之间保持一致的状态信息，确保功能的正确实现。</p><p><strong>4.</strong> ****通知机制****：筛选驱动程序可以注册回调函数，以便在特定事件发生时接收通知。这些事件包括文件打开、关闭、读写操作、目录浏览等。通过通知机制，驱动程序可以实时监控文件系统活动，并在特定事件发生时执行相应操作。例如，文件监控驱动程序可以在文件被修改时记录日志。通知机制增强了驱动程序的监控和响应能力，使其能够快速反应并处理文件系统中的变化。</p><p><strong>5.</strong> ****性能优化****：文件系统筛选驱动程序框架提供了多种性能优化机制，如异步I&#x2F;O处理、缓存管理和批处理操作。这些机制可以提高驱动程序的性能，减少对系统资源的占用。例如，筛选驱动程序可以使用异步I&#x2F;O处理来提高并发性能，或使用缓存管理来减少磁盘I&#x2F;O操作。性能优化机制确保驱动程序在高负载环境下依然能够高效运行，不影响系统的整体性能。</p><h4 id="2）-使用方法"><a href="#2）-使用方法" class="headerlink" title="2） 使用方法"></a>2） <strong>使用方法</strong></h4><p>开发文件系统筛选驱动程序需要使用Windows Driver Kit (WDK)和相关的开发工具。以下是使用文件系统筛选驱动开发框架的一般步骤：</p><p><strong>1.</strong> ****创建驱动程序项目****：使用WDK和Visual Studio创建一个新的筛选驱动程序项目。选择适当的项目模板，并配置项目属性。Visual Studio 提供了专门的驱动程序项目模板，使得开发者可以快速开始开发过程，并自动设置项目的基本结构和配置。</p><p><strong>2.</strong> ****编写驱动程序代码****：根据需求编写驱动程序代码，包括I&#x2F;O请求处理函数、上下文管理函数和回调函数。使用WDK提供的头文件和库文件，调用框架API实现驱动程序功能。例如，开发者需要编写函数来处理文件创建、读取和写入请求，并在这些函数中实现具体的功能，如加密、解密或日志记录。</p><p><strong>3.</strong> ****编译和链接****：使用Visual Studio和WDK编译和链接驱动程序代码，生成驱动程序二进制文件（.sys文件）。确保所有依赖项和库文件都正确链接，并解决编译过程中出现的任何错误。编译过程会生成驱动程序的二进制文件，这些文件将在目标系统上运行。</p><p><strong>4.</strong> ****测试和调试****：使用WDK提供的工具（如WinDbg和Driver Verifier）测试和调试驱动程序，确保其在各种环境下都能正常工作。捕获和分析调试输出，解决驱动程序中的问题。例如，使用WinDbg进行内核调试，可以在驱动程序运行时设置断点、检查内存和变量的值，从而找出问题的根源。</p><p><strong>5.</strong> ****部署和安装****：将驱动程序部署到目标系统，并使用设备管理器或命令行工具（如pnputil）安装驱动程序。配置驱动程序的加载顺序和依赖关系，确保其能够正确加载和运行。部署过程中，需要创建驱动程序的安装包，并在目标系统上安装和配置驱动程序，以便其能够与操作系统和其他驱动程序协同工作。</p><h4 id="3）-文件系统筛选器管理器"><a href="#3）-文件系统筛选器管理器" class="headerlink" title="3） 文件系统筛选器管理器"></a>3） <strong>文件系统筛选器管理器</strong></h4><p>文件系统筛选器管理器（Filter Manager）是Windows内核中的一个组件，它提供了一种机制，用于在文件系统驱动程序和I&#x2F;O请求之间插入额外的处理逻辑。筛选器驱动程序可以通过Filter Manager来注册自己，并拦截和处理I&#x2F;O请求。</p><p><strong>1.</strong> <em><strong>*功能*</strong></em></p><p><strong>l</strong> ****统一的框架****：FltMgr 提供了一个统一的框架，使开发者可以轻松编写文件系统筛选驱动程序，而不需要处理复杂的底层细节。通过使用 FltMgr，开发者可以专注于实现具体的筛选功能，如加密、压缩和日志记录，而无需处理低级别的I&#x2F;O管理。</p><p><strong>l</strong> ****过滤器驱动程序注册与管理****：FltMgr 允许筛选驱动程序注册自己，并与文件系统驱动程序堆栈集成。筛选驱动程序可以通过 FltRegisterFilter 函数注册自己，并在系统启动时自动加载。FltMgr 管理所有注册的筛选驱动程序，并按照其加载顺序进行组织和调度。</p><p><strong>l</strong> ****I&#x2F;O 请求处理****：FltMgr 提供了处理I&#x2F;O请求的标准化接口。筛选驱动程序可以通过注册预操作和后操作回调函数来拦截和处理I&#x2F;O请求。这些回调函数可以用于修改、拒绝或记录I&#x2F;O请求，从而实现特定的筛选功能。例如，筛选驱动程序可以在文件被写入之前对其进行加密，或者在文件被读取之后进行解密。</p><p><strong>l</strong> ****上下文管理****：FltMgr 提供了强大的上下文管理功能，允许筛选驱动程序为文件、目录、卷等对象分配和管理上下文信息。上下文信息是筛选驱动程序维护的特定数据，用于在处理I&#x2F;O请求时存储和检索状态信息。例如，加密筛选驱动程序可以为每个文件分配一个上下文结构，以存储加密密钥和加密状态。</p><p><strong>l</strong> ****通知机制****：FltMgr 支持注册回调函数，以便在特定事件发生时接收通知。通过这种机制，筛选驱动程序可以实时监控文件系统活动，并在特定事件发生时执行相应操作。例如，筛选驱动程序可以在文件被创建、删除、打开或关闭时接收通知，并记录这些操作。</p><p><strong>l</strong> ****性能优化****：FltMgr 提供了多种性能优化机制，如异步I&#x2F;O处理、缓存管理和批处理操作。这些机制可以提高筛选驱动程序的性能，减少对系统资源的占用。例如，筛选驱动程序可以使用异步I&#x2F;O处理来提高并发性能，或者使用缓存管理来减少磁盘I&#x2F;O操作，从而提高整体系统的响应速度。</p><p><strong>2.</strong> <em><strong>*使用方法*</strong></em></p><p>l 创建驱动程序项目：使用WDK和Visual Studio创建一个新的筛选驱动程序项目。选择适当的项目模板，并配置项目属性。Visual Studio 提供了专门的筛选驱动程序项目模板，使得开发者可以快速开始开发过程，并自动设置项目的基本结构和配置。</p><p>l 注册筛选驱动程序：编写驱动程序代码时，首先需要通过调用FltRegisterFilter函数来注册筛选驱动程序。注册过程中需要指定驱动程序的回调函数和操作模式。然后，通过调用FltStartFiltering函数来启动筛选功能，使驱动程序开始拦截和处理I&#x2F;O请求。</p><p>l 实现I&#x2F;O请求处理函数：根据需求编写I&#x2F;O请求处理函数，包括预操作回调函数和后操作回调函数。预操作回调函数在I&#x2F;O请求到达筛选驱动程序时被调用，可以对请求进行修改、记录或拒绝。后操作回调函数在I&#x2F;O请求处理完成后被调用，用于执行后续处理或清理操作。</p><p>l 管理上下文信息：使用FltMgr 提供的上下文管理API，为文件、目录、卷等对象分配和管理上下文信息。在I&#x2F;O请求处理中，可以通过上下文信息存储和检索状态数据。例如，在文件打开时分配上下文结构，在文件关闭时释放上下文结构。</p><p>l 处理通知事件：注册回调函数，以便在特定事件发生时接收通知。实现通知处理函数，根据需要执行相应操作。例如，在文件被创建或删除时记录日志，或者在文件被修改时触发特定的安全措施。</p><p>l 编译和链接：使用Visual Studio和WDK编译和链接驱动程序代码，生成驱动程序二进制文件（.sys文件）。确保所有依赖项和库文件都正确链接，并解决编译过程中出现的任何错误。编译过程会生成驱动程序的二进制文件，这些文件将在目标系统上运行。</p><p>l 测试和调试：使用WDK提供的工具（如WinDbg和Driver Verifier）测试和调试驱动程序，确保其在各种环境下都能正常工作。捕获和分析调试输出，解决驱动程序中的问题。例如，使用WinDbg进行内核调试，可以在驱动程序运行时设置断点、检查内存和变量的值，从而找出问题的根源。</p><p>l 部署和安装：将驱动程序部署到目标系统，并使用设备管理器或命令行工具（如pnputil）安装驱动程序。配置驱动程序的加载顺序和依赖关系，确保其能够正确加载和运行。部署过程中，需要创建驱动程序的安装包，并在目标系统上安装和配置驱动程序，以便其能够与操作系统和其他驱动程序协同工作。</p><h4 id="4）-微筛选器"><a href="#4）-微筛选器" class="headerlink" title="4） 微筛选器"></a>4） <strong>微筛选器</strong></h4><p>微筛选器（Minifilter）是通过Filter Manager注册的小型筛选器驱动程序。微筛选器提供了一种简化的方式来编写文件系统筛选驱动，开发者可以通过微筛选器来实现特定的功能，如文件加密、日志记录等。</p><ol><li>功能</li></ol><p><strong>l</strong> ****模块化设计****：微筛选器采用模块化设计，可以在不修改内核文件系统驱动程序的情况下，添加或删除筛选功能。每个微筛选器都是一个独立的模块，可以单独加载或卸载，从而提高了系统的灵活性和可维护性。开发者可以根据需要编写多个微筛选器，并将其组合使用，以实现复杂的文件系统功能。</p><p><strong>l</strong> ****标准化接口****：微筛选器通过标准化接口与文件系统筛选器管理器（FltMgr）进行交互。FltMgr 提供了一组API，用于注册微筛选器、管理上下文信息、处理I&#x2F;O请求和接收事件通知。通过这些标准化接口，开发者可以轻松地编写和管理微筛选器，而无需处理底层的I&#x2F;O管理和同步问题。</p><p><strong>l</strong> ****I&#x2F;O 请求处理****：微筛选器可以拦截和处理文件系统的I&#x2F;O请求，如文件创建、读取、写入、删除等操作。开发者可以注册预操作和后操作回调函数，在I&#x2F;O请求到达和完成时执行特定的筛选逻辑。例如，微筛选器可以在文件写入磁盘之前对其进行加密，或者在文件被读取时进行解密，从而实现数据保护功能。</p><p><strong>l</strong> ****上下文管理****：微筛选器可以为文件、目录、卷等对象分配和管理上下文信息。上下文信息是微筛选器维护的特定数据，用于在处理I&#x2F;O请求时存储和检索状态信息。通过上下文管理，微筛选器可以在不同的I&#x2F;O操作之间保持一致的状态，从而确保功能的正确实现。例如，加密微筛选器可以为每个文件分配一个上下文结构，以存储加密密钥和加密状态。</p><p><strong>l</strong> ****通知机制****：微筛选器可以注册回调函数，以便在特定事件发生时接收通知。这些事件包括文件打开、关闭、读写操作、目录浏览等。通过通知机制，微筛选器可以实时监控文件系统活动，并在特定事件发生时执行相应操作。例如，文件监控微筛选器可以在文件被修改时记录日志，或在文件被删除时触发警报。</p><p><strong>l</strong> ****性能优化****：微筛选器框架提供了多种性能优化机制，如异步I&#x2F;O处理、缓存管理和批处理操作。这些机制可以提高微筛选器的性能，减少对系统资源的占用。例如，微筛选器可以使用异步I&#x2F;O处理来提高并发性能，或者使用缓存管理来减少磁盘I&#x2F;O操作，从而提高整体系统的响应速度。</p><ol start="2"><li>使用方法</li></ol><p>开发微筛选器需要使用Windows Driver Kit (WDK)和相关的开发工具。以下是使用微筛选器框架的一般步骤：</p><p><strong>l</strong> ****创建微筛选器项目****：使用WDK和Visual Studio创建一个新的微筛选器项目。选择适当的项目模板，并配置项目属性。Visual Studio 提供了专门的微筛选器项目模板，使得开发者可以快速开始开发过程，并自动设置项目的基本结构和配置。</p><p><strong>l</strong> ****注册微筛选器****：编写微筛选器代码时，首先需要通过调用FltRegisterFilter函数来注册微筛选器。注册过程中需要指定微筛选器的回调函数和操作模式。然后，通过调用FltStartFiltering函数来启动筛选功能，使微筛选器开始拦截和处理I&#x2F;O请求。</p><p><strong>l</strong> ****实现I&#x2F;O请求处理函数****：根据需求编写I&#x2F;O请求处理函数，包括预操作回调函数和后操作回调函数。预操作回调函数在I&#x2F;O请求到达微筛选器时被调用，可以对请求进行修改、记录或拒绝。后操作回调函数在I&#x2F;O请求处理完成后被调用，用于执行后续处理或清理操作。</p><p><strong>l</strong> ****管理上下文信息****：使用FltMgr 提供的上下文管理API，为文件、目录、卷等对象分配和管理上下文信息。在I&#x2F;O请求处理中，可以通过上下文信息存储和检索状态数据。例如，在文件打开时分配上下文结构，在文件关闭时释放上下文结构。</p><p><strong>l</strong> ****处理通知事件****：注册回调函数，以便在特定事件发生时接收通知。实现通知处理函数，根据需要执行相应操作。例如，在文件被创建或删除时记录日志，或者在文件被修改时触发特定的安全措施。</p><p><strong>l</strong> ****编译和链接****：使用Visual Studio和WDK编译和链接微筛选器代码，生成微筛选器二进制文件（.sys文件）。确保所有依赖项和库文件都正确链接，并解决编译过程中出现的任何错误。编译过程会生成微筛选器的二进制文件，这些文件将在目标系统上运行。</p><p><strong>l</strong> ****测试和调试****：使用WDK提供的工具（如WinDbg和Driver Verifier）测试和调试微筛选器，确保其在各种环境下都能正常工作。捕获和分析调试输出，解决微筛选器中的问题。例如，使用WinDbg进行内核调试，可以在微筛选器运行时设置断点、检查内存和变量的值，从而找出问题的根源。</p><p><strong>l</strong> ****部署和安装****：将微筛选器部署到目标系统，并使用设备管理器或命令行工具（如pnputil）安装微筛选器。配置微筛选器的加载顺序和依赖关系，确保其能够正确加载和运行。部署过程中，需要创建微筛选器的安装包，并在目标系统上安装和配置微筛选器，以便其能够与操作系统和其他驱动程序协同工作。</p><h4 id="5）-Windows-筛选平台"><a href="#5）-Windows-筛选平台" class="headerlink" title="5） Windows 筛选平台"></a>5） <strong>Windows 筛选平台</strong></h4><p>Windows筛选平台（Windows Filtering Platform，WFP）是一个框架，提供了一种方式来创建网络数据包筛选驱动程序。WFP主要用于实现防火墙和网络安全功能，但在本项目中未使用。</p><h4 id="6）-上层筛选驱动"><a href="#6）-上层筛选驱动" class="headerlink" title="6） 上层筛选驱动"></a>6） <strong>上层筛选驱动</strong></h4><p>上层筛选驱动（Legacy Filter Drivers）是传统的筛选驱动程序，通过直接与I&#x2F;O请求包（IRP）进行交互来实现功能。相比微筛选器，编写和维护上层筛选驱动更加复杂，因此本项目未使用。</p><h1 id="二、-总体功能设计"><a href="#二、-总体功能设计" class="headerlink" title="二、 *总体功能设计*"></a><strong>二、</strong> <em><strong>*总体功能设计*</strong></em></h1><h2 id="二-1-用户需求分析"><a href="#二-1-用户需求分析" class="headerlink" title="二.1 *用户需求分析*"></a><strong>二.1</strong> <em><strong>*用户需求分析*</strong></em></h2><p>在现代信息社会，数据的安全性变得越来越重要。用户对于文件的加密需求主要体现在以下几个方面：</p><p>文件不能泄露：防止敏感数据被未经授权的用户访问是用户的首要关注点。随着网络威胁和恶意攻击的增加，确保只有授权人员可以访问和读写重要数据至关重要。任何未经授权的访问可能会导致严重的数据泄露、经济损失和法律问题。</p><p><strong>l</strong> ****保存明文备份****：在文件加密后，用户常常需要保留一份明文备份以防止数据丢失。在加密文件的过程中，尽管加密算法非常强大，但仍有可能由于误操作、硬件故障或其他不可预见的原因导致数据损坏或丢失。因此，保留一份明文备份确保在紧急情况下可以恢复重要数据。</p><p><strong>l</strong> ****用户友好的加密和解密操作****：用户需要一种直观且易于操作的加密工具，可以简化加密和解密过程。一款好的文件加密驱动应用应当具备简洁明了的界面，允许用户轻松选择需要加密的文件或文件夹，同时也能方便地进行解密操作，确保用户体验顺畅无阻。</p><p><strong>l</strong> ****高效的加密算法****：用户希望加密工具不仅安全可靠，还能高效地处理文件。加密算法的选择至关重要，既要确保数据的高度安全性，又要保证在大文件或大量文件加密时的处理速度，使得加密过程不至于过于拖延工作效率。</p><p><strong>l</strong> ****版本控制和加密历史记录****：用户需要对加密文件进行版本控制和查看历史记录的功能。这样，他们可以追踪文件的加密、修改和解密的时间点及操作人，在需要时回溯到特定版本，为数据管理和审计提供便利。</p><h3 id="（一）-文件透明加解密"><a href="#（一）-文件透明加解密" class="headerlink" title="（一） 文件透明加解密"></a>（一） 文件透明加解密</h3><p>在当今高度数字化的信息社会，数据安全和隐私保护变得尤为重要。随着网络犯罪、数据泄露和隐私侵犯事件的频繁发生，用户和企业面临的风险与日俱增。无论是黑客攻击、恶意软件，还是内部人员的无意泄露，都可能导致敏感信息的外泄，进而带来严重的经济损失、法律责任以及声誉损害。因此，如何有效保护数据的安全性成为一个亟待解决的问题。</p><p>为了应对这些挑战，我们的加密系统需要实现透明的文件加解密功能。这个功能的核心在于用户在访问文件时无需手动进行加解密操作，系统会自动完成这一过程。这样的设计不仅极大地简化了用户的操作流程，使得用户在日常工作中无需关心复杂的加解密步骤，还显著提高了工作效率。同时，自动化的加解密过程确保了数据在传输和存储中的安全性，避免了因人为操作失误导致的潜在风险。</p><p>通过这种透明的文件加解密机制，用户可以在不知不觉中享受到高强度的数据保护。无论是企业内部的敏感文档，还是个人用户的私密文件，都可以在无需额外操作的情况下得到有效的加密保护。这种便捷性和高效性不仅提升了用户体验，也为企业和个人的数字资产提供了坚实的保障。在当前信息安全威胁日益严峻的背景下，我们的加密系统无疑为用户提供了一道重要的防线。</p><p>我们的加密系统具体功能包括：</p><p>1）****针对特定进程进行文件加解密操作****：我们加密系统的一个显著特点是能够针对特定进程进行文件加解密操作。也就是说，系统会监测并识别特定的应用程序和进程，当这些进程试图访问文件时，系统会自动执行相应的加解密操作。通过这种方式，只有经过授权的进程才能够访问加密文件，从而强化了文件的安全性和访问控制。</p><p>2）****自动加解密操作****：我们的加密系统能够在文件被写入时自动加密，在文件被读取时自动解密。这意味着，当用户保存或修改文件时，系统会即时加密文件，确保其在存储介质上的任何时候都是以加密形式存在的。同样，当用户或授权进程需要读取文件时，系统会实时解密文件，使得用户可以无缝访问文件内容，而无需手动进行加解密操作。这样的设计不仅提升了数据的安全性，还极大地简化了用户的操作流程。</p><p>3）****无缝集成与用户透明度****：我们的加密系统设计旨在最大限度地减少用户的参与和干预。用户在日常工作中无需关心文件的加解密过程，一切都在后台自动完成。无缝的透明加解密功能确保了文件的安全性，同时保持了用户体验的一致性和便捷性。</p><p>4）****细粒度的进程过滤****：系统可以通过设置细粒度的进程过滤规则，确定哪些进程有权访问哪些特定文件或文件类型。这种细粒度的控制能够确保只有经过授权的应用程序可以访问特定的加密文件，进一步增强了系统的安全性和灵活性。</p><p>5）****高效的性能保障****：在实现文件透明加解密的同时，我们的系统也注重性能优化。通过高效的加密算法和优化的加解密流程，确保系统在执行加解密操作时不会对文件访问的速度和响应时间产生显著影响，为用户提供流畅的使用体验。</p><p>6）****安全日志与审计****：系统会记录所有加解密操作的日志，包括文件的访问时间、操作类型和进程信息。这些日志可用于安全审计和问题排查，帮助用户全面了解和监控文件的访问情况，进一步提升系统的安全管理能力。</p><p>综上所述，我们的文件透明加解密系统通过针对特定进程的过滤和自动化的加解密操作，为用户提供了高效、安全且便捷的数据保护解决方案。这种设计不仅大大简化了用户的操作流程，提高了工作效率，还增强了数据的安全性和系统的兼容性，为用户的数据安全保驾护航。</p><h3 id="（二）-远程备份服务器"><a href="#（二）-远程备份服务器" class="headerlink" title="（二） 远程备份服务器"></a>（二） 远程备份服务器</h3><p>在当今信息化社会，数据的重要性不言而喻，数据丢失或损坏可能导致严重的经济损失和业务中断。为了确保数据的安全和可恢复性，我们设计了一套完善的远程备份方案，旨在为用户提供可靠的长距离数据保护服务。远程备份服务器是这一方案的核心组件，通过高效的备份和恢复机制，确保用户数据在任何情况下都能得到妥善保存和快速恢复。</p><p>具体来说，我们的远程备份功能具备以下几项关键要求：</p><p>1）****系统能够将文件的明文备份保存到远程服务器。****这一过程包括将用户本地的文件数据通过安全的传输协议上传到远程服务器，并在服务器端进行存储。为了确保数据在传输过程中的安全性，我们采用了先进的加密传输技术，防止数据被截获或篡改。同时，为了保证备份数据的一致性和完整性，系统在上传过程中会进行校验，确保每个文件的备份都能够准确无误地保存到远程服务器上。</p><p>2）****系统支持用户从远程服务器下载备份文件。****当用户需要恢复数据时，可以通过简单的操作从远程服务器下载所需的备份文件。下载过程同样采用加密传输技术，确保数据在传输过程中的安全性。此外，系统提供了灵活的恢复选项，用户可以选择恢复整个备份文件夹或单个文件，满足不同场景下的数据恢复需求。为了提升用户体验，系统界面设计简洁友好，下载操作便捷高效，用户可以轻松找到并恢复所需的备份文件。</p><p>3）****在数据安全性方面，我们对存储在远程服务器上的备份数据进行了严格的访问控制。****只有经过授权的用户和应用程序才能访问和操作备份数据，防止未经授权的访问和数据泄露。系统还提供了详细的访问日志，记录每一次备份和恢复操作，方便用户进行安全审计和问题排查。</p><p>综上所述，我们设计的远程备份功能不仅能够确保数据的安全和可恢复性，还具备高效的传输和存储能力，灵活的备份和恢复选项，以及严格的安全控制措施。通过这套完善的远程备份方案，用户可以安心地将数据托付给我们的系统，无论何时何地，都能确保数据的完整性和安全性，真正实现数据的无忧备份和快速恢复。</p><h2 id="二-2-整体架构设计"><a href="#二-2-整体架构设计" class="headerlink" title="二.2 *整体架构设计*"></a><strong>二.2</strong> <em><strong>*整体架构设计*</strong></em></h2><p>我们的系统，包括三个主要模块：内核驱动模块、用户程序模块和远程备份模块。</p><p>内核驱动模块是系统的核心部分，负责在操作系统内核层面实现对文件系统的透明加解密操作。该模块能够拦截文件的读写请求，在数据写入磁盘前进行加密处理，在数据读出时进行解密操作，从而确保数据在存储介质上的安全性。通过内核驱动模块，我们能够在操作系统层面提供无缝的加密服务，无需用户干预。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps4.png" alt="img"></p><p>图 1 整体设计架构图</p><p>用户程序模块主要提供用户界面和操作工具，使用户能够方便地进行系统配置和管理。该模块包括图形化的配置界面和命令行工具，用户可以通过这些接口进行系统设置，如指定进程，设置密码。此外，用户程序模块还提供日志查看功能，帮助用户了解加解密操作记录。</p><p>远程备份模块旨在确保数据的安全和可恢复性。该模块将文件的明文备份保存到远程服务器，并支持用户从远程服务器下载备份文件。远程备份模块采用安全的传输协议，能够在保证数据安全性的同时，高效地处理海量数据的存储和检索需求。通过远程备份模块，用户可以在任何时候恢复备份数据，确保数据的完整性和可用性。</p><h3 id="（一）-内核驱动模块设计"><a href="#（一）-内核驱动模块设计" class="headerlink" title="（一） 内核驱动模块设计"></a>（一） 内核驱动模块设计</h3><p>内核驱动模块是系统安全机制的核心，负责实现透明的文件加解密操作，确保数据在存储介质上的安全性。具体设计包括以下几个方面：</p><p>1）****文件写后加密****：在文件写入操作完成后，内核驱动模块会自动对文件内容进行加密处理。此过程在文件系统级别进行，用户和应用程序无需进行任何额外的操作或配置。加密算法采用先进的加密标准，确保数据在存储介质上的高度安全性，防止未经授权的访问和信息泄露。</p><p>2）****文件读前解密****：在文件读取操作开始前，内核驱动模块会自动对文件内容进行解密处理。此过程同样在文件系统级别进行，对用户和应用程序透明。解密操作保证了用户和应用程序在访问文件时得到的是原始的明文数据，提高了系统的易用性和透明度。</p><p>3）****验证进程身份****：为了确保加解密操作的安全性，内核驱动模块会验证触发这些操作的进程身份。只有经过授权的进程才能执行加解密操作，防止恶意进程利用该功能进行攻击或窃取数据。验证机制包括进程标识符（PID）检查和权限验证，确保只有可信赖的进程能够进行敏感的加解密操作。</p><p>4）****保存文件明文备份至缓冲区****：在文件写入时，除了进行加密处理外，内核驱动模块还会将文件的明文备份保存到缓冲区。这个缓冲区用于临时存储文件的明文版本，便于在需要时进行快速恢复或用于其他安全操作。缓冲区管理采用高效的内存分配和存储策略，确保系统性能不受影响，同时保证明文备份的完整性和安全性。</p><p>内核驱动模块通过这些功能的集成，实现了对文件系统的透明加解密保护，有效提高了数据的安全性和系统的可靠性。文件写后加密和文件读前解密机制确保了数据在存储和访问过程中的安全性；验证进程身份防止了未经授权的加解密操作，从根本上提高了系统的安全防护能力；保存文件明文备份至缓冲区则为数据恢复和其他安全操作提供了基础支持。通过这一模块的设计和实现，我们能够在不影响用户操作体验的前提下，为用户数据提供强有力的安全保护。</p><h3 id="（二）-用户程序模块设计"><a href="#（二）-用户程序模块设计" class="headerlink" title="（二） 用户程序模块设计"></a>（二） 用户程序模块设计</h3><p>用户程序模块是系统与用户交互的桥梁，提供直观的图形化界面，方便用户进行各种配置和控制操作。具体设计包括以下几个方面：</p><p>1）****配置驱动参数****：用户程序模块允许用户配置与内核驱动相关的参数，确保系统能够按照用户需求进行加解密操作。用户可以通过图形化界面指定需要进行加解密操作的进程，这些进程将在内核驱动模块中被授权执行加解密操作。此外，用户还可以设置和管理加密密码。密码的设置采用严格的安全策略，包括要求用户输入强密码、定期更新密码等，确保加密过程的安全性和可靠性。配置界面设计简洁友好，用户可以轻松完成参数的设置和修改。</p><p>2）****完成远程备份****：用户程序模块还负责与远程备份服务器进行通信，完成文件的上传和下载操作。在用户界面中，用户可以选择需要备份的文件和文件夹，并启动备份操作。系统将通过安全的传输协议将文件上传至远程备份服务器，确保数据在传输过程中的安全性。用户也可以通过界面查看备份记录，并在需要时下载备份文件进行数据恢复。远程备份功能不仅提供高效的数据保护，还支持灵活的备份和恢复选项，满足用户的多样化需求。</p><p>3）****用户界面****：为了提升用户体验，用户程序模块提供了直观且易于操作的图形化界面。界面设计遵循用户体验最佳实践，布局清晰，功能划分明确，用户可以通过简单的点击和输入完成各种配置和操作。界面还提供实时状态监控和日志查看功能，用户可以随时了解系统的运行状况和操作记录，便于进行系统管理和问题排查。</p><p>4）****安全与权限管理****：用户程序模块具有严密的安全与权限管理机制，防止未经授权的访问和操作。用户需要通过身份验证才能访问配置界面和进行操作，确保只有授权用户才能对系统进行配置和管理。系统还提供详细的操作日志，记录每一次配置和备份操作，便于安全审计和问题追踪。</p><p>用户程序模块通过这些功能的集成，为用户提供了便捷的配置和控制手段，确保系统能够灵活、安全地进行文件的加解密和远程备份操作。配置驱动参数功能使用户能够根据需要灵活设置加解密进程和密码；远程备份功能确保用户数据的安全性和可恢复性；通过直观的用户界面和严格的安全管理，用户程序模块提升了系统的易用性和安全性，满足了用户对数据保护和系统管理的需求。</p><h3 id="（三）-远程备份模块设计"><a href="#（三）-远程备份模块设计" class="headerlink" title="（三） 远程备份模块设计"></a>（三） 远程备份模块设计</h3><p>远程备份模块运行在服务器端，是确保数据安全和可恢复性的关键组件。其主要功能包括以下几个方面：</p><p>1）****接收客户端的上传请求****：远程备份模块能够接收来自客户端的文件备份上传请求。用户在客户端发起备份操作后，模块通过安全的传输协议（如HTTPS或其他加密通信协议）接收并保存用户上传的文件备份。服务器端进行严格的身份验证和权限检查，确保只有经过认证的用户才能进行文件上传操作。上传过程中，模块会对数据进行校验，确保文件的完整性和传输的正确性。</p><p>2）****处理下载请求****：远程备份模块同样具备处理下载请求的能力。当用户需要恢复或下载备份文件时，模块会响应用户的下载请求，通过安全的传输通道将备份文件发送至客户端。下载请求同样需要进行身份验证和权限检查，以确保只有授权用户能够访问备份文件。模块支持多种下载形式，包括单个文件下载和批量下载，满足用户不同的恢复需求。</p><p>3）****保存文件内容与索引****：在服务器端，远程备份模块不仅保存用户上传的文件内容，还维护详细的索引信息。文件内容按照用户和文件类型进行分类存储，并采用高效的存储结构保证数据的快速访问和检索。索引信息包括文件名、上传时间、文件大小、用户ID等，通过这些索引信息，模块可以迅速定位和检索用户需要的备份文件。索引机制还支持模糊搜索和条件检索，提供灵活的查询功能。</p><p>4）****数据备份与冗余****：为进一步提高数据的可靠性，远程备份模块会对存储的数据进行冗余备份。通过多副本存储和分布式数据存储技术，模块能够在发生硬件故障或其他突发事件时，迅速从冗余备份中恢复数据，确保用户数据的高可用性和持久性。</p><p>5）****性能优化与扩展性****：远程备份模块在设计时考虑了高并发和大数据量的处理能力，采用负载均衡和分布式存储架构，确保在大量用户同时进行备份和恢复操作时，系统仍能保持高效的性能表现。模块还具备良好的扩展性，能够根据业务需求灵活扩展存储容量和处理能力，满足不断增长的用户需求。</p><p>通过这些功能的集成，远程备份模块为用户提供了安全、可靠和高效的远程备份服务。接收客户端的上传请求和处理下载请求保证了备份操作的顺畅进行；保存文件内容与索引功能确保了数据的快速检索和管理；数据安全与加密存储策略保护了用户数据的隐私和安全；数据备份与冗余机制则提高了数据的可靠性和可用性；性能优化与扩展性设计保证了系统的高效运行和灵活扩展。远程备份模块通过全面的功能和严密的安全设计，为用户提供了强有力的数据保护解决方案。</p><h1 id="三、-关键技术研究"><a href="#三、-关键技术研究" class="headerlink" title="三、 *关键技术研究*"></a><strong>三、</strong> <em><strong>*关键技术研究*</strong></em></h1><p>我们从四个关键方面进行了Windows文件加密驱动的设计：文件加密驱动的核心技术、用户程序功能的实现、远程备份功能的集成、以及模块接口的设计。这些方面涵盖了系统的安全性、可用性和扩展性。每个部分都需要满足特定的性能要求和指标，以确保整个加密系统的高效运行和安全性。通过深入研究这些关键技术，我们能够确保设计出的文件加密驱动在实际应用中具备出色的性能和可靠性。</p><h2 id="三-1-文件加密驱动研究"><a href="#三-1-文件加密驱动研究" class="headerlink" title="三.1 *文件加密驱动研究*"></a><strong>三.1</strong> <em><strong>*文件加密驱动研究*</strong></em></h2><h3 id="（一）-概述"><a href="#（一）-概述" class="headerlink" title="（一） 概述"></a>（一） 概述</h3><p>文件加密驱动的设计和实现是确保文件系统安全性的关键环节。通过透明的文件加解密处理，这一驱动程序可以有效防止未授权访问和数据泄露，保护用户的重要信息免遭恶意攻击和未经许可的访问。透明处理意味着用户和应用程序无需意识到加密和解密操作的存在，这不仅提升了安全性，还确保了用户体验的无缝性。</p><p>文件加密驱动在内核态执行，具有高效处理文件I&#x2F;O操作的能力。相比于用户态执行，内核态操作能够直接与操作系统的核心交互，从而减少上下文切换的开销，提高系统响应速度和整体性能。在这种模式下，加解密操作与文件I&#x2F;O过程紧密结合，确保每次读写操作都经过严格的加密或解密处理。</p><p>此外，内核态执行的文件加密驱动能够更好地利用系统资源和硬件加速功能，例如使用处理器的加密指令集来加速加密算法的执行。这种高效的处理方式不仅确保了系统性能不受到明显影响，还能在某些情况下提升系统的I&#x2F;O性能。</p><p>文件加密驱动的设计和实现需要综合考虑安全性、性能和用户体验等多方面因素。通过内核态的高效执行和透明的加解密处理，该驱动程序能够为用户提供强大的数据保护功能，同时确保系统的高效运行和稳定性。这一关键技术环节在现代信息安全体系中具有不可替代的重要作用。</p><h3 id="（二）-研究目标"><a href="#（二）-研究目标" class="headerlink" title="（二） 研究目标"></a>（二） 研究目标</h3><p>我们的研究目标是开发一个高效、安全、可靠的文件加密驱动。该驱动应能够在不影响用户体验的前提下，实现文件的实时加解密处理，并提供严格的进程身份验证机制。最终目标是保护文件数据的机密性和完整性，同时确保系统的稳定性和可维护性。具体来说，我们的目标包括以下几个方面。</p><p><strong>1)</strong> ****高效性****：我们的文件加密驱动应具备卓越的性能，能够在不显著影响系统整体效率的情况下，快速处理文件的加密和解密操作。我们将通过优化算法和合理的资源调度，确保加解密过程尽可能高效。</p><p><strong>2)</strong> ****安全性****：安全性是文件加密驱动的核心目标之一。我们将采用先进的加密算法和安全协议，确保文件数据在存储和传输过程中始终保持机密性和完整性。同时，我们将设计严格的访问控制和身份验证机制，以防止未经授权的进程和用户访问加密文件。</p><p><strong>3)</strong> ****可靠性****：文件加密驱动应具备高度的可靠性，能够在各种操作环境下稳定运行。我们将通过详尽的测试和验证，确保驱动在处理大规模数据和高频文件操作时，能够保持稳定性和可靠性。错误处理机制也将被精心设计，以在出现异常情况时迅速恢复，并最小化对用户的影响。</p><p><strong>4)</strong> ****用户体验****：在保障安全性和效率的前提下，我们还将特别关注用户体验。文件加密和解密过程应对用户和应用程序透明，不影响正常的文件操作和系统性能。用户界面和交互设计将简洁直观，便于用户管理加密文件和配置相关设置。</p><p><strong>5)</strong> ****进程身份验证机制****：我们将设计和实现严格的进程身份验证机制，确保只有经过授权的进程能够触发文件的加解密操作。此机制将防止未授权进程访问加密文件，进一步提升系统的安全性。</p><p><strong>6)</strong> ****可维护性****：文件加密驱动的设计应考虑长远的可维护性和可扩展性。代码结构将尽量模块化，便于后续的维护和功能扩展。同时，我们将提供详细的日志记录和诊断工具，帮助开发者和系统管理员快速定位和解决问题。</p><h3 id="（三）-研究内容"><a href="#（三）-研究内容" class="headerlink" title="（三） 研究内容"></a>（三） 研究内容</h3><h4 id="1）-文件加解密算法"><a href="#1）-文件加解密算法" class="headerlink" title="1） 文件加解密算法"></a>1） <strong>文件加解密算法</strong></h4><p>选择合适的加密算法是文件加密驱动设计的首要任务。我们考虑使用RC4作为加密算法，并在内核态实现高效的加解密操作。这是因为RC4是一种高效的对称加密算法，具有简单的结构和快速的加解密速度，非常适合在内核态环境中实现。内核态的操作需要快速响应和高性能处理，因此RC4的高效率使其成为一个理想的选择。</p><p>在内核态实现RC4算法时，我们可以利用内核态直接访问硬件资源的能力，进一步优化算法的执行效率。我们可以在内核态实现流水线并行处理和缓存优化，以提高加解密速度。此外，RC4的密钥流生成机制也非常适合内核态环境，可以通过高效的随机数生成和密钥管理来保证加解密过程中的数据完整性和安全性。</p><p>为了确保RC4算法的安全性，我们将特别关注以下几个方面：</p><p><strong>1.</strong> ****密钥管理****：设计安全的密钥管理机制，确保密钥在整个加解密过程中保持机密</p><p><strong>2.</strong> ****随机数生成****：使用高质量的随机数生成器，防止预测性攻击。</p><p><strong>3.</strong> ****防止攻击****：采取措施防止常见的加密攻击，如重放攻击和中间人攻击，确保数据在传输和存储过程中不被篡改或窃取。</p><p>通过这些优化和安全措施，我们能够在内核态实现一个高效、安全的RC4加解密模块，满足文件加密驱动的性能需求。</p><h4 id="2）-文件I-O拦截"><a href="#2）-文件I-O拦截" class="headerlink" title="2） 文件I&#x2F;O拦截"></a>2） <strong>文件I&#x2F;O拦截</strong></h4><p>通过微筛选器技术拦截文件的读写操作，并在适当的时机进行加解密处理是文件加密驱动的核心功能之一。微筛选器技术允许我们在文件系统操作层面上，精细地控制文件的读写行为，从而确保每次文件操作都能经过加密或解密处理。</p><p>研究的重点在于如何高效、准确地拦截文件I&#x2F;O操作，同时确保加解密过程不会引入显著的性能开销。具体来说，我们需要关注以下几个方面：</p><p><strong>1.</strong> ****拦截机制的设计****：过设计高效的微筛选器驱动程序，我们能够拦截文件系统的各种I&#x2F;O请求包（IRP）。这些请求包包括文件的打开、读取、写入和关闭等操作。我们需要确保拦截机制能够准确识别这些I&#x2F;O操作，并在适当的时机对文件数据进行加解密处理。例如，在文件被读取时，先解密文件内容再返回给用户；在文件被写入时，先加密数据再进行存储。</p><p><strong>2.</strong> ****性能优化****：截文件I&#x2F;O操作会带来一定的性能开销，因此我们需要研究如何在不显著影响系统性能的前提下，实现高效的加解密处理。可以采用以下优化策略：</p><p>l 异步处理：利用异步I&#x2F;O操作，将加解密处理与文件I&#x2F;O请求的实际处理分离，以减少同步等待时间。</p><p>l 缓存机制：通过设计高效的缓存机制，减少重复加解密操作。例如，可以缓存解密后的文件数据，当同一文件在短时间内被多次读取时，直接返回缓存数据。</p><p>l 批处理技术：在适当情况下，对一批I&#x2F;O请求进行统一处理，以减少每次I&#x2F;O操作的加解密开销。</p><p><strong>3.</strong> ****数据一致性和安全性****：拦截文件I&#x2F;O操作时，必须确保数据的一致性和安全性。任何加解密处理都不应破坏文件的完整性，尤其是在多线程或并发操作的情况下。需要设计合适的锁机制和同步策略，确保在高并发环境下，加解密操作仍然是安全可靠的。</p><p><strong>4.</strong> ****错误处理和恢复机制****：拦截和处理文件I&#x2F;O操作过程中，可能会遇到各种错误情况，如加解密失败、I&#x2F;O请求异常等。我们需要设计健全的错误处理机制，能够在错误发生时及时恢复正常操作，并记录相关错误信息以供后续调试和维护。</p><p>通过这些措施，我们可以实现一个高效、准确的文件I&#x2F;O拦截机制，确保文件加密驱动在提供强大安全保护的同时，仍能保持良好的系统性能和用户体验。</p><h4 id="3）-进程身份验证"><a href="#3）-进程身份验证" class="headerlink" title="3） 进程身份验证"></a>3） <strong>进程身份验证</strong></h4><p>确保只有特定进程可以触发文件的加解密操作，防止未授权的进程访问加密文件，是文件加密驱动的重要安全保障。这需要设计一种可靠的进程身份验证机制，能够准确识别和验证合法进程，并拒绝非法访问请求。以下是该机制的详细设计和实现思路：  </p><p><strong>1.</strong> ****进程白名单****：首先，可以维护一个进程白名单，只有在白名单中的进程才被允许执行加解密操作。白名单可以基于进程的唯一标识符（如PID）或者进程名称进行管理。我们可以通过系统配置文件或管理工具来动态更新白名单，确保其灵活性和安全性。</p><p><strong>2.</strong> ****进程特权级别检查****：同的进程具有不同的权限级别，只有具备特定权限级别的进程才可以执行加解密操作。我们可以通过操作系统的安全机制（如Windows的用户访问控制，UAC）来检查进程的特权级别，确保只有特权级别符合要求的进程才能触发加解密操作。</p><p><strong>3.</strong> ****实时监控和审计****：实时监控和审计机制对于进程身份验证非常重要。我们可以设计一个实时监控模块，记录所有试图执行加解密操作的进程信息，包括进程ID、进程名称、操作时间等。通过审计日志，可以发现并防范潜在的安全威胁和未授权访问行为。</p><p><strong>4.</strong> ****动态行为分析****：用动态行为分析技术，对进程的行为进行实时分析，判断其合法性。例如，通过监控进程的系统调用、资源访问模式等行为特征，识别异常行为并阻止非法进程执行加解密操作。这种方法可以有效应对高级持续性威胁（APT）和零日攻击。</p><p>通过这些设计和策略，我们能够构建一个可靠的进程身份验证机制，确保只有经过授权的合法进程才能触发文件加解密操作，从而有效防止未授权进程访问加密文件，保障系统的安全性和数据的机密性。</p><h4 id="4）-错误处理和日志记录"><a href="#4）-错误处理和日志记录" class="headerlink" title="4） 错误处理和日志记录"></a>4） <strong>错误处理和日志记录</strong></h4><p>在加解密操作失败时记录错误日志，便于调试和维护。研究内容包括如何设计高效的错误处理机制，确保在错误发生时能够快速恢复，并将错误信息详细记录以供后续分析和维护使用。以下是详细的设计和实现思路：</p><p><strong>1.</strong> ****详细的日志记录****：详细的日志记录对于调试和维护至关重要。我们需要设计一个日志系统，能够记录所有加解密操作的详细信息，包括成功和失败的操作。日志记录的内容应包括但不限于：</p><p><strong>l</strong> ****操作时间戳****：记录操作的开始和结束时间，以便分析操作的时效性和性能。</p><p><strong>l</strong> ****操作类型和状态****：记录具体的加密或解密操作类型，以及操作是否成功。</p><p><strong>l</strong> ****文件信息****：记录涉及操作的文件名称、路径和大小等信息，方便定位问题文件。</p><p><strong>l</strong> ****进程信息****：记录发起操作的进程ID、进程名称和用户身份，便于审计和安全分析。</p><p><strong>l</strong> ****错误详情****：在操作失败时，记录具体的错误类型、错误代码和错误描述，帮助开发人员和运维人员快速定位和解决问题。</p><p><strong>l</strong> ****环境信息****：记录操作时的系统环境信息，如操作系统版本、内存状态、CPU负载等，便于重现问题和进行性能分析。</p><p><strong>2.</strong> ****日志管理和分析工具：****为了有效地管理和分析日志数据，我们需要设计和实现日志管理工具。该工具应具备以下功能：</p><p><strong>l</strong> ****日志存储和归档****：设计高效的日志存储机制，确保日志数据不会因为存储空间不足而丢失。定期归档旧日志，以便长期保存和备查。</p><p><strong>l</strong> ****日志查询和过滤****：提供便捷的查询和过滤功能，允许用户按时间、操作类型、文件、进程等条件检索日志数据，快速找到所需信息。</p><p><strong>l</strong> ****日志分析和报告****：设计日志分析工具，能够自动生成统计报告和图表，帮助用户了解系统运行状况和错误发生情况。例如，按时间段统计加解密操作的成功率和失败率，分析错误类型的分布等。</p><p><strong>l</strong> ****警报和通知****：在检测到关键错误或异常行为时，系统可以自动生成警报并通知相关人员，确保问题能够及时处理。例如，通过电子邮件、短信或系统通知等方式发送警报。</p><p><strong>3.</strong> ****安全性和隐私保护****：在记录和管理日志数据时，必须确保日志内容的安全性和隐私保护。我们可以采取以下措施：</p><p><strong>l</strong> ****日志加密****：对日志数据进行加密存储，防止未授权访问和数据泄露。</p><p><strong>l</strong> ****访问控制****：设计严格的访问控制机制，确保只有授权人员可以访问和管理日志数据。</p><p><strong>l</strong> ****日志审计****：记录对日志数据的所有访问和操作行为，进行审计和追踪，防止日志篡改和滥用。</p><p>通过以上设计和措施，我们可以建立一个高效、可靠的错误处理和日志记录系统，确保文件加密驱动在出现错误时能够快速恢复，提供详细的日志信息供后续分析和维护使用。</p><h3 id="（四）-设计原则"><a href="#（四）-设计原则" class="headerlink" title="（四） 设计原则"></a>（四） 设计原则</h3><p><strong>1)</strong> ****安全性****：所有的加解密操作必须确保数据的机密性和完整性。算法选择和实现必须经过严格的安全性验证，防止任何潜在的攻击或漏洞。在具体实现过程中，我们将采用经过广泛验证和认可的加密算法，如RC4，并结合最新的安全协议，确保数据在传输和存储过程中的安全性。我们还将实施严格的密钥管理策略，确保密钥在整个生命周期中都能得到安全的存储和传输，防止密钥泄露或被篡改。此外，我们将进行定期的安全审计和渗透测试，及时发现和修复潜在的安全漏洞，确保系统始终处于安全状态。</p><p><strong>2)</strong> ****性能****：文件加密驱动应尽可能减少对系统性能的影响。在设计过程中，需要充分考虑内核态操作的效率，优化算法和拦截机制，以确保系统的高性能运行。我们将采用高效的加解密算法，并进行深度的代码优化，确保加解密操作能够在最低的计算开销下完成。同时，我们会利用并行处理和多线程技术，充分利用多核处理器的性能优势，提高系统的并发处理能力。此外，我们将设计高效的缓存机制，减少重复加解密操作对系统性能的影响，通过这些优化策略，确保文件加密驱动在提供强大安全保护的同时，仍能保持优异的系统性能。</p><p><strong>3)</strong> <em><strong>*可靠性*</strong></em>: 系统应具有高可靠性，在出现错误时能够迅速恢复，并提供详细的日志记录以支持调试和维护。错误处理机制必须健全，确保在异常情况下系统能够稳定运行。为此，我们将设计健全的错误检测和处理机制，能够及时捕捉并处理各种异常情况。在发生错误时，系统应能够迅速进行恢复操作，如自动重试、回滚等，确保数据的一致性和系统的稳定性。同时，我们将记录所有的操作日志和错误日志，包括操作时间、操作类型、文件信息、进程信息、错误详情等，提供详尽的调试信息支持，帮助开发人员和系统管理员快速定位和解决问题。</p><p><strong>4)</strong> <em><strong>*可维护性*</strong></em>: 代码设计应尽量简洁、模块化，便于后续的维护和升级。所有的日志记录和错误处理信息都应详细记录，提供必要的调试信息支持。我们将采用模块化设计，将文件加密驱动的不同功能分解为多个独立的模块，每个模块负责特定的功能。这样，不仅能够提高代码的可读性和可维护性，还能够方便地进行功能扩展和更新。同时，我们将编写详细的文档和注释，记录系统的设计思路、实现细节和使用方法，帮助开发人员和维护人员快速理解和掌握系统。此外，我们还将设计友好的用户界面和管理工具，提供便捷的配置和管理功能，帮助用户轻松进行系统的配置和维护。</p><p>通过对以上各个方面的深入研究和设计，我们期望能够设计和实现一个高效、安全、可靠的Windows文件加密驱动，为用户提供强大的数据保护功能。我们的目标是确保用户的数据始终处于安全状态，同时系统能够高效运行，具有高度的可靠性和易维护性，从而为用户提供最佳的使用体验。</p><h2 id="三-2-用户程序功能研究"><a href="#三-2-用户程序功能研究" class="headerlink" title="三.2 *用户程序功能研究*"></a><strong>三.2</strong> <em><strong>*用户程序功能研究*</strong></em></h2><h3 id="（一）-概述-1"><a href="#（一）-概述-1" class="headerlink" title="（一） 概述"></a>（一） 概述</h3><p>用户程序功能设计是确保用户能够便捷、安全地使用文件加密驱动的重要环节。通过设计友好的图形用户界面、可靠的配置参数保存机制和安全的通信方式，用户程序提供了一个直观、易于导航的操作界面，并强化了系统的数据保护能力，使用户能够轻松设置和管理文件加密选项，同时确保配置和数据在各种使用场景下的安全性。</p><p>图形用户界面（GUI）需要直观、响应迅速，使用户无需了解底层技术即可完成任务。此外，GUI设计应兼顾不同用户习惯和操作系统的兼容性，确保在不同平台上提供一致的用户体验。</p><p>配置参数保存机制确保用户设置的持久性和安全性。系统重启后，用户的设置能自动恢复，提升使用便利性。</p><p>安全通信确保用户程序与内核驱动及远程服务器之间的数据交换安全。使用TLS&#x2F;SSL等加密协议保护数据传输的完整性和机密性，防止数据被截获或篡改。</p><p>总体而言，用户程序功能设计在文件加密驱动的整体架构中扮演着至关重要的角色。通过关注图形用户界面的友好性、配置参数保存机制的可靠性和通信过程的安全性，我们能够为用户提供一个高效、安全且易用的文件加密解决方案，满足用户对数据保护和操作便捷性的双重需求。</p><h3 id="（二）-研究目标-1"><a href="#（二）-研究目标-1" class="headerlink" title="（二） 研究目标"></a>（二） 研究目标</h3><p>我们的研究目标是开发一个功能完善、用户友好且安全可靠的用户程序，能够有效支持文件加密驱动的各项功能。具体目标包括设计直观的图形用户界面、实现配置参数的持久化存储和加密通信，以确保用户在使用过程中能够获得最佳的体验和安全性。</p><h3 id="（三）-研究内容-1"><a href="#（三）-研究内容-1" class="headerlink" title="（三） 研究内容"></a>（三） 研究内容</h3><p><strong>1)</strong> ****图形用户界面****：设计一个直观、友好的图形用户界面（GUI），提供简单易用的配置和操作选项。研究内容包括界面布局、交互设计和用户体验优化。我们需要确保用户能够轻松地完成加密驱动的配置和操作，如设置加密参数、选择加密文件等。此外，界面设计应符合现代化审美标准，提供视觉上的舒适感和操作上的流畅感。</p><p><strong>2)</strong> ****配置参数保存****：实现配置参数的持久化存储，将用户配置的参数保存到本地，以便在系统重启后能够恢复配置。研究内容包括选择合适的存储方式（如配置文件、注册表或数据库），确保参数保存的安全性和可靠性。我们需要设计一种高效的参数存储机制，能够快速读取和写入配置数据，并在必要时进行加密存储，以防止配置数据被篡改或泄露。</p><p><strong>3)</strong> ****安全通信****：实现与内核驱动和远程服务器之间的安全通信，确保传输数据的安全性。研究内容包括设计和实现加密通信协议，防止数据在传输过程中被窃听或篡改。我们可以采用TLS（传输层安全）协议或其他加密通信标准，确保数据传输的机密性和完整性。此外，我们还需要设计认证机制，确保只有经过授权的用户和服务器才能进行通信，防止未经授权的访问和操作。</p><h3 id="（四）-设计原则-1"><a href="#（四）-设计原则-1" class="headerlink" title="（四） 设计原则"></a>（四） 设计原则</h3><p><strong>1)</strong> ****安全性****：用户程序的所有操作和通信必须确保数据的机密性和完整性。界面设计、配置参数保存和通信协议都必须经过严格的安全性验证，防止任何潜在的攻击或漏洞。</p><p><strong>2)</strong> ****易用性****：用户界面的设计应注重用户体验，提供直观的操作流程和清晰的界面布局。配置参数的保存和恢复应当尽量简化操作步骤，减少用户的操作负担。</p><p><strong>3)</strong> ****可靠性****：用户程序应具备高可靠性，在任何情况下都能够正常运行。配置参数保存和通信机制应确保数据不丢失、不篡改，提供详细的错误处理和恢复机制，保证系统的稳定性。</p><p><strong>4)</strong> ****可维护性****：用户程序的代码设计应尽量简洁、模块化，便于后续的维护和升级。所有的操作日志和错误信息都应详细记录，提供必要的调试信息支持，帮助开发人员和维护人员快速定位和解决问题。</p><p>通过对以上各个方面的深入研究和设计，我们期望能够开发出一个高效、安全、可靠且用户友好的用户程序，为文件加密驱动提供强大的支持和保障。我们的目标是确保用户在使用过程中能够获得最佳的体验，同时系统能够高效、安全地运行。</p><h2 id="三-3-远程备份功能研究"><a href="#三-3-远程备份功能研究" class="headerlink" title="三.3 *远程备份功能研究*"></a><strong>三.3</strong> <em><strong>*远程备份功能研究*</strong></em></h2><h3 id="（一）-概述-2"><a href="#（一）-概述-2" class="headerlink" title="（一） 概述"></a>（一） 概述</h3><p>远程备份功能的设计和实现是确保用户数据安全和可恢复性的重要环节。在当今信息化时代，数据的价值不断提升，数据丢失或损坏可能带来巨大的损失。因此，构建一个强大且可靠的远程备份系统至关重要。通过安全的数据传输、严格的数据完整性验证和高效的备份文件管理机制，远程备份功能不仅能够保护用户的敏感信息免受恶意攻击和数据泄露，还能在数据意外丢失时迅速恢复，保障业务的连续性和数据的完整性。</p><p>远程备份功能的设计和实现必须全面考虑安全性、完整性、高效性、可靠性和可维护性，确保用户数据在各种情况下都能得到安全存储和快速恢复，从而提供可靠的数据保护服务，增强用户对数据安全的信心。</p><h3 id="（二）-研究目标-2"><a href="#（二）-研究目标-2" class="headerlink" title="（二） 研究目标"></a>（二） 研究目标</h3><p>我们的研究目标是开发一个安全、高效、可靠的远程备份系统，以确保用户数据在各种情况下都能得到安全存储和快速恢复。具体目标包括以下几个方面：</p><p><strong>1)</strong> ****采用SSL&#x2F;TLS协议确保数据在传输过程中的安全性****：数据在传输过程中可能会遭受截获和篡改的风险。为了防止这种情况的发生，我们将采用SSL&#x2F;TLS协议对数据进行加密传输，确保数据在传输过程中始终保持机密性和完整性。通过使用最新的加密算法和安全协议，我们能够有效防止数据被窃听或篡改，保护用户的敏感信息不被泄露。</p><p><strong>2)</strong> ****实现数据完整性验证机制****：数据完整性是远程备份系统中的关键环节。在文件上传和下载过程中，必须进行严格的数据完整性验证，确保文件未被篡改。我们将设计和实现基于哈希值的验证机制，在数据传输前后生成和比对文件的哈希值，确保数据的一致性和可靠性。通过这种验证机制，用户可以放心地存储和恢复数据，确保数据的真实性和完整性。</p><p><strong>3)</strong> ****设计高效的服务器端文件管理和索引机制****：为了支持备份文件的快速检索和恢复，我们将设计高效的服务器端文件管理和索引机制。研究内容包括优化文件存储结构、实现多级索引和缓存策略，以提高文件的存储和检索效率。我们还将实现文件版本控制和生命周期管理，支持多版本文件的存储和过期文件的自动清理，确保备份系统在大规模数据和高并发访问情况下的性能和稳定性。</p><p>通过以上目标的实现，我们期望开发出一个安全、高效、可靠的远程备份系统，为用户提供强大的数据保护服务，确保用户数据在各种情况下都能得到安全存储和快速恢复。</p><h3 id="（三）-研究内容-2"><a href="#（三）-研究内容-2" class="headerlink" title="（三） 研究内容"></a>（三） 研究内容</h3><ol><li>数据传输安全：采用SSL&#x2F;TLS协议确保数据在传输过程中的安全性。研究内容包括：</li></ol><p><strong>l</strong> ****选择合适的SSL&#x2F;TLS版本和加密算法****：确保传输数据的机密性和完整性。我们将评估不同的SSL&#x2F;TLS版本和加密算法，选择最适合的方案，以提供强大的安全保障。  </p><p><strong>l</strong> ****配置和管理SSL&#x2F;TLS证书****：确保通信双方的身份验证和数据加密。我们将应用自动化的证书管理流程，包括证书的生成、签发、续期和吊销，以便简化证书管理并增强系统的安全性。</p><p><strong>l</strong> ****实现传输层的加密模块****：集成到备份系统中，确保所有数据传输均经过加密保护。具体实现包括开发传输层加密模块，支持SSL&#x2F;TLS协议，并将其无缝集成到备份系统的网络通信组件中。我们将进行广泛的兼容性测试，以确保该模块在各种网络环境中都能可靠运行。</p><ol start="2"><li>数据完整性验证：在文件上传和下载过程中进行数据完整性验证，确保文件未被篡改。研究内容包括：</li></ol><p><strong>l</strong> ****设计和实现文件的哈希值生成和验证机制****：在上传前生成文件的哈希值，并在下载后进行验证。我们将使用SHA-256等安全哈希算法，为每个文件生成唯一的哈希值，并在文件传输完成后进行验证，以确保文件的完整性。</p><p><strong>l</strong> ****研究适用于大文件和高并发情况下的高效哈希算法****：确保数据完整性验证的速度和准确性。我们将比较不同哈希算法在处理大文件和高并发请求时的性能表现，选择最适合的算法，并优化其实现，以提高验证速度和准确性。</p><p><strong>l</strong> ****集成数据完整性验证模块****：确保每次文件传输前后均进行完整性检查，防止数据篡改。我们将开发一个数据完整性验证模块，并将其嵌入到文件传输流程中，确保每次文件传输前后都能自动进行哈希值计算和验证。</p><ol start="3"><li>备份文件管理：在服务器端实现高效的文件管理和索引机制，以支持快速检索和恢复。研究内容包括：</li></ol><p><strong>l</strong> ****设计文件存储结构和索引机制****：确保备份文件能够高效存储和快速检索。我们将设计层次化的文件存储结构，结合元数据索引和哈希索引技术，以提高文件存储和检索的效率。</p><p><strong>l</strong> ****实现文件的版本控制和生命周期管理****：支持文件的多版本存储和过期文件的自动清理。我们将开发版本控制系统，记录每个文件的不同版本，并根据预设的策略自动清理过期或冗余文件，节省存储空间。</p><p><strong>l</strong> ****研究和优化文件的存储和检索算法****：确保在大规模数据存储和高并发访问情况下，备份系统的性能和响应速度。我们将探索分布式存储技术和并行检索算法，通过实验验证和性能调优，优化备份系统在处理海量数据和高并发请求时的表现。</p><h3 id="（四）-设计原则-2"><a href="#（四）-设计原则-2" class="headerlink" title="（四） 设计原则"></a>（四） 设计原则</h3><p><strong>1)</strong> ****安全性****：远程备份系统必须确保数据在传输和存储过程中的安全性。所有传输的数据必须经过加密保护，以防止在传输过程中被截获或篡改。为了实现这一目标，我们将采用强大的加密协议（如SSL&#x2F;TLS）来保护数据传输，并使用先进的加密算法（如AES）对存储数据进行加密。此外，系统将实施严格的访问控制和身份验证机制，确保只有经过授权的用户和进程才能访问备份数据。还将引入定期的安全审计和监控，及时发现和应对潜在的安全威胁。</p><p><strong>2)</strong> ****完整性****：数据完整性是远程备份系统的关键。所有备份和恢复的文件在传输过程中必须进行完整性验证，确保文件未被篡改。我们将设计和实现文件哈希值生成和验证机制，在文件上传和下载时生成和验证文件的哈希值，确保数据的一致性。每次文件传输前后，系统都将进行完整性检查，并在发现数据篡改或损坏时立即发出警报并阻止不完整的数据写入或读取，确保用户数据的完整性和可靠性。</p><p><strong>3)</strong> ****高效性****：远程备份系统应具备高效的传输和存储性能。在设计过程中，需要充分考虑大文件和高并发情况下的性能优化，确保系统能够快速响应用户的备份和恢复请求。我们将采用优化的传输协议和算法，提高数据传输的速度和稳定性。同时，设计高效的存储结构和索引机制，减少文件存储和检索的时间。对于高并发访问，系统将引入负载均衡和并行处理技术，确保在高流量情况下仍能保持高性能。</p><p><strong>4)</strong> ****可靠性****：系统应具备高可靠性，确保在各种情况下数据都能安全备份和快速恢复。我们将设计完善的错误处理和恢复机制，确保在出现异常时能够迅速恢复系统的正常运行。例如，系统将实现自动故障检测和恢复功能，在硬件故障或软件错误时能够自动切换到备份系统，并保持数据的可用性和一致性。此外，定期的备份验证和恢复测试将确保备份数据在实际恢复过程中能够正常使用，提供高度可靠的灾难恢复能力。</p><p><strong>5)</strong> ****可维护性****：系统的设计应简洁、模块化，便于后续的维护和升级。所有的日志记录和错误信息都应详细记录，提供必要的调试信息支持，帮助开发人员和运维人员快速定位和解决问题。模块化设计允许各个功能组件独立开发和测试，简化了系统的更新和扩展过程。我们还将提供直观的管理界面和自动化工具，简化日常运维和监控操作，确保系统的高可用性和易维护性。</p><p>通过以上设计原则的实施，我们期望开发出一个安全、完整、高效、可靠且易于维护的远程备份系统，为用户提供强大的数据保护服务，确保用户数据在各种情况下都能得到安全存储和快速恢复。</p><h2 id="三-4-模块接口设计研究"><a href="#三-4-模块接口设计研究" class="headerlink" title="三.4 *模块接口设计研究*"></a><strong>三.4</strong> <em><strong>*模块接口设计研究*</strong></em></h2><h3 id="（一）-概述-3"><a href="#（一）-概述-3" class="headerlink" title="（一） 概述"></a>（一） 概述</h3><p>模块接口设计是确保各个模块能够高效、稳定协作的关键环节。一个系统的模块接口设计直接影响其整体性能和可靠性。通过定义清晰的接口规范、设计合理的异常处理机制和优化接口调用性能，我们可以构建一个高效、可靠的系统，确保各模块之间的通信顺畅，从而提升系统的整体性能和稳定性。</p><p>在实际应用中，各模块之间的接口设计不仅需要满足当前的功能需求，还需要具备良好的扩展性和可维护性，以应对未来的功能扩展和系统升级。接口规范的明确定义，包括函数名称、参数类型和返回值，不仅提高了代码的可读性和一致性，还减少了接口调用时的错误率，便于开发人员理解和使用。</p><p>模块接口设计不仅是技术实现的基础，更是确保系统高效、稳定运行的保障。通过规范化的接口设计、全面的异常处理机制和深入的性能优化，我们能够构建一个高性能、高可靠的系统，为用户提供流畅、可靠的服务体验。</p><h3 id="（二）-研究目标-3"><a href="#（二）-研究目标-3" class="headerlink" title="（二） 研究目标"></a>（二） 研究目标</h3><p>我们的研究目标是设计一个规范化、高效、可靠的模块接口系统，确保各模块之间的无缝协作。具体目标包括：</p><p><strong>1)</strong> ****接口规范化****：定义清晰的接口规范，包括函数名称、参数类型和返回值，确保接口的统一性和可读性。通过制定详细的接口规范，我们可以提高代码的可维护性和可扩展性，减少开发过程中由于接口不一致导致的错误。具体目标包括：</p><p><strong>l</strong> ****函数名称****：制定统一的命名规则，确保函数名称能够清晰地反映其功能和作用。</p><p><strong>l</strong> ****参数类型****：明确每个接口的参数类型和传递方式（如值传递或引用传递），确保接口调用的一致性和可靠性。</p><p><strong>l</strong> ****返回值****：定义接口的返回值类型和含义，确保调用者能够正确处理接口的返回结果。</p><p><strong>2)</strong> ****异常处理****：设计合理的异常处理机制，确保系统在出现错误时能够正确恢复，保证系统的稳定性和可靠性。通过全面的异常处理设计，我们能够提高系统的鲁棒性，减少由于异常情况导致的系统故障。具体目标包括：</p><p><strong>l</strong> ****异常类型****：定义不同类型的异常情况，明确每种异常的处理方式。</p><p><strong>l</strong> ****异常捕获****：设计异常捕获机制，确保所有可能的异常都能被及时捕获并处理，避免异常传播导致系统崩溃。</p><p><strong>l</strong> ****错误恢复****：实现自动恢复机制，确保系统在处理完异常后能够迅速恢复正常运行，保证系统的高可用性。</p><p><strong>3)</strong> ****性能优化****：优化接口调用的性能，减少不必要的开销，提高系统整体效率，确保系统在高负载情况下仍能高效运行。通过深入的性能分析和优化设计，我们能够提高系统的响应速度和处理能力。具体目标包括：</p><p><strong>l</strong> ****调用路径优化****：简化接口调用路径，减少不必要的函数调用和数据传输，提高接口调用的效率。</p><p><strong>l</strong> ****缓存机制****：设计高效的缓存机制，减少重复计算和数据传输，提高接口调用的响应速度。</p><p><strong>l</strong> ****并发控制****：实现并发控制策略，确保接口在高并发访问情况下仍能保持稳定和高效，避免资源争用和死锁等问题。</p><h3 id="（三）-研究内容-3"><a href="#（三）-研究内容-3" class="headerlink" title="（三） 研究内容"></a>（三） 研究内容</h3><p><strong>1)</strong> ****接口规范化****：定义清晰的接口规范是模块接口设计的基础。研究内容包括：</p><p><strong>l</strong> ****接口定义****：确定各模块之间的接口，包括函数名称、参数类型和返回值。确保接口定义统一规范，便于开发和维护。通过详细的接口定义，可以提高模块之间的协作效率，减少由于接口不明确导致的沟通成本和开发错误。</p><p><strong>l</strong> ****文档编写****：编写详细的接口文档，记录每个接口的功能描述、参数说明和返回值定义。文档应易于理解，便于开发人员查阅和使用。完整的接口文档不仅是开发过程中的重要参考，也是后续维护和升级的重要依据。</p><p><strong>l</strong> ****接口一致性****：确保所有接口遵循统一的命名规则和编码风格，提高代码的可读性和一致性，减少接口调用的错误率。通过制定并严格遵守接口一致性规范，可以显著提高代码的可维护性和团队协作效率。</p><p><strong>2)</strong> ****异常处理****：设计合理的异常处理机制，确保系统在出现错误时能够正确恢复。研究内容包括：</p><p><strong>l</strong> ****异常捕获****：定义各模块接口的异常类型和异常处理方法，确保异常能够被及时捕获和处理，防止异常传播导致系统崩溃。通过详细的异常捕获设计，可以快速定位和解决问题，保障系统的稳定性。</p><p><strong>l</strong> ****错误恢复****：设计错误恢复机制，确保系统在出现错误时能够迅速恢复正常运行。包括自动重试、回滚操作和备用方案等，确保系统的高可用性。通过预设的错误恢复策略，可以最小化错误对系统运行的影响。</p><p><strong>l</strong> ****日志记录****：实现详细的异常日志记录，记录每次异常的发生时间、异常类型、错误信息和处理过程，为后续的调试和维护提供支持。详尽的日志记录是系统运维和问题诊断的重要工具，能够帮助开发人员快速识别和修复问题。</p><p><strong>3)</strong> ****性能优化****：优化接口调用的性能，减少不必要的开销，提高系统整体效率。研究内容包括：</p><p><strong>l</strong> ****调用优化****：分析和优化接口调用的路径，减少不必要的函数调用和数据传输，降低接口调用的延迟和资源消耗。通过性能分析工具识别性能瓶颈，并采取相应的优化措施，提升系统的响应速度。</p><p><strong>l</strong> ****缓存机制****：设计高效的缓存机制，减少重复计算和数据传输，提高接口调用的响应速度和系统的整体性能。通过合理的缓存策略，可以显著减少系统的负载，提高数据访问的效率。</p><p><strong>l</strong> ****并发控制****：设计并发控制机制，确保在高并发访问情况下接口调用的稳定性和高效性。包括线程池管理、锁机制和任务调度等，确保系统在高负载下仍能稳定运行。通过优化并发控制策略，可以有效防止资源争用和死锁，提高系统的吞吐量。</p><h3 id="（四）-设计原则-3"><a href="#（四）-设计原则-3" class="headerlink" title="（四） 设计原则"></a>（四） 设计原则</h3><p><strong>1)</strong> ****规范性****：接口设计应具备高度的规范性，确保接口定义清晰、统一，便于开发、测试和维护。所有接口的命名、参数和返回值必须符合统一的规范，确保接口的可读性和一致性。具体而言，接口命名应能够准确描述其功能，参数类型和顺序应遵循一致的标准，并且返回值应明确和一致。通过严格的接口规范，可以提高代码的可读性和可维护性，减少因接口定义不规范导致的错误和误解。</p><p><strong>2)</strong> ****鲁棒性****：接口设计应具备高度的鲁棒性，能够应对各种异常情况。在设计过程中，必须考虑到可能出现的各种异常情况，并设计合理的异常处理和恢复机制，确保系统在出现错误时能够迅速恢复。例如，接口应能够处理无效输入、网络故障、资源不可用等情况，提供详细的错误信息和恢复建议。通过设计健全的异常处理机制，可以提高系统的稳定性和可靠性，减少系统崩溃和数据损坏的风险。</p><p><strong>3)</strong> ****高效性****：接口设计应注重高效性，尽量减少接口调用的开销。在设计过程中，需要充分考虑接口调用的路径和资源消耗，优化数据传输和计算过程，确保接口调用的高效性。具体措施包括减少不必要的数据传输、使用高效的数据结构和算法、避免重复计算等。通过优化接口性能，可以提高系统的响应速度和处理能力，满足高性能应用的需求。</p><p><strong>4)</strong> ****扩展性****：接口设计应具备良好的扩展性，能够适应系统功能的不断扩展和变化。在设计接口时，应考虑到未来可能的扩展需求，确保接口具有良好的灵活性和可扩展性。例如，接口应尽量采用松耦合设计，避免硬编码依赖，提供灵活的配置和扩展点。通过设计具备良好扩展性的接口，可以降低系统的维护成本和扩展难度，支持系统的持续发展和功能升级。</p><p><strong>5)</strong> ****可维护性****：接口设计应注重可维护性，便于后续的维护和升级。所有接口的定义和实现都应具备良好的可读性和可维护性，确保开发人员能够快速理解和修改接口代码，提高系统的可维护性。具体措施包括编写清晰的接口文档、遵循统一的编码规范、进行详细的注释等。通过提高接口的可维护性，可以减少维护和升级过程中的错误和时间成本，提升系统的长期稳定性和可靠性。</p><p>通过对以上各个方面的深入研究和设计，我们期望能够开发出一个规范化、高效、可靠的模块接口系统，确保各模块之间的无缝协作，提升系统的整体性能和稳定性。</p><h1 id="四、-技术实现细节"><a href="#四、-技术实现细节" class="headerlink" title="四、 *技术实现细节*"></a><strong>四、</strong> <em><strong>*技术实现细节*</strong></em></h1><h2 id="四-1-驱动开发测试平台环境"><a href="#四-1-驱动开发测试平台环境" class="headerlink" title="四.1 *驱动开发测试平台环境*"></a><strong>四.1</strong> <em><strong>*驱动开发测试平台环境*</strong></em></h2><p>在驱动开发和测试过程中，选择合适的平台和配置环境对于项目的成功至关重要。我们的开发测试平台选择了Windows 10 企业版 LTSC (Long-Term Servicing Channel)，版本为 Build 19041.vb_release.191206-1406，并且在测试模式下进行。这一选择的原因和配置细节如下：</p><h3 id="（一）-平台选择原因"><a href="#（一）-平台选择原因" class="headerlink" title="（一） 平台选择原因"></a>（一） 平台选择原因</h3><p>选择Windows 10 企业版 LTSC作为开发测试平台有以下几个原因：</p><p><strong>1)</strong> ****稳定性和长期支持****：LTSC版本提供了长期支持和稳定性，避免了频繁的功能更新带来的潜在不稳定因素，非常适合驱动开发和测试。</p><p><strong>2)</strong> ****测试模式支持****：Windows 10测试模式允许加载未签名的驱动程序，方便我们在开发过程中进行调试和测试，而不需要每次更改都重新签名。</p><p><strong>3)</strong> ****广泛兼容性****：Windows 10是目前主流的操作系统版本，选择这一平台能够确保驱动程序在广泛的用户基础上进行测试，最大程度上兼容不同的硬件和软件环境。</p><h3 id="（二）-系统配置细节"><a href="#（二）-系统配置细节" class="headerlink" title="（二） 系统配置细节"></a>（二） 系统配置细节</h3><p>为了确保开发测试环境的一致性和可复现性，详细的系统配置如下：</p><p><strong>1)</strong> ****操作系统****：Windows 10 企业版 LTSC，版本号 Build 19041.vb_release.191206-1406。</p><p><strong>2)</strong> ****测试模式****：启用Windows测试模式，通过命令提示符以管理员权限运行以下命令：bcdedit &#x2F;set testsigning on</p><p>重新启动计算机后，系统将进入测试模式。</p><h3 id="（三）-开发工具介绍"><a href="#（三）-开发工具介绍" class="headerlink" title="（三） 开发工具介绍"></a>（三） 开发工具介绍</h3><p>在驱动开发过程中，我们使用了以下工具和SDK：</p><p><strong>1)</strong> ****Windows 10 SDK (10.0.19041.0)****：该SDK包含开发Windows应用和驱动所需的头文件、库文件、示例代码和工具。具体来说，它提供了开发文件系统筛选驱动所需的API和开发文档。</p><p><strong>2)</strong> ****MSVC v142 (Microsoft Visual C++ 2019)****：这是Visual Studio 2019中的C++编译器版本，为驱动程序开发提供了高效的编译和调试支持。</p><ol start="3"><li>****WDK for Windows 10 (Windows Driver Kit)****：WDK提供了编写高质量Windows驱动程序所需的工具、库和头文件。我们使用的WDK版本与操作系统版本一致，确保了良好的兼容性。</li></ol><h3 id="（四）-配置步骤说明"><a href="#（四）-配置步骤说明" class="headerlink" title="（四） 配置步骤说明"></a>（四） 配置步骤说明</h3><p>配置开发环境的详细步骤如下：</p><p><strong>1)</strong> ****安装Windows 10 SDK****：从微软官网下载Windows 10 SDK (10.0.19041.0)并安装。</p><p><strong>2)</strong> ****安装Visual Studio 2019****：选择安装MSVC v142组件，并确保安装了WDK集成工具。</p><p><strong>3)</strong> ****安装WDK for Windows 10****：从微软官网下载对应版本的WDK，并按照提示进行安装。确保WDK版本与操作系统版本一致。</p><p><strong>4)</strong> ****启用测试模式****：按照前述命令启用测试模式，以便加载和测试未签名的驱动程序。</p><p>通过上述配置，我们建立了一个稳定、高效的开发测试环境，确保驱动程序在Windows 10环境下能够顺利开发和调试。同时，这一环境也为后续的功能测试和性能测试提供了可靠的基础。</p><h2 id="四-2-文件加密驱动实现细节"><a href="#四-2-文件加密驱动实现细节" class="headerlink" title="四.2 *文件加密驱动实现细节*"></a><strong>四.2</strong> <em><strong>*文件加密驱动实现细节*</strong></em></h2><h3 id="（一）-筛选"><a href="#（一）-筛选" class="headerlink" title="（一） 筛选"></a>（一） 筛选</h3><p>在文件加密驱动中，筛选是实现文件读写操作拦截的关键步骤。具体实现细节如下：</p><ol><li>编写DriverEntry 函数，使用FltRegisterFilter函数注册对 RP_MJ_READ 和 IRP_MJ_WRITE 操作的过滤。通过注册微筛选器，可以拦截文件系统的读写请求。</li></ol><p>CONST FLT_OPERATION_REGISTRATION callbacks[] &#x3D; {  {    IRP_MJ_READ,    0,    PreRead,    PostRead,  },  {    IRP_MJ_WRITE,    0,    PreWrite,    PostWrite,  },  {    IRP_MJ_OPERATION_END,  },};</p><p>图 2 FltRegisterFilter函数代码图</p><ol start="2"><li>在FLT_PREOP_CALLBACK回调函数中，使用PsGetCurrentProcess函数获取当前I&#x2F;O操作的进程信息。这有助于识别发起读写请求的进程。</li></ol><p>NTSTATUS status;PEPROCESS process &#x3D; PsGetCurrentProcess();PUNICODE_STRING processImageName &#x3D; NULL;status &#x3D; SeLocateProcessImageName(process, &amp;processImageName);</p><p>图 3 PsGetCurrentProcess函数代码图</p><ol start="3"><li>调用wintrust.sys驱动来验证进程签名，确认进程身份。通过这种方式，可以确保只有被授权的进程才能执行文件加解密操作。</li></ol><p>BOOLEAN VerifySignature(PUNICODE_STRING ImagePath) {  WINTRUST_FILE_INFO FileData;  WINTRUST_DATA WinTrustData;GUID WVTPolicyGUID &#x3D;WINTRUST_ACTION_GENERIC_VERIFY_V2;  LONG status;  RtlZeroMemory(&amp;FileData, sizeof(FileData));  FileData.cbStruct &#x3D; sizeof(WINTRUST_FILE_INFO);  FileData.pcwszFilePath &#x3D; ImagePath-&gt;Buffer;  RtlZeroMemory(&amp;WinTrustData, sizeof(WinTrustData));  WinTrustData.cbStruct &#x3D; sizeof(WINTRUST_DATA);  WinTrustData.dwUnionChoice &#x3D; WTD_CHOICE_FILE;  WinTrustData.pFile &#x3D; &FileData;  WinTrustData.dwUIChoice &#x3D; WTD_UI_NONE;  WinTrustData.fdwRevocationChecks &#x3D; WTD_REVOKE_NONE;  WinTrustData.dwStateAction &#x3D; WTD_STATEACTION_IGNORE;  WinTrustData.dwProvFlags &#x3D; WTD_SAFER_FLAG;  WinTrustData.dwUIContext &#x3D; WTD_UICONTEXT_EXECUTE;  status &#x3D; WinVerifyTrust(NULL, &amp;WVTPolicyGUID, &amp;WinTrustData);  return (status &#x3D;&#x3D; ERROR_SUCCESS);}</p><p>图 4 进程签名验证函数代码图</p><ol start="4"><li>对于匹配的进程，进行后续的加解密操作。未匹配的进程则直接跳过，确保系统的安全性和效率。</li></ol><h3 id="（二）-加解密"><a href="#（二）-加解密" class="headerlink" title="（二） 加解密"></a>（二） 加解密</h3><p>加解密操作是文件加密驱动的核心功能。具体实现细节如下：</p><ol><li>在FLT_PREOP_CALLBACK回调函数中，在写入操作前对缓冲区进行加密处理。这样可以确保写入到磁盘上的数据是加密状态。</li></ol><p>ULONG length &#x3D; Data-&gt;Iopb-&gt;Parameters.Write.Length;LONGLONG offset &#x3D; Data-&gt;Iopb-&gt;Parameters.Write.ByteOffset.QuadPart;PUCHAR buffer &#x3D; (PUCHAR)Data-&gt;Iopb-&gt;Parameters.Write.WriteBuffer;SIZE_T key_len &#x3D; strlen(gRc4Key);RC4_CONTEXT TBox &#x3D; Rc4GetContext((CONST PVOID)gRc4Key, key_len);RC4Crypt(TBox, buffer, length, offset);</p><p>图 5 缓冲区加密代码图</p><ol start="2"><li>在FLT_POSTOP_CALLBACK回调函数中，在读取操作后对缓冲区进行解密处理，确保从磁盘读取的数据是解密后的明文。</li></ol><p>ULONG length &#x3D; Data-&gt;Iopb-&gt;Parameters.Read.Length;LONGLONG offset &#x3D; Data-&gt;Iopb-&gt;Parameters.Read.ByteOffset.QuadPart;PUCHAR buffer &#x3D; (PUCHAR)Data-&gt;Iopb-&gt;Parameters.Read.ReadBuffer;SIZE_T key_len &#x3D; strlen(gRc4Key);RC4_CONTEXT TBox &#x3D; Rc4GetContext((CONST PVOID)gRc4Key, key_len);RC4Crypt(TBox, buffer, length, offset);</p><p>图 6 缓冲区解密代码图</p><ol start="3"><li>使用 RC4 算法进行加解密。RC4是一种流加密算法，具有实现简单、速度快的优点，适合在内核态进行快速加解密操作。RC4算法通过对称密钥流生成伪随机字节流（密钥流），然后将其与明文数据按字节异或来生成密文。具体步骤如下：</li><li>RC4密钥初始化</li></ol><p>l 初始化一个256字节的状态向量<img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps5.jpg" alt="img">，并用0到255的值填充：</p><p>l 用密钥<img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps6.jpg" alt="img">对状态向量 <img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps7.jpg" alt="img"> 进行排列。假设密钥长度为 <img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps8.jpg" alt="img"> 字节，密钥为<img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps9.jpg" alt="img">：</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps10.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps11.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps12.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps13.jpg" alt="img"> </p><ol start="2"><li>RC4密钥流生成</li></ol><p>初始化两个索引<img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps14.jpg" alt="img">和<img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps15.jpg" alt="img">为0。</p><p>生成伪随机字节流：</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps16.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps17.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps18.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps19.jpg" alt="img"> </p><ol start="4"><li>在进行文件读写操作时，根据文件的读写偏移量，先完成对应轮数的RC4密钥流生成，然后对缓冲区进行加解密。</li><li>为了提升性能，在进行RC4密钥流生成时进行缓存。每隔8192字节的偏移量保存一次RC4密钥参数至缓存队列，并更新相关索引。下次读取或写入时，如果偏移量大于某个已缓存的RC4密钥参数，则直接读取缓存的参数，从该偏移量开始继续生成RC4密钥流。这种缓存机制大大减少了RC4密钥流生成的计算轮数，提高了中等大小文件密集I&#x2F;O操作的性能。</li></ol><h3 id="（三）-备份"><a href="#（三）-备份" class="headerlink" title="（三） 备份"></a>（三） 备份</h3><p>备份操作确保每次写入操作完成后，文件的副本能够被保存，以便进行数据恢复或审计。具体实现细节如下：</p><ol><li>每次写入操作完成后，将文件副本保存至备份缓冲区，路径为C:\FsFilterDemotemp。此路径用于临时存储备份文件。</li><li>更新待备份文件的索引。每次文件写入操作完成后，记录该文件在备份缓冲区中的信息，便于后续的管理和操作。</li><li>备份缓冲区中的文件将由应用层程序进一步处理。这可能包括将备份文件上传到远程服务器进行长期存储，或者进行其他的备份策略处理。</li></ol><p>PFLT_FILE_NAME_INFORMATION fileNameInfo &#x3D; NULL;NTSTATUS status;status &#x3D; FltGetFileNameInformation(Data,  FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT,  &amp;fileNameInfo);WCHAR target_path[512];PWCHAR basePath &#x3D; L”\Device\HarddiskVolume3\FsFilterDemotemp\“;RtlStringCbCopyW(target_path, 512 * sizeof(WCHAR), basePath);AppendTimestampedFilename(target_path);CopyFile(fileNameInfo-&gt;Name.Buffer, target_path);</p><p>图 7 备份操作代码图</p><p>通过上述三部分的实现，文件加密驱动能够有效地拦截文件读写操作，对敏感数据进行透明的加解密处理，并在必要时保存文件的备份副本，从而提供了一个安全、高效的文件保护解决方案。</p><h2 id="四-3-用户程序前端实现细节"><a href="#四-3-用户程序前端实现细节" class="headerlink" title="四.3 *用户程序前端实现细节*"></a><strong>四.3</strong> <em><strong>*用户程序前端实现细节*</strong></em></h2><p>用户程序前端设计的主要目的是提供一个友好且功能完善的界面，方便用户对驱动进行加载卸载、配置远程备份服务器以及访问备份数据。以下从设计和技术两个部分详细说明前端实现细节。</p><h3 id="（一）-设计部分"><a href="#（一）-设计部分" class="headerlink" title="（一） 设计部分"></a>（一） 设计部分</h3><p>在用户界面设计上，我们考虑了用户体验的便利性和功能的完整性，具体设计如下：</p><h4 id="1）-左侧导航栏"><a href="#1）-左侧导航栏" class="headerlink" title="1） 左侧导航栏"></a>1） <strong>左侧导航栏</strong></h4><p>左侧放置导航栏，方便用户在不同功能界面之间进行切换。导航栏包括“驱动管理”、“远程备份”和“备份访问”三个主要部分。</p><h4 id="2）-驱动加载界面"><a href="#2）-驱动加载界面" class="headerlink" title="2） 驱动加载界面"></a>2） <strong>驱动加载界面</strong></h4><p>在驱动加载界面中，提供以下功能模块：</p><p><strong>l</strong> ****监控进程路径输入框****：用户可以在此输入框中输入需要监控的进程路径。</p><p><strong>l</strong> ****密码输入框****：用户可以在此输入框中输入用于文件加解密的密码。</p><p><strong>l</strong> ****加载驱动按钮****：点击此按钮加载加密驱动。</p><p><strong>l</strong> ****卸载驱动按钮****：点击此按钮卸载加密驱动。</p><p><strong>l</strong> ****当前驱动状态显示****：实时显示当前驱动的加载状态，帮助用户了解驱动的工作情况。</p><h4 id="3）-远程备份节点界面"><a href="#3）-远程备份节点界面" class="headerlink" title="3） 远程备份节点界面"></a>3） <strong>远程备份节点界面</strong></h4><p>在远程备份节点界面中，提供以下功能模块：</p><p><strong>l</strong> ****服务器地址输入框****：用户可以在此输入框中输入远程备份服务器的地址。</p><p><strong>l</strong> ****设置按钮****：点击此按钮将服务器地址设置为当前备份节点。</p><p><strong>l</strong> ****当前服务器链接展示****：显示当前连接的服务器地址，方便用户确认和修改。</p><h4 id="4）-备份数据访问界面"><a href="#4）-备份数据访问界面" class="headerlink" title="4） 备份数据访问界面"></a>4） <strong>备份数据访问界面</strong></h4><p>在备份数据访问界面中，提供以下功能模块：</p><p><strong>l</strong> ****当前访问路径显示****：显示当前备份数据的访问路径。</p><p><strong>l</strong> ****文件列表展示****：展示当前路径下的备份文件列表，用户可以点击查看文件详情或进行恢复操作。</p><p>以上设计考虑了用户的操作便利性和界面的简洁性，使得用户能够快速上手并高效完成各项操作。</p><h3 id="（二）-技术部分"><a href="#（二）-技术部分" class="headerlink" title="（二） 技术部分"></a>（二） 技术部分</h3><p>在技术实现上，我们选择了现代前端开发技术栈，以保证界面的响应速度和稳定性。具体技术细节如下：</p><p><strong>1)</strong> ****Vue 框架****：使用 Vue 框架绘制界面。Vue 是一款轻量级、易于使用的前端框架，具有良好的组件化支持和双向数据绑定能力，适合开发复杂的单页应用。</p><p><strong>2)</strong> ****Bootstrap 组件库与图标库****：使用 Bootstrap 组件库和图标库进行界面布局和样式美化。Bootstrap 提供了丰富的 UI 组件和响应式设计支持，使得界面在不同设备上都能有良好的显示效果。</p><p><strong>3)</strong> ****TypeScript 和 JavaScript****：使用 TypeScript 和 JavaScript 编写界面逻辑。TypeScript 作为 JavaScript 的超集，提供了静态类型检查和现代编程特性，能够提高代码的可靠性和可维护性。</p><p><strong>4)</strong> ****HTTP 协议与 Websocket 协议****：使用 HTTP 协议和 Websocket 协议与后端进行交互。HTTP 协议用于常规的数据请求和响应，Websocket 协议用于实时数据通信，例如驱动状态更新和远程备份进度等。</p><p>选择上述技术有以下优势：</p><p><strong>1)</strong> ****高效开发****：Vue 框架和 Bootstrap 组件库的结合，使得界面的开发效率大大提高，开发者可以快速构建和调整 UI 界面。</p><p><strong>2)</strong> ****良好的用户体验****：通过响应式设计和实时通信技术，用户可以获得流畅和及时的操作反馈。</p><p><strong>3)</strong> ****高可靠性****：TypeScript 的类型检查和现代编程特性，提高了代码的健壮性，减少了运行时错误。</p><p><strong>4)</strong> ****易维护性****：组件化的开发方式使得代码结构清晰，便于后续的维护和功能扩展。</p><p>综上所述，通过合理的界面设计和先进的技术选型，我们实现了一个功能齐全、操作便捷、界面美观的用户程序前端，为用户提供了良好的使用体验。</p><h2 id="四-4-用户程序后端实现细节"><a href="#四-4-用户程序后端实现细节" class="headerlink" title="四.4 *用户程序后端实现细节*"></a><strong>四.4</strong> <em><strong>*用户程序后端实现细节*</strong></em></h2><p>用户程序后端负责与前端进行数据交互、驱动的构建与管理、文件的实时备份以及与远程备份服务器的通信。以下从具体功能实现、实现方法的合理性、选用技术及其优势等方面详细说明用户程序后端的实现细节。</p><h3 id="（一）-后端服务构建"><a href="#（一）-后端服务构建" class="headerlink" title="（一） 后端服务构建"></a>（一） 后端服务构建</h3><p><strong>1)</strong> ****使用 Python 的 Flask 框架构建本地 HTTP 服务器****：Flask 是一个轻量级的 Web 框架，非常适合构建小型的 HTTP 服务。其简洁的设计和丰富的扩展性使得开发者能够快速搭建起与前端交互的 API 服务。</p><p><strong>2)</strong> ****实现与前端的交互****：通过定义一系列 API 接口，Flask 服务器能够接收前端发送的请求，例如驱动加载、卸载请求、设置远程备份服务器地址等，并将相应的结果返回给前端，确保前后端的数据通信顺畅。</p><h3 id="（二）-驱动的构建与管理"><a href="#（二）-驱动的构建与管理" class="headerlink" title="（二） 驱动的构建与管理"></a>（二） 驱动的构建与管理</h3><p><strong>1)</strong> ****使用 msbuild 构建驱动****：msbuild 是 Microsoft 提供的构建工具，广泛用于 Windows 驱动程序的构建。通过调用 msbuild，可以自动化编译驱动程序，生成所需的二进制文件，确保驱动程序的构建过程高效且可重复。</p><p><strong>2)</strong> ****使用 fltmc 工具完成驱动的加载与卸载****：fltmc 是 Windows 内置的过滤管理控制工具，用于管理文件系统筛选器驱动。通过调用 fltmc 工具，可以方便地加载和卸载驱动程序，从而控制驱动的启用和禁用。</p><h3 id="（三）-实时备份实现"><a href="#（三）-实时备份实现" class="headerlink" title="（三） 实时备份实现"></a>（三） 实时备份实现</h3><p><strong>1)</strong> ****设置监听线程监听驱动的待备份文件****：在后端程序中，设置一个专门的监听线程，用于监控驱动程序产生的待备份文件。当有新的待备份文件生成时，监听线程会立即进行处理，确保备份操作的实时性。</p><p><strong>2)</strong> ****完成实时备份****：监听线程检测到新的待备份文件后，将其复制到本地备份目录，确保数据不会因意外情况而丢失。这一过程在内存中进行，速度快且不影响系统性能。</p><h3 id="（四）-远程备份通信"><a href="#（四）-远程备份通信" class="headerlink" title="（四） 远程备份通信"></a>（四） 远程备份通信</h3><p><strong>1)</strong> ****使用 HTTP 协议将备份文件上传至远程备份服务器****：HTTP 协议是目前最常用的网络传输协议，具有简单、灵活和广泛支持的优点。通过 HTTP POST 请求，可以将备份文件上传至远程备份服务器，确保数据的异地存储和安全性。</p><p><strong>2)</strong> ****处理上传结果和异常情况****：在上传过程中，后端程序会处理服务器的响应结果，确认文件上传成功。如果上传失败或遇到网络异常，程序会进行重试或记录错误日志，确保数据备份的可靠性。</p><h3 id="（五）-技术选用的合理性及优势"><a href="#（五）-技术选用的合理性及优势" class="headerlink" title="（五） 技术选用的合理性及优势"></a>（五） 技术选用的合理性及优势</h3><p><strong>1)</strong> ****Flask 框架****：Flask 作为轻量级框架，学习曲线平缓，适合快速开发和迭代。同时，Flask 的模块化设计和丰富的扩展库支持，使得其在处理各种 Web 应用需求时游刃有余。</p><p><strong>2)</strong> ****msbuild 工具****：msbuild 是 Windows 环境中最常用的构建工具，提供了强大的功能和灵活的配置，能够高效地完成驱动程序的构建任务。</p><p><strong>3)</strong> ****fltmc 工具****：fltmc 是管理 Windows 文件系统筛选器驱动的官方工具，使用它能够确保驱动加载和卸载操作的可靠性和兼容性。</p><p><strong>4)</strong> ****HTTP 协议****：HTTP 协议简单易用且兼容性强，适用于各种网络环境下的数据传输需求。通过使用 HTTP 协议，能够轻松实现与远程服务器的数据通信，确保备份文件的安全传输。</p><p>综上所述，通过选择合适的技术和合理的实现方法，我们构建了一个功能完备、性能优良的用户程序后端，确保了驱动的高效管理和数据的实时备份与安全传输。</p><h2 id="四-5-远程备份模块实现细节"><a href="#四-5-远程备份模块实现细节" class="headerlink" title="四.5 *远程备份模块实现细节*"></a><strong>四.5</strong> <em><strong>*远程备份模块实现细节*</strong></em></h2><h3 id="（一）-功能实现"><a href="#（一）-功能实现" class="headerlink" title="（一） 功能实现"></a>（一） 功能实现</h3><p>远程备份模块通过一个 HTTP 服务器来接收和处理用户程序的备份请求，并将接收到的备份文件存储到服务器本地的指定路径中。</p><p><strong>1)</strong> ****使用 Python 的 Flask 框架构建 HTTP 服务器****：Flask 是一个轻量级的 Web 框架，适合快速开发和部署小型 Web 应用。使用 Flask 可以快速搭建一个 HTTP 服务器，接收用户程序发送的文件上传请求。</p><p><strong>2)</strong> ****接收备份文件请求****：服务器端定义一个文件上传接口，接收用户程序通过 HTTP POST 请求发送的备份文件。接口处理请求并将文件保存到服务器的本地存储中。</p><p><strong>3)</strong> ****保存备份文件到本地****：将接收到的备份文件保存到服务器本地的 backup路径中，并按照一定的目录结构组织这些文件，方便后续的管理和访问。</p><h3 id="（二）-实现方法的合理性"><a href="#（二）-实现方法的合理性" class="headerlink" title="（二） 实现方法的合理性"></a>（二） 实现方法的合理性</h3><p>选择 Flask 框架构建 HTTP 服务器的合理性在于其简洁易用、功能强大、社区支持丰富，非常适合快速搭建和部署 Web 服务。</p><p><strong>1)</strong> ****简洁易用****：Flask 框架的设计非常简洁，只需要几行代码就可以构建一个功能完善的 HTTP 服务器，非常适合快速开发。</p><p><strong>2)</strong> ****功能强大****：尽管 Flask 是一个轻量级框架，但它提供了丰富的功能模块和扩展库，能够满足各种 Web 应用的需求。</p><p><strong>3)</strong> ****社区支持丰富****：Flask 具有庞大的社区支持，开发者可以方便地找到各种问题的解决方案和优秀的第三方扩展。</p><h3 id="（三）-选用技术及其优势"><a href="#（三）-选用技术及其优势" class="headerlink" title="（三） 选用技术及其优势"></a>（三） 选用技术及其优势</h3><p>选择 Flask 框架和 HTTP 协议来实现远程备份模块，具有以下技术优势：</p><ol><li>Flask 框架</li></ol><p><strong>1.</strong> ****快速开发****：Flask 框架的简单和灵活性使得开发者能够快速搭建起 Web 服务，缩短开发周期。</p><p><strong>2.</strong> ****可扩展性****：Flask 提供了丰富的扩展库，可以根据需要快速添加各种功能模块，例如身份验证、数据库集成等。</p><p><strong>3.</strong> ****高性能****：对于大部分应用场景，Flask 的性能足以应对，同时可以通过部署优化和使用 WSGI 服务器（如 Gunicorn）进一步提升性能。</p><ol start="2"><li>HTTP 协议</li></ol><p><strong>1.</strong> ****简单易用****：HTTP 协议是目前最常用的网络传输协议，易于实现和使用，且有广泛的工具和库支持。</p><p><strong>2.</strong> ****兼容性强****：HTTP 协议具有很好的兼容性，能够在各种网络环境下稳定运行，确保数据传输的可靠性。</p><p><strong>3.</strong> ****安全性****：通过使用 HTTPS（HTTP over SSL&#x2F;TLS），可以确保数据在传输过程中的安全性，防止数据被窃听和篡改。</p><p>综上所述，通过使用 Flask 框架构建 HTTP 服务器，结合 HTTP 协议进行数据传输，我们实现了一个高效、可靠的远程备份模块，确保用户程序的备份文件能够安全地存储到远程服务器中。</p><h2 id="四-6-模块通信接口实现细节"><a href="#四-6-模块通信接口实现细节" class="headerlink" title="四.6 *模块通信接口实现细节*"></a><strong>四.6</strong> <em><strong>*模块通信接口实现细节*</strong></em></h2><p>本系统各模块间通信使用 RESTful 风格的接口，具有以下好处：</p><ol><li>标准化与一致性</li></ol><p><strong>1.</strong> ****标准化****：RESTful 接口基于 HTTP 协议，使用标准的 HTTP 方法（如 GET、POST、PUT、DELETE）进行操作，符合 Web 标准，易于理解和使用。</p><p><strong>2.</strong> ****一致性****：使用 RESTful 风格的接口，可以确保系统中各模块的 API 设计风格一致，方便开发人员维护和扩展系统。</p><ol start="2"><li>灵活性与扩展性</li></ol><p><strong>1.</strong> ****灵活性****：RESTful 接口通过 URL 定位资源，使用 HTTP 方法操作资源，可以灵活地设计和调整 API，满足不同的业务需求。</p><p><strong>2.</strong> ****扩展性****：由于 RESTful 接口的松耦合特性，各模块之间的依赖性较低，易于进行模块的替换和扩展，提升系统的可维护性。</p><ol start="3"><li>可维护性与可测试性</li></ol><p><strong>1.</strong> ****可维护性****：RESTful 接口设计简洁、清晰，资源和操作分离，便于开发人员理解和维护系统，降低维护成本。</p><p><strong>2.</strong> ****可测试性****：基于 HTTP 协议的 RESTful 接口，可以使用各种测试工具（如 Postman、Curl）进行测试，方便对 API 进行验证和调试。</p><ol start="4"><li>性能与可扩展性</li></ol><p><strong>1.</strong> ****性能****：RESTful 接口通常使用 JSON 或 XML 格式进行数据传输，数据格式轻量，解析效率高，有助于提升系统的响应速度。</p><p><strong>2.</strong> ****可扩展性****：RESTful 接口通过 URI 定位资源，可以根据需要动态扩展资源路径和接口，不影响现有接口的使用，具有良好的可扩展性。</p><ol start="5"><li>跨平台与跨语言支持</li></ol><p><strong>1.</strong> ****跨平台****：RESTful 接口基于 HTTP 协议，与平台无关，可以在各种操作系统和设备上使用，具有良好的跨平台兼容性。</p><p><strong>2.</strong> ****跨语言****：RESTful 接口与编程语言无关，可以使用任何支持 HTTP 的编程语言进行开发，方便不同语言和技术栈的系统进行集成。</p><p>各模块间具体的通信流程如下。</p><h3 id="（一）-加载驱动流程"><a href="#（一）-加载驱动流程" class="headerlink" title="（一） 加载驱动流程"></a>（一） 加载驱动流程</h3><p>当需要加载驱动时，用户在前端界面输入需要加密的程序信息和用于进行RC4加密的密钥。程序前端通过HTTP协议与后端进行交互，将目标程序和密钥传递给后端。后端接收到请求后，解析出程序信息和加密密钥，接着使用msbuild工具构建对应的驱动文件。构建完成后，后端程序使用fltmc工具加载构建好的驱动，并将驱动加载的状态信息返回给前端。前端程序接收到后端返回的状态信息后，将其解析并展示在界面上，供用户查看。这样用户可以了解驱动加载的结果，包括是否成功加载以及可能的错误详情。当检测到驱动处于加载状态时，前端界面将为用户提供卸载驱动的选项。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps20.png" alt="img"></p><p>图 8 加载驱动流程图</p><h3 id="（二）-卸载驱动流程"><a href="#（二）-卸载驱动流程" class="headerlink" title="（二） 卸载驱动流程"></a>（二） 卸载驱动流程</h3><p>当用户需要卸载驱动时，可以点击前端界面上的驱动卸载按钮，此时前端会向后端程序发送卸载驱动的请求。后端接收到请求后，使用fltmc工具卸载驱动，并将卸载结果信息返回给前端。前端程序接收到后端返回的信息后，会在界面上显示给用户，使用户了解驱动卸载的结果，包括成功卸载或可能的错误详情。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps21.png" alt="img"></p><p>图 9 卸载驱动流程图</p><h3 id="（三）-设置备份服务器流程"><a href="#（三）-设置备份服务器流程" class="headerlink" title="（三） 设置备份服务器流程"></a>（三） 设置备份服务器流程</h3><p>由于我们的驱动提供了文件备份功能，用户可以根据需求设置文件备份的服务器。在前端界面，用户可以选择已存在的服务器地址，或输入新的服务器地址。当用户确认选择后，前端将新的服务器地址传递给后端。后端接收到服务器地址后，会测试新服务器的可用性。如果服务器正常运作，后端将其状态更新并返回给前端。前端接收到后端的测试结果后，将其显示给用户，使用户了解新服务器的可用性情况。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps22.png" alt="img"></p><p>图 10 设置备份服务器流程图</p><h3 id="（四）-查询备份文件流程"><a href="#（四）-查询备份文件流程" class="headerlink" title="（四） 查询备份文件流程"></a>（四） 查询备份文件流程</h3><p>用户还可以查看当前选择的服务器上已备份的文件。当用户请求查看时，前端会将用户查看的目录信息实时传给后端。后端根据接收到的目录信息与文件备份服务器进行交互，获取相应的目录列表和文件信息。备份服务器返回目录列表后，后端进行处理并将目录信息和文件列表返回给前端，前端再将这些信息显示给用户。这样，用户可以实时查看备份服务器上的文件，确保备份数据的可访问性和管理的便捷性。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps23.png" alt="img"></p><p>图 11 查询备份文件流程图</p><h3 id="（五）-更新备份文件流程"><a href="#（五）-更新备份文件流程" class="headerlink" title="（五） 更新备份文件流程"></a>（五） 更新备份文件流程</h3><p>当一份加密文件的存储更新时，我们的程序会记录待备份的文件信息及其内容，并由后端程序开辟一个缓冲区暂存这些内容。随后，后端程序与当前指定的备份服务器通信，进行文件的远程备份操作。备份服务器完成文件备份后，会返回一个备份状态信息给后端程序。后端程序在收到此状态信息后，会清除临时缓冲区中的内容，从而完成备份流程。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps24.png" alt="img"></p><p>图 12 更新备份文件流程图</p><h3 id="（六）-下载备份文件流程"><a href="#（六）-下载备份文件流程" class="headerlink" title="（六） 下载备份文件流程"></a>（六） 下载备份文件流程</h3><p>最后，如果用户需要从远程备份服务器上下载备份的文件，可以在前端界面输入所需文件的地址。前端程序将该文件地址发送给远程备份服务器，服务器会根据指定的文件路径查找并提供用户需要的文件。服务器将文件发送给后端程序，后端程序再将文件传送到前端，最终提供给用户下载。这样，用户可以方便地从远程备份服务器获取所需的文件。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps25.png" alt="img"></p><p>图 13 下载备份文件流程图</p><h1 id="五、-加密驱动测试"><a href="#五、-加密驱动测试" class="headerlink" title="五、 *加密驱动测试*"></a><strong>五、</strong> <em><strong>*加密驱动测试*</strong></em></h1><h2 id="五-1-功能测试"><a href="#五-1-功能测试" class="headerlink" title="五.1 *功能测试*"></a><strong>五.1</strong> <em><strong>*功能测试*</strong></em></h2><p>在这一部分，对我们程序的功能进行了一系列测试，首先说明一下我们演示的样例进程，我们下载了一个wordpad写字板程序，这个程序用来演示进程加密。该wordpad写字板程序与Windows附件中自带的写字板程序功能相同，但两个程序相互独立，因此对我们下载的wordpad写字板进行加密，并不会影响Windows自带写字板程序运行。后续演示中为方便区分，进程加密的写字板我们称为wordpad，系统自带的称为写字板。</p><h3 id="（一）-系统功能介绍"><a href="#（一）-系统功能介绍" class="headerlink" title="（一） 系统功能介绍"></a>（一） 系统功能介绍</h3><p>我们的系统前端使用Vue搭建，打开程序就可以看见系统首页，首页向用户展示了本产品和支持院校了logo，并简单明了展示系统名称。在主页下方我们还对系统主要功能进行简介，本产品可以实现进程过滤、透明加密和远程备份功能。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps26.jpg" alt="img"> </p><p>图 14 首页展示图</p><p>在左侧边栏可以看见系统的功能列表，首先介绍的是驱动加密启动功能，用户可以输入想要加密的程序路径，点击加载驱动就会对该程序进程进行加密，在下方如果发生错误，还会显示错误处理日志，并给出部分错误处理办法，更加人性化。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps27.jpg" alt="img"> </p><p>图 15 驱动加密图</p><p>在驱动加密操作记录页面，可以看见以前加载进程的操作日志。除程序路径外，还会显示加载和卸载时间信息。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps28.jpg" alt="img"> </p><p>图 16 驱动加密使用记录图</p><p>接下来介绍远程备份节点功能，这一界面可以选择远程明文备份的服务器节点，当前备份使用的是本机，在上方可以随时更改备份服务器。在下方我们提供了常用的服务器节点备份列表。用户可以编辑自己常用的IP地址和备注信息，也可以新增地址记录，输入IP信息，并根据需求输入备注信息，可以点击保存或者删除。该列表操作会实时响应数据库进行保存，方便用户的使用。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps29.jpg" alt="img"> </p><p>图 17：备份节点设置图</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps30.jpg" alt="img"> </p><p>图 18 新增备份节点列表信息图</p><p>在备份数据访问中，可以访问当前备份节点上的备份数据，其中也包括以前加密进程保存在该节点的数据。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps31.jpg" alt="img"> </p><p>图 19 备份数据访问页面图</p><p>我们还制作了版权声明显示，明确的声明本产品的版权所属和联系信息。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps32.jpg" alt="img"> </p><p>图 20 版权声明页面</p><p>此外我们还提供了异常处理和使用说明模块，在这里不做详细介绍。</p><h3 id="（二）-驱动加密演示"><a href="#（二）-驱动加密演示" class="headerlink" title="（二） 驱动加密演示"></a>（二） 驱动加密演示</h3><p>下面演示我们具体的实现过程。首先启动我们想要加密的程序，这里启动加密的就是我们刚才的wordpad程序。并设置当前密钥。驱动加载成功后，若没有发生错误，则下方不会出现日志输出。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps33.jpg" alt="img"> </p><p>图 21 启动加密驱动</p><p>打开驱动加密后的wordpad程序，输入测试样例，这里输入test 2024.6.6. 21：47。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps34.jpg" alt="img"> </p><p>图 22 明文信息图</p><p>对文件进行保存，这里以富文本格式进行保存，保存在桌面位置并起名为测试文件。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps35.jpg" alt="img"> </p><p>图 23 富文本保存图</p><p>保存成功后，将wordpad程序关闭，即不在使用驱动加密后的程序进程。打开Windows自带的写字板程序，用这个程序读取刚才的保存文件，若内容乱码则说明确实刚在的wordpad进程已加密。可以看见打开的数据确实已被加密，并且无法更改。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps36.jpg" alt="img"> </p><p>图 24 写字板打开富文本图</p><p>回到文件加密驱动系统，对远程明文备份数据进行访问。打开文件保存目录，点击用户名称，点击刚才保存的位置桌面，系统会根据原有加密数据存储位置实时更新远程存储。可以看见现在的文件已经存储在了服务器上。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps37.jpg" alt="img"> </p><p>图 25 查看备份文件图</p><p>返回wordpad进行操作，将文件以其他形式进行保存。比如将文件保存为TXT文本格式，依旧保存在桌面。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps38.jpg" alt="img"> </p><p>图 26 文本格式保存图</p><p>打开刚才保存的TXT文件，依旧显示的是加密信息，无法读取数据，确实实现了进程的加密。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps39.jpg" alt="img"> </p><p>图 27 文本加密加密展示图</p><p>返回文件加密驱动系统，重新刷新远程备份数据，可以看见文件已被远程存储。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps40.jpg" alt="img"> </p><p>图 28 文本备份展示图</p><p>随后更换节点进行备份演示，我们现在使用我们准备的生活数据备份节点，这个节点目前位于我的主机上。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps41.jpg" alt="img"> </p><p>图 29 更换服务器节点图</p><p>复制节点信息并进行设置，可以看见备份服务器更换成功。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps42.jpg" alt="img"> </p><p>图 30 服务器节点成功更换展示图</p><p>查看备份数据访问，可以看见在该节点存储的一些以前的数据备份信息，由于远程备份节点不同，所以该文件夹中和刚才的存储数据不同。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps43.jpg" alt="img"> </p><p>图 31 文本备份查看图</p><p>此时再次保存文本文件，这里演示以TXT文本进行保存。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps44.jpg" alt="img"> </p><p>图 32 另存加密文件图</p><p>打开后显示乱码，进程加密依旧在工作。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps45.jpg" alt="img"> </p><p>图 33 检查新保存加密文件图</p><p>重新使用加密进程进行打开，可以看见原有明文信息。说明更换备份节点不影响加密进程工作。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps46.jpg" alt="img"> </p><p>图 34 驱动解密展示图</p><p>返回服务器，刷新备份数据信息，可以看见当前文本已更新到服务器中。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps47.jpg" alt="img"> </p><p>图 35 远程备份更新展示图</p><p>打开查看备份文件内容，确实实现了使用明文保存。中间部分存在乱码是由于刚才的冒号使用的是中文字符，浏览器默认解码格式不同，下载至本地使用文本文档打开即可解决问题。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps48.jpg" alt="img"> </p><p>图 36 远程备份明文展示图</p><p>此时我们关闭加密驱动，使用系统默认驱动，点击卸载驱动。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps49.jpg" alt="img"> </p><p>图 37 卸载驱动展示图</p><p>返回程序wordpad，可以看见此时即使使用wordpad程序打开刚才的加密文件，也会是被保护的状态，无法访问原文信息。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps50.jpg" alt="img"> </p><p>图 38 加密数据展示图</p><p>此时他和普通的写字板功能一样，不具有加密功能，比如测试输入文件123，保存到桌面。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps51.jpg" alt="img"> </p><p>图 39卸载驱动写字板功能展示图</p><p>打开可以看见依旧是明文信息，没有进行加密。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps52.jpg" alt="img"> </p><p>图 40未加密明文信息展示图</p><h3 id="（三）-个性化功能演示"><a href="#（三）-个性化功能演示" class="headerlink" title="（三） 个性化功能演示"></a>（三） 个性化功能演示</h3><p>最后展示一下我们提供的个性化功能。可以对功能进行关键词检索，使用模糊搜索快速找到所需功能，假设这里想找备份节点路径设置，就可以搜关键词备份，找到远程备份节点，这样就可以快捷进行更改。此外我们还可以对搜索历史进行长久性的收藏，或者进行历史记录删除。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps53.jpg" alt="img"> </p><p>图 41 模糊搜索展示图</p><p>我们还提供了大屏模式，便于长期使用，更加美观。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps54.jpg" alt="img"> </p><p>图 42 全屏模式展示图</p><p>为了方便用户个性化需求，我们还提供了丰富的系统个性化页面配置。用户可以根据自身需求调整整体风格配置，这里提供了浅色系、深色系和跟随电脑系统默认，适用于白天和夜间模式的转换。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps55.jpg" alt="img"> </p><p>图 43 颜色配置展示图</p><p>根据用户的个人喜好，可以自行调整系统的主题风格颜色，这里也提供了多种选项。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps56.jpg" alt="img"> </p><p>图 44 主题配色展示图</p><p>根据用户使用系统的习惯，我们还提供了三种最为通用的导航风格，可以根据用户使用习惯自行调整。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps57.jpg" alt="img"> </p><p>图 45 导航模式展示图</p><p>对于整体页面，在特殊日期、特殊场合如国家公祭日等，还可以设置灰色模式。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps58.jpg" alt="img"> </p><p>图 46 灰色模式展示图</p><p>对于色弱用户群体我们也提供了专门的色弱模式，方便广大用户在各种应用场景下使用。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps59.jpg" alt="img"> </p><p>图 47 色弱模式展示图</p><h2 id="五-2-性能测试"><a href="#五-2-性能测试" class="headerlink" title="五.2 *性能测试*"></a><strong>五.2</strong> <em><strong>*性能测试*</strong></em></h2><p>为了全面评估加密驱动系统的性能，我们进行了一系列深入的性能测试，通过测试评估在实际工作环境中引入加密和远程备份功能对系统性能的影响。我们特别关注了处理不同大小文件时的性能表现，从工作用时（即处理文件所需的时间）和吞吐量（系统在单位时间内能处理的数据量）两个维度进行了全面的测试。具体性能比对如下图所示：</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps60.jpg" alt="img"> </p><p>图 48 驱动时间性能测试图</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/wps61.jpg" alt="img"> </p><p>图 49 驱动吞吐量性能测试</p><p>测试结果表明，引入加密功能和远程备份功能确实对系统的性能造成了一定影响。具体来说，在处理特别大或特别小的文件时，我们注意到工作用时有所增加，表明加密操作增加了数据处理的负担。同时，系统的吞吐量也有所下降，反映出在加密数据并进行远程备份时，系统处理数据的速度有所减慢。</p><p>尽管如此，性能下降的幅度整体上是可接受的。这表明尽管加密和远程备份功能对性能有一定的影响，但这种影响并不足以阻碍系统的正常运行。事实上，这些性能损失在很大程度上可以通过系统的其他性能优化措施来弥补。比如，通过优化加密算法的效率，或者通过增加系统资源（如处理器速度和内存容量）来提高处理能力，都能有效减少加密和备份操作对性能的影响。在最后我们给出加密驱动和未加密驱动的性能测试数据。</p><p>表 1 驱动未加载写入性能表</p><table><thead><tr><th>文件大小（MB）</th><th>用时（s）</th><th>吞吐量（Mbps）</th></tr></thead><tbody><tr><td>1</td><td>0.056629</td><td>141.2710883</td></tr><tr><td>2</td><td>0.087779</td><td>182.2767405</td></tr><tr><td>4</td><td>0.13759</td><td>232.5747546</td></tr><tr><td>8</td><td>0.382535</td><td>167.3050652</td></tr><tr><td>16</td><td>0.683632</td><td>187.2352006</td></tr><tr><td>32</td><td>1.167732</td><td>219.2283487</td></tr><tr><td>64</td><td>1.72694</td><td>296.4782189</td></tr><tr><td>128</td><td>3.176761</td><td>322.3409235</td></tr><tr><td>256</td><td>9.10944</td><td>224.8217342</td></tr><tr><td>512</td><td>15.67556</td><td>261.2984521</td></tr><tr><td>1024</td><td>29.86975</td><td>274.2574081</td></tr></tbody></table><p>表 2 驱动加载写入性能测试</p><table><thead><tr><th>文件大小（MB）</th><th>用时（s）</th><th>吞吐量（Mbps）</th></tr></thead><tbody><tr><td>1</td><td>0.1112</td><td>71.94247763</td></tr><tr><td>2</td><td>0.120824</td><td>132.4235478</td></tr><tr><td>4</td><td>0.282408</td><td>113.3111041</td></tr><tr><td>8</td><td>0.718032</td><td>89.13255002</td></tr><tr><td>16</td><td>1.050038</td><td>121.9003111</td></tr><tr><td>32</td><td>1.957108</td><td>130.8052735</td></tr><tr><td>64</td><td>3.987499</td><td>128.4012938</td></tr><tr><td>128</td><td>5.422757</td><td>188.833833</td></tr><tr><td>256</td><td>9.757642</td><td>209.8867763</td></tr><tr><td>512</td><td>17.32165</td><td>236.4671241</td></tr><tr><td>1024</td><td>37.52648</td><td>218.2991622</td></tr></tbody></table><h1 id="六、-项目总结展望"><a href="#六、-项目总结展望" class="headerlink" title="六、 *项目总结展望*"></a><strong>六、</strong> <em><strong>*项目总结展望*</strong></em></h1><h2 id="六-1-项目总结"><a href="#六-1-项目总结" class="headerlink" title="六.1 *项目总结*"></a><strong>六.1</strong> <em><strong>*项目总结*</strong></em></h2><p>在本项目中，我们成功设计并实现了一种Windows文件加密驱动。该系统通过透明的加解密机制，为特定进程提供文件加密和解密服务，并且实现了远程备份功能。以下是项目的主要成就：</p><p><strong>1)</strong> ****透明加解密****：我们设计了一种透明加解密系统，针对特定进程提供文件加密和解密服务，确保数据在存储和传输过程中得到有效保护。</p><p><strong>2)</strong> ****远程备份功能****：实现了文件的远程备份，用户可以设置备份服务器，定期将重要文件备份到远程服务器，确保数据的安全性和可恢复性。</p><p><strong>3)</strong> ****性能优化****：通过对接口调用路径的优化和缓存机制的设计，显著提高了系统的响应速度和处理能力，确保系统在高负载情况下仍能高效运行。</p><p><strong>4)</strong> ****用户友好性****：系统前端使用Vue框架搭建，提供了直观友好的用户界面，用户可以方便地进行系统配置和操作。</p><p><strong>5)</strong> ****安全性****：采用TLS&#x2F;SSL等加密协议保护数据传输的完整性和机密性，防止数据被截获或篡改。设计了全面的异常处理机制，确保系统在出现错误时能够正确恢复。</p><h2 id="六-2-发展期望"><a href="#六-2-发展期望" class="headerlink" title="六.2 *发展期望*"></a><strong>六.2</strong> <em><strong>*发展期望*</strong></em></h2><p>未来的发展将集中在以下几个方面，以进一步提高系统的性能、功能和用户体验：</p><p><strong>1)</strong> ****扩展功能模块****：在现有的加密和备份功能基础上，增加更多的安全功能模块，例如数据完整性验证、多因素认证等，进一步提高系统的安全性和可靠性。</p><p><strong>2)</strong> ****优化加密算法****：研究和实现更高效的加密算法，减少加密和解密操作对系统性能的影响，特别是在处理大文件和高并发请求时，提升系统的整体效率。</p><p><strong>3)</strong> ****增强用户体验****：不断优化用户界面设计，提供更多的个性化设置选项，满足不同用户的使用需求。增加系统的可视化功能，使用户能够直观地了解系统状态和操作结果。</p><p><strong>4)</strong> ****提高系统稳定性****：通过持续的性能测试和优化，确保系统在各种复杂环境下的稳定运行。定期进行安全审计和监控，及时发现和解决潜在的问题和安全威胁。</p><p><strong>5)</strong> ****跨平台支持****：在未来的开发中，考虑实现跨平台支持，使系统能够在更多操作系统和设备上运行，扩大用户群体，提升系统的应用价值。</p><p>通过以上发展规划，我们期待将该系统打造成为一个功能强大、安全可靠、用户友好的文件加密解决方案，为用户的数据保护需求提供全面支持。</p>]]></content>
    
    
    <summary type="html">课程作业，文件自动备份与强制加密系统驱动开发</summary>
    
    
    
    <category term="信安课程实验" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="信息安全编程技术与实例开发" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://shuita2333.github.io/project/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>同态加密算法实现及推导</title>
    <link href="https://shuita2333.github.io/project/2024/04/08/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/"/>
    <id>https://shuita2333.github.io/project/2024/04/08/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/</id>
    <published>2024-04-07T18:00:00.000Z</published>
    <updated>2024-07-10T15:25:19.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-理解并验证加解密算法"><a href="#一、-理解并验证加解密算法" class="headerlink" title="一、 *理解并验证加解密算法*"></a><strong>一、</strong> <em><strong>*理解并验证加解密算法*</strong></em></h1><h2 id="（一）-同态加密算法的主要背景"><a href="#（一）-同态加密算法的主要背景" class="headerlink" title="（一） 同态加密算法的主要背景"></a>（一） 同态加密算法的主要背景</h2><p>同态加密提供了一种对加密数据进行处理的功能。也就是说其他人可以对加密后的数据进行处理，在这个过程中不会泄露任何原始的内容，在数据处理完成之后再进行解密，得到的正是对原始数据进行相同处理后的结果。</p><h2 id="（二）-关键算法"><a href="#（二）-关键算法" class="headerlink" title="（二） 关键算法"></a>（二） 关键算法</h2><p>同态加密算法可以分为部分同态、全同态、加法同态、乘法同态、近似同态几种。接下来对其具体算法进行详细解释：</p><ol><li>加法同态加密：支持密文的加法运算。给定两个密文，可以得到它们对应明文和的加密版本，而不需要知道原始明文。RSA加密就是一种天然的加法同态加密系统。</li><li>乘法同态加密：与加法同态相对应，乘法同态加密支持密文的乘法运算。可以将两个密文相乘，得到的结果等同于将它们各自的明文相乘后再加密的结果。</li><li>部分同态加密：部分同态加密方案指的是仅支持单一类型运算（加法或乘法）的同态加密。例如，RSA是一种部分同态加密系统，因为它仅支持加法同态。同理，ElGamal加密是另一种部分同态加密系统，它支持乘法同态。</li><li>全同态加密（FHE）：全同态加密是最强大的同态加密形式，它允许在密文上进行无限次的加法和乘法运算，因此可以构建任意复杂的计算而无需解密。2009年，Craig Gentry首次提出了全同态加密的概念。尽管全同态加密非常强大，但现有的实现通常相对缓慢，不适用于实时或大规模计算。</li><li>近似同态加密（AHE）：近似同态加密是一种支持在密文上执行准确或近似运算的加密方法。它对于机器学习和数据分析尤其有用，因为这些领域中的算法有时可以容忍轻微的计算不精确性。它允许在结果的精度和计算效率之间进行权衡。</li></ol><h2 id="（三）-应用领域"><a href="#（三）-应用领域" class="headerlink" title="（三） 应用领域"></a>（三） 应用领域</h2><p>同态加密的应用场景可以包括几个方面：</p><ol><li>云计算安全：用户可以加密自己的数据并将其上传到云端，云服务提供者可以在不了解数据内容的情况下对其进行处理。这保护了数据在处理过程中的隐私性。</li><li>保护隐私的数据挖掘和分析：允许公司在不泄露个人信息或敏感数据的前提下，对用户数据进行分析和挖掘。</li><li>安全的多方计算：多个参与者可以共同进行数据分析或运算，而无需透露各自的输入。例如，两个公司可能想要合作确定它们的客户群有多少重叠，而不泄露各自的客户名单。</li><li>电子投票系统：在电子投票应用中，同态加密可以用来确保投票的隐私性和完整性，同时还能验证投票结果的正确性。</li><li>安全的医疗记录管理：医生或研究人员可以在不直接访问患者详细信息的情况下，进行诊断或研究。</li><li>金融服务：金融机构可以在不暴露交易细节的情况下，处理加密的交易和查询。</li><li>加密货币：同态加密可以提供对加密货币交易的隐私保护，同时允许验证交易的有效性而不需要解密。</li><li>供应链管理：企业可以在保护相关数据隐私的同时，验证供应链中的计算和数据的正确性。</li></ol><h2 id="（四）演算及验证过程"><a href="#（四）演算及验证过程" class="headerlink" title="（四）演算及验证过程"></a>（四）演算及验证过程</h2><ol><li>演算样例1</li></ol><p>(1) 演算过程</p><p>p&#x3D; 7 ,q&#x3D; 11 ,n&#x3D; 77 ,g&#x3D; 5652 ,m&#x3D; 42 ,r&#x3D; 23 </p><p>步骤1：Paillier系统加密过程</p><p>c &#x3D; (5652)^42*(23)^77 mod 5929</p><p>c &#x3D; (4019)*(606) mod 5929 &#x3D; 2435514 mod 5929 &#x3D; 4624</p><p>(2) 验证过程</p><p>步骤2-Paillier系统解密中间过程-L（.）求解</p><p>λ(77) &#x3D; lcm(6,10) &#x3D; 30</p><p>L(5652^30 mod 5929) &#x3D; L(3928)</p><p>L(3928) &#x3D; (3928-1)&#x2F;77 &#x3D; 51</p><p>步骤3： Paillier系统加密过程-计算µ</p><p>µ &#x3D; 51^-1 mod 77 &#x3D; 74 mod 77</p><p>Paillier加密系统解密过程-解密出最终结果</p><p>m &#x3D; L(4624^30 mod 5929)*74 mod 77 &#x3D; 42</p><ol start="2"><li>演算样例1</li></ol><p>(1) 演算过程</p><p>p&#x3D; 11 ,q&#x3D; 13 ,n&#x3D; 143 ,g&#x3D; 3544 ,m&#x3D; 72 ,r&#x3D; 61  </p><p>步骤1：Paillier系统加密过程</p><p>c &#x3D; (3544)^72*(61)^143 mod 20449</p><p>c &#x3D; (1093)*(4033) mod 20449 &#x3D; 4408069 mod 20449 &#x3D; 11534</p><p>(2) 验证过程</p><p>步骤2-Paillier系统解密中间过程-L（.）求解</p><p>λ(143) &#x3D; lcm(10,12) &#x3D; 60</p><p>L(3544^60 mod 20449) &#x3D; L(11727)</p><p>L(11727) &#x3D; (11727-1)&#x2F;143 &#x3D; 82</p><p>步骤3： Paillier系统加密过程-计算µ</p><p>µ &#x3D; 82^-1 mod 143 &#x3D; 75 mod 143</p><p>Paillier加密系统解密过程-解密出最终结果</p><p>m &#x3D; L(11534^60 mod 20449)*75 mod 143 &#x3D; 72</p><ol start="3"><li>演算样例3</li></ol><p>(1) 演算过程</p><p>p&#x3D; 29 ,q&#x3D; 51 ,n&#x3D; 1479 ,g&#x3D; 2061 ,m&#x3D; 39 ,r&#x3D; 21 </p><p>步骤1：Paillier系统加密过程</p><p>c &#x3D; (2061)^39*(21)^1479 mod 2187441</p><p>c &#x3D; (302256)*(1384272) mod 2187441 &#x3D; 418404517632 mod 2187441 &#x3D; 1740357</p><p>(2) 验证过程</p><p>步骤2-Paillier系统解密中间过程-L（.）求解</p><p>λ(1479) &#x3D; lcm(28,50) &#x3D; 700</p><p>L(2061^700 mod 2187441) &#x3D; L(787815)</p><p>L(787815) &#x3D; (787815-1)&#x2F;1479 &#x3D; 532</p><p>步骤3： Paillier系统加密过程-计算µ</p><p>µ &#x3D; 532^-1 mod 1479 &#x3D; 670 mod 1479</p><p>Paillier加密系统解密过程-解密出最终结果</p><p>m &#x3D; L(1740357^700 mod 2187441)*670 mod 1479 &#x3D; 39</p><h1 id="二、-实现算法对应关键函数"><a href="#二、-实现算法对应关键函数" class="headerlink" title="二、 *实现算法对应关键函数*"></a><strong>二、</strong> <em><strong>*实现算法对应关键函数*</strong></em></h1><ol><li>模幂运算</li></ol><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/wps1.jpg" alt="img"> </p><ol start="2"><li>L(x)函数</li></ol><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/wps2.jpg" alt="img"> </p><ol start="3"><li>逆元计算</li></ol><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/wps3.jpg" alt="img"> </p><ol start="4"><li>λ函数</li></ol><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/wps4.jpg" alt="img"><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/wps5.jpg" alt="img"> </p><ol start="5"><li>加解密运算未封装</li></ol><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/wps6.jpg" alt="img"> </p><h1 id="三、-完整实现同态加密算法"><a href="#三、-完整实现同态加密算法" class="headerlink" title="三、 *完整实现同态加密算法*"></a><strong>三、</strong> <em><strong>*完整实现同态加密算法*</strong></em></h1><p>主函数即功能函数截图</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/wps7.jpg" alt="img"> </p><p>主函数调用</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/wps8.jpg" alt="img"> </p><p>运行效果截图</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/wps9.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/wps10.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/wps11.jpg" alt="img"> </p>]]></content>
    
    
    <summary type="html">课程作业，深入理解同态加密算法</summary>
    
    
    
    <category term="信安课程实验" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="信息安全编程技术与实例开发" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://shuita2333.github.io/project/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>CNN简述与应用</title>
    <link href="https://shuita2333.github.io/project/2024/04/08/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/"/>
    <id>https://shuita2333.github.io/project/2024/04/08/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/</id>
    <published>2024-04-07T18:00:00.000Z</published>
    <updated>2024-07-10T15:25:34.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、来源与背景"><a href="#一、来源与背景" class="headerlink" title="*一、来源与背景*"></a><em><strong>*一、来源与背景*</strong></em></h1><p>在图像处理领域，cnn出现之前主要存在两个问题：</p><p><em><strong>*1. 需要处理的数据量太大*</strong></em></p><p>图像是由每个带有颜色的像素构成的，且每个像素都有RGB（可简单理解为光学三原色：红、绿、蓝）3个参数来表示颜色信息。</p><p>假如现在需要处理一张100<em>100像素的图片，就需要处理100</em>100*3&#x3D;30,000个参数。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps1.jpg" alt="img"><em><strong>*2. 弱化局部特征*</strong></em></p><p>以往的全连接模式会对整张图片进行识别，无法有效提取图片中的细节特征，按照人眼的视觉信息识别方法，我们更会根据某些细节信息进行组合，从而识别物体，而不是通过整个画面进行识别，例如全连接神经网络可能更认为这是乌鸦而循环神经网络会认为是猫。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps2.jpg" alt="img"><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps3.jpg" alt="img"><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps4.jpg" alt="img"> </p><p>为此产生了CNN，通过将复杂问题简化和保留图像特征就较为完美地解决图像识别上的一些问题。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps5.jpg" alt="img"> </p><h1 id="二、CNN的发展"><a href="#二、CNN的发展" class="headerlink" title="*二、CNN的发展*"></a><em><strong>*二、CNN的发展*</strong></em></h1><h2 id="1-AlexNet"><a href="#1-AlexNet" class="headerlink" title="*1. AlexNet*"></a><em><strong>*1. AlexNet*</strong></em></h2><p>2012年，AlexNet的出现标志着神经网络的复苏和深度学习的崛起。在imageNet2012的图片分类任务上，AlexNet以15.3%的错误率登顶，而且以高出第二名十几个百分点的差距远超所有其他参与者。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps6.jpg" alt="img"> </p><p>自从AlexNet发布后，该论文的引用量也在随后的几年中逐年上升，可见其模型对神经网络和深度学习的发展有着十分深远的影响。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps7.jpg" alt="img"> </p><p>同时AlexNet的模型架构也为后续的CNN模型架构建立奠定了基础，虽然具体参数和模型层数都发生了一定变化，但在逻辑结构和方法上，AlexNet都提供了一定的参考性意见。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps8.jpg" alt="img"> </p><h2 id="2-CNN网络结构"><a href="#2-CNN网络结构" class="headerlink" title="2. *CNN网络结构*"></a><strong>2.</strong> <em><strong>*CNN网络结构*</strong></em></h2><p>CNN是一种人工神经网络，CNN的结构可以分为3层：</p><p>卷积层(Convolutional Layer) - 主要作用是提取特征。</p><p>池化层(Max Pooling Layer) - 主要作用是下采样(downsampling)，却不会损坏识别结果。</p><p>全连接层(Fully Connected Layer) - 主要作用是分类。</p><p>例如拿人类识别物品做类比，人类识别一张图片内容是小鸟时，首先会判断鸟的嘴是尖的，全身有羽毛和翅膀，有尾巴。然后通过这些联系起来判断这是一只鸟。而CNN的原理也类似，通过卷积层来查找特征，然后通过全连接层来做分类判断这是一只鸟，而池化层则是为了让训练的参数更少，在保持采样不变的情况下，忽略掉一些信息。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps9.jpg" alt="img"> </p><h3 id="卷积层-Convolutional-Layer"><a href="#卷积层-Convolutional-Layer" class="headerlink" title="*卷积层(Convolutional Layer)*"></a><em><strong>*卷积层(Convolutional Layer)*</strong></em></h3><p>卷基层用来实现特征提取，将2个函数进行叠加，应用在图像上，找出图像中的某些特征，由于需要找到很多特征才能区分某一物体，所以会有多个滤镜，通过这些滤镜的组合，我们可以得出很多的特征。</p><p>卷积层中有三个重要参数</p><p>深度&#x2F;depth（解释见下图）</p><p>步幅&#x2F;stride （窗口一次滑动的长度）</p><p>填充值&#x2F;zero-padding</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps10.jpg" alt="img"> </p><h3 id="步幅"><a href="#步幅" class="headerlink" title="*步幅*"></a><em><strong>*步幅*</strong></em></h3><p>步幅控制着过滤器围绕输入内容进行卷积计算的方式。想象一个 7 x 7 的输入图像，一个 3 x 3 过滤器（简单起见不考虑第三个维度），步幅为 1。这是一种惯常的情况。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps11.jpg" alt="img"> </p><p>如果步幅增加到 2</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps12.jpg" alt="img"> </p><h3 id="填充值"><a href="#填充值" class="headerlink" title="*填充值*"></a><em><strong>*填充值*</strong></em></h3><p>把 5 x 5 x 3 的过滤器用在 32 x 32 x 3 的输入上时，输出的大小会是 28 x 28 x 3。注意，这里空间维度减小了。如果继续用卷积层，尺寸减小的速度就会超过期望。在网络的早期层中，想要尽可能多地保留原始输入内容的信息，这样我们就能提取出那些低层的特征。比如说我们想要应用同样的卷积层，但又想让输出量维持为 32 x 32 x 3 。为做到这点，我们可以对这个层应用大小为 2 的零填充（zero padding）。零填充在输入内容的边界周围补充零。如果我们用两个零填充，就会得到一个 36 x 36 x 3 的输入卷。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps13.jpg" alt="img"> </p><h3 id="非线性层（或激活层）"><a href="#非线性层（或激活层）" class="headerlink" title="*非线性层（或激活层）*"></a><em><strong>*非线性层（或激活层）*</strong></em></h3><p>激活层用于把卷积层输出结果做非线性映射。激活函数是激活层中用加入的非线性因素，能够提高网络表达能力，卷积神经网络中最常用的是ReLU，Sigmoid使用较少。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps14.jpg" alt="img"> </p><p>CNN采用的激活函数一般为ReLU(The Rectified Linear Unit&#x2F;修正线性单元)，它的特点是收敛快，求梯度简单，但较脆弱，图像如下。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps15.jpg" alt="img"> </p><h3 id="池化层"><a href="#池化层" class="headerlink" title="*池化层*"></a><em><strong>*池化层*</strong></em></h3><p>池化层夹在连续的卷积层中间，用于压缩数据和参数的量，减小过拟合。</p><p>简而言之，如果输入是图像的话，那么池化层的最主要作用就是压缩图像。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps16.jpg" alt="img"> </p><p>池化层的作用主要有三点：</p><p>特征不变性，平时一张狗的图像被缩小了一倍我们还能认出这是一张狗的照片，这说明这张图像中仍保留着狗最重要的特征，我们一看就能判断图像中画的是一只狗，图像压缩时去掉的信息只是一些无关紧要的信息，而留下的信息则是具有尺度不变性的特征，是最能表达图像的特征。</p><p>特征降维，一幅图像含有的信息数量大，特征多，但是有些信息对于做图像任务没有太多用途，可以把这类冗余信息去除，把最重要的特征抽取出来。</p><p>在一定程度上防止过拟合，更方便优化。</p><p>池化的具体方法主要分为以下两种，最大池化和平均池化，具体池化方法如图所示。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps17.jpg" alt="img"> </p><h3 id="改进与提升"><a href="#改进与提升" class="headerlink" title="*改进与提升*"></a><em><strong>*改进与提升*</strong></em></h3><p>由于AlexNet模型所使用7*7的卷积核，较大的卷积核使其对于较深的网络结构需要更多的计算资源。因此从缩小卷积核的角度着手，产生了VGG网络模型结构。</p><p><strong>3.</strong> <em><strong>*VGG*</strong></em><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps18.jpg" alt="img"></p><p>VGG16相比AlexNet的一个改进是采用连续的几个3x3的卷积核代替AlexNet中的较大卷积核（11x11，7x7，5x5）。对于给定的感受野（与输出有关的输入图片的局部大小），采用堆积的小卷积核是优于采用大的卷积核，因为多层非线性层可以增加网络深度来保证学习更复杂的模式，而且代价还比较小（参数更少）。</p><h3 id="感受野"><a href="#感受野" class="headerlink" title="*感受野*"></a><em><strong>*感受野*</strong></em></h3><p>在卷积神经网络中,感受野(Receptive Field)是指特征图上的某个点能看到的输入图像的区域,即特征图上的点是由输入图像中感受野大小区域的计算得到的神经元。感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps19.jpg" alt="img"> </p><p>在刚才提到的VGG网络当中，假设输出大小都是h<em>w</em>c，并且使用c个卷积核，可以计算一下其格子所需参数：</p><p>7*7卷积核所需参数：<img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps20.jpg" alt="img"></p><p>3个3*3卷积核所需参数：</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps21.jpg" alt="img"> </p><p>很明显，堆叠小的卷积核所需的参数更少一些，并且卷积过程越多，特征提取也会越细致，加入的非线性变换也随着增多，还不会增大权重参数个数，这就是VGG网络的基本出发点，用小的卷积核来完成体特征提取操作。</p><p>在VGG的基础上进行进一步改进和优化，产生了残差网络Resnet。</p><h2 id="4-Resnet"><a href="#4-Resnet" class="headerlink" title="4. *Resnet*"></a><strong>4.</strong> <em><strong>*Resnet*</strong></em></h2><p>ResNet的主要创新是引入了残差结构，允许网络学习残差映射，而不是直接学习完整的特征映射。这有助于解决梯度消失问题，允许训练非常深的网络。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps22.jpg" alt="img"> </p><p>在ResNet网络提出之前，传统的卷积神经网络都是通过将一系列卷积层与下采样层进行堆叠得到的。但是当堆叠到一定网络深度时，就会出现两个问题。</p><p>l 梯度消失或梯度爆炸。</p><p>l 退化问题(degradation problem)。</p><p>ResNet论文提出了residual结构（残差结构）来减轻退化问题。使用residual结构的卷积网络，随着网络的不断加深，效果并没有变差，反而变的更好了。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps23.jpg" alt="img"> </p><p>ResNet团队分别构建了带有“直连边（Shortcut Connection）”的ResNet残差块、以及降采样的ResNet残差块，区别是降采样残差块的直连边增加了一个1×1的卷积操作。对于直连边，当输入和输出维度一致时，可以直接将输入加到输出上，这相当于简单执行了同等映射，不会产生额外的参数，也不会增加计算复杂度。但是当维度不一致时，这就不能直接相加，通过添加1×1卷积调整通道数。这种残差学习结构可以通过前向神经网络+直连边实现， 而且整个网络依旧可以通过端到端的反向传播训练。结构如下图所示：</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps24.jpg" alt="img"> </p><p>同时残差块也可以存在不同的格式，不同的残差块示例如下：</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps25.jpg" alt="img"><em><strong>*三、CNN网络实验*</strong></em></p><h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="*1. 背景介绍*"></a><em><strong>*1. 背景介绍*</strong></em></h2><p>隐写分析是为了检测表面上无害的载体中是否存在机密消息（或秘密信息）。它是针对隐写术的对策技术，而隐写术则是将秘密信息嵌入数字载体的技术。</p><p>在本实验中，我们将检测一种新型的隐写术，它将多种正交隐写术方法应用于单个载体。所谓正交，即隐写方法的信息隐藏和提取过程独立运行。这种新型的隐写术有两个特点。首先，它是异构的，因为它使用两种或多种不同的隐写方法来隐藏信息。其次，它是并行的，因为每种隐写方法隐藏的机密消息都是单独嵌入的。因此，这种隐写术称为异构并行隐写术（HPS）。因此，使用一种隐写方法的传统隐写术称为单一隐写术。</p><p>流媒体，例如VoIP，是HPS的合适载体。流媒体是通过互联网以压缩形式发送的音频或视频内容。它由一系列包含协议标头和有效负载（例如音频和&#x2F;或视频帧）的数据包组成。HPS可以应用于流媒体。以VoIP为例，在线性预测编码（LPC）过程中嵌入消息的隐写方法与将信息隐藏与基音周期预测相结合的隐写方法是正交的。因此，这两种隐写方法都可以为VoIP构建HPS。</p><p>本实验的目标是检测低比特率 VoIP 语音流（即一种广泛使用的流媒体）的 HPS。两种正交隐写方法，即量化索引调制（QIM）和音高调制隐写术（PMS），用于形成HPS。我们调研并使用了一种十分有效的深度模型，叫做隐写分析特征融合网络（SFFN）。SFFN结合了三种神经网络结构，即卷积神经网络（CNN）、循环神经网络（RNN）和全连接网络（FCN）。这种方法能够有效地融合HPS中使用的不同隐写方法提取的隐写分析特征，因此，我们的方法能够在检测低比特率VoIP语音流的HPS任务中实现高精度。</p><h2 id="2-实验数据载体简介"><a href="#2-实验数据载体简介" class="headerlink" title="*2. 实验数据载体简介*"></a><em><strong>*2. 实验数据载体简介*</strong></em></h2><p>VoIP 是一种广泛使用的流媒体，由于其易于数据网络访问，为电话通信提供了一种经济的协议。由于综合分析LPC可以实现高压缩比和令人满意的语音质量，因此基于LPC的低比特率语音编解码器，例如G.723.1和G.729，被广泛应用于VoIP。对于这些编解码器，在对语音进行编码的过程中，信息可以隐藏在有效负载（即语音帧）上。</p><p>基于低比特率VoIP语音流有效负载的隐写方法可以大致分为两类。第一类是在LPC编码过程中隐藏秘密消息，例如互补邻居顶点（CNV）来改进QIM的码本划分。在CNV-QIM中，秘密信息嵌入到语音的线谱对（LSP) 参数中。第二类将信息隐藏集成到基音周期预测中，这些方法也称为音调调制隐写术（PMS）。在PMS中，通过修改自适应码topic延迟（ACD）参数，将机密消息隐藏在语音中。</p><p>由于QIM和PMS涉及独立的语音编码过程，因此这两种隐写方法是正交的，并且可以用于形成低比特率VoIP语音流的HPS。</p><h2 id="3-具体的方法（SFFN）"><a href="#3-具体的方法（SFFN）" class="headerlink" title="*3. 具体的方法（SFFN）*"></a><em><strong>*3. 具体的方法（SFFN）*</strong></em></h2><h3 id="3-1-数据处理"><a href="#3-1-数据处理" class="headerlink" title="*3.1. 数据处理*"></a><em><strong>*3.1. 数据处理*</strong></em></h3><p>首先，我们需要分析 VoIP 的哪些框架部分被 QIM 和 PMS 修改。对于QIM，它在矢量量化过程中嵌入隐藏消息以计算LSP系数。因此，使用从编码语音中提取的 LSP 码字作为 QIM 的隐写分析描述符。与 QIM 不同，PMS 在音调分析过程中隐藏秘密信息，并根据隐藏信息修改音调延迟。由于音调延迟被编码为 ACD 码字，因此需要将 ACD 码字解码为音调延迟并将其用作 PMS 隐写分析描述符，以避免编码的不良影响。 QIM 和 PMS 隐写分析描述符都用作SFFN方法的输入数据。</p><p>通过对G.729a语音流处理后，我们得到了针对QIM和PMS两种隐写方法分析的描述符，其形状分别为（3，T）和（4，T），其中T为语音帧个数，在 G.729 编解码器中，我们选取帧长度为10ms，因此对于1s的语音流而言，我们能够从中提取出100个语音帧，因此T为100。即我们从每个1s的语音流样本中提取出了（3，100）和（4，100）两部分隐写分析描述符，以作模型输入。</p><h3 id="3-2-网络架构"><a href="#3-2-网络架构" class="headerlink" title="*3.2. 网络架构*"></a><em><strong>*3.2. 网络架构*</strong></em></h3><p>SFFN方法的整体网络结构如下图所示，其中包含三个子网络：特征学习网络、特征融合网络和分类网络。特征学习网络用于从输入数据中学习每个隐写术的隐写分析特征。特征融合网络用于融合特征以生成联合特征以进行最终预测。分类网络利用联合特征来预测隐藏消息存在的概率。在本实验中，我们采用交叉熵损失函数。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps26.jpg" alt="img"> </p><h4 id="3-2-1-特征学习网络"><a href="#3-2-1-特征学习网络" class="headerlink" title="3.2.1. 特征学习网络"></a>3.2.1. 特征学习网络</h4><p>特征学习网络由两个堆叠的长短期记忆（LSTM）网络组成。LSTM是RNN的一种变体，它可以有效地处理语音和文本等序列数据。在特征学习网络中，第一个 LSTM 来学习 QIM 的隐写分析特征。第二个LSTM来学习PMS的特征。两个 LSTM 都有两个堆叠层，每层隐藏状态的维度都设置为50。最终，两个LSTM网络的输出形状均为(50，T)。最后，两个形状均为（50，T）的输出数组被连接并重塑为3D联合数组，记为M，其形状为(50，T，2)。</p><h4 id="3-2-2-特征融合网络"><a href="#3-2-2-特征融合网络" class="headerlink" title="3.2.2. 特征融合网络"></a>3.2.2. 特征融合网络</h4><p>SFFN利用CNN将两种隐写方法的隐写分析特征融合到一个联合特征向量中。在本实验中，采用精心设计的CNN来提取HPS检测的高级特征，下图3展示了 CNN 的详细结构。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps27.jpg" alt="img"> </p><p>特征融合网络由三个CNN块组成。前两个块分别由两个3×3卷积层、一个步长为2的最大池化层和一个ReLU激活层组成。最后一个块包含两个3×3卷积层、一个ReLU激活层和一个全局平均池化层。在这些块中，每个卷积层将通道数加倍，以便最终卷积层的输出具有128个通道。前两个块中的最大池化层将特征图的宽度和高度减少一半。同时，最后一个块中的全局平均池化层计算每个通道的平均值，从而输出1×1×128的数组。最后，全局平均池化层的输出被重塑为128维的向量。</p><h4 id="3-2-3-分类网络"><a href="#3-2-3-分类网络" class="headerlink" title="3.2.3. 分类网络"></a>3.2.3. 分类网络</h4><p>这一网络模块是一个FCN，用于根据特征融合网络计算的联合特征来预测隐藏消息存在的概率。FCN由全连接 (FC)层和softmax激活层组成。FC层的输出大小为2。</p><h3 id="3-3-训练过程"><a href="#3-3-训练过程" class="headerlink" title="*3.3. 训练过程*"></a><em><strong>*3.3. 训练过程*</strong></em></h3><p>整体训练过程分为三个阶段。在第一阶段，使用两个辅助FCN（即两个额外的分类器网络）预训练特征学习网络。在第二阶段，通过最小化分类损失仅更新特征融合网络（CNN）和分类网络的参数。在第三阶段，对三个子网络的所有参数进行微调。</p><p>对于此方法而言，从头开始训练整个子网络很难实现，特别是当语音中秘密信息的嵌入率较低时。因此为了解决这个问题，我们需要对特征学习网络进行预训练。具体来说，即利用交叉熵损失来预训练两个LSTM。对于特征学习网络的每个LSTM，我们将LSTM的最终隐藏状态馈送到FCN以生成2维向量。2维向量中的元素表示语音中存在和不存在隐藏消息的概率。接下来，我们对三个阶段分别进行概括。</p><p>第一阶段：在此阶段，首先随机初始化特征学习网络中两个 LSTM 的参数。然后，通过使用辅助FCN最小化交叉熵损失来单独训练每个LSTM。这个预训练阶段可以促进后期分类损失的收敛。</p><p>第二阶段：在此阶段，首先用随机值初始化特征融合网络和分类网络的参数。然后，通过最小化分类损失来更新它们。由于特征学习网络已在第一阶段进行了优化，因此我们在此阶段进一步训练其参数。</p><p>第三阶段：在这个阶段，对三个子网络的所有参数进行微调。优化目标与第二阶段相同。从实验结果来看，与第二阶段相比，对三个子网络的整体参数进行微调可以实现分类精度的稳定提高。</p><p>经过上述三个阶段训练后，SFFN方法能够实现HPS的高精度检测。</p><h2 id="4-实验设计及实验结果"><a href="#4-实验设计及实验结果" class="headerlink" title="*4. 实验设计及实验结果*"></a><em><strong>*4. 实验设计及实验结果*</strong></em></h2><h3 id="4-1-数据集构建"><a href="#4-1-数据集构建" class="headerlink" title="*4.1. 数据集构建*"></a><em><strong>*4.1. 数据集构建*</strong></em></h3><p>我们使用814,592条G.729a语音构成数据集进行实验。其中，764,592个样本（382,296个Stego-Cover对，即正负样本对）被划分为训练集，其余50,000个作为测试集。数据集中所有样本的持续时间均为1秒。</p><p>在训练集的正样本中，QIM隐写样本数与PMS隐写样本数之比为1：1。如上所述，正负样本比也为1：1，因此训练集的样本是平衡的，这样更加有利于模型的训练，增强测试效果。</p><h3 id="4-2-模型效果"><a href="#4-2-模型效果" class="headerlink" title="*4.2. 模型效果*"></a><em><strong>*4.2. 模型效果*</strong></em></h3><p>如下表所示，在检测HPS时， SFFN方法在所有嵌入率下均取得了最佳性能。在嵌入率为100%的情况下进行HPS分类的准确率高达 91.65%，当以大于60%的嵌入率检测CNV-QIM时，SFFN方法可以达到高于84.90%的分类精度。实验结果表明，该方法在CNV-QIM、PMS以及HPS检测上均取得了令人满意的精度。 </p><table><thead><tr><th>Steganalysis method</th><th>Steganography Method</th><th>Embedding Rate (%)</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>10</td><td>20</td><td>30</td><td>40</td><td>50</td><td>60</td><td>70</td><td>80</td><td>90</td><td>100</td><td></td><td></td></tr><tr><td>SFFN</td><td>CNV-QIM</td><td>54.28</td><td>54.62</td><td>71.23</td><td>65.08</td><td>82.19</td><td>84.90</td><td>87.43</td><td>89.66</td><td>91.86</td><td>93.50</td></tr><tr><td>PMS</td><td>51.17</td><td>53.76</td><td>61.52</td><td>63.94</td><td>69.74</td><td>72.80</td><td>76.11</td><td>79.07</td><td>82.04</td><td>83.93</td><td></td></tr><tr><td>CNV-QIM + PMS</td><td>66.67</td><td>70.44</td><td>77.81</td><td>75.01</td><td>84.37</td><td>87.66</td><td>88.44</td><td>89.66</td><td>91.08</td><td>91.65</td><td></td></tr></tbody></table><p>在本实验中，对于PMS隐写检测而言，我们比较了采用基音延迟或ACD码字作为PMS描述符时的平均准确度。结果如下所示。通过查阅资料可知，尽管有许多学者建议使用ACD码字，但在与SFFN方法中使用ACD码字相比，使用音调延迟可带来大约5%到10%的分类精度提高。结果表明，基音延迟比 ACD 码字更适合SFFN网络提取隐写分析特征。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps28.jpg" alt="img"> </p><h3 id="4-3-消融实验"><a href="#4-3-消融实验" class="headerlink" title="*4.3. 消融实验*"></a><em><strong>*4.3. 消融实验*</strong></em></h3><p>为了探索微调的好处，我们比较了第三阶段网络所有参数微调之前和之后在不同隐写嵌入率下的平均检测精度。</p><p>下图显示了SFFN方法在有和没有微调阶段的结果，可以观察到微调可以带来精度的提高，特别是当嵌入率较低时。例如，当中文语音和英语语音的嵌入率为 30% 时，SFFN方法在微调后的准确率分别比微调前高出3.5%和3.7%。在其他设置下也可以观察到类似的准确性提高。结果表明，在第三阶段对整个子网络进行微调有利于SFFN方法提高分类精度。</p><p><img src="/../../../images/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/wps29.jpg" alt="img"> </p><h3 id="4-4-实时性测试"><a href="#4-4-实时性测试" class="headerlink" title="*4.4. 实时性测试*"></a><em><strong>*4.4. 实时性测试*</strong></em></h3><p>为了进行在线隐写分析，需要实时进行检测。因此评估了SFFN方法对不同长度的语音（即0.1s、0.2s、…、1s和2s）的检测时间。实验在配备AMD Ryzen 7 5700X 8-Core CPU的平台上进行。此外，GPU不用于加速测试。经过实验，我们测得SFFN方法需要0.34毫秒来检查10毫秒的单个语音帧。因此，本实验表明SFFn方法满足实时隐写分析的要求。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="*5. 总结*"></a><em><strong>*5. 总结*</strong></em></h2><p>​在本实验中，我们完成了检测流媒体上的异构并行隐写术（HPS）这一任务。具体来说，实验关注特定的介质，即低比特率 VoIP 语音流，HPS 由两种正交隐写方法（即QIM和PMS）形成。我们使用了一种名为隐写分析特征融合网络（SFFN）的深度模型来解决该任务。SFFN可以有效地提取HPS中使用的隐写方法的隐写分析特征，并融合这些特征以做出可信的预测。在实验中，SFFN在检测HPS时表现出了十分良好的性能。此外，SFFN方法可以满足实时检测的要求，例如检查10 ms的语音帧只需要0.34 ms。</p>]]></content>
    
    
    <summary type="html">CNN调研学习报告</summary>
    
    
    
    <category term="信安课程实验" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="机器学习与安全" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://shuita2333.github.io/project/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>SQL Server灾备实验</title>
    <link href="https://shuita2333.github.io/project/2024/04/06/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/SQL%20Server%E7%81%BE%E5%A4%87%E5%AE%9E%E9%AA%8C/"/>
    <id>https://shuita2333.github.io/project/2024/04/06/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/SQL%20Server%E7%81%BE%E5%A4%87%E5%AE%9E%E9%AA%8C/</id>
    <published>2024-04-05T18:00:00.000Z</published>
    <updated>2024-08-08T02:57:50.736Z</updated>
    
    <content type="html"><![CDATA[<p>1 概念</p><p>1.1 数据库备份</p><p>从物理与逻辑的角度，备份可分为：</p><p>1.1.1 物理备份</p><p>物理备份是对数据库操作系统的物理文件（如数据文件、日志文件等）的备份方式，方法有：</p><p>l 冷备份（脱机备份）：是在关闭数据库的时候进行的；</p><p>l 热备份（联机备份）：数据库处于运行状态，依赖于数据库的日志文件；</p><p>l 温备份：数据库锁定表格（不可写入但可读）的状态下进行备份操作。</p><p>1.1.2 逻辑备份</p><p>逻辑备份是对数据库逻辑组件（如：表等数据库对象）的备份方式，从数据库的备份策略角度，可分为：</p><p>l 完全备份：每次对数据库进行完整的备份；</p><p>l 差异备份：备份自从上次完全备份之后被修改过的文件；</p><p>l 增量备份：只有在上次完全备份或者增量备份后被修改的文件才会被备份。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps1.jpg) </p><p>1.2 完全备份、增量备份概述与对比</p><p>1.2.1 完全备份</p><p>完全备份是对整个数据库、数据库结构和文件结构的备份；保存的是备份完成时刻的数据库；是差异备份与增量备份的基础；每次对数据进行完整的备份。</p><p>该备份方式的优点为：</p><p>l 备份与恢复操作简单方便。</p><p>该备份方式的缺点为：</p><p>l 数据存在大量的重复；</p><p>l 占用大量的备份空间；</p><p>l 备份与恢复时间长。</p><p>1.2.2 增量备份</p><p>MySQL增量备份是自上一次备份后增加&#x2F;变化的文件或者内容，其特点为：</p><p>l 没有重复数据，备份量不大，时间短；</p><p>l 依靠二进制日志文件进行逐次增量备份，单个文件丢失则数据不完整，安全性低。</p><p>1.3 数据库镜像概念</p><p>1.3.1 数据库镜像概念</p><p>数据库管理系统自动把数据库或者其中的关键数据复制到另一个磁盘上；数据库系统自动保证镜像数据和主数据的一致性，每当主数据更新时，数据库管理系统自动把更新后的数据复制过去。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps2.jpg) </p><p>1.3.2 数据库镜像的用途</p><p>当系统出现介质故障时：</p><p>l 可由镜像磁盘继续提供使用；</p><p>l 同时数据库管理系统自动利用镜像磁盘数据进行数据的恢复；</p><p>l 不需要关闭系统和重装数据库副本。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps3.jpg) </p><p>当系统没出现介质故障时：</p><p>l 可用于并发操作；</p><p>l 一个用户加排它锁修改数据，其他用户可以读镜像数据库上的数据而不必等待该用户释放锁。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps4.jpg) </p><p>实际操作中，频繁的复制数据自然会降低系统的运行效率，在实际应用中用户往往只选择对关键数据和日志文件镜像，而不是对整个数据库镜像。</p><p>1.4 数据库镜像的优势</p><p>数据库镜像技术有以下优势：</p><p>l 消除存储方面的单一故障点：不用共享磁盘；</p><p>l 提高数据库可用性：快速自动&#x2F;手动主从切换；</p><p>l 增强的数据保护：提供完整的数据冗余；</p><p>l 自动页修复：2008企业版在某些类型的错误导致页损坏，使其无法读取后，在 SQL Server 2008 企业版或更高版本上运行的数据库镜像伙伴（主体或镜像）将尝试自动修复该页。无法读取该页的伙伴将从其伙伴请求该页的新副本。如果此请求成功，则将以可读副本替换不可读的页，并且这通常会解决该错误。</p><p>1.5 数据库镜像的不足</p><p>镜像数据库技术有以下不足之处：</p><p>（1）版本限制：对于标准版的 SQL Server 实例，只可以使用“高安全模式”，即主体数据库与镜像数据库必须实现同步操作。在这种运行模式时，如果任何一个伙伴遇到性能问题，都将使同步操作带来较大的延时。通常标准版的 SQL Server 受到一些技术限制导致性能不能提升，从而使同步操作的延时更加明显。</p><p>（2）镜像数据库的访问限制：镜像数据库甚至不可以提供只读访问，只有通过创建快照才能访问，因此镜像数据库的利用率不高。</p><p>由于数据库镜像技术存在上述不足，SQL Server 后续产品将删除此项功能，建议改用 AlwaysOn 可用性组。SQL Server 2012 中已经引入了”AlwaysOn 基本可用性组”，用来替代数据库镜像技术。</p><p>2 数据库完整&#x2F;差异备份、数据库恢复</p><p>2.1 实验环境</p><p>操作系统：Windows10</p><p>数据库：SQL Server</p><p>2.2 数据库完整&#x2F;差异备份</p><p>2.2.1 创建数据库</p><p>创建一个“灾备demo”数据库，并创建stu表存储组员信息。如下所示。</p><p>CREATE TABLE stu (</p><p>  StudentID int,</p><p>​Class int,</p><p>  Name nvarchar(255)</p><p>);</p><p>INSERT INTO stu (StudentID, Name) </p><p>VALUES </p><p>(2021212053,2021211803, N’张原赫’),</p><p>(2021212024,2021211803, N’范思宇’),</p><p>(2021212065,2021211803, N’方正阳’);</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps5.jpg) </p><p>2.2.2 完整备份</p><p>右击需要备份的数据库，“任务”→“备份”。备份类型选择“完整”，删除自动生成的备份文件路径及文件名，填写备份路径及备份文件名。确认后，完成备份。如下所示。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps6.jpg) </p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps7.jpg) </p><p>2.2.3 差异备份</p><p>首先，查看数据表条目，查询一共有多少条信息，完整备份时的数据总数为3条。如下所示。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps8.jpg) </p><p>USE 灾备demo</p><p>select COUNT(1) ‘total’ from stu</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps9.jpg) </p><p>接下来，新增几条记录，用作差异备份。添加之后，一共有11条。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps10.jpg) </p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps11.jpg) </p><p>进行差异备份，右击需要备份的数据库，“任务”→“备份”。备份类型：差异，填写备份路径及备份文件名。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps12.jpg) </p><p>2.3 数据库恢复</p><p>2.3.1 完整备份恢复</p><p>设置访问权限。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps13.jpg) </p><p>右击“数据库”→“还原数据库”，使用设备还原，选择完整备份文件，直接在目标数据库处更改还原数据库名。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps14.jpg) </p><p>成功恢复。如下所示。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps15.jpg) </p><p>2.3.2 差异备份还原</p><p>使用脚本进行差异备份，还原到和完整备份相同的目标数据库。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps16.jpg) </p><p>查询总条目进行验证，成功恢复。如下所示。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps17.jpg) </p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps18.jpg) </p><p>3 同步或异步镜像搭建、数据实时复制</p><p>3.1 实验环境</p><p>​服务器1：系统Windows10，IP地址192.168.75.161</p><p>​服务器2：系统Windows10，IP地址192.168.75.162</p><p>3.2 实验准备</p><p>3.2.1 新建用户名</p><p>统一在主服务器和从服务器上新建一个登录名：DR_user，同时赋予 sysadmin角色。如下所示。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps19.jpg) </p><p>3.2.2 数据库准备 </p><p>在主服务器数据库中新建数据库“DR_exp”，其中stu 表记录小组成员信息如下所示。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps20.jpg) </p><p>3.3 同步或异步镜像搭建</p><p>3.3.1 创建master数据库主密钥</p><p>分别在两台虚拟机上执行如下命令：</p><p>Use master; </p><p>CREATE MASTER KEY ENCRYPTION BY PASSWORD &#x3D; ‘23987hxJ#KL95234nl0zBe’; </p><p>GO </p><p>3.3.2 对服务器实例创建一个用于其数据库镜像出站连接的加密证书</p><p>在主服务器上执行如下命令：</p><p>USE master; </p><p>CREATE CERTIFICATE SQLSVR1_cert WITH SUBJECT &#x3D;’SQLSVR1 certificate for database </p><p>mirroring’, </p><p>start_date&#x3D;’2024-03-01’,expiry_date&#x3D;’2099-01-01’; </p><p>GO </p><p>在从服务器上执行如下命令： </p><p>USE master; </p><p>go </p><p>CREATE CERTIFICATE SQLSVR2_cert WITH SUBJECT &#x3D;’SQLSVR2 certificate for database mirroring’, </p><p>start_date&#x3D;’2024-03-01’,expiry_date&#x3D;’2099-01-01’; </p><p>GO </p><p>这里设置了证书的有效期是从 2024 年到 2099 年。如下所示。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps21.jpg) </p><p>3.3.3 使用服务器实例证书为服务器创建端点</p><p>使用主服务器实例的证书SQLSVR1_cert为主服务器SQLSVR1创建端点，在主服务器上执行如下命令：</p><p>Use master; </p><p>go </p><p>CREATE ENDPOINT DbMirroringEndpoint </p><p>STATE &#x3D; STARTED AS TCP ( </p><p>LISTENER_PORT&#x3D;5022 </p><p>, LISTENER_IP &#x3D; ALL </p><p>) </p><p>FOR DATABASE_MIRRORING ( </p><p>AUTHENTICATION &#x3D; CERTIFICATE SQLSVR1_cert </p><p>, ENCRYPTION &#x3D; REQUIRED ALGORITHM AES </p><p>, ROLE &#x3D; ALL </p><p>); </p><p>GO</p><p>使用从服务器实例的证书SQLSVR2_cert为从服务器SQLSVR2创建端点，在从服务器上执行如下命令：</p><p>Use master; </p><p>go </p><p>CREATE ENDPOINT DbMirroringEndpoint </p><p>STATE &#x3D; STARTED AS TCP( </p><p>LISTENER_PORT&#x3D;5022, </p><p>LISTENER_IP &#x3D;ALL </p><p>) </p><p>FOR DATABASE_MIRRORING ( </p><p>AUTHENTICATION &#x3D; CERTIFICATE SQLSVR2_cert, </p><p>ENCRYPTION &#x3D; REQUIRED ALGORITHM AES, </p><p>ROLE &#x3D;ALL </p><p>); </p><p>GO</p><p>在上述命令中：</p><p>CREATE ENDPOINT DbMirroringEndpoint：这条命令是用来创建一个名为 DbMirroringEndpoint 的端点。端点是 SQL Server 上的一个对象，用于定义一个通信端口，允许 SQL Server 实例之间或与客户端之间进行网络通信；</p><p>AS TCP (LISTENER_PORT&#x3D;5022, LISTENER_IP &#x3D; ALL )：此部分配置端点使用 TCP 协议进行通信，并监听所有网络接口上的 5022 端口；</p><p>FOR DATABASE_MIRRORING：指定端点的用途为数据库镜像，这意味着这个端点将被用于数据库镜像会话中，以支持数据库之间的数据同步和故障转移。</p><p>3.3.4 备份服务器的加密证书</p><p>在主服务器上执行如下命令：</p><p>BACKUP CERTIFICATE SQLSVR1_cert TO FILE &#x3D;’C:\data\SQLSVR1.cer’; </p><p>在从服务器上执行如下命令： </p><p>BACKUP CERTIFICATE SQLSVR2_cert TO FILE &#x3D;’C:\data\SQLSVR2.cer’; </p><p>将证书存在了各自 C:\data\ 目录下。如下所示。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps22.jpg) </p><p>3.3.5 分别为另一个服务器创建登录名和用户 </p><p>在主服务器实例的 master 数据库中为镜像服务器创建一个登录名，同时为该用户名创建一个用户。</p><p>USE master; </p><p>go </p><p>CREATE LOGIN SQLSVR2_login WITH PASSWORD&#x3D;‘Sample@#’; </p><p>CREATE USER SQLSVR2_user FOR LOGIN SQLSVR2_login; </p><p>GO </p><p>在从服务器实例的 master 数据库中为主服务器创建一个登录名，同时为该用户名创建一个用户。</p><p>USE master; </p><p>go </p><p>CREATE LOGIN SQLSVR1_login WITH PASSWORD&#x3D;‘Sample@#’; </p><p>CREATE USER SQLSVR1_user FOR LOGIN SQLSVR1_login; </p><p>GO </p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps23.jpg) </p><p>3.3.6 将上述创建的用户与对应服务器的证书相关联</p><p>这里首先要将各自服务器生成的证书复制粘贴到对方相应目录下。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps24.jpg) </p><p>在主服务器中执行如下命令：</p><p>Use master; </p><p>go </p><p>CREATE CERTIFICATE SQLSVR2_cert AUTHORIZATION SQLSVR2_user FROM FILE &#x3D; </p><p>‘C:\data\SQLSVR2.cer’ </p><p>GO </p><p>在从服务器中执行如下命令：</p><p>Use master; </p><p>go </p><p>CREATE CERTIFICATE SQLSVR1_cert AUTHORIZATION SQLSVR1_user FROM FILE &#x3D; </p><p>‘C:\data\SQLSVR1.cer’ </p><p>GO </p><p>3.3.7 授予登录名对数据库镜像端点的 CONNECT 权限</p><p>在主服务器中执行如下命令：</p><p>GRANT connect on endpoint::DbMirroringEndpoint TO SQLSVR2_login; </p><p>GO </p><p>在从服务器中执行如下命令：</p><p>GRANT connect on endpoint::DbMirroringEndpoint TO SQLSVR1_login; </p><p>GO </p><p>3.3.8 主服务器备份数据库，从服务器恢复数据库</p><p>设置主服务器中主库为完整恢复模式，并备份到对应目录。在主服务器中执行如下命令：</p><p>Alter database DR_exp set recovery full with no_wait </p><p>Backup database DR_exp to disk&#x3D;’C:\Program Files\Microsoft SQL Server\MSSQL16.SQLSERVER\MSSQL\Backup\DR_exp.bak’ </p><p>执行成功。如下所示。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps25.jpg) </p><p>在从服务器中还原主数据库的备份文件（先手动把备份文件拷贝到从服务器上）。在从服务器中执行如下命令：</p><p>Restore database DR_exp from disk&#x3D;’C:\Program Files\Microsoft SQL Server\MSSQL16.SQLSERVER\MSSQL\Backup\DR_exp.bak’ with norecovery</p><p>3.3.9 设置镜像 </p><p>执行下述操作，192.168.75.161 为主服务器的 IP 地址。</p><p>Alter database DR_exp set partner&#x3D;’TCP:&#x2F;&#x2F;192.168.75.161:5022’</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps26.jpg) </p><p>在从服务器上操作完成后，在主服务器上进行如下操作，192.168.75.162 为主从服务器的 IP 地址。</p><p>Alter database DR_exp set partner&#x3D;’TCP:&#x2F;&#x2F;192.168.75.162:5022’</p><p>3.3.10 配置完成 </p><p>至此，镜像配置完成。查看主服务器上数据库状态，显示如下：</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps27.jpg) </p><p>从服务器上显示如下：</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps28.jpg) </p><p>同时，可以使用 T-SQL 语句来检查镜像同步状态：</p><p>SELECT DB_NAME(database_id) AS DatabaseName, mirroring_state_desc </p><p>FROM sys.database_mirroring </p><p>WHERE mirroring_guid IS NOT NULL; </p><p>执行结果如下，SYNCHRONIZED 意味着数据已经实时复制并保持同步。</p><p>3.3.11 主备切换 </p><p>在高安全模式下，在主机执行如下命令及完成主备切换： </p><p>use master; </p><p>alter database DR_exp set partner failover;</p><p>刷新之后可以看到主服务器和从服务器进行切换：</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps29.jpg) </p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps30.jpg) </p><p>3.4 数据实时复制</p><p>3.4.1 在主服务器上对数据库进行增删改的操作</p><p>如下是在 DR_exp 数据库的 team_info 表中新插入一行数据：</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps31.jpg) </p><p>3.4.2 检查镜像数据库的数据</p><p>使用数据库快照：在镜像服务器上创建数据库的快照，然后查询该快照中的数据。数据库快照提供了镜像数据库在创建快照时刻的静态视图。</p><p>在镜像服务器上创建快照：</p><p>CREATE DATABASE DR_exp_snapshot ON </p><p>(NAME &#x3D; DR_exp, FILENAME &#x3D; ‘C:\Program Files\Microsoft SQL </p><p>Server\MSSQL16.MSSQLSERVER\MSSQL\DATA\DR_exp_snapshot.ss’) </p><p>AS SNAPSHOT OF DR_exp; </p><p>查询快照数据：</p><p>use DR_exp_snapshot; </p><p>select *from team_info;</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps32.jpg) </p><p>4 创建快照、查询快照</p><p>4.1 实验环境</p><p>操作系统：Windows10</p><p>数据库：SQL Server</p><p>4.2 实验准备</p><p>使用“灾备demo”数据库，其中表“stu”中记录了小组三人的姓名学号。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps33.jpg) </p><p>4.3 创建快照</p><p>创建数据库“灾备demo”的快照，并命名为“Snapshot_Test_shot”，存储于 C:\test\test.mdf 。</p><p>刷新后发现数据库快照文件夹中已存在该快照。创建快照成功。</p><p>create database Snapshot_Test_shot ON</p><p>(</p><p>  Name &#x3D; 灾备demo,</p><p>  FileName &#x3D; ‘C:\test\test.mdf’</p><p>) </p><p>AS SNAPSHOT OF 灾备demo;</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps34.jpg) </p><p>4.4 查询快照</p><p>查询快照中的“stu”表，查询成功。</p><p>USE Snapshot_Test_shot ;</p><p>SELECT * FROM stu</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps35.jpg) </p><p>4.5 使用快照恢复数据库</p><p>删除数据库“灾备demo”中的“stu”表，刷新后发现删除成功。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps36.jpg) </p><p>执行命令，将“test”数据库恢复为数据库快照“Snapshot_Test_shot”。</p><p>use master;</p><p>GO</p><p>RESTORE DATABASE 灾备demo from </p><p>DATABASE_SNAPSHOT &#x3D; ‘Snapshot_Test_shot’;</p><p>再次查询“灾备demo”数据库中的“stu”表,查询成功。数据库通过快照恢复成功。</p><p>![img](..&#x2F;..&#x2F;..&#x2F;images&#x2F;Information_Security_Experiment&#x2F;信息系统灾备&#x2F;SQL Server灾备实验&#x2F;wps37.jpg) </p><p>5  总结</p><p>​通过本次实验，我们了解到了数据库的多种备份方式的整体操作过程，即差异备份和完整备份，同时，掌握了在异常情况发生后数据库恢复的基本方法。之后，我们使用SQL Server完成了同步镜像搭建、数据实时复制，以及创建和查询快照的过程。这次实验让我们对SQL Server的高可用性和数据恢复功能有了更深入的了解，并提高了实际操作能力。</p>]]></content>
    
    
    <summary type="html">深入SQL Server灾备原理</summary>
    
    
    
    <category term="信安课程实验" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="信息系统灾备" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://shuita2333.github.io/project/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>现有灾备技术调研报告</title>
    <link href="https://shuita2333.github.io/project/2024/04/06/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
    <id>https://shuita2333.github.io/project/2024/04/06/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</id>
    <published>2024-04-05T18:00:00.000Z</published>
    <updated>2024-07-10T15:36:17.754Z</updated>
    
    <content type="html"><![CDATA[<p>一、现有灾备技术调研</p><p>灾备是指为了防止业务系统和业务数据因各种灾难事件（自然灾害、软硬件故障、网络攻击、病毒入侵、操作失误等）的影响，导致数据丢失、业务系统服务终止，而利用技术、管理手段以及相关软硬件资源，在本地或异地进行备份，以确保机构关键数据、关键系统和关键业务能够在灾难发生后，快速利用备份，恢复正常运行，实现业务服务的可持续性。灾备不等于数据备份，灾备不仅考虑数据安全，而且考虑业务应用安全。一般包括：容灾、备份、恢复、归档、高可用等。</p><p><strong>1.</strong> 数据备份</p><p>1.1. 传统备份</p><p>备份主要是对数据提供多副本冗余，当数据发生误操作、病毒感染和丢失等逻辑错误后，可以用备份副本进行恢复，保证数据少丢失的数据备份技术。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps1.png" alt="img"></p><p>1.2. CDP</p><p>CDP(Continuous Data Protection连续数据保护)是一套方法，它可以捕获或跟踪数据的变化，并将其在生产数据之外独立存放，以确保数据可以恢复到过去的任意时间点。持续数据保护系统可以基于块、文件或应用实现，可以为恢复对象提供足够细的恢复粒度，实现几乎无限多的恢复时间点。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps2.png" alt="img"></p><p>1.3. CDM</p><p>组织依赖于具有存储分层的穷举拷贝、缺陷快照和专用拷贝管理工具来对拷贝创建和维护过程进行管理。IDC 和 Gartner 将这一产品类别称之为“拷贝数据管理”（Copy Data Management, CDM）。但当前的 CDM 方法基本上都面临着存储激增、性能&#x2F;可扩展性和 SLA 问题，并且其拷贝频率地限制。CDM 技（Copy Data Management ）可以说是应云和数据副本管理而生的，业务对 CDM 技术的基本诉求主要体现在：不论是什么类型的数据，数据库、文件系统、虚拟机等等，都实现永远增量备份。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps3.png" alt="img"></p><p><strong>2.</strong> 复制技术</p><p>2.1. 同步复制</p><p>同步复制可以做到主&#x2F;备中心磁盘阵列同步地进行数据更新，应用系统的I&#x2F;O写入主磁盘阵列后(写入Cache中)，主磁盘阵列将利用自身的机制（如EMC的SRDF&#x2F;S）同时将写I&#x2F;O写入后备磁盘阵列，后备磁盘阵列确认后，主中心磁盘阵列才返回应用的写操作完成信息。</p><p>采用同步方式，使得后备磁盘阵列中的数据总是与生产系统数据同步，因此当生产数据中心发生灾难事件时，不会造成数据丢失。为避免对生产系统性能的影响，同步方式通常在近距离范围内。</p><p>2.2. 异步复制</p><p>异步复制是在应用系统的I&#x2F;O写入主磁盘阵列后(写入Cache中)，主磁盘阵列立即返回给主机应用系统“写完成”信息，主机应用可以继续进行读、写I&#x2F;O操作。同时，主中心磁盘阵列将利用自身的机制（如EMC的SRDF&#x2F;A）将写I&#x2F;O写入后备磁盘阵列，实现数据保护。</p><p>采用异步方式应用程序不必等待远程更新的完成，因此远程数据备份的性能的影响通常较小，并且备份磁盘的距离和生产磁盘间的距离理论上没有限制（可以通过IP连接来实现数据的异步复制）。</p><p><strong>3.</strong> 高可用性系统</p><p>3.1. 冗余硬件</p><p>硬件容错方法之一是硬件冗余，在物理级可通过元件的重复而获得（如相同元件的串、并联，四倍元件等）。</p><p>另一硬件容错的方法叫待命储备冗余。该系统中共有M＋1个模块，其中只有一块处于工作状态，其余M块都处于待命接替状态。一旦工作模块出了故障，立刻切换到一个待命模块，当换上的储备模块发生故障时，又切换到另一储备模块，直到资源枯竭，显然，这种系统必须具有检错和切换的装置。</p><p>混合冗余系统是堆积冗余和待命储备冗余的结合应用。当堆积冗余中有一个模块发生故障时，立刻将其切除，并代之以无故障待命模块。这种方法可达到较高的可靠性。</p><p>上述三种容错基本结构统称K出自N结构。该结构中共有N个相同的模块，其中至少有K个是正常的，系统才能正常运行。这种结构能容忍分别出现在N－K个模块中的N－K个独立的故障，或称其容忍能力是t&#x3D;N－K。</p><p>对有人维修的系统，一有故障就能排除，两模块就能起到多模块的作用，因此可以构成双模冗余系统。在部件级和整机级可实现双模结构。在整机级可采用双机交替工作、双机协同工作和修理不停机等工作方式。如重要业务处室的备用机，一些服务器的双网卡并行工作，双CPU，双电源等。</p><p>3.2. 虚拟化</p><p>虚拟化技术是通过虚拟化技术将一台计算机虚拟为多台逻辑计算机，在一台计算机上同时运行多个逻辑计算机，同时每个逻辑计算机可运行不同的操作系统，应用程序都可以在相互独立的空间内运行而互相不影响，从而提高计算机的工作效率。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps4.jpg" alt="img"></p><p>3.2.1. 虚拟化类型</p><p>l 全虚拟化：将物理硬件资源全部通过软件的方式抽象化，最后进行调用</p><p>l 使用的方法: 使用hypervisor（VMM）软件，其原理是在底层硬件和服务器之间建立一个抽象层，而基于核心的虚拟机是面向Linux系统的开源产品hypervisor(VMM)可以捕捉CPU的指令，为指令访问硬件控制器和外设充当中介。</p><p>l 半虚拟化：需要修改操作系统</p><p>l 直通：直接使用物理硬件资源（需要支持，还不完善)</p><p>3.2.2. 虚拟化优势</p><p>① 集中化管理（远程管理、维护）</p><p>② 提高硬件利用率（物理资源利用率低-例如峰值，虚拟化解决了“空闲”容量）</p><p>③ 动态调整机器&#x2F;资源配置（虚拟化把系统的应用程序和服务硬件分离、提高了灵活性）</p><p>④ 高可靠（可部署额外的功能和方案，可提高透明负载均衡、迁移、恢复复制等应用环境）</p><p>3.2.3. 虚拟化缺点</p><p>① 前期高额费用（初期的硬件支持）</p><p>② 降低硬件利用率（特定场景-例如极度吃资源的应用不一定适合虚拟化）</p><p>③ 更大的错误影响面（本地物理机down机会导致虚拟机均不可用，同时可能虚拟机中文件全部损坏）</p><p>④ 实施配置复杂、管理复杂（管理人员运维、排障困难）</p><p>⑤ 一定的限制性（虚拟化技术涉及各种限制，必须与支持&#x2F;兼容虚拟化的服务器、应用程序及供应商结合使用）</p><p>⑥ 安全性（虚拟化技术自身的安全隐患）</p><p><strong>4.</strong> 容灾技术</p><p>4.1. 容灾站点</p><p>4.1.1. 热站点</p><p>灾难发生后，故障转移会在几分钟或几小时内发生。日常数据同步通常发生在主站点和热站点之间，导致数据丢失最少或没有丢失。可以获取异地数据备份磁带并将其传送到热站点以帮助恢复操作。应定期测试备份磁带，以检测数据损坏、恶意代码和环境破坏。热备份站点是最昂贵的灾难恢复方法。</p><p>4.1.2. 温站点</p><p>包含部分冗余的硬件和软件，具有电信、电话和公用设施连接以继续一些但不是所有的主站点操作。故障转移会在灾难发生后的数小时或数天内发生。每天或每周的数据同步通常发生在主站点和温站点之间，从而将数据丢失降至最低。必须获取异地数据备份磁带并将其交付到温站以恢复操作。温站是成本介于“冷”和“热”之间的选择。</p><p>4.1.3. 冷站点</p><p>订购、运送和安装硬件，并加载软件。基本的电信、电话和公用事业连接可能需要时间才能继续一些但不是所有的主要站点操作。灾难发生后，搬迁会在几周或更长时间内发生，具体取决于硬件到达时间。主站点和冷站点之间不会发生数据同步，可能会导致大量数据丢失。必须获取异地数据备份磁带并将其交付到冷站点以恢复操作。冷站点是最便宜的选择。</p><p>4.2. 容灾和灾备的区别</p><p>当系统发生故障时，容灾仍然能够正常地向网络系统提供数据和服务，以使系统不致停顿。而备份技术的目的与此并不相同，备份是“将在线数据转移成离线数据的过程”，其目的在于应付系统数据中的逻辑错误和历史数据保存，当系统数据崩溃时能够恢复数据。</p><p>备份数据是为了防止系统出现操作失误或系统故障导致数据丢失，而将全系统或部分数据集合从应用主机的硬盘或阵列复制到其它的存储介质的过程。</p><p>系统备份不可以替换容灾。上述描述了备份的目的只能满足数据丢失、数据破坏时的数据恢复，而不能提供实时的业务接管功能。容灾具备实时的业务接管功能，同时远程容灾系统具备应付各种灾难，特别是区域性与毁灭性灾难的能力，具备较为完善的数据保护与灾难恢复功能，保证灾难降临时数据的完整性及业务的连续性，并在最短时间内恢复业务系统的正常运行，将损失降到最小。</p><p>系统容灾不可以替换备份。容灾系统会完整地把生产系统的任何变化复制到容灾中心去，包括不想让它复制的工作，比如不小心把系统的业务数据删除了，同时容灾中心的业务数据也会被完整删除，如果是同步容灾，那容灾中心同时就删除了，反之是异步容灾，那容灾中心在数据异步复制的间隔内就会被删除，此时就需要从备份中心中取出最新备份数据，来恢复被错误删除的信息。因此容灾中心的建设不能替代备份中心的建设。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps5.jpg" alt="img"></p><p>4.3. 容灾难点</p><p>4.3.1. 脑裂</p><p>数据中心脑裂简单说就是两个数据中心间的网络和存储链路同时发生中断，导致两个数据中心内的应用、数据库或者操作系统同时抢占和利用共享的资源，造成资源的数据不一致，产生重大影响。此类问题是在存储跨中心双活方案设计、实施阶段不可避免要遇到的问题。</p><p>4.3.2. 性能</p><p>双活系统在写入数据时，会写两次数据，尤其是通过复制功能写到远端存储的过程，传输链路的性能也会影响整体性能。通常存储还是跨两个不同数据中心，随着距离的增加，单个存储I&#x2F;O处理处于比较高性能的模式。如果加上其他因素，如：并发、数据处理等，数据延迟会成倍增加。而存储双活的初衷是只是为了高可用性和提高总体并发、吞吐量，并不是为了降低读写响应时间。</p><p>4.3.3. 数据一致性</p><p>当跨中心的写入数据时，在复制过程中，数据传递是在缓存中进行的，这样做的好处是提升了性能，问题是当出现控制器节点异常宕机事件时，就会导致缓存内的数据不能写入存储中，从而造成数据的不一致。通常可以采用物理存储加存储虚拟化网关。</p><p>4.3.4. 数据同步</p><p>存储层面的复制技术基本以存储块进行的数据复制，如数据块发生了逻辑错误，那么存储是无法检测到的，它会继续将坏的数据块儿同步到灾备端，如果因此数据库发生宕机，那么灾备端的数据库也同样无法正常启动。所以需要有多层次的防范机制, 来保障数据的可靠性和安全性，需要以备份技术、数据库复制技术，连续性数据保护，建立了完善的数据保障体系。</p><p><strong>5.</strong> 快照和克隆技术</p><p>5.1. 快照</p><p>根据SNIA的定义，快照是指对指定数据集合（卷）的一个完全可用复制，该复制是源数据在某一个时间点的静态映像。快照一般是源数据的一个“虚拟”副本，相比于镜像，快照仅保存了数据集合某一段时间内的状态，因此，快照占用的空间较小。快照最初诞生的目的是数据保护，但随着数据重要性的增加，快照也逐渐被应用于数据分析和应用测试等场景。一般情况下，快照在数据保护场景下的主要用途可分为3类。</p><p>l 数据恢复：当数据面临恶意攻击或人为误操作时，快照可将数据快速恢复到指定的版本。</p><p>l 数据备份：存储系统自身或备份归档软件周期性对业务数据生成快照，同时定期删除较早生成的快照。</p><p>l 数据分析：在不对业务产生影响的情况下，通过对快照的读写，实现数据测试、分析和挖掘的目的。</p><p>5.2. 克隆</p><p>克隆和快照是都是数据的复制。区别之处在于，快照仅为存储系统在某一个时间点的系统状态或数据映像，而克隆则是对存储系统的完全复制。因此，克隆可独立于原始系统，具有更高效的数据恢复能力。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps6.jpg" alt="img"></p><p>5.3. 镜像</p><p>镜像技术是指对存储数据实现副本复制，原数据和副本数据具有一致性，并支持存储系统对源数据和副本数据的独立访问。镜像是针对系统内部数据保护的一个有效技术手段，一般镜像技术主要应用于解决单个LUN请求失效引起的整个业务中断与数据丢失的情况。目前，镜像技术主要包括两种方案，分别是存储自带镜像特性和借助存储网关实现镜像特性。</p><p><strong>6.</strong> 归档</p><p>6.1. 归档介绍</p><p>在信息系统出现之前，归档的概念就已出现，主要指把公文、资料等分类保存起来，便于查询，例如档案馆对个人档案的归档保存。到了信息时代，数据的管理发展到以存放电子信息为主，数据归档将不经常访问的数据转移到低成本的存储库。</p><p>数据归档是企业为了满足企业业务需要、遵从法律法规长期存放有价值的数据，当需要的时候能快速查询和检索的行为。根据需求的不同，数据归档的架构和功能多样，其最基本的功能要求是索引和搜索，以确保文件仍然易于访问。</p><p>6.2. 考虑因素</p><p>l 数据安全存放，保证数据完整性。</p><p>l 数据易于查询，易于读取。</p><p>l 遵从法律法规，保证数据不泄露、不被篡改。</p><p>l 低成本存放。由于数据归档是为了保证企业审计和法规遵从，平时归档数据是不被使用的，而数据本身量非常大，低成本存放是必须要考虑的因素。因此，分级存储技术、离线存储、低成本存储（如磁带、蓝光、云存储归档技术）不断涌现。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps7.jpg" alt="img"></p><p><strong>7.</strong> 业界灾备系统建设</p><p>7.1. 灾备系统分析</p><p>业界在灾备系统的建设上一般按照以下方式：建设机房内的本地备份系统、建设异地的备份系统。该方式可以备份系统的价格满足备份和异地容灾功能，能够避免主生产中心由于地震、火灾或其他灾害造成的数据丢失。备份系统＋异地容灾系统，这是一个较为理想化的容灾系统一体化解决方案，能够在很大程度上避免各种可能的错误。</p><p>腾讯云的备端在线两地三中心灾备方案网络设计如下：</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps8.jpg" alt="img"></p><p>7.2. 容灾系统设计</p><p>备端在线容灾系统设计。当生产服务器处于正常工作状态时，把生产服务器的监控代理软件连接至服务器。当监控代理检测到主存储数据变化后，将捕获变化的数据实时的复制到备用存储上，实现了实时的复制。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps9.jpg" alt="img"></p><p>当生产服务器故障，或者存储故障导致生产系统无法正常提供业务支持时，本地容灾服务器可直接接替生产服务器工作保障业务系统的持续运行；当本地机房发生灾难时，异地机房的容灾服务器可直接接替生产服务器工作保障业务系统的持续运行。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps10.jpg" alt="img"></p><p>当生产系统恢复工作后，代理软件会继续其生产服务器的复制工作，并且在这之前会通过回切工具保障主备系统数据一致。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps11.jpg" alt="img"></p><p>异地容错的容灾系统设计。如果本地机房发生故障，将异地容灾服务器中备份的数据进行手动恢复，可以直接恢复到原生产服务器（也可恢复到新服务器）。备份存储系统保存了应用系统任意时刻的数据，恢复时可恢复到任意时间点，实现容错。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%8E%B0%E6%9C%89%E7%81%BE%E5%A4%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/wps12.jpg" alt="img"></p><p>7.3. 具体实施面临的问题</p><p>7.3.1. 分类</p><p>异地多活方案可以根据数据同步的需求分为以下三类：</p><p>l 必须同步型，比如数据库，需要实时数据同步以保证数据的一致性和完整性。</p><p>l 无须同步型，比如缓存，作为临时存储，可以容忍一定程度的数据不一致性。</p><p>l 单活型，比如对于对全局原子性要求较高的业务，如金融交易，无法接受数据同步时延带来的“不一致”窗口。</p><p>核心问题主要是：</p><p>l 数据同步：确保数据在不同机房的一致性。</p><p>l 网络时延：影响数据同步的效率和实时性。</p><p>异地多活方案的切换方式主要有两种：</p><p>l 自动切换，在灾难发生时，系统能够自动识别问题并自动切换至可用机房。</p><p>l 手动切换，通过配置，可以在几分钟或几小时内手动切换至另一机房。</p><p>7.3.2. 异地多活面临的挑战</p><p>l 切换问题，当自动切换至备用机房后，需要确保灾难机房恢复时的回切操作不会对业务造成干扰，并且要保证数据同步的完整性。这需要一个高效的数据同步机制和智能的切换策略，以确保数据不会因为回切操作而出现丢失或不一致的情况。</p><p>l 跨机房流量问题，数据在机房间同步时会产生流量，尤其在跨地域同步时，这会带来额外的成本。流量成本需要控制，跨机房流量有限且成本较高。</p><p>l 用户分区问题，为了减少跨机房流量和提高性能，需要用户分区策略将用户数据分布在不同的机房。这样做的同时，需要确保在任何一个机房发生故障时，用户仍能访问到他们的数据，并且数据的完整性得到保障。</p><p>l 业务适用性问题，随着业务数量的增加，异地多活的开发和维护成本也会随之增加。而并不是所有的业务系统都需要或适合实施异地多活方案，特别是那些对数据一致性要求极高的业务，如处理“余额”和“库存”等。</p><p>l 冷备与热备问题，热备系统能够提供即时切换和较高的数据一致性，但成本较高。冷备机房存在切换风险，长期未使用可能导致切换时出现问题，但可以降低成本。</p><p>l 数据一致性问题，在数据同步过程中，可能会出现由于网络问题、软件缺陷或操作错误导致的异常写入，这可能会引起数据不一致的问题。解决方案包括守护进程同步、客户端双写以及用户分区。</p><p>l 读取问题，为了提供更好的用户体验，需要减少读取操作的延迟解决方案包括就近读取，即将用户的读请求重定向到距离用户最近的数据中心，来减少延迟。</p><p>7.3.3. 解决方案</p><p>l 守护进程同步，通过部署守护进程来监控数据变化，并实时同步到远程机房。</p><p>l 客户端双写，在客户端层面实现数据的双写操作，即每次写入操作同时向两个机房的数据库发送，以此来保证数据的同步。</p><p>l 用户分区，通过用户分区避免数据一致性问题，但牺牲了部分双活特性。</p>]]></content>
    
    
    <summary type="html">现有灾备技术调研报告</summary>
    
    
    
    <category term="信安课程实验" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="信息系统灾备" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://shuita2333.github.io/project/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>磁盘阵列实验</title>
    <link href="https://shuita2333.github.io/project/2024/04/06/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/"/>
    <id>https://shuita2333.github.io/project/2024/04/06/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/</id>
    <published>2024-04-05T18:00:00.000Z</published>
    <updated>2024-07-10T15:30:37.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、实验要点"><a href="#一、实验要点" class="headerlink" title="*一、实验要点*"></a><em><strong>*一、实验要点*</strong></em></h1><p><em><strong>*1.RAID概念*</strong></em></p><p>RAID ( Redundant Array of Independent Disks ) ，即独立磁盘冗余阵列 &#x2F; 磁盘阵列。该技术使用多个独立的磁盘组成在一起形成一个大的磁盘组，从而实现比单块磁盘更好的存储性能和更高的可靠性。</p><p><em><strong>*2.RAID级别分类及特点*</strong></em></p><p><em><strong>*2.1. RAID 1*</strong></em></p><p>（1）RAID1模式最少需要两块硬盘，所有硬盘互为镜像，每块硬盘上存储的数据都一模一样，阵列中只要有一块硬盘损坏，数据都可以完整读出来，因此安全性非常高。</p><p>（2）但是也可以看出RAID1的写性能不如RAID0，因为数据没有分段，要同步的写入所有硬盘，写入时间以最慢的那个为准。并且硬盘利用率低，可用的容量是最小的单硬盘容量。所以RAID1适用于存储重要数据。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps1.jpg" alt="img"> </p><p><em><strong>*2.2. RAID 5*</strong></em></p><p>（1）RAID5采用奇偶校验算法对数据进行校验。</p><p>（2）RAID5的校验数据是分散存在各个硬盘里，每个硬盘里都有校验数据，当一块硬盘损坏，所有其他盘里的数据配合校验信息可以进行恢复，避免了RAID3校验盘坏了无法恢复数据的情况，并且解决了校验盘争用的问题。</p><p>（3）RAID5至少三块硬盘，以三块硬盘为例的话，每个硬盘的1&#x2F;3空间作为冗余，存放校验数据，另外2&#x2F;3空间存原始数据。</p><p>（4）RAID 5可以理解为是RAID 0和RAID 1的折中方案。RAID5的读速度与RAID0相近，写速度不如RAID0，因为每次写还要产生其校验数据。但是安全性比RAID0高，硬盘利用率比RAID1高。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps2.png" alt="img">（5）缺点：损坏两块无法恢复。</p><p><em><strong>*2.2. RAID 6*</strong></em></p><p>（1）RAID6与RAID5相比，也是将校验数据分散在硬盘里，但是增加到了两个硬盘空间存放校验数据，来解决两个盘损坏，恢复数据的问题。</p><p>（2）这导致RAID6最少需要四块硬盘才行，RAID6模式数据安全性非常高，使用不同的校验算法，计算了两个校验值，分别是P和Q，P是分层校验,与RAID5的计算原理一样，Q是总体校验，起作用相当于给数据盘加了一组线性不相关的系数，所以RAID6任意坏两块硬盘，都能实现数据完全恢复。安全性相对RAID6更高一级。</p><p>（3）但因为采用两种奇偶校验算法校验数据，校验数据量是RAID5的两倍，同时校验算法计算量也偏大，导致RAID6读写速度不及RAID5。</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps3.jpg" alt="img"> <img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps4.jpg" alt="img"><em><strong>*3.*</strong></em> <em><strong>*RAID在容灾备份中的重要性*</strong></em></p><p>容灾备份指的是一种预防性措施，旨在应对各种不可预测的灾难性事件，如自然灾害、硬件故障、人为错误等，确保系统和数据能够在灾难发生后快速恢复。容灾备份的主要意义在于保障数据的完整性、可用性和持续性。RAID作为一种数据存储技术，具有数据冗余、容错性、快速恢复的优势，在容灾备份中发挥着关键作用。</p><p>纵观RAID的一个发展过程，可以发现，从刚开始的RAID0和RAID1极端追求速度和安全，到后面的RAID2到RAID6引入校验技术逐渐权衡两者。在实际应用中，RAID0、1、5、6是比较常见的。虽然除了RAID0以外的其他RAID模式都提供了数据安全保障机制，但是RAID不能替代备份，为了数据的完全安全，仍需要备份存储在RAID上的数据。</p><h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="*二、实验环境*"></a><em><strong>*二、实验环境*</strong></em></h1><p><em><strong>*1. 操作系统：CentOS 7*</strong></em></p><p><em><strong>*2. 管理工具：Linux系统中的RAID阵列管理工具mdadm*</strong></em></p><h1 id="三、实验过程与结果"><a href="#三、实验过程与结果" class="headerlink" title="*三、实验过程与结果*"></a><em><strong>*三、实验过程与结果*</strong></em></h1><p><em><strong>*1. 磁盘分区管理*</strong></em></p><p>1.1. 在虚拟机中创建磁盘分区。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps5.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps6.jpg" alt="img"> </p><p>1.2. 磁盘分区添加完成。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps7.jpg" alt="img"> </p><p>1.3. 使用工具安装mdadm。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps8.jpg" alt="img"> </p><p>1.4. 更改磁盘分区格式为fd，并重新检查每个磁盘的当前状态。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps9.jpg" alt="img"> </p><p><em><strong>*2. RAID1实验*</strong></em></p><p>2.1. 在&#x2F;dev&#x2F;md1目录下将sdd1与sde1两块磁盘创建为RAID级别为1，磁盘数为2 的RAID1磁盘阵列，并将sdd1作为备用磁盘。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps10.jpg" alt="img"> </p><p>2.2. 查看当前RAID 1磁盘阵列状态。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps11.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps12.jpg" alt="img"> </p><p>2.3. 使用mdadm工具模拟磁盘损坏。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps13.jpg" alt="img"> </p><p>2.4. 此时再次查看RAID1阵列详细信息，发现&#x2F;dev&#x2F;sdb1磁盘已经自动替换了损坏的&#x2F;dev&#x2F;sdd1磁盘。</p><p>2.5. 等待备用磁盘自动替换损坏的磁盘，查看RAID1阵列详细信息。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps14.jpg" alt="img"> </p><p>2.6. 移除损坏的磁盘。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps15.jpg" alt="img"> </p><p>2.7. 添加新磁盘到RAID1阵列，将&#x2F;dev&#x2F;sdc1磁盘添加为RAID1阵列的备用设备，新增加的硬盘需要与原硬盘大小一致。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps16.jpg" alt="img"> </p><p>2.8. 如果原有阵列缺少工作磁盘（如RAID1只有一块在工作，RAID5只有2块在工作），这时新增加的磁盘直接变为工作磁盘，如果原有阵列工作正常，则新增加的磁盘为热备磁盘。</p><p>2.9. 取消RAID挂载，并停止阵列，之后自动删除创建阵列的目录，此时无法访问，说明暂停成功。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps17.jpg" alt="img"> </p><p><em><strong>*3. RAID5实验*</strong></em></p><p>3.1. 在&#x2F;dev&#x2F;md5目录下将sdb1、sdc1、sdd1三块磁盘创建为RAID级别为5，磁盘 数为3的RAID5磁盘阵列并将sde1作为备用磁盘。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps18.jpg" alt="img"> </p><p>3.2. 查看RAID 5阵列信息。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps19.jpg" alt="img"> </p><p>3.3. 模拟磁盘损坏，此时提示sdb1已损坏。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps20.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps21.jpg" alt="img"> </p><p>3.4. 格式化并挂载RAID5阵列。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps22.jpg" alt="img"> </p><p>3.5. 取消RAID挂载，并停止阵列。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps23.jpg" alt="img"> </p><p><em><strong>*4. RAID6实验*</strong></em></p><p>4.1. 新增两个磁盘，以创建后续RAID6阵列。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps24.jpg" alt="img"> </p><p>4.2. 在&#x2F;dev&#x2F;md6目录下将sdb1、sdc1、sdd1、sde1四块磁盘创建为RAID级别 为6，磁盘数为4的RAID6磁盘阵列并将sdf1、sdg1作为备用磁盘。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps25.jpg" alt="img"> </p><p>4.3. 查看RAID 6阵列信息。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps26.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps27.jpg" alt="img"> </p><p>4.4. 模拟两块磁盘，即sdb1和sdc1同时损坏。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps28.jpg" alt="img"> </p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps29.jpg" alt="img"> </p><p>4.5. 格式化并挂载RAID6阵列。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps30.jpg" alt="img"> </p><p>4.6. 取消RAID挂载，并停止阵列。如图所示</p><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps31.jpg" alt="img"> </p><h1 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="*四、实验总结*"></a><em><strong>*四、实验总结*</strong></em></h1><ol><li>在本实验中，我们通过使用Linux系统下的阵列管理工具成功构建了RAID1、RAID5、RAID6磁盘阵列，并详细记录了完整流程，了解到了三种磁盘阵列的灾备能力强弱区别，并且分别实现了数据恢复的过程。</li><li>在完成本实验后，我们进一步探索了其他种类的RAID阵列，不同种类之间的对比如下图所示。</li></ol><p><img src="/../../../images/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AE%9E%E9%AA%8C/wps32.jpg" alt="img"> </p><ol start="3"><li>在进行了更加全面的思考后，总的来说：RAID0和RAID1最少都需要2块磁盘，RAID0是效能和储存空间的最大化，但不注重安全性，因此比较适合放一些消失不见也没关系的档案，例如快取、或是整理档案时的暂存空间；RAID1则是安全性最大化，适合放一些重要的数据。RAID5和RAID6可以放在一起探讨，以安全性来排序由高至低为RAID6 &gt; RAID5，空间利用率则是RAID5 &gt; RAID6。综上所述，RAID5是目前综合性能最佳的数据保护解决方案，它基本上可以满足大部分的存储应用需求，数据中心大多采用它作为应用数据的保护方案。当然它们之间各有区别，有时候也需要看实际情况来决定RAID的级别。</li></ol>]]></content>
    
    
    <summary type="html">深入了解磁盘阵列原理</summary>
    
    
    
    <category term="信安课程实验" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="信息系统灾备" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%81%BE%E5%A4%87/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://shuita2333.github.io/project/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>软件安全课程笔记</title>
    <link href="https://shuita2333.github.io/project/2024/01/15/BUPT_note/Notes_on_software_security/"/>
    <id>https://shuita2333.github.io/project/2024/01/15/BUPT_note/Notes_on_software_security/</id>
    <published>2024-01-15T13:00:00.000Z</published>
    <updated>2024-07-07T08:15:42.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件安全-张淼"><a href="#软件安全-张淼" class="headerlink" title="软件安全 张淼"></a>软件安全 张淼</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h3 id="信息安全现状"><a href="#信息安全现状" class="headerlink" title="信息安全现状"></a>信息安全现状</h3><p><strong>信息安全现象</strong></p><p>➔ <strong>病毒、黑客攻击的泛滥</strong></p><p>➢数量规模大、智能程度高（技术含量）、组织方式多样化（个人、组织和集团等）</p><p>➢危害程度严重</p><p>➔ <strong>信息安全成为国家安全的重要内容</strong></p><p>➢国家领导层的意识</p><p>➢信息化建设的经验、伊战的教训</p><p>➔ <strong>关键技术受制于人</strong></p><p>➢CPU、OS</p><p>➢专利、标准</p><h3 id="信息安全威胁"><a href="#信息安全威胁" class="headerlink" title="信息安全威胁"></a><strong><strong>信息安全威胁</strong></strong></h3><p>信息安全威胁的表现：</p><p>➔ 网络协议的弱点</p><p>➔ 网络操作系统的漏洞</p><p>➔ 应用系统设计的漏洞</p><p>➔ 网络系统设计的缺陷</p><p>➔ 恶意攻击</p><p>➔ 来自合法用户的攻击</p><p>➔ 互联网的开放性</p><p>➔ 物理安全</p><p>➔ 管理安全</p><p>威胁的根源</p><p>➔ <strong>信息系统的复杂性：</strong></p><p>➢系统软硬件缺陷，网络协议的缺陷</p><p>➔ <strong>信息系统的开放性：</strong></p><p>➢系统开放：计算机及计算机通信系统是根据行业标准规定的接口建立起来的。</p><p>➢标准开放：网络运行的各层协议是开放的，并且标准的制定也是开放的。</p><p>➢业务开放：用户可以根据需要开发新的业务。</p><h2 id="问题的原因和根源"><a href="#问题的原因和根源" class="headerlink" title="问题的原因和根源"></a><strong><strong>问题的原因和根源</strong></strong></h2><h3 id="软件问题的原因"><a href="#软件问题的原因" class="headerlink" title="软件问题的原因"></a><strong><strong>软件问题的原因</strong></strong></h3><p>⚫<strong>Connectivity（互联性）</strong></p><ul><li>终端设备的互联给了攻击者有更多的机会</li><li>攻击者利用系统弱点不再需要进行物理访问</li><li>平台设计缺陷</li></ul><p>⚫<strong>Extensibility（扩展性）</strong></p><ul><li>目前很多软件技术都支持扩展技术</li><li>优点在于可以很方便的加载以及扩展新的功能与组件</li><li>问题在于扩展的功能与组件不可控，会带来未知的安全风险</li></ul><p>⚫<strong>Complexity（复杂性</strong>）</p><ul><li>软件系统代码增长速度惊人</li></ul><p>系统越复杂，Bug越难避免，质量越难保证，可能发生的安全风险越多。</p><h3 id="新的需求与传统安全技术的不足"><a href="#新的需求与传统安全技术的不足" class="headerlink" title="新的需求与传统安全技术的不足"></a><strong><strong>新的需求与传统安全技术的不足</strong></strong></h3><p>传统网络安全技术只能对网络层进行防护</p><p>无法分辨与正常应用数据混杂在一起的攻击</p><p>➔<strong>XSS</strong></p><p>➔<strong>SQL注入</strong></p><p>➔<strong>未校验参数</strong></p><p>➔<strong>etc.</strong></p><table><thead><tr><th>传统的安全模式</th><th>新的安全模式</th></tr></thead><tbody><tr><td>保护”边界”</td><td>构建安全的系统</td></tr><tr><td>网络安全</td><td>设计安全的软件</td></tr><tr><td>安全负责的人是 IT&#x2F;MIS&#x2F;CISSP等部门</td><td>软件开发人员和设计人员对安全负责</td></tr><tr><td>被动式</td><td>主动式</td></tr></tbody></table><h1 id="缓冲区溢出基础"><a href="#缓冲区溢出基础" class="headerlink" title="缓冲区溢出基础"></a>缓冲区溢出基础</h1><h2 id="缓冲区溢出概述－缓冲区溢出原理简介"><a href="#缓冲区溢出概述－缓冲区溢出原理简介" class="headerlink" title="缓冲区溢出概述－缓冲区溢出原理简介"></a>缓冲区溢出概述－缓冲区溢出原理简介</h2><p>缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量溢出的数据覆盖在合法数据上。</p><p>在初始化、拷贝或移动数据时，C语言并不自动地支持内在的数组边界检查。</p><p><strong>目前对于缓冲区溢出,主要分为静态保护和动态保护:</strong></p><p>⚫**静态保护:**不执行代码,通过静态分析来发现代码中可能存在的漏洞.静态的保护技术包括编译时加入限制条件,返回地址保护,二进制改写技术,基于源码的代码审计等.</p><p>⚫**动态保护:**通过执行代码分析程序的特性,测试是否存在漏洞,或者是保护主机上运行的程序来防止来自外部的缓冲区溢出攻击</p><h2 id="PE文件格式简介"><a href="#PE文件格式简介" class="headerlink" title="PE文件格式简介"></a>PE文件格式简介</h2><p>PE(Portable Executable)是Win32平台下可执行文件遵守的数据格式。常见的可执行文件(如“*.exe”文件和“*.dll”文件)都是典型的PE文件。</p><p>PE 文 件 格 式 把 可 执 行 文 件 分 成 若 干 个 数 据 节(section)，不通的资源被存放在不同的节中。一个典型的PE文件包含的节如下：</p><p>➔ .text 由编译器产生，存放着二进制的机器代码，也是我们反汇编和调试的对象。<br>➔ .data 初始化的数据块，如宏定义、全局变量、静态变量等。<br>➔ .idata 可执行文件所使用的动态链接库等外来函数与文件的信息。<br>➔ .rsrc 存放程序的资源，如图标、菜单等。<br>➔ 除此之外 ， 还 可 能 出 现 的 节 包 括 “.reloc” 、“.edata”、 “.tls”、 “.rdata”等。</p><p><strong>PE文件简单构成</strong></p><table><thead><tr><th>其他</th></tr></thead><tbody><tr><td>.data节</td></tr><tr><td>.rdata节</td></tr><tr><td>.text节</td></tr><tr><td>文件头、节</td></tr><tr><td>表等</td></tr></tbody></table><h2 id="虚拟内存相关知识—虚拟内存简介"><a href="#虚拟内存相关知识—虚拟内存简介" class="headerlink" title="虚拟内存相关知识—虚拟内存简介"></a>虚拟内存相关知识—虚拟内存简介</h2><p>Windows的内存可以被分为两个层面：物理内存和虚拟内存 。 其 中 ， 物理内存比较复杂 ， 需要进入Windows内核级别ring0才能看到。通常，在用户模式下，我们用调试器看到的地址都是虚拟内存。</p><p>虽然每个进程都“相信”自己拥有4GB的空间，但实际上它们运行时真正能用到的空间根本没有那么多。</p><p>内存管理器只是分给进程一片“假地址”，或者说是“虚拟地址”，它们对进程来说只是一笔“无形的数字财富”；</p><p>当需要实际的内存操作时，内存管理器才会把“虚拟地址”和“物理地址”联系起来。</p><h2 id="PE文件与虚拟内存之间的映射"><a href="#PE文件与虚拟内存之间的映射" class="headerlink" title="PE文件与虚拟内存之间的映射"></a><strong>PE文件与虚拟内存之间的映射</strong></h2><p>静态反汇编工具看到的PE文件中某条指令的位置是相对于磁盘文件而言的，即所谓的文件偏移，我们可能还需要知道这条指令在内存中所处的位置，即虚拟内存的位置</p><p>反之，在调试时看到的某条指令的地址是虚拟内存地址，我们也经常需要回到PE文件中找到这条指令对应的机器码</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>⚫ <strong>文件偏移地址(File Offset)</strong></p><p>➢数据在PE文件中的地址叫做文件偏移地址。这是文件在磁盘上存放时相对于文件开头的偏移。</p><p>⚫ <strong>装载基址(Image Base)</strong></p><p>➢PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址是0x00400000,DLL文件是0x10000000。这些位置可以通过修改编译选项更改。</p><p>⚫ <strong>虚拟内存地址(Virtual Address,VA)</strong></p><p>➢PE文件中的指令被装入内存后的地址。</p><p>⚫ <strong>相对虚拟地址(Relative Virtual Address,RVA)</strong></p><p>➢相对虚拟地址是内存地址相对于映射基址的偏移量。</p><h2 id="系统栈的工作原理—内存的不同用途"><a href="#系统栈的工作原理—内存的不同用途" class="headerlink" title="系统栈的工作原理—内存的不同用途"></a><strong><strong>系统栈的工作原理—内存的不同用途</strong></strong></h2><p>成功地利用缓冲区溢出漏洞可以修改内存中的变量的值，甚至可以劫持进程，执行恶意代码，最终获得主机的控制权。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h3><p>⚫ 通用寄存器</p><p>➔ 32位的通用寄存器有<em>EAX</em>、<em>EBX</em>、<em>ECX</em>、<em>EDX</em>、<em>ESP</em>、<em>EBP</em>、<em>ESI</em>和<em>EDL</em>，它们的使用方法不总是相同的。一些指令赋予它们特殊的功能。</p><p>⚫ 段寄存器</p><p>➔ 段寄存器被用于指向进程地址空间不同的段。</p><p>➔ <em>CS</em>指向一个代码段的开始；</p><p>➔ <em>SS</em>是一个堆栈段；</p><p>➔ <em>DS</em>、<em>ES</em>、<em>FS</em>、<em>GS</em>和各种其他数据段，例如存储静态数据的段。</p><p>⚫ 程序流控制寄存器</p><p>⚫ 其他寄存器</p><p>程序员习惯中已经默认的给每个寄存器赋上了特殊的含义，比如：</p><p>➔ EAX一般用来做返回值<br>➔ ECX用于记数<br>➔ EIP：扩展指令指针。在调用一个函数时，这个指针被存储在堆栈中，用于后面的使用。在函数返回时，这个被存储的地址被用于决定下一个将被执行的指令的地址。<br>➔ ESP：扩展堆栈指针。这个寄存器指向堆栈的当前位置，并允许通过使用push和pop操作或者直接的指针操作来对堆栈中的内容进行添加和移除。<br>➔ EBP：扩展基指针。主要用与存放在进入call以后的ESP的值，便于退出的时候回复ESP的值，达到堆栈平衡的目的</p><p>内存的4个部分和相关用途:</p><table><thead><tr><th>名称</th><th>用途</th></tr></thead><tbody><tr><td>代码区</td><td>这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指并执行。</td></tr><tr><td>数据区</td><td>用于存储全局变量等。</td></tr><tr><td>堆区</td><td>进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。</td></tr><tr><td>栈区</td><td>用于动态地存储函数之间的调用关系，以保证被调用函数在返回时恢复到父函数中继续执行。</td></tr></tbody></table><h3 id="栈与系统栈"><a href="#栈与系统栈" class="headerlink" title="栈与系统栈"></a><strong><strong>栈与系统栈</strong></strong></h3><p>从计算机科学的角度来看，栈指的是一种数据结构，是一种先进后出的数据表。栈的最常见操作有两种：压栈(PUSH)、弹栈(POP)；用于标识栈的属性也有两个：栈顶(TOP)、栈底(BASE)。</p><p>内存的栈区实际上指的就是系统栈。系统栈由系统自动维护，它用于实现高级语言中函数的调用。对 于 类 似 C 语 言 这 样 的 高 级 语 言 ， 系 统 栈 的PUSH&#x2F;POP等堆栈平衡细节是透明的。</p><table><thead><tr><th>代码空间</th><th>系统栈空间</th></tr></thead><tbody><tr><td>程序被装入，由main函数代码空间依次取指执行</td><td>系统栈 栈顶为当前正在执行的main函数栈帧</td></tr><tr><td>执行到main代码区的call指令时，跳转到funca的代码区继续执行</td><td>为配合funca的执行，在系统栈中为其开辟新的栈帧并压入</td></tr><tr><td>执行到funca代码区的call指令时，跳转到funcb的代码区继续执行</td><td></td></tr><tr><td>为配合funcb的执行，在系统栈中为其开辟新的栈帧并压入</td><td></td></tr><tr><td>funcb代码执行完毕，弹出自己的栈帧并从中获得返回地址，跳回funca代码区继续执行</td><td>弹出funcb的栈帧。对应于当前正在执行的函数，当前栈顶栈帧重新恢复成funca函数栈帧</td></tr><tr><td>funca代码执行完毕，弹出自己的栈帧并从中获得返回地址，跳回main代码区继续执行</td><td>弹出funca的栈帧。对应于当前正在执行的函数，当前栈顶栈帧重新恢复成main函数栈帧</td></tr></tbody></table><h2 id="寄存器与函数栈帧"><a href="#寄存器与函数栈帧" class="headerlink" title="寄存器与函数栈帧"></a><strong><strong>寄存器与函数栈帧</strong></strong></h2><p>（1）ESP：栈指针寄存器(extended stackpointer),其内存放着一个指针，该指针永远指向系统栈最上面的一个栈帧的栈顶。</p><p>（2）EBP：基址指针寄存器(extended basepointer),其内存放着一个指针，该指针永远指向系统栈最上面的一个栈帧的底部。</p><p>（3）EIP ：指令寄存器 (Extended InstructionPointer),其内存放着一个指针，该指针永远指向一条等待执行的指令地址。</p><p><strong>在函数栈帧中，一般包含以下几类重要信息。</strong></p><p>（1）局部变量：为函数局部变量开辟的内存空间。</p><p>（2）栈帧状态值：保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡计算得到），用于在本帧被弹出后恢复出上一个栈帧。</p><p>（3）函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令</p><p><strong>函数调用步骤</strong></p><p>（1）参数入栈：将参数从右向左一次压入系统栈中。</p><p>（2）返回地址入栈：将当前代码区调用指令的下一跳指令地址压入栈中，<br>供函数返回时继续执行。</p><p>（3）代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。</p><p>（4）栈帧调整</p><ul><li>保存当前栈帧的状态值，以备后面恢复本栈帧时使用（EBP入栈）；</li><li>将当前栈帧切换到新栈帧（将ESP值装入EBP，更新栈帧底部）；</li><li>给新栈帧分配空间（把ESP减去所需空间的大小，抬高栈帧）；</li></ul><h2 id="函数调用约定与相关指令"><a href="#函数调用约定与相关指令" class="headerlink" title="函数调用约定与相关指令"></a><strong>函数调用约定与相关指令</strong></h2><p>入栈</p><table><thead><tr><th>序列</th><th>备注</th></tr></thead><tbody><tr><td>push 参数 3</td><td>假设该函数有3个参数，将从右向左依次入栈</td></tr><tr><td>push 参数 2</td><td></td></tr><tr><td>push 参数 1</td><td></td></tr><tr><td>call 函数地址</td><td>call指令将同时完成两项工作:a)向栈中压入当前指令在内存中的位置，即保存返回地址。</td></tr><tr><td>b)跳转到所调用函数的入口地址函数入口处</td><td></td></tr><tr><td>push ebp</td><td>保存旧栈帧的底部</td></tr><tr><td>mov ebp,esp</td><td>设置新栈帧的底部(栈帧切换)</td></tr><tr><td>sub esp,xxx</td><td>sub esp,xxx 设置新栈帧的顶部(抬高栈顶，为新栈帧开辟空间）</td></tr></tbody></table><p>类似的，函数返回的步骤如下。<br>（1）保存返回值：通常将函数的返回值保存在寄存器EAX中。<br>（2）弹出当前栈帧，恢复上一个栈帧，具体包括：</p><p>在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间。</p><p>将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复上一个栈帧。</p><p>将函数返回地址弹给EIP寄存器。</p><p>（3）跳转：按照函数返回地址跳回母函数中继续执行。</p><table><thead><tr><th>指令</th><th>备注</th></tr></thead><tbody><tr><td>add esp,xxx</td><td>降低栈顶，回收当前的栈帧</td></tr><tr><td>pop ebp</td><td>将上一个栈帧底部位置恢复到ebp</td></tr><tr><td>retn</td><td>这条指令有两个功能:</td></tr><tr><td>a)弹出当前栈顶元素，即弹出栈帧中的返回地址。至此，栈帧恢复工作完成。</td><td></td></tr><tr><td>b)让处理器跳转到弹出的返回地址，恢复调用前的代码区</td><td></td></tr></tbody></table><h1 id="第三讲-字符串安全"><a href="#第三讲-字符串安全" class="headerlink" title="第三讲 字符串安全"></a><strong><strong>第三讲 字符串安全</strong></strong></h1><h2 id="C-风格的字符串"><a href="#C-风格的字符串" class="headerlink" title="C-风格的字符串"></a><strong><strong>C-风格的字符串</strong></strong></h2><p>c风格的字符串由一个连续的字符序列组成，并以一个空字符（null ）作为结束。</p><p>➔ 一个指向字符串的指针实际上就是指向该字符串的起始字符。</p><p>➔ 字符串长度指空字符之前的字节数</p><p>➔ 字符串的值则是它所包含的按顺序排列的字符序列。</p><p>➔ 存储一个字符串所需要的字节数是字符串的字符数加1。 (x 是每个字符的大小)</p><h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a><strong><strong>C++ 字符串</strong></strong></h2><p>C++的标准化促进了：</p><p>➔ <strong>标准的类模板std::basic_string</strong></p><p>➔ 及它的<strong>char</strong> 实例化 <strong>std::string</strong></p><p>➔ 相对于C风格的字符串，<strong>basic_string</strong> 类更不容易出现安全漏洞 。</p><h2 id="常见的字符串操作错误"><a href="#常见的字符串操作错误" class="headerlink" title="常见的字符串操作错误"></a><strong><strong>常见的字符串操作错误</strong></strong></h2><p>最常见的错误有<br>➢ 无界字符串复制<br>➢ 空结尾错误<br>➢ 截断<br>➢ 差－错误<br>➢ 数组写入越界<br>➢ 不恰当的数据处理</p><h2 id="无边界字符串复制"><a href="#无边界字符串复制" class="headerlink" title="无边界字符串复制"></a><strong><strong>无边界字符串复制</strong></strong></h2><p>无边界字符串复制发生于从一个无边界数据源复制数据到一个定长的字符数组时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> Password[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter 8 character password:&quot;</span>);</span><br><span class="line"><span class="built_in">gets</span>(Password);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制和连接字符串时也容易出现错误，因为标准strcpy() 和strcat() 函数执行的都是无边界复制操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> name[<span class="number">2048</span>];</span><br><span class="line"><span class="number">3.</span> <span class="built_in">strcpy</span>(name, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="number">4.</span> <span class="built_in">strcat</span>(name, <span class="string">&quot; = &quot;</span>);</span><br><span class="line"><span class="number">5.</span> <span class="built_in">strcat</span>(name, argv[<span class="number">2</span>]);</span><br><span class="line">...</span><br><span class="line"><span class="number">6.</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="简单的解决方案"><a href="#简单的解决方案" class="headerlink" title="简单的解决方案"></a><strong><strong>简单的解决方案</strong></strong></h3><p>利用strlen() 测试输入字符串的长度然后动态分配内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> *buff = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>])+<span class="number">1</span>);</span><br><span class="line"><span class="number">3.</span> <span class="keyword">if</span> (buff != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">4.</span> <span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="number">5.</span> <span class="built_in">printf</span>(<span class="string">&quot;argv[1] = %s.\n&quot;</span>, buff);</span><br><span class="line"><span class="number">6.</span> &#125;</span><br><span class="line"><span class="number">7.</span> <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Couldn&#x27;t get the memory - recover*/</span></span><br><span class="line"><span class="number">8.</span> &#125;</span><br><span class="line"><span class="number">9.</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">10.</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="C-无界字符串复制"><a href="#C-无界字符串复制" class="headerlink" title="C++无界字符串复制"></a><strong><strong>C++无界字符串复制</strong></strong></h2><p>对于下列的C＋＋程序，如果用户输入多于11个字符，也会导<br>致越界写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">3.</span> <span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line"><span class="number">4.</span> cin &gt;&gt; buf;</span><br><span class="line"><span class="number">5.</span> cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line"><span class="number">6.</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="简单的解决方案-1"><a href="#简单的解决方案-1" class="headerlink" title="简单的解决方案"></a><strong><strong>简单的解决方案</strong></strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">3.</span> <span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line"><span class="number">3.</span> cin.<span class="built_in">width</span>(<span class="number">12</span>);</span><br><span class="line"><span class="number">4.</span> cin &gt;&gt; buf;</span><br><span class="line"><span class="number">5.</span> cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line"><span class="number">6.</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="空结尾错误"><a href="#空结尾错误" class="headerlink" title="空结尾错误"></a><strong><strong>空结尾错误</strong></strong></h2><p>当使用C风格字符时，另一个常见的问题是字符串末尾没有正确的空字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> a[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> b[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> c[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(a, <span class="string">&quot;0123456789abcdef&quot;</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="built_in">strncpy</span>(b, <span class="string">&quot;0123456789abcdef&quot;</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line"><span class="built_in">strncpy</span>(c, a, <span class="built_in">sizeof</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strncpy-函数"><a href="#strncpy-函数" class="headerlink" title="strncpy 函数"></a><strong><strong>strncpy 函数</strong></strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncpy</span><span class="params">(<span class="type">char</span> * restrict s1,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">char</span> * restrict s2,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>从数组S2中复制不超过 <strong>n</strong> 个字符串 (空字符后的字符不会被复制) 到目标数组S1 *****中。</p><p>➔ *因此，如果第一个数组S2中的前n个字符中不存在空字符，那么其结果字符串将不会是以空字符结尾的。</p><h2 id="字符串截断"><a href="#字符串截断" class="headerlink" title="字符串截断"></a><strong><strong>字符串截断</strong></strong></h2><p>⚫<strong>一些限制字节数的函数通常用来防止缓冲区溢出漏洞</strong></p><p>➔ <strong>strncpy() 代替 strcpy()</strong></p><p>➔ <strong>fgets()代替 gets()</strong></p><p>➔ <strong>snprintf()代替 sprintf()</strong></p><p>⚫当目标字符数组的长度不足以容纳一个字符串的内容时，就会发生字符串截断</p><p>⚫字符串截断会丢失数据，有时也会导致软件漏洞</p><h2 id="数组写入越界"><a href="#数组写入越界" class="headerlink" title="数组写入越界"></a><strong><strong>数组写入越界</strong></strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">2.</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="number">3.</span> <span class="type">char</span> buff[<span class="number">128</span>];</span><br><span class="line"><span class="number">4.</span> <span class="type">char</span> *arg1 = argv[<span class="number">1</span>];</span><br><span class="line"><span class="number">5.</span> <span class="keyword">while</span> (arg1[i] != <span class="string">&#x27;\0&#x27;</span> ) &#123;</span><br><span class="line"><span class="number">6.</span> buff[i] = arg1[i];</span><br><span class="line"><span class="number">7.</span> i++;</span><br><span class="line"><span class="number">8.</span> &#125;</span><br><span class="line"><span class="number">9.</span> buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="number">10.</span> <span class="built_in">printf</span>(<span class="string">&quot;buff = %s\n&quot;</span>, buff);</span><br><span class="line"><span class="number">11.</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="程序栈"><a href="#程序栈" class="headerlink" title="程序栈"></a><strong><strong>程序栈</strong></strong></h2><p>⚫栈（ 栈 ）通过存储下列内容来追踪程序的执行和状态。<br>➢ 调用函数的返回地址<br>➢ 函数参数<br>➢ 局部 (临时）变量<br>⚫在下列情况下栈需要被修改<br>➢ 在函数调用期间<br>➢ 函数初始化期间<br>➢ 从子例程返回时</p><h3 id="栈粉碎"><a href="#栈粉碎" class="headerlink" title="栈粉碎"></a><strong><strong>栈粉碎</strong></strong></h3><p>⚫堆栈支持嵌套调用</p><p>⚫帧指由函数调用引发的压入栈的数据。</p><p>⚫栈用于存储</p><p>➔ 调用函数的返回地址</p><p>➔ 子例程的实际参数</p><p>➔ 局部（自动）变量</p><p>⚫当前帧的地址被存储到帧或者基址寄存器中(英特尔架构中的EBP)</p><p>⚫帧指针在栈中是一个定点的引用。</p><p>⚫下列情况出现时，栈要要被修改</p><p>➔ 子例程调用</p><p>➔ 子例程初始化</p><p>➔ 从子例程返回</p><p><strong>EIP：扩展指令指针  ESP: 扩展栈指针  EBP:扩展基指针</strong></p><h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a><strong><strong>缓冲区溢出</strong></strong></h2><p>当向为某特定数据结构分配的内存空间边界之外写入数据时， 就会发生缓冲区溢出。</p><p>➔当缓冲区溢出覆写分配给执行栈内存中的数据时，就会导致栈粉碎</p><p>➔成功的利用这个漏洞能够覆写栈返回地址，从而在目标机器中执行任意代码。</p><h2 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a><strong><strong>代码注入</strong></strong></h2><p>⚫攻击者创建一个恶意参数</p><p>➔一个蓄意构造的字符串，其中包含一个指向某些恶意代码的指针，该代码也由攻击者提供。</p><p>⚫当函数返回时，控制就被转移到了那段恶意代码。</p><p>➔注入的代码就会以与该有漏洞的程序相同的权限运行</p><p>➔攻击者通常都以“以root或其他较高权限运行”的程序为目标</p><p>⚫恶意参数的目的是把控制权转移给恶意代码</p><p>➔ 可能包含在恶意参数 (如本实例)中</p><p>➔ 可能在一个有效的输入操作期间注入恶意代码</p><p>➔ 恶意代码可以执行以其他任何形式编程所能执行的功能，</p><p>不过它们通常只是简单地在受害机器上开一个远程<strong>。</strong></p><h2 id="弧注入-return-into-libc"><a href="#弧注入-return-into-libc" class="headerlink" title="弧注入 (return-into-libc)"></a><strong><strong>弧注入 (return-into-libc)</strong></strong></h2><p>弧注入将控制转移到已经存在于程序内存空间中的代码中</p><p>➔ 弧注入的利用方式是在程序的控制流“团”中插入一段新的“弧’（表示控制流转移），而不是进行代码注入。</p><p>➔ 可以安装一个已有函数的地址（如system() 或exec ()，用于执行已存在于本地系统上的程序</p><p>➔ 更复杂的攻击可能会使用这种技术</p><h3 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a><strong><strong>缓解措施</strong></strong></h3><p>⚫缓解措施包括：</p><p>➔预防缓冲区溢出</p><p>➔侦测缓冲区溢出并安全地恢复，使得漏洞利用的企图无法得逞。</p><p>⚫防范策略</p><p>➔静态分配空间</p><p>➔动态分配空间</p><h3 id="静态方法-静态分配缓冲区"><a href="#静态方法-静态分配缓冲区" class="headerlink" title="静态方法  静态分配缓冲区"></a><strong>静态方法  静态分配缓冲区</strong></h3><p>假设一个固定大小的缓冲区</p><p>➔在缓冲区满了以后，不可能添加再数据</p><p>➔因为静态的方法丢弃了超出的数据，所以实际的程序数据会丢失。</p><p>➔因此，生成的字符串必须被充分验证</p><p><strong>输入验证</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="number">2.</span> <span class="type">char</span> buff[<span class="number">100</span>];</span><br><span class="line"><span class="number">3.</span> <span class="keyword">if</span> (<span class="built_in">strlen</span>(arg) &gt;= <span class="built_in">sizeof</span>(buff)) &#123;</span><br><span class="line"><span class="number">4.</span> <span class="built_in">abort</span>();</span><br><span class="line"><span class="number">5.</span> &#125;</span><br><span class="line"><span class="number">6.</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>strlcpy() 和 strlcat()</strong></p><p>采用一个更不容易出错的方式来复制和链接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlcpy</span><span class="params">(<span class="type">char</span> *dst,<span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlcat</span><span class="params">(<span class="type">char</span> *dst,<span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>strlcpy()</strong> 从<strong>src</strong>复制空结尾的字符串到<strong>dst</strong> (直到<strong>size</strong> 大小的字符)。</p><p><strong>strlcat()</strong> 函数把非空结尾的字符串<strong>src</strong> 连接到<strong>dst</strong>末尾 (不超过<strong>size</strong> 的字符都能够连接到dst末尾)</p><p>两个函数都确保目标字符串对所有非零长度的缓冲区来说都是<br>非空结尾的。</p><p><strong><strong>ISO&#x2F;IEC “Security” TR 24731</strong></strong></p><p>➔strcpy_s() 代替strcpy()</p><p>➔strcat_s()代替strcat()</p><p>➔strncpy_s()代替strncpy()</p><p>➔strncat_s()代替strncat()</p><h3 id="strcpy-s-函数"><a href="#strcpy-s-函数" class="headerlink" title="strcpy_s() 函数"></a><strong><strong>strcpy_s() 函数</strong></strong></h3><p>把字符从源字符串复制到目标字符数组，直到并包括终止null字<br>符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">errno_t</span> <span class="title">strcpy_s</span><span class="params">(<span class="type">char</span> * restrict s1,<span class="type">rsize_t</span> s1max,<span class="type">const</span> <span class="type">char</span> * restrict s2)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="动态方法-动态地分配缓冲区"><a href="#动态方法-动态地分配缓冲区" class="headerlink" title="动态方法  动态地分配缓冲区"></a><strong>动态方法  动态地分配缓冲区</strong></h2><p>⚫动态分配的缓冲区需要动态调整额外的内存。</p><p>⚫动态方法更好，而且不丢弃多余的数据。</p><p>⚫主要缺点是,如果输入被限制，则可能</p><p>➔耗尽机器内存</p><p>➔结果导致拒绝服务攻击</p><h3 id="防范策略"><a href="#防范策略" class="headerlink" title="防范策略"></a><strong><strong>防范策略</strong></strong></h3><p>为C提供丰富的字符串操作库，</p><p>➔ 拥有安全的语义</p><p>➔ 与遗留的库代码互操作</p><p>➔ 使用一种动态分配的方式，可以在需要时自动调整字符串的大小。</p><h3 id="safestr-t-类型"><a href="#safestr-t-类型" class="headerlink" title="safestr_t 类型"></a><strong><strong>safestr_t 类型</strong></strong></h3><p>safestr_t类型与char<em>是兼容的，并且可以将safestr_t转型为char</em>当作<br>C风格字符使用。<br> safestr_t类型保存了由该指针所引用的内存部分的说明信息（例如，<br>实际长度和分配的长度），保存子指针所指向的内存之前</p><p>⚫管理动态字符串</p><p>➔ 分配缓冲区</p><p>➔ 如果需要额外的内存，则重新调整内存大小</p><p>⚫管理字符串操作，以确保</p><p>➔ 字符串操作没有导致缓冲区溢出</p><p>➔ 数据没有丢失</p><p>➔ 字符串正常终止(字符串可能是也可能不是内部空结尾)</p><p>⚫缺点</p><p>➔ 无限制地消耗内存，可能导致拒绝服务攻击</p><p>➔ 性能开销</p><h1 id="第四讲-软件安全漏洞基础"><a href="#第四讲-软件安全漏洞基础" class="headerlink" title="第四讲 软件安全漏洞基础"></a><strong><strong>第四讲 软件安全漏洞基础</strong></strong></h1><h2 id="软件漏洞简介"><a href="#软件漏洞简介" class="headerlink" title="软件漏洞简介"></a><strong><strong>软件漏洞简介</strong></strong></h2><p>在形形色色的软件逻辑缺陷中，有一部分如果被利用能够引起非常严重的后果。</p><p>例如:SQL注入,跨站脚本,缓冲区溢出</p><p>我们通常把这类能够引起软件做一些“超出设计范围的事情”的bug称为漏洞</p><table><thead><tr><th></th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>BUG</td><td>功能性逻辑缺陷，影响软件的正常功能</td><td>执行结果错误、图标显示错误等</td></tr><tr><td>漏洞</td><td>安全性逻辑缺陷，通常情况下不影响软件的正常功能，但被攻击者成功利用后，有可能引起软件去执行额外的恶意代码</td><td>软件缓冲区溢出漏洞、网站的跨站脚本漏洞(XSS)、SQL注入漏洞等</td></tr></tbody></table><h3 id="典型的软件漏洞"><a href="#典型的软件漏洞" class="headerlink" title="典型的软件漏洞"></a><strong><strong>典型的软件漏洞</strong></strong></h3><p>缓冲区溢出漏洞：它发生的原理是，由于用户处理用户数据时使用了不限边界的拷贝，导致程序内部一些关键数据被覆盖，引发了安全问题，严重的缓冲区溢出漏洞会使得程序被利用而安装上木马或病毒</p><p>整数溢出漏洞：对于有符号的16位整数来说，它的最大值就是0x7fff，也就是十进制的32767，当赋值给一个整数的值为其最大值时，如果此时再加上1，就会发生整数型的溢出。</p><p>格式化字符串漏洞：格式化字符串漏洞是由于程序的数据输出函数中对输出数据的格式解析不当而发生的。</p><p><strong>SQL注入漏洞：</strong>通过控制传递给软件数据库操作语句 的关键变量来获得恶意控制软件数据库、获取有用信息或者制造恶意破坏的，甚至是控制用户计算机系统的漏洞，就成为”SQL注入漏洞”。</p><h3 id="软件漏洞的危害"><a href="#软件漏洞的危害" class="headerlink" title="软件漏洞的危害"></a><strong><strong>软件漏洞的危害</strong></strong></h3><p>无法正常使用,引发恶性事件,关键数据丢失,秘密信息泄漏,被安装木马病毒</p><h3 id="安全漏洞出现的原因"><a href="#安全漏洞出现的原因" class="headerlink" title="安全漏洞出现的原因"></a><strong><strong>安全漏洞出现的原因</strong></strong></h3><p>小作坊式的软件开发、赶进度带来的弊端、被轻视的软件安全测试、淡薄的安全思想、不完善的安全维护、</p><h2 id="漏洞挖掘、分析、利用简介"><a href="#漏洞挖掘、分析、利用简介" class="headerlink" title="漏洞挖掘、分析、利用简介"></a><strong><strong>漏洞挖掘、分析、利用简介</strong></strong></h2><p>⚫从技术角度讲，漏洞挖掘实际上是一种高级的测试(QA)。</p><p>⚫学术界一直热衷于使用静态分析的方法寻找源代码中的漏洞；</p><p>⚫而在工程界，不管是安全专家还是攻击者，普遍采用的漏洞挖掘方法是Fuzz，这实际是一种“灰”盒测试。</p><p>⚫当fuzz捕捉到软件一个严重的异常时，当你想透过厂商公布的简单描述了解漏洞细节的时候，我们就需要具备一定的漏洞分析能力。一般情况下，我们需要调试二进制级别的程序。</p><h2 id="PE文件格式简介-1"><a href="#PE文件格式简介-1" class="headerlink" title="PE文件格式简介"></a><strong><strong>PE文件格式简介</strong></strong></h2><p>PE(Portable Executable)是Win32平台下可执行文件遵守的数据格式。常见的可执行文件(如“*.exe”文件和“*.dll”文件)都是典型的PE文件。</p><p>PE 文 件 格 式 把 可 执 行 文 件 分 成 若 干 个 数 据 节(section)，不通的资源被存放在不同的节中。一个典型的PE文件包含的节如下：</p><table><thead><tr><th>DOS头</th></tr></thead><tbody><tr><td>PE签名</td></tr><tr><td>PE头文件</td></tr><tr><td>PE可选头</td></tr><tr><td>节表</td></tr><tr><td>.idata节</td></tr><tr><td>.text节</td></tr><tr><td>.data节</td></tr></tbody></table><h2 id="虚拟内存相关知识"><a href="#虚拟内存相关知识" class="headerlink" title="虚拟内存相关知识"></a><strong>虚拟内存相关知识</strong></h2><h3 id="PE文件与虚拟内存之间的映射-1"><a href="#PE文件与虚拟内存之间的映射-1" class="headerlink" title="PE文件与虚拟内存之间的映射"></a><strong>PE文件与虚拟内存之间的映射</strong></h3><p>⚫ <strong>文件偏移地址(File Offset)</strong></p><p>➢数据在PE文件中的地址叫做文件偏移地址。这是文件在磁盘上存放时相对于文件开头的偏移。</p><p>⚫ <strong>装载基址(Image Base)</strong></p><p>➢PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址是0x00400000,DLL文件是0x10000000。这些位置可以通过修改编译选项更改</p><p>⚫ <strong>虚拟内存地址(Virtual Address,VA)</strong></p><p>➢PE文件中的指令被装入内存后的地址。</p><p>⚫ <strong>相对虚拟地址(Relative Virtual Address,RVA)</strong></p><p>➢相对虚拟地址是内存地址相对于映射基址的偏移量。</p><p>➔ <strong>虚拟内存地址、映射基址、相对虚拟内存地址三</strong>者有如下关系 VA&#x3D;Image Base + RVA</p><h1 id="第五讲-漏洞利用技术"><a href="#第五讲-漏洞利用技术" class="headerlink" title="第五讲 漏洞利用技术"></a><strong><strong>第五讲 漏洞利用技术</strong></strong></h1><h2 id="shellcode概述"><a href="#shellcode概述" class="headerlink" title="shellcode概述"></a><strong><strong>shellcode概述</strong></strong></h2><h3 id="淹没返回地址"><a href="#淹没返回地址" class="headerlink" title="淹没返回地址"></a><strong><strong>淹没返回地址</strong></strong></h3><p>buffer[0-3]<br>buffer[4-7]<br>authenticated          左侧是变量的 排列顺序图<br>EBP<br>返回地址<br>观察一下我们发现我们只需要先放置16个字符串，然后接下来<br>的4个字节就能够淹没返回地址，达到控制返回地址的目的</p><h3 id="栈帧移位与jmp-esp"><a href="#栈帧移位与jmp-esp" class="headerlink" title="栈帧移位与jmp esp"></a><strong><strong>栈帧移位与jmp esp</strong></strong></h3><p>一般情况下，ESP寄存器中的地址总是指向系统栈中，且不会被溢出的数据破坏。函数返回时，ESP所指的位置恰好是我们所淹没的返回地址的下一个位置</p><h3 id="获取“跳板”的地址"><a href="#获取“跳板”的地址" class="headerlink" title="获取“跳板”的地址"></a><strong><strong>获取“跳板”的地址</strong></strong></h3><p>在利用跳板之前，我们必须在进程空间中找到一条jmp esp指令的地址作为“跳板”。除了PE文件的代码被读入内存空间，一些经常被用到的动态链接库也将会一同被映射到内存 。 其 中 ， 注 入kernel32.dll,user32.dll之类的动态链接库几乎会被所有的进程加载，且加载基址始终相同。</p><h2 id="缓冲区的组织"><a href="#缓冲区的组织" class="headerlink" title="缓冲区的组织"></a><strong><strong>缓冲区的组织</strong></strong></h2><p>填充物:可以是任何值，但是一般用NOP指令对应的0x90来进行填充，这样只要能跳进填充区，处理器最终也能顺序执行到shellcode。</p><p>淹没返回地址的数据：可以是跳转指令的地址，shellcode的起始地址，或者近似的shellcode地址（跳转进NOP填充区）</p><p>shellcode:可执行的机器代码。</p><h1 id="第六讲-漏洞挖掘与模糊测试"><a href="#第六讲-漏洞挖掘与模糊测试" class="headerlink" title="第六讲 漏洞挖掘与模糊测试"></a><strong><strong>第六讲 漏洞挖掘与模糊测试</strong></strong></h1><h2 id="漏洞挖掘技术简介"><a href="#漏洞挖掘技术简介" class="headerlink" title="漏洞挖掘技术简介"></a><strong><strong>漏洞挖掘技术简介</strong></strong></h2><p>工业界目前普遍采用的是进行Fuzz测试，与基于功能性的测试有所不同，Fuzz的主要目的是”崩溃crash”,”中断break”,”销毁destroy”。</p><p>Fuzz的测试用例往往是带有攻击性的畸形数据，用以触发各种类型的漏洞。<br>我们可以把Fuzz理解成为一种能自动进行”rough attack”尝试的工具。之所以说它是”rough attack”,是因为Fuzz往往可以触发一个缓冲区溢出的漏洞，但却不能实现有效的exploit。<br>测试人员需要实时地捕捉目标程序抛出的异常、发生的崩溃和寄存器等信息，综合判断这些错误是不是真正的可利用漏洞</p><h3 id="动态测试技术与静态代码审计的对比"><a href="#动态测试技术与静态代码审计的对比" class="headerlink" title="动态测试技术与静态代码审计的对比"></a><strong>动态测试技术与静态代码审计的对比</strong></h3><table><thead><tr><th></th><th>动态测试技术</th><th>静态代码审计</th></tr></thead><tbody><tr><td>主要技术</td><td>Fuzz等黑盒测试</td><td>数据流分析、类型验证系统、边界检验系统、状态机系统等</td></tr><tr><td>主要应用人群</td><td>攻击者</td><td>学者、QA工程师</td></tr><tr><td>优点</td><td>快捷，准确</td><td>检测出的漏洞数量多</td></tr><tr><td>缺点</td><td>不能发现系统里全部（或者大部分）漏洞</td><td>实现静态代码分析工具相当困难</td></tr></tbody></table><h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h3><p>Fuzz的测试用例往往是带有攻击性的畸形数据，用以触发各种类型的漏洞。<br>我们可以把Fuzz理解成为一种能自动进行”rough attack”尝试的工具。之所以说它是”rough attack”,是因为Fuzz往往可以触发一个缓冲区溢出的漏洞，但却不能实现有效的exploit。</p><p>Fuzz的测试优点是很少出现误报，能够迅速地找到真正的漏洞；缺点是Fuzz永远不能保证系统里已经没漏洞。</p><h2 id="文件类型漏洞挖掘—文件格式Fuzz的基本方法"><a href="#文件类型漏洞挖掘—文件格式Fuzz的基本方法" class="headerlink" title="文件类型漏洞挖掘—文件格式Fuzz的基本方法"></a><strong>文件类型漏洞挖掘—文件格式Fuzz的基本方法</strong></h2><p>不管IE还是OFFICE，它们都有一个共同点，那就是用文件作为程序的主要输入。从本质上来说，这些软件都是按照事先约定好的数据结构对文件中不同的数据域进行解析，以决定用什么颜色、在什么位置显示这些数据。<br>假如我们习惯了这样的思维，也就是假设他们所使用的文件是严格遵守软件规定的数据格式的。因为用Word生成的doc文件一般不会存在什么非法数据。<br>文件格式Fuzz就是利用这种“畸形文件”测试软件的方法。我们可以在网上找到很多FileFuzz的工具。</p><p><strong>一个File Fuzz工具通常包括以下几个步骤：</strong></p><p>(1)以一个正常的文件模板作为基础，按照一定规则产生一批畸形文件。<br>(2)将畸形文件逐一送入软件进行解析，并监视软件是否会抛出异常<br>(3)记录软件产生的错误信息，如寄存器状态、栈状态等。<br>(4)用日志或其他UI形式向测试人员展示异常信息，以进一步鉴定这些错误是否能被利用</p><blockquote><p><strong>Blind Fuzz</strong>即通常所说的“盲测”，就是在随机位置插入随机的数据以生成畸形文件。然而现代软件往往使用非常复杂的私有数据结构。</p></blockquote><blockquote><p>针对Blind Fuzz的不足，<strong>Smart Fuzz</strong>被越来越多地提出和应用。通常Smart Fuzz包括三方面的特征：<br>面向逻辑(Logic Oriented Fuzzing)<br>面向数据类型(Data Type Oriented Fuzzing)<br>基于样本(Sample Based Fuzzing)</p></blockquote><p><strong>面向数据类型测试：</strong>测试中可以生成的数据通常包括以下几种类型。</p><p>1）算术型：包括以HEX、ASCII、Unicode、Raw格式存在的各种数值。</p><p>2）指针型：包括Null指针、合法&#x2F;非法的内存指针等。</p><p>3）字符串型：包括超长字符串、缺少终止符(0x00)的字符串等。</p><p>4）特殊字符：包括#，@，’，&lt;,&gt;,&#x2F;,,..&#x2F;等等。</p><h1 id="第七讲-指针安全"><a href="#第七讲-指针安全" class="headerlink" title="第七讲 指针安全"></a><strong><strong>第七讲 指针安全</strong></strong></h1><h2 id="缓冲区溢出覆写指针条件："><a href="#缓冲区溢出覆写指针条件：" class="headerlink" title="缓冲区溢出覆写指针条件："></a>缓冲区溢出覆写指针条件：</h2><p>➔ 缓冲区与目标指针必须分配在同一个段内</p><p>➔ 缓冲区必须位于比目标指针更低的内存地址处</p><p>➔ 该缓冲区必须是界限不充分的，因此容易被缓冲区溢出利用</p><h2 id="虚函数攻击"><a href="#虚函数攻击" class="headerlink" title="虚函数攻击"></a><strong><strong>虚函数攻击</strong></strong></h2><p>多态是面向对象的一个重要特性，在C++中，这个特性主要靠对虚函数的动态调用来实现。</p><p>在仅仅关注漏洞利用的前提下，我们可以简单地把虚函数和虚表理解为一下几个要点。</p><p>1）C++类的成员函数在声明时，若使用关键字virtual进行修饰，则被称为虚函数</p><p>2）一个类中可能有很多个虚函数。</p><p>3）虚函数的入口地址被统一保存在虚表(Vtable)中。</p><p>4）对象在使用虚函数时，先通过虚表指针找到虚表，然后从虚表中取出最终的函数入口地址进行调用。</p><p>5）虚表指针保存在对象的内存空间中，紧接着虚表指针的是其他成员变量。</p><p>6）虚函数只有通过对象指针的引用才能显示出其动态调用的特性</p><h2 id="SEH攻击"><a href="#SEH攻击" class="headerlink" title="SEH攻击"></a><strong>SEH攻击</strong></h2><p>1）S.E.H结构体存放在系统栈中。</p><p>2）当线程初始化时，会自动向栈中安装一个S.E.H，作为线程默认的异常处理。</p><p>3）如果程序源代码中使用了__try{}__except{}或者Assert宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个S.E.H来实现异常处理。</p><p>4）栈中一般会同时存在多个S.E.H</p><p>5）栈中的多个S.E.H通过链表指针在栈内由栈顶向栈底串成单向链表，位于链表最顶端的S.E.H通过T.E.B(线程环境块)0字节偏移处的指针标识。</p><p>6）当异常发生时，操作系统会中断程序，并首先从T.E.B的0字节偏移处取出距离栈顶最近的S.E.H，使用异常处理函数句柄所指向的代码来处理异常。</p><p>7）当离“事故现场”最近的异常处理函数运行失败时，将顺着S.E.H链表依次尝试其他的异常处理函数。</p><p>8）如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通常，这个函数会弹出一个对话框，然后强制关闭程序</p><blockquote><p>首先，S.E.H存放在栈内，我们学过的栈溢出漏洞可能会派上用场。<br>其次，我们可以精心制造出溢出数据来把S.E.H的异常处理的函数地址替换为shellcode的起始地址。<br>再次，溢出后错误的栈帧或堆块数据往往会触发异常，或者我们能查到哪些能触发异常的片段。<br>最后，当Windows开始处理溢出后的异常时，会把hellcode当作异常函数来处理异常。</p></blockquote><h1 id="第八讲-格式化输出"><a href="#第八讲-格式化输出" class="headerlink" title="第八讲 格式化输出"></a><strong>第八讲 格式化输出</strong></h1><p><strong>格式化输出函数参数由一个格式字符串和可变数目的参数构成</strong></p><p>➔格式化字符串提供了一组可以由格式化输出函数解释执行的指令<br>➔用户可以通过控制格式字符串的内容来控制格式化输出函数的执行</p><p><strong>变参函数在C语言中实现的局限性导致格式化输出函数的使用中容易产生漏洞！</strong></p>]]></content>
    
    
    <summary type="html">软件安全的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://shuita2333.github.io/project/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://shuita2333.github.io/project/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>信息系统安全课程笔记</title>
    <link href="https://shuita2333.github.io/project/2024/01/14/BUPT_note/Notes_on_Information_System_Security/"/>
    <id>https://shuita2333.github.io/project/2024/01/14/BUPT_note/Notes_on_Information_System_Security/</id>
    <published>2024-01-14T13:00:00.000Z</published>
    <updated>2024-07-07T08:14:59.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息系统安全"><a href="#信息系统安全" class="headerlink" title="信息系统安全"></a>信息系统安全</h1><h1 id="信息系统发展趋势（自学）"><a href="#信息系统发展趋势（自学）" class="headerlink" title="信息系统发展趋势（自学）"></a>信息系统发展趋势（自学）</h1><h1 id="第一讲-信息系统概述"><a href="#第一讲-信息系统概述" class="headerlink" title="第一讲  信息系统概述"></a>第一讲  信息系统概述</h1><h2 id="信息系统架构"><a href="#信息系统架构" class="headerlink" title="信息系统架构"></a>信息系统架构</h2><h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a><strong><strong>单机架构</strong></strong></h3><p>在网站开设初期，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。</p><h3 id="第一次演进：Tomcat与数据库分开部署"><a href="#第一次演进：Tomcat与数据库分开部署" class="headerlink" title="第一次演进：Tomcat与数据库分开部署"></a><strong><strong>第一次演进：Tomcat与数据库分开部署</strong></strong></h3><p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能</p><h3 id="第二次演进：引入本地缓存和分布式缓存"><a href="#第二次演进：引入本地缓存和分布式缓存" class="headerlink" title="第二次演进：引入本地缓存和分布式缓存"></a><strong><strong>第二次演进：引入本地缓存和分布式缓存</strong></strong></h3><p>在Tomcat服务器增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的HTML页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力</p><h3 id="第三次演进：引入反向代理实现负载均衡"><a href="#第三次演进：引入反向代理实现负载均衡" class="headerlink" title="第三次演进：引入反向代理实现负载均衡"></a><strong><strong>第三次演进：引入反向代理实现负载均衡</strong></strong></h3><p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发</p><h3 id="第四次演进：数据库读、写分离"><a href="#第四次演进：数据库读、写分离" class="headerlink" title="第四次演进：数据库读、写分离"></a><strong><strong>第四次演进：数据库读、写分离</strong></strong></h3><p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据</p><h3 id="第五次演进：数据库按业务分库"><a href="#第五次演进：数据库按业务分库" class="headerlink" title="第五次演进：数据库按业务分库"></a><strong><strong>第五次演进：数据库按业务分库</strong></strong></h3><p>把不同业务的数据保存到不同的数据库中，降低业务之间的资源竞争，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决</p><h3 id="第六次演进：把大表拆分为小表"><a href="#第六次演进：把大表拆分为小表" class="headerlink" title="第六次演进：把大表拆分为小表"></a><strong><strong>第六次演进：把大表拆分为小表</strong></strong></h3><p>这种做法显著增加了数据库运维的难度，对DBA的要求较高!!!</p><p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀地分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能</p><h3 id="第七次演进：使用LVS或F5使多个Nginx负载均衡"><a href="#第七次演进：使用LVS或F5使多个Nginx负载均衡" class="headerlink" title="第七次演进：使用LVS或F5使多个Nginx负载均衡"></a><strong><strong>第七次演进：使用LVS或F5使多个Nginx负载均衡</strong></strong></h3><p>LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。</p><h3 id="第八次演进：通过DNS轮询实现机房间的负载均衡"><a href="#第八次演进：通过DNS轮询实现机房间的负载均衡" class="headerlink" title="第八次演进：通过DNS轮询实现机房间的负载均衡"></a><strong><strong>第八次演进：通过DNS轮询实现机房间的负载均衡</strong></strong></h3><p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href="http://www.taobao.com时,dns服务器会使用轮询策略或其他策略,来选择某个ip供用户访问/">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问</a></p><h3 id="第九次演进：引入NoSQL数据库和搜索引擎等技术"><a href="#第九次演进：引入NoSQL数据库和搜索引擎等技术" class="headerlink" title="第九次演进：引入NoSQL数据库和搜索引擎等技术"></a><strong><strong>第九次演进：引入NoSQL数据库和搜索引擎等技术</strong></strong></h3><p>针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key&#x2F;value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决</p><h3 id="第十次演进：大应用拆分为小应用"><a href="#第十次演进：大应用拆分为小应用" class="headerlink" title="第十次演进：大应用拆分为小应用"></a><strong><strong>第十次演进：大应用拆分为小应用</strong></strong></h3><p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决</p><h3 id="第十一次演进：复用的功能抽离成微服务"><a href="#第十一次演进：复用的功能抽离成微服务" class="headerlink" title="第十一次演进：复用的功能抽离成微服务"></a><strong><strong>第十一次演进：复用的功能抽离成微服务</strong></strong></h3><p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理</p><h3 id="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"><a href="#第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异" class="headerlink" title="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"></a><strong><strong>第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异</strong></strong></h3><p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong><strong>架构</strong></strong></h2><p>架构（architecture）是针对某种特定目标系统的普遍性</p><p>问题而提供的具有体系性质的、通用的解决方案，是对复</p><p>杂系统的一种共性的体系抽象，目的是帮助人们能够正确、</p><p>合理地理解、设计和最终构建复杂的系统。</p><h3 id="信息系统体系架构分析的必要性：系统的复杂度"><a href="#信息系统体系架构分析的必要性：系统的复杂度" class="headerlink" title="信息系统体系架构分析的必要性：系统的复杂度"></a><strong><strong>信息系统体系架构分析的必要性：系统的复杂度</strong></strong></h3><p>从系统分析方法论的角度看，如果一个系统过于复杂，则对其进行分析的最好方法就是按照某种角度对整个系统进行<strong>解构</strong>。</p><h1 id="第二讲-信息系统安全概述"><a href="#第二讲-信息系统安全概述" class="headerlink" title="第二讲 信息系统安全概述"></a>第二讲 信息系统安全概述</h1><p>攻击致命度：攻击所具有的固话危害程度</p><p>描述网络威胁信息的结构化语言：STIX（结构化威胁信息表达式）</p><h2 id="信息系统的脆弱性"><a href="#信息系统的脆弱性" class="headerlink" title="信息系统的脆弱性"></a>信息系统的脆弱性</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>硬件电路也可以设计后门（在电容器累计电荷，触发操作）</p><p><strong>Intel AMT存在高危漏洞</strong></p><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>软件问题漏洞来自于软件的复杂性</p><h3 id="攻防不对称性"><a href="#攻防不对称性" class="headerlink" title="攻防不对称性"></a><strong><strong>攻防不对称性</strong></strong></h3><table><thead><tr><th>攻击可以在任意时刻发起</th><th>防御必须随时警惕</th></tr></thead><tbody><tr><td>攻击可以选择一个薄弱点进行</td><td>防御必须全线设防</td></tr><tr><td>攻击包含了对未知缺陷的探测</td><td>防御只能对已知的攻击防御</td></tr><tr><td>攻击常在暗处，具隐蔽性</td><td>防御常在明处，表面看起来完美，使人容易疏忽，丧失警惕</td></tr><tr><td>攻击可以肆意进行</td><td>防御必须遵循一定的规则</td></tr></tbody></table><ul><li>网络是个整体，攻击可以从任何一个薄弱点发起</li><li>网络攻击已自动化和智能化</li><li>安全响应速度要求越来越快，但面对海量安全事件，人力无法及时有效地分析处理</li></ul><h2 id="网络切片带来的安全挑战"><a href="#网络切片带来的安全挑战" class="headerlink" title="网络切片带来的安全挑战"></a><strong><strong>网络切片带来的安全挑战</strong></strong></h2><p>网络切片对网络构建带来了一定的挑战，需要考虑以下安全需求：</p><ul><li>切片授权与接入控制</li><li>切片间的资源冲突</li><li>切片间的安全隔离</li><li>切片用户的隐私保护</li><li>以切片方式隔离故障网元</li></ul><h2 id="信息系统安全实现"><a href="#信息系统安全实现" class="headerlink" title="信息系统安全实现"></a><strong><strong>信息系统安全实现</strong></strong></h2><p>信息系统安全保障是在信息系统的整个生命周期中，通过对信息系统的风险分析，制定并执行相应的安全保障策略，从技术、管理、工程和人员等方面提出安全保障要求，确保信息系统的保密性、完整性和可用性，降低安全风险到可接受的程度，从而保障系统实现组织机构的使命</p><h2 id="信息系统安全保障模型⎯⎯CMM框架"><a href="#信息系统安全保障模型⎯⎯CMM框架" class="headerlink" title="信息系统安全保障模型⎯⎯CMM框架"></a><strong><strong>信息系统安全保障模型⎯⎯CMM框架</strong></strong></h2><p>第一能力级别0：未实施<br>第二能力级别1：基本执行<br>第三能力级别2：计划跟踪<br>第四能力级别3：充分定义<br>第五能力级别4：量化控制<br>第六能力级别5：持续改进</p><h2 id="信息系统安全的理解"><a href="#信息系统安全的理解" class="headerlink" title="信息系统安全的理解"></a><strong><strong>信息系统安全的理解</strong></strong></h2><p>信息网络的硬件、软件及其系统中的数据受到保护，不受偶然的或者恶意的原因而遭到破坏、更改、泄露，系统连续可靠正常地运行，信息服务不中断。</p><h3 id="信息系统安全的实质"><a href="#信息系统安全的实质" class="headerlink" title="信息系统安全的实质"></a><strong><strong>信息系统安全的实质</strong></strong></h3><p><strong><strong>安全＝及时的检测和处理</strong></strong></p><p>$$<br>P_t&gt;Dt+R_t<br>$$</p><p>防护时间<em>Pt</em>：黑客在到达攻击目标之前需要攻破很多的设备（路由器，交换机）、系统（NT，UNIX）和防火墙等障碍，在黑客达到目标之前的时间</p><p>在黑客攻击过程中，我们检测到他的活动的所用时间称之为<em>Dt</em>，检测到黑客的行为后，我们需要作出响应，这段时间称之为<em>Rt</em>.</p><h2 id="应对威胁的方式——拟态主动防御"><a href="#应对威胁的方式——拟态主动防御" class="headerlink" title="应对威胁的方式——拟态主动防御"></a><strong><strong>应对威胁的方式——拟态主动防御</strong></strong></h2><h3 id="拟态路由器"><a href="#拟态路由器" class="headerlink" title="拟态路由器"></a><strong><strong>拟态路由器</strong></strong></h3><p>拟态路由器在其架构中引入多个异构冗余的路由执行体，通过对各个执行体维护的路由表项进行共识裁决，生成拟态路由器的路由表；通过对执行体的策略调度，可以实现拟态路由器对外呈现特征的不确定变化。在满足一定差异化设计的前提下，不同的执行体存在完全相同漏洞或后门的概率极低，攻击者即使控制了部分执行体，其恶意行为也很容易被拟态裁决机制所阻断，从而极大地提高路由器应对网络攻击的能力。</p><h3 id="拟态域名服务器"><a href="#拟态域名服务器" class="headerlink" title="拟态域名服务器"></a><strong>拟态域名服务器</strong></h3><p>拟态域名服务器以遏制域名解析服务漏洞后门的可利用性、建立内生安全防御机制、大幅提高攻击者的攻击难度和代价为出发点，可以在不改变现有域名协议和地址解析设施的基础上，通过拟态防御设备的增量部署，能够有效防御针对域名系统的域名投毒、域名劫持攻击等各种已知和未知域名攻击，能够提供安全可靠的域名解析服务。</p><h3 id="拟态Web虚拟机"><a href="#拟态Web虚拟机" class="headerlink" title="拟态Web虚拟机"></a><strong>拟态Web虚拟机</strong></h3><p>拟态Web虚拟机利用云平台部署空间上的优势，构建功能等价、多样化、动态化的异构虚拟web服务器池，采用动态执行体调度、数据库指令异构化、多余度（共识）表决等技术，建立多维动态变换的运行空间，阻断攻击链，大幅增加传统web服务和虚拟环境中的漏洞及后门利用难度，在不影响web服务性能的前提下，保证服务功能的安全可信</p><h3 id="拟态云服务器"><a href="#拟态云服务器" class="headerlink" title="拟态云服务器"></a><strong>拟态云服务器</strong></h3><p>拟态化的云服务器通过构建功能等价的异构云服务器池的方法，采用动态执行体调度、多余度（共识）表决、异常发现、线上（下）清洗等技术，及时阻断基于执行体软硬件漏洞后门等的“差模”攻击，使得蓄意攻击难以奏效。</p><h3 id="拟态防火墙"><a href="#拟态防火墙" class="headerlink" title="拟态防火墙"></a><strong>拟态防火墙</strong></h3><p>拟态化的云服务器通过构建功能等价的异构云服务器池的方法，采用动态执行体调度、多余度（共识）表决、异常发现、线上（下）清洗等技术，及时阻断基于执行体软硬件漏洞后门等的“差模”攻击，使得蓄意攻击难以奏效</p><h1 id="第三讲-安全需求及安全策略"><a href="#第三讲-安全需求及安全策略" class="headerlink" title="第三讲 安全需求及安全策略"></a><strong>第三讲 安全需求及安全策略</strong></h1><h2 id="安全需求的定义"><a href="#安全需求的定义" class="headerlink" title="安全需求的定义"></a><strong><strong>安全需求的定义</strong></strong></h2><p><strong>安全需求</strong>就是在设计一个安全系统时<strong>期望得到的安全保障</strong></p><h3 id="一般性的安全需求"><a href="#一般性的安全需求" class="headerlink" title="一般性的安全需求"></a><strong><strong>一般性的安全需求</strong></strong></h3><ul><li><strong>机密性需求</strong>，防止信息被泄漏给未授权的用户</li><li><strong>完整性需求，</strong>防止未授权用户对信息的修改</li><li><strong>可用性需求，</strong>保证授权用户对系统信息的可访问性</li><li><strong>可记账性需求，</strong>防止用户对访问过某信息或执行过某一操作以否认</li></ul><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a><strong><strong>安全策略</strong></strong></h2><p>针对面临的威胁决定采用何种对策的方法</p><ul><li>安全策略为针对威胁而选择和实行对策提供了框架</li></ul><h2 id="最常用的安全策略"><a href="#最常用的安全策略" class="headerlink" title="最常用的安全策略"></a><strong><strong>最常用的安全策略</strong></strong></h2><p><strong><strong>访问控制策略</strong></strong></p><p>系统必须选择下列三类相关属性制定访问控制策略</p><p>➢<strong>主体属性</strong></p><p>主体是系统内行为的发起者，通常是用户发起的进程</p><ul><li>信息的访问者（用户）</li><li>信息的拥有者</li><li>系统管理员</li></ul><p>➢<strong>客体属性</strong></p><p>➢<strong>系统环境（上下文）</strong></p><h2 id="自主访问控制策略"><a href="#自主访问控制策略" class="headerlink" title="自主访问控制策略"></a><strong><strong>自主访问控制策略</strong></strong></h2><p>❖ 自主访问控制的优点</p><p>➢ 访问模式设定灵活。</p><ul><li>读；写；执行；“每隔一周的周五可以读”；“读完文件x后才能</li></ul><p>读此文件”等等</p><p>➢ 具有较好的适应性，常用与商用OS和应用中</p><p>❖ 自主访问控制的缺点</p><p>➢ 不能防范木马和某些形式的恶意代码。</p><h2 id="强制访问控制策略"><a href="#强制访问控制策略" class="headerlink" title="强制访问控制策略"></a><strong><strong>强制访问控制策略</strong></strong></h2><h3 id="Bell-LaPadula模型"><a href="#Bell-LaPadula模型" class="headerlink" title="Bell-LaPadula模型"></a><strong><strong>Bell-LaPadula模型</strong></strong></h3><p><strong>公开 受限 秘密 机密 高密</strong></p><p>BLP 保密模型基于两种规则来保障数据的机密度与敏感度：</p><p>➢ 不上读（NRU）⎯⎯主体不可读安全级别高于它的数据</p><p>➢ 不下写（NWD）⎯⎯主体不可写安全级别低于它的数据</p><p><strong>BLP</strong>模型允许用户读取安全级别比他低的资源；相反地，写入对象的安全级别只能高于用户级别。</p><h3 id="防火墙所实现的单向访问机制"><a href="#防火墙所实现的单向访问机制" class="headerlink" title="防火墙所实现的单向访问机制"></a><strong>防火墙所实现的单向访问机制</strong></h3><p>防火墙所实现的单向访问机制不允许敏感数据从内部网络（例：其安全级别为“机密”）流向Internet（安全级别为“公开”）。</p><p>➢ 防火墙提供“不上读”功能来阻止Internet对内部网络的访问；</p><p>➢ 提供“不下写”功能来限制进入内部的数据流只能经由由内向外发起的连接流入（例如，允许HTTP的“GET”操作而拒绝“POST”操作，或阻止任何外发的邮件）。</p><h3 id="BIBA完整性模型"><a href="#BIBA完整性模型" class="headerlink" title="BIBA完整性模型"></a><strong>BIBA完整性模型</strong></h3><p>BIBA模型基于两种规则来保障数据的完整性的保密性：</p><p>➢ <strong>不下读（NRU）属性主体不能读取安全级别低于它的数据</strong></p><p>➢ <strong>不上写（NWD）属性主体不能写入安全级别高于它的数据</strong></p><h2 id="强制访问控制策略-1"><a href="#强制访问控制策略-1" class="headerlink" title="强制访问控制策略"></a><strong>强制访问控制策略</strong></h2><p>❖ <strong>最显著的特征</strong>：全局性和永久性</p><p>➢ 无论何时何地，主体和客体的标签是不会改变的。</p><p>➢ <strong>全局性</strong>：对特定的信息，从任何地方访问，它的敏感级别相同</p><p>➢ <strong>永久性</strong>：对特定的信息，在任何时间访问，它的敏感级别相同</p><p>➢ 上述特征在多级安全体系中称为“<strong>宁静性原则</strong>”（tranquility）</p><p>❖ 一旦不满足该原则，无法从根本上防备木马和恶意代码</p><h2 id="SSR安全模型"><a href="#SSR安全模型" class="headerlink" title="SSR安全模型"></a><strong><strong>SSR安全模型</strong></strong></h2><ol><li>当标签级别为“中级别”的主体访问标签级别为“高级别”的客体时，主体对客体无任何访问权限(no read up, no write up）。</li><li>当标签级别为“中级别”的主体访问标签级别为“中级别”的客体时，主体对客体持所有权限。</li><li>当标签级别为“中级别”的主体访问标签级别为“低级别”的客体时，主体对客体拥有只读权限（nowrite down）。</li></ol><p><strong>SSR安全模型的主要特点</strong></p><ol><li><p>信息流只能从低级别流向高级，确保的信息的保密性。</p></li><li><p>高级别主体对低级别客体的访问只能进行读取，确保了低级别资源的完整性</p></li></ol><h3 id="主体颗粒度扩充"><a href="#主体颗粒度扩充" class="headerlink" title="主体颗粒度扩充"></a><strong>主体颗粒度扩充</strong></h3><p>主体颗粒度扩充主要是把主体的颗粒度从用户级别扩充到进程级别，扩充的目的是为了实现更加细化的安全策略以保证信息系统的安全。</p><h3 id="SSR安全模型的应用"><a href="#SSR安全模型的应用" class="headerlink" title="SSR安全模型的应用"></a><strong><strong>SSR安全模型的应用</strong></strong></h3><p><strong>涉密系统方案</strong></p><p>通过应用SSR安全模型，信息流只能从低级别流向高级别，而不能往下，即使某一级别的用户受到病毒感染或者黑客渗透，其也只能感染和阅读自己的信息与读取下级的信息，确保了保密性。高权限用户无法篡改低权限用户的文件，保证了文件的完整性，避免了官大压人的现象，可以保证递交文件的真实可靠。</p><p><strong>病毒防治方案</strong></p><p>信息的访问需要程序，因此程序往往是被攻击对象，攻击了程序就可以访问其对应的文件甚至其他程序的文件。应用SSR安全模型以后，把主体颗粒度扩充到进程，让程序与程序需要文件进行绑定，然后再将程序本身进行只读保护，既能保证程序不被感染，又能防止对象被非法程序访问，从而保证了应用系统的安全性</p><h2 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a><strong><strong>访问控制列表</strong></strong></h2><p><strong>访问控制列表（ACL）</strong></p><p>访问控制列表是一系列允许或拒绝数据的指令的集合。</p><p><strong>读取第三层、第四层包头信息</strong></p><p><strong>根据预先定义好的规则对包进行过滤</strong></p><ul><li><p>**标准ACL:**只使用数据包的源地址作为测试条件。所有决定是基于源IP地址的。</p><p>  标准访问列表的创建根据 “动作”＋“源地址”，即允许谁、拒绝谁的方法来创建</p></li><li><p>**扩展ACL:**可以测试IP包的第3层和第4层报头中的字段。包括源IP地址、目的IP地址、网络层报头中的协议字段（如，TCP、UDP、ICMP等）以及位于传输层报头中的端口号。<br>扩展列表的放置——靠近源地址</p></li><li><p>**命名ACL:**命名ACL以列表名代替列表编号来定义IP访问控制列表，同样包括标准和扩展两种列表，定义过滤的语句与编号方式中相似。</p></li></ul><h3 id="通配掩码"><a href="#通配掩码" class="headerlink" title="通配掩码"></a><strong>通配掩码</strong></h3><p>路由器使用<strong>IP地址和通配掩码</strong>（wildcard-mask）一起来分辨匹配的地址范围，它跟子网掩码刚好相反。</p><p>它不像子网掩码告诉路由器IP地址的哪一位属于网络号一样，通配符掩码告诉路由器为了判断出匹配，它需要检查IP地址中的多少位。</p><p>有了通配掩码，可以只使用两个32位的号码来确定IP地址的范围，<strong>这是十分方便的</strong></p><ul><li>通配掩码（wildcard mask）是分成4字节的32bit数</li><li>通配掩码与IP地址位位配对，相应位为0&#x2F;1，用于表示如何对待IP地址中的相应位</li></ul><p>IP地址的第三个字节为16（00010000）。通配掩码中的前四位为0，告诉路由器要匹配IP地址的前四位（0000）。由于最后的四位被忽略，则所有的在范围16（00010000）到31（00011111）的都将被允许，相应的通配掩码位是1。</p><h1 id="第四讲安全风险评估"><a href="#第四讲安全风险评估" class="headerlink" title="第四讲安全风险评估"></a><strong>第四讲安全风险评估</strong></h1><h2 id="风险评估涉及标准"><a href="#风险评估涉及标准" class="headerlink" title="风险评估涉及标准"></a><strong><strong>风险评估涉及标准</strong></strong></h2><p>ISO&#x2F;IEA</p><h2 id="风险（Risk）的概念"><a href="#风险（Risk）的概念" class="headerlink" title="风险（Risk）的概念"></a><strong><strong>风险（Risk）的概念</strong></strong></h2><p>风险指在某一特定环境下，在某一特定时间段内，特定的威胁利用资产的一种或一组薄弱点，导致资产的丢失或损害的潜在可能性，即特定威胁事件发生的可能性与后果的结合</p><p><strong>安全风险组成的四要素：</strong>信息系统资产（Asset）、信息系统脆弱性（Vulnerability）、信息安全威胁（Threat）、信息系统安全保护措施（Safeguard）。</p><h2 id="风险处置策略"><a href="#风险处置策略" class="headerlink" title="风险处置策略"></a><strong><strong>风险处置策略</strong></strong></h2><p><strong>降低风险（Reduce Risk）</strong>采取适当的控制措施来降低风险，包括技术手段和管理手段，如安装防火墙，</p><p>杀毒软件，或是改善不规范的工作流程、制定业务连续性计划，等等。</p><p><strong>避免风险（Avoid Risk）</strong>通过消除可能导致风险发生的条件来避免风险的发生，如将公司内外网隔离</p><p>以避免来自互联网的攻击，或是将机房安置在不可能造成水患的位置，等等。</p><p>**转移风险（Transfer Risk)**将风险全部或者部分地转移到其他责任方，例如购买商业保险。</p><p><strong>接受风险（Accept Risk）</strong>在实施了其他风险应对措施之后，对于残留的风险，可以有意识地选择接受。</p><h2 id="风险评估的要素"><a href="#风险评估的要素" class="headerlink" title="风险评估的要素"></a><strong><strong>风险评估的要素</strong></strong></h2><p><strong>风险评估围绕着资产、威胁、脆弱性和安全措施这些基本要素展开。</strong></p><p>需要充分考虑业务战略、资产价值、安全需求、安全事件、残余风险等与这些基本要素相关的各类属性。</p><h3 id="信息系统安全风险计算模型（GB-T20984-2007）"><a href="#信息系统安全风险计算模型（GB-T20984-2007）" class="headerlink" title="信息系统安全风险计算模型（GB&#x2F;T20984-2007）"></a><strong><strong>信息系统安全风险计算模型（GB&#x2F;T20984-2007）</strong></strong></h3><p>风险计算模型是对通过风险分析计算风险值过程的抽象，它主要包括资产评估、威胁评估、脆弱性评估。</p><h3 id="安全风险评估的框架及流程（GB-T20984-2007）"><a href="#安全风险评估的框架及流程（GB-T20984-2007）" class="headerlink" title="安全风险评估的框架及流程（GB&#x2F;T20984-2007）"></a><strong><strong>安全风险评估的框架及流程（GB&#x2F;T20984-2007）</strong></strong></h3><p>① 对资产进行识别，并对资产的重要性进行赋值；<br>② 对威胁进行识别，描述威胁的属性，并对威胁出现的频率赋值；<br>③ 对资产的脆弱性进行识别，并对具体资产的脆弱性的严重程度赋值；<br>④ 根据威胁和脆弱性的识别结果判断安全事件发生的可能性；<br>⑤ 根据脆弱性的严重程度及安全事件所作用资产的重要性计算安全事件的损失；<br>⑥ 根据安全事件发生的可能性以及安全事件的损失，计算安全事件一旦发生对组织的影响，即风险值。</p><h2 id="资产分类方法"><a href="#资产分类方法" class="headerlink" title="资产分类方法"></a><strong><strong>资产分类方法</strong></strong></h2><table><thead><tr><th>分类</th><th>示例</th></tr></thead><tbody><tr><td>数据</td><td>保存在信息媒介上的各种数据资料，包括源代码、数据库数据、系统文档、运行管理规程、计划、报告、用户手册、各类纸质的文档等</td></tr><tr><td>软件</td><td>系统软件：操作系统、数据库管理系统、语句包、开发系统等</td></tr><tr><td>应用软件：办公软件、数据库软件、各类工具软件等</td><td></td></tr><tr><td>源程序：各种共享源代码、自行或合作开发的各种代码等</td><td></td></tr><tr><td>硬件</td><td>网络设备：路由器、网关、交换机等</td></tr><tr><td>计算机设备：大型机、小型机、服务器、工作站、台式计算机、便携计算机等</td><td></td></tr><tr><td>存储设备：磁带机、磁盘阵列、磁带、光盘、软盘、移动硬盘等</td><td></td></tr><tr><td>传输线路：光纤、双绞线等</td><td></td></tr><tr><td>保障设备：UPS、变电设备等、空调、保险柜、文件柜、门禁、消防设施等</td><td></td></tr><tr><td>安全保障：防火墙、入侵检测系统、身份鉴别等</td><td></td></tr><tr><td>其他：打印机、复印机、扫描仪、传真机等</td><td></td></tr><tr><td>服务</td><td>信息服务：对外依赖该系统开展的各类服务</td></tr><tr><td>网络服务：各种网络设备、设施提供的网络连接服务</td><td></td></tr><tr><td>办公服务：为提高效率而开发的管理信息系统，包括各种内部配置管理、文件流转管理等服务</td><td></td></tr><tr><td>人员</td><td>掌握重要信息和核心业务的人员，如主机维护主管、网络维护主管及应用项目经理等</td></tr><tr><td>其他</td><td>企业形象、客户关系等</td></tr></tbody></table><h3 id="资产等级计算公式"><a href="#资产等级计算公式" class="headerlink" title="资产等级计算公式"></a><strong><strong>资产等级计算公式</strong></strong></h3><p>AV&#x3D;F(AC, AI, AA)</p><p>Asset Value 资产价值</p><p>Asset Confidentiality 资产保密性赋值</p><p>Asset Integrity 资产完整性赋值</p><p>Asset Availability 资产可用性赋值</p><p>例1：AV&#x3D;MAX(AC, AI, AA)</p><p>例2：AV&#x3D;AC+AI+AA</p><p>例3：AV&#x3D;AC×AI×AA</p><h2 id="威胁来源列表"><a href="#威胁来源列表" class="headerlink" title="威胁来源列表"></a><strong><strong>威胁来源列表</strong></strong></h2><table><thead><tr><th>来源</th><th></th><th>描述</th></tr></thead><tbody><tr><td>环境因素</td><td></td><td>断电、静电、灰尘、潮湿、温度、鼠蚁虫害、电磁干扰、洪灾、火灾、地震、意外 事故等环境危害或自然灾害，以及软件、硬件、数据、通信线路等方面的故障</td></tr><tr><td>人为因素</td><td>恶意人员</td><td>不满的或有预谋的内部人员对信息系统进行恶意破坏；</td></tr><tr><td>采用自主或内外勾结的方式盗窃机密信息或进行篡改，获取利益外部人员利用信息系统的脆弱性,对网络或系统的机密性、完整性和可用性进行破坏，以获取利益或炫耀能力</td><td></td><td></td></tr><tr><td>人为因素</td><td>非恶意人员</td><td>内部人员由于缺乏责任心，或者由于不关心和不专注，或者没有遵循规章制度和操作流程而导致故障或信息损坏；</td></tr><tr><td>内部人员由于缺乏培训、专业技能不足、不具备岗 位技能要求而导致信息系统故障或被攻击</td><td></td><td></td></tr></tbody></table><h2 id="风险计算方法"><a href="#风险计算方法" class="headerlink" title="风险计算方法"></a><strong>风险计算方法</strong></h2><p><strong>风险值&#x3D;<em>R</em>(A, T, V) &#x3D; <em>R</em>(<em>L</em>(T, V), <em>F</em>(Ia,Va))</strong></p><p><strong>R</strong>安全风险计算函数</p><p><strong>A</strong>资产</p><p><strong>T</strong>威胁</p><p><strong>V</strong>脆弱性</p><p><strong>Ia</strong>安全事件所作用的资产价值</p><p><strong>Va</strong> 脆弱性严重程度</p><p><strong>L</strong>威胁利用资产的脆弱性导致安全事件发生的可能性</p><p><strong>F</strong>安全事件发生后产生的损失</p><h2 id="残留风险评价"><a href="#残留风险评价" class="headerlink" title="残留风险评价"></a><strong>残留风险评价</strong></h2><ul><li>绝对安全（即零风险）是不可能的</li><li>实施安全控制后会有残留风险或残存风险（Residual Risk）</li><li>为了确保信息安全，应该确保残留风险在可接受的范围内：</li></ul><p>➢ 残留风险Rr ＝ 原有的风险R0 － 控制ΔR</p><p>➢ 残留风险Rr ≤ 可接受的风险Rt</p><p><strong><strong>风险评估应贯穿于信息系统生命周期的各阶段</strong></strong></p><p><strong><strong>规划阶段的风险评估</strong></strong></p><p>规划阶段的评估结果应体现在信息系统整体规划或项目建议书中。</p><p><strong><strong>设计阶段的风险评估</strong></strong></p><p>设计阶段的评估可以以安全建设方案评审的方式进行，判定方案所提供的安全功能与信息技术安全技术标准的符合性。评估结果应体现在信息系统需求分析报告或建设实施方案中。</p><p><strong><strong>实施阶段的风险评估</strong></strong></p><p>本阶段风险评估可以采取对照实施方案和标准要求的方式，对实际建设结果进行测试、分析。</p><p><strong><strong>运行维护阶段的风险评估</strong></strong></p><p>运行维护阶段的风险评估应定期执行；当组织的业务流程、系统状况发生重大变更时，也应进行风险评估。</p><p><strong><strong>废弃阶段的风险评估</strong></strong></p><p>信息系统的维护技术人员和管理人员均应该参与此阶段的评估</p><p><strong><strong>一种新的风险评估⎯⎯数据风险评估</strong></strong></p><h2 id="风险评估项目实施过程"><a href="#风险评估项目实施过程" class="headerlink" title="风险评估项目实施过程"></a><strong><strong>风险评估项目实施过程</strong></strong></h2><p><strong>策划 准备 实施 报告 跟踪</strong></p><h1 id="第五讲-信息系统等级保护"><a href="#第五讲-信息系统等级保护" class="headerlink" title="第五讲  信息系统等级保护"></a><strong>第五讲  信息系统等级保护</strong></h1><h3 id="什么是等级保护"><a href="#什么是等级保护" class="headerlink" title="什么是等级保护"></a><strong>什么是等级保护</strong></h3><p>网络安全等级保护是指对国家重要信息、法人和其他组织及公民的专有信息以及公开信息和存储、传输、处理这些信息的信息系统分等级实行安全保护，对信息系统中使用的信息安全产品实行按等级管理，对信息系统中发生的信息安全事件分等级响应、处置</p><p><strong><strong>定级对象</strong></strong></p><p>也称等级保护对象、网络安全等级保护工作的作用对象</p><p>包括网络基础设施（广电网、电信网、专用通信网络等）、云计算平台系统、大数据平台系统、物联网、工业控制系统、采用移动互联技术的系统等</p><h2 id="等级保护有“五个规定动作”"><a href="#等级保护有“五个规定动作”" class="headerlink" title="等级保护有“五个规定动作”"></a><strong><strong>等级保护有“五个规定动作”</strong></strong></h2><h2 id="等级保护主要工作流程"><a href="#等级保护主要工作流程" class="headerlink" title="等级保护主要工作流程"></a><strong><strong>等级保护主要工作流程</strong></strong></h2><p>1 <strong>定级  定级是等级保护的首要环节</strong></p><p>2 <strong>备案 备案是等级保护的核心</strong></p><p>3 <strong>建设整改 建设整改是等级保护工作落实的关键</strong></p><p>4 <strong>等级测评 等级测评是评价安全保护状况的方法</strong></p><h1 id="第六讲-物理安全"><a href="#第六讲-物理安全" class="headerlink" title="第六讲 物理安全"></a><strong>第六讲 物理安全</strong></h1><h2 id="环境安全"><a href="#环境安全" class="headerlink" title="环境安全"></a><strong><strong>环境安全</strong></strong></h2><ul><li>安防技术</li><li>计算机机房的温度、湿度、洁净度</li><li>计算机机房的用电安全技术</li><li>计算机机房安全管理制度</li></ul><h3 id="机房三度要求"><a href="#机房三度要求" class="headerlink" title="机房三度要求"></a><strong><strong>机房三度要求</strong></strong></h3><blockquote><p>温度：机房温度一般应控制在18～22℃</p><p>湿度：相对湿度一般控制在40％～60％为宜</p><p>洁净度：尘埃颗粒直径&lt;0.5<em>m</em>，含尘量&lt;1万颗&#x2F;升</p></blockquote><p>GB50174-2008 电子信息系统机房设计规范</p><h3 id="防火与防水要求"><a href="#防火与防水要求" class="headerlink" title="防火与防水要求"></a><strong><strong>防火与防水要求</strong></strong></h3><p>为避免火灾、水灾，应采取如下具体措施:<br>（1）隔离<br>（2）火灾报警系统<br>（3）灭火设施<br>（4）管理措施</p><h3 id="机房防盗要求"><a href="#机房防盗要求" class="headerlink" title="机房防盗要求"></a><strong><strong>机房防盗要求</strong></strong></h3><h3 id="机房防鼠"><a href="#机房防鼠" class="headerlink" title="机房防鼠"></a><strong><strong>机房防鼠</strong></strong></h3><h3 id="防静电措施"><a href="#防静电措施" class="headerlink" title="防静电措施"></a><strong>防静电措施</strong></h3><blockquote><p> 机房的内装修材料一般应避免使用挂毯、地毯等吸尘、容易产生静电的材料，而应采用乙烯材料。</p><p>为了防静电，机房一般要安装防静电地板。</p><p> 机房内应保持一定湿度，特别是在干燥季节应适当增加空气湿度，以免因干燥而产生静电。</p></blockquote><h3 id="接地要求"><a href="#接地要求" class="headerlink" title="接地要求"></a><strong>接地要求</strong></h3><p>接地可以为计算机系统的数字电路提供一个稳定的0V参考电位</p><h1 id="第七讲-可靠性的基本概念"><a href="#第七讲-可靠性的基本概念" class="headerlink" title="第七讲 可靠性的基本概念"></a><strong>第七讲 可靠性的基本概念</strong></h1><h3 id="可靠性的定义"><a href="#可靠性的定义" class="headerlink" title="可靠性的定义"></a><strong><strong>可靠性的定义</strong></strong></h3><p>在规定的条件下、在给定的时间内，系统能实施应有功能的能力。</p><h3 id="可靠性参数"><a href="#可靠性参数" class="headerlink" title="可靠性参数"></a><strong><strong>可靠性参数</strong></strong></h3><p>$T_{MTTF}：$平均失效前时间</p><p>$T_{MTBF}：$平均故障间隔时间</p><p>$R：$<strong><strong>可靠度</strong></strong></p><p>$λ：$<strong><strong>失效率</strong></strong></p><h3 id="寿命"><a href="#寿命" class="headerlink" title="寿命"></a><strong><strong>寿命</strong></strong></h3><p>通常用一个非负随机变量$<em><strong>X</strong></em>$来描述产品的寿命。</p><p>$<em><strong>X</strong></em>$的分布函数为</p><p>$<em>F(t) &#x3D; P{X \le t}，t\ge0</em>$</p><p>有了寿命分布<em>F</em>(<em>t</em>) ，就知道产品的平均寿命</p><p>$EX&#x3D;\int_0^\infty tdF(t)$</p><h3 id="可靠度R"><a href="#可靠度R" class="headerlink" title="可靠度R"></a><em><strong><em>可靠度</em>R</strong></em></h3><p>产品在时刻 <em>t</em> 之前都正常工作（不失效）的概率，即产品在时刻 <em>t</em>的生存概率，称为无故障工作概率（可靠度函数）</p><p>$$<br>R(t)&#x3D;P{X&gt;t}&#x3D;\int_0^\infty dF(t)&#x3D;\int_0^\infty f(t)dt \<br>𝑹(t) +F(t)&#x3D;1<br>$$</p><blockquote><p>假设 C 是一个具有 <em>N</em> 个元器件的数字系统，在一定的条件和环境（如温度、湿度、电压等）下运行，并且随着时间 <em>t</em> 的推移质量逐步下降</p></blockquote><p>系统<strong>C</strong>在时刻 <em>t</em> 能正常工作的概率 $<em><strong>R(t)&#x3D;S(t)&#x2F;N</strong></em>$</p><p>**<em>R</em>(<em>t</em>)**称为系统 <strong>C</strong> 在时刻 <em>t</em> 的可靠度。</p><h3 id="失效率λ"><a href="#失效率λ" class="headerlink" title="失效率λ"></a><strong><strong>失效率λ</strong></strong></h3><p>假设<em>F</em>(<em>t</em>)是绝对连续的，即存在分布密度函数$<em>f(t)&#x3D;F’(t)</em>$且$F(t)&#x3D;\int_0^tf(x)dx$</p><blockquote><p>将发生故障的条件概率密度叫做失效率。<br>$λ(t)&#x3D;f(t)&#x2F;R(t)&#x3D;-R’(t)&#x2F;R(t)$<br>失效率**λ(<em>t</em>)**表示系统中元器件失效的速率。</p></blockquote><h3 id="λ-t-的浴缸形曲线（Bathtub-curve）"><a href="#λ-t-的浴缸形曲线（Bathtub-curve）" class="headerlink" title="**λ(t)的浴缸形曲线（Bathtub-curve）"></a>**<strong>λ(<em>t</em>)的浴缸形曲线（Bathtub-curve）</strong></h3><p><strong>第一阶段 早期失效期（Infant Mortality）</strong></p><p>器件在开始使用时失效率很高，但随着产品工作时间的增加，失效率迅速降低。这一阶段失效的原因大多是由于设计、原材料和制造过程中的缺陷造成的。为了缩短这一阶段的时间，产品应在投入运行前进行试运转，以便及早发现、修正和排除故障；或通过试验进行筛选，剔除不合格品。</p><p><strong>第二阶段 偶然失效期，也称随机失效期（Random Failures）</strong></p><p>这一阶段的特点是失效率较低，且较稳定，往往可近似看作常数。这一时期是产品的良好使用阶段。由于在这一阶段中，产品失效率近似为一常数，故设<em></em>(<em>t</em>)&#x3D;<em>λ</em>（常数）由可靠度计算公式得$R(t)&#x3D;e^{-λt}$ 这一式表明<strong>设备的可靠性与失效率成指数关系</strong>。</p><p><strong>第三阶段 耗损失效期（Wearout）</strong></p><p>该阶段的失效率随时间的延长而急速增加，主要原因是器件的损失己非常的严重，寿命快到尽头了，可适当的维修或直接更换。</p><p>**<strong><em>R</em>(<em>t</em>)和λ的关系</strong></p><p>可靠性不仅是时间<em>t</em>的函数，而且与失效率<strong><strong>λ</strong></strong>有着密切的关联。</p><p>$$<br>R(t)&#x3D;e^{\int^t_0\lambda(t)dt }<br>$$</p><h3 id="可维修产品的平均维修时间"><a href="#可维修产品的平均维修时间" class="headerlink" title="可维修产品的平均维修时间"></a><strong><strong>可维修产品的平均维修时间</strong></strong></h3><p>可维修产品的可维护性平均维修时间（MTTR，Mean Time To Repair）来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间（即设备处于故障状态时间的平均值，或设备修复时间的平均值）。系统的可维护性越好，平均维修时间越短</p><p>$$<br>MTTR&#x3D;\int^\infty _0t\mu(t)dt<br>$$</p><blockquote><p>$<em>\mu(t)</em>$是维修时间的概率密度函数</p></blockquote><h3 id="可维修产品的维修性指标：可用性"><a href="#可维修产品的维修性指标：可用性" class="headerlink" title="可维修产品的维修性指标：可用性"></a><strong><strong>可维修产品的维修性指标：可用性</strong></strong></h3><p>可维修产品的可用性定义为：</p><p>$$<br>\frac{MTBF}{MTBF+MTTR}*100%<br>$$</p><p><strong>计算机系统可靠性举例</strong></p><p>已知世界上第一代电子管计算机ENIAC有20000个电子管，假<br>设每个电子管的失效率为&#x3D;0.5%&#x2F;kh（千小时），试求：<br>（1）该计算机的MTTF；<br>（2）若要求计算机的可靠性在95%以上，则至多可以工作多久？</p><p>$$<br>MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i}&#x3D;\frac{1}{\frac{0.05}{100}*\frac{1}{1000}*20000}&#x3D;\frac{1}{0.01}&#x3D;100H\ R(t)&#x3D;e^{-\frac{t}{MTTF}}\ t&#x3D;5H<br>$$</p><h2 id="系统可靠性模型"><a href="#系统可靠性模型" class="headerlink" title="系统可靠性模型"></a><strong><strong>系统可靠性模型</strong></strong></h2><p><strong>可靠性模型：描述了系统及其组成单元之间的故障逻辑关系</strong></p><h3 id="串联系统"><a href="#串联系统" class="headerlink" title="串联系统"></a><strong><strong>串联系统</strong></strong></h3><p>假设第<em>i</em>个部件的寿命为$<em><strong>X_i</strong></em>$，可靠度为$<em>R_i(t)&#x3D;P{X_i &gt;t}，i&#x3D;1, 2, …,n,</em>$第$<em>i</em>$个部件的失效率为$<em>\lambda_i(t)</em>$$，X_1，X_2 ，…，X_n$相互独立。若</p><p>初始时刻$<em>t&#x3D;0</em>$，所有部件都是新的，且同时开始工作。</p><p>(1) 系统的寿命是： $X&#x3D;min{X_1 ，X_2，…，X_n}$</p><p>(2) 系统的可靠度是：</p><p>$$<br>R(t)&#x3D;P{min(X_1 ，X_2，…，X_n)&gt;t}&#x3D;\Pi^n_{i&#x3D;1}R_i(t)\ &#x3D;\Pi^n_{i&#x3D;1}exp{-\int^t_0\lambda_i(u)du}<br>$$</p><p>(3) 系统的失效率为：</p><p>$$<br>\lambda(t)&#x3D;-\frac{R’(t)}{R(t)}&#x3D;\sum^n_{i&#x3D;1}\lambda_i(t)<br>$$</p><p>(4) 系统的平均寿命为:</p><p>$$<br>MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\int^\infty_0exp{-\int^t_0\lambda(u)du}dt<br>$$</p><p>当$R_i(t)&#x3D;exp{-\lambda_t}，i&#x3D;1, 2, …, n$时（及当第<em>i</em>个部件的命遵从参数为$<em>\lambda_i</em>$的</p><p>指数分布时），系统的可靠度和平均寿命为</p><p>$$<br>R(t)&#x3D;exp{-\sum^n_{i&#x3D;1}\lambda_it}\ MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i}<br>$$</p><h3 id="并联系统"><a href="#并联系统" class="headerlink" title="并联系统"></a><strong><strong>并联系统</strong></strong></h3><p>(1) 系统的寿命是： $X&#x3D;max{X_1，X_2，…，X_n<br>}$</p><p>(2) 系统的可靠度是：</p><p>$$<br>R(t)&#x3D;P{max(X_1 ，X_2，…，X_n)&gt;t}\ &#x3D;1-P{max(X_1 ，X_2，…，X_n)\le t } \ &#x3D;1-\Pi^n_{i&#x3D;1}[1-R_i(t)]<br>$$</p><p>(3) 系统的平均寿命为：</p><p>$$<br>MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\sum^n_{i&#x3D;1}\frac{1}{\lambda_i}\ &#x3D;sum_{1\le&lt;i&lt;j\le n}\frac{1}{\lambda_1+\lambda_j}+…+(-1)^{n-1}\frac{1}{\lambda_1+…+\lambda_n}<br>$$</p><h1 id="第八讲-信息系统的可靠性"><a href="#第八讲-信息系统的可靠性" class="headerlink" title="第八讲 信息系统的可靠性"></a><strong>第八讲 信息系统的可靠性</strong></h1><h3 id="计算机系统可靠性"><a href="#计算机系统可靠性" class="headerlink" title="计算机系统可靠性"></a><strong>计算机系统可靠性</strong></h3><p><strong>硬件可靠性</strong></p><p>硬件在使用过程中有磨损、材料的老化、变质和使用环境等多种因素</p><p><strong>软件可靠性</strong></p><p>软件使用期间无磨损;存在物质老化和变质</p><h2 id="提高信息系统可靠性的途径"><a href="#提高信息系统可靠性的途径" class="headerlink" title="提高信息系统可靠性的途径"></a><strong><strong>提高信息系统可靠性的途径</strong></strong></h2><p><strong>提高可靠性有两个方面：一是尽量使系统在规定时间内少发生故障和错误；二是发生了故障能迅速排除。</strong></p><h3 id="提高硬件可靠性"><a href="#提高硬件可靠性" class="headerlink" title="提高硬件可靠性"></a><strong><strong>提高硬件可靠性</strong></strong></h3><p><strong>设计</strong></p><p>结构优化<br>功能合理</p><p><strong>环境</strong></p><p>符合相关的标准和要求</p><p><strong>使用</strong></p><p>符合操作规程<br>减少人为失误</p><blockquote><p><strong>冗余设计</strong></p><p>故障容错是利用冗余的元部件来屏蔽已发生的故障对系统的影响。</p><p>三模冗余（TMR，Triple Modular Redundancy）的基本原理是：系统输入通过3个功能相同的模块，产生的3个结果送到多数表决器进行表决，即三中取二的原则，如果模块中有一个出错，而另外两个模块正常，则表决器的输出正确，从而可以屏蔽一个故障。</p><p><strong>TMR的缺点是：如果3个模块的输出各不相同，则无法进行多数表决；若有两个模块出现一致的故障，则表决的结果会出现错误。</strong></p></blockquote><h2 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h2><p><strong><strong>程序运行监视系统</strong></strong></p><p>程序运行监视系统WTD（“看门狗”），是一种软硬件结合的抗程序“跑飞”的措施。其硬件是一个用于产生定时 <em>T</em> 的计数器或单稳触发器。其定时输出端接至CPU 的复位线，而其定时清零则由CPU 控制。</p><p>在正常情况下，程序启动WTD 后，即以小于<em>T</em> 的间隔 <em>t</em> 将其清零一次，这样WTD 的定时溢出就不会发生。在受到干扰的异常情况下，程序的正常执行顺序被破坏，不可能周期性地将WTD清零，导致WTD定时溢出，使系统复位，CPU 摆脱因程序“跑飞”造成的瘫痪状态</p><h3 id="软件可靠性模型"><a href="#软件可靠性模型" class="headerlink" title="软件可靠性模型"></a><strong><strong>软件可靠性模型</strong></strong></h3><p><strong><strong>失效时间间隔模型</strong></strong></p><p>这类模型最常用的方法是假定第<em>i</em>个失效到第<em>i</em>+1个失效间隔时间服从某一分布，而分布的参数依赖于各间隔时间内程序中的残留错误数。通过测试所得到的失效间隔时间数据来估计模型的参数，由获得的模型可以估算软件的可靠度以及各失效间的平均工作时间等</p><p><strong><strong>Jelinski-Moranda模型</strong></strong></p><p>系统基本假设如下：<br>（1）软件中的固有错误数<em>N</em>是一个未知的常数；<br>（2）软件中的各个错误是相互独立的，每个错误导致系统发生失效的可能性大致相同,各次失效间隔时间也相互独立；<br>（3）软件错误被发现后立即排除，每次排除一个错误且不引入新的错误，排除错误的时间忽略不计；<br>（4）软件的失效率在每个失效间隔时间内是常数，其数值正比于程序中残留的错误数，在第$<em>i</em>$个测试区间$<em>t_i</em>$，其失效率函数为:$\lambda(t_i)&#x3D;\phi(N-i+1)$,$\phi$为比例常数 。</p><p><strong><strong>缺陷计数模型</strong></strong></p><p>这类模型关心的是在<strong>特定的时间间隔内软件的错误数或失效数</strong>，并假定故障累计数服从某个己知的随机过程，过程强度是时间的离散或连续函数，根据在给定的测试时间间隔发现的错误数或失效数来估计故障强度、均值等参数。</p><p><strong><strong>错误植入模型</strong></strong></p><p>这类模型的基本思路是通过将一组已知的错误人为地植入到一个固有错误总数尚不清楚的程序中，然后在程序的测试中观察并统计发现的植入错误数和程序总的错误数，通过计数的比值估计程序的固有错误总数，从而得到软件可靠度及其有关指标。这类模型的代表是Mills的超几何分布模型。</p><p><strong><strong>基于输入域的模型</strong></strong></p><p>这类模型的基本研究方法是根据程序的使用情况，找出程序可能输入的概率分布，根据这种分布产生一个测试用例的集合。由于得到输入的分布难度较大，一般将输入域划分成等价类，每个等价类与程序的一条执行路径相联。在输入域上随机抽取测试用例，执行相应的程序测试，观测故障，从而推断出各项指标。这类模型以Nelson模型为代表，还有Brown-Lipow的基于输入域模型和Ramamoorthy-Bastani的基于输入域模型</p><h2 id="网络可靠性"><a href="#网络可靠性" class="headerlink" title="网络可靠性"></a><strong><strong>网络可靠性</strong></strong></h2><p><strong>故障定义</strong>– <strong>网络不能在用户期望的时间范围内将物质、信息、能量按用户需求完整、正确地在网络中传输的状态或事件</strong></p><p><strong><strong>计算机网络可靠性定义</strong></strong></p><p>在人为或自然的破坏作用下，网络在特定环境和规定时间内，充分完成规定的通信功能的能力。<strong>环境、时间和充分完成功能是这一定义的三要素。</strong></p><p>当传输设备和交换设备发生故障时网络可以维持正常业务的程度</p><h1 id="第九讲-信息系统的容错技术"><a href="#第九讲-信息系统的容错技术" class="headerlink" title="第九讲 信息系统的容错技术"></a><strong>第九讲 信息系统的容错技术</strong></h1><h2 id="容错的概念"><a href="#容错的概念" class="headerlink" title="容错的概念"></a><strong><strong>容错的概念</strong></strong></h2><p>容忍故障，即故障一旦发生时能够<strong>自动检测</strong>出来并使系统能够<strong>自动恢复正常运行</strong></p><p><strong>容错设计的软件可以有某些规定数目的故障但不导致失效，但对无容错的软件而言，故障即失效。</strong></p><h2 id="容错的主要内容"><a href="#容错的主要内容" class="headerlink" title="容错的主要内容"></a><strong><strong>容错的主要内容</strong></strong></h2><p><strong>故障检测和诊断</strong></p><p>故障检测（Fault Detection）：判断系统是否存在故障的过程<br><strong>故障检测的作用是确认系统是否发生了故障，指示故障的状态，即查找故障源和故障性质。一般来说，故障检测只能找到错误点（错误单元），不能准确找到故障点。</strong></p><p>故障诊断（Fault Diagnosis）：检测出系统存在故障后要进行故障的定位，找出故障所在的位置</p><p><strong>故障屏蔽技术</strong></p><p>故障屏蔽技术是防止系统中的故障在该系统的信息结构中产生差错的各种措施的总称，其实质是在故障效应达到模块的输出以前，利用冗余资源将故障影响掩盖起来，达到容错目的</p><p><strong>冗余技术</strong></p><p>三模冗余可以由用户手动完成，也可以依靠工具完成。Xilinx推出了XIlInXtMrtool ，可以方便地实现三模冗余设计，并且可以方便地配置被冗余项，大大方便了用户</p><p><strong>时间冗余技术</strong></p><p><strong>基本思想：</strong>重复执行指令或者一段程序来消除故障的影响，以达到容错的效果，它是用消耗时间来换取容错的目的。</p><p><strong>信息冗余技术</strong></p><p>信息容错技术是通过在数据中附加冗余的信息位来达到故障检测和容错的目的</p><p><strong>软件冗余技术</strong></p><p>软件容错是指在出现有限数目的软件故障的情况下，系统仍可提供连续正确执行的内在能力。其目的是屏蔽软件故障，恢复因出故障而影响的运行进程。</p><p>实现软件容错的基本方法，是将若干个根据同一需求说明编写的不同程序（即多版本程序），在不同空间同时运行，然后在每一个设置点通过表决或接收测试进行表决。</p><h2 id="典型的容错应用"><a href="#典型的容错应用" class="headerlink" title="典型的容错应用"></a><strong><strong>典型的容错应用</strong></strong></h2><p><strong><strong>热备份（Hot-Standby）</strong></strong></p><p>M运行，S后备；</p><p>M故障，S接管作M；</p><p>原M修复，S归还M。</p><h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a><strong><strong>RAID</strong></strong></h3><p>廉价磁盘冗余阵列（Redundant Arrays of Inexpensive Disks），以多个低成本磁盘构成磁盘子系统，提供比单一硬盘更完备的可靠性和高性能</p><p><strong>数据基带条阵列（RAID0）</strong></p><p>分块无校验型，无冗余存储。简单将数据分配到各个磁盘上，不提供真正容错性。带区化至少需要2个硬盘，可支持8&#x2F;16&#x2F;32个磁盘</p><p> <strong>优点</strong></p><p>➢允许多个小区组合成一个大分</p><p>➢更好地利用磁盘空间，延长磁盘寿命</p><p>➢多个硬盘并行工作，提高了读写性能</p><p> <strong>缺点</strong></p><p>➢不提供数据保护，任一磁盘失效，数据可能丢失，且不能自动恢复。</p><p><strong>磁盘镜象（RAID1）</strong></p><p>每一组盘至少两台，数据同时以同样的方式写到两个盘上，两个盘互为镜象。磁盘镜象可以是分区镜象、全盘镜象。容错方式以空间换取，实施可以采用镜象或者双工技术。</p><p> <strong>优点</strong></p><p>➢ 可靠性高，策略简单，恢复数据时不必停机。</p><p> <strong>缺点</strong></p><p>➢ 有效容量只有总容量的1&#x2F;2，利用率50%。由于磁盘冗余，硬件</p><p>开销较大，成本较高</p><p><strong>循环奇偶校验阵列（RAID5）</strong></p><p>与RAID4类似，但校验数据不固定在一个磁盘上，而是循环地依次分布在不同的磁盘上，也称块间插入分布校验。它是目前采用最多、最流行的方式，至少需要3个硬盘。</p><p> 优点</p><p>➢ 校验分布在多个磁盘中，写操作可以同时处理；</p><p>➢ 为读操作提供了最优的性能；</p><p>➢ 一个磁盘失效，分布在其他盘上的信息足够完成数据重建 。</p><p> 缺点</p><p>➢ 数据重建会降低读性能；</p><p>➢ 每次计算校验信息，写操作开销会增大，是一般存储操作时间的3倍</p>]]></content>
    
    
    <summary type="html">信息系统安全的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://shuita2333.github.io/project/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://shuita2333.github.io/project/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编译原理与技术课程笔记</title>
    <link href="https://shuita2333.github.io/project/2024/01/11/BUPT_note/Notes_on_Compilation_principle/"/>
    <id>https://shuita2333.github.io/project/2024/01/11/BUPT_note/Notes_on_Compilation_principle/</id>
    <published>2024-01-11T13:00:00.000Z</published>
    <updated>2024-07-07T08:22:31.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译原理与技术-郭燕慧"><a href="#编译原理与技术-郭燕慧" class="headerlink" title="编译原理与技术 郭燕慧"></a>编译原理与技术 郭燕慧</h1><h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><table><thead><tr><th>Lexical Analyzer</th><th>词法分析</th></tr></thead><tbody><tr><td>Syntax Analyzer</td><td>语法分析</td></tr><tr><td>Semantic Analyzer</td><td>语义分析</td></tr><tr><td>Intermediate Code Generator</td><td>中间代码生成</td></tr><tr><td>Machine-Independent Code Optimizer</td><td>机器无关的代码优化</td></tr><tr><td>Code Generator</td><td>代码生成</td></tr><tr><td>Machine-Dependent Code Optimizer</td><td></td></tr></tbody></table><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>将源程序分解为多个组成部分，并对其施加语法结构</li><li>使用语法结构创建一个中间表示intermediate representation(IR)的源程序</li><li>收集有关源程序的信息，并将其存储在称为符号表的数据结构中(将通过IR传递给后端)</li></ul><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul><li>根据IR和符号表中的信息构造目标程序(通常用机器语言)</li><li>在此过程中执行代码优化</li></ul><h3 id="词法分析-Lexical-Analyzer"><a href="#词法分析-Lexical-Analyzer" class="headerlink" title="词法分析 Lexical Analyzer"></a>词法分析 Lexical Analyzer</h3><p>&lt;token-name, attribute-value&gt;</p><aside>💡 token-name 在语法分析中使用的抽象符号</aside><aside>💡 attribute-value 指向符号表中的一个项。表项中的信息用于语义分析和代码生成</aside><p>position &#x3D; initial + rate * 60</p><p>Lexical Analyzer</p><p>&lt;id, 1&gt;<br>&lt;&#x3D;&gt;<br>&lt;id, 2&gt;<br>&lt;+&gt;<br>&lt;id, 3&gt;<br>&lt;*&gt;<br>&lt;60&gt;</p><h3 id="语法分析-Syntax-Analyzer"><a href="#语法分析-Syntax-Analyzer" class="headerlink" title="语法分析 Syntax Analyzer"></a>语法分析 Syntax Analyzer</h3><p>语法分析器(解析器)使用词法分析器生成的令牌名称来创建描述令牌流语法结构的中间表示，通常是语法树</p><p>每个内部节点表示一个操作，该节点的子节点表示该操作的参数</p><h3 id="语义分析-Semantic-Analysis"><a href="#语义分析-Semantic-Analysis" class="headerlink" title="语义分析 Semantic Analysis"></a>语义分析 Semantic Analysis</h3><p>语义分析器使用语法树和符号表中的信息来检查源程序与语言定义的语义一致性</p><p>还收集用于类型检查、类型转换和中间代码生成的类型信息</p><p>编程语言的语法描述了其程序的适当形式</p><p>编程语言的语义描述了其程序的含义，即每个程序在执行时所做的事情</p><h3 id="类型检查-Type-Checking"><a href="#类型检查-Type-Checking" class="headerlink" title="类型检查 Type Checking"></a>类型检查 Type Checking</h3><p>语义分析的一个重要部分是类型检查编译器检查每个操作符是否有匹配的操作数(类型正确)</p><h3 id="中间代码生成-Machine-Independent-Code-Optimizer"><a href="#中间代码生成-Machine-Independent-Code-Optimizer" class="headerlink" title="中间代码生成 Machine-Independent Code Optimizer"></a>中间代码生成 Machine-Independent Code Optimizer</h3><ul><li>经过语义分析后，编译器生成一个中间值representation, typically three-address code (Three-address code)</li><li>类汇编指令，每条指令有三个操作数，每个操作数就像一个寄存器</li><li>每个赋值指令在RHS上最多有一个操作符</li><li>易于翻译成目标机器的机器指令</li></ul><h3 id="机器无关的代码优化-Machine-Independent-Code-Optimization"><a href="#机器无关的代码优化-Machine-Independent-Code-Optimization" class="headerlink" title="机器无关的代码优化 Machine-Independent Code Optimization"></a>机器无关的代码优化 Machine-Independent Code Optimization</h3><p>类似于英文的文章编辑&#x2F;修改，改进中间代码以获得更好的目标代码</p><p>t1 &#x3D; inttofloat(60) </p><p>t2 &#x3D; id3 * t1<br>t3 &#x3D; id2 + t2</p><p>id1 &#x3D; t3</p><p>—&gt;</p><p>t1 &#x3D; id3 * 60.0 </p><p>id1 &#x3D; id2 + t1</p><h3 id="代码生成-Code-Generator"><a href="#代码生成-Code-Generator" class="headerlink" title="代码生成 Code Generator"></a>代码生成 Code Generator</h3><p>t1 &#x3D; id3 * 60.0 </p><p>id1 &#x3D; id2 + t1</p><p>Code<br>Generation</p><p>LDF R2, id3<br>MULF R2, R2, #60.0 </p><p>LDF R1, id2<br>ADDF R1, R1, R2</p><p> STF id1, R1</p><h3 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h3><ul><li>由前端执行，符号表与中间代码一起传递到后端</li><li>记录变量名称和存储分配的各种属性、类型、作用域</li><li>记录过程名称和各种属性<ul><li>参数的数量和类型</li><li>传递参数的方式(通过值或引用)</li><li>返回类型</li></ul></li></ul><h3 id="中间语言（Intermediate-Language）IL"><a href="#中间语言（Intermediate-Language）IL" class="headerlink" title="中间语言（Intermediate Language）IL"></a><strong><strong>中间语言（Intermediate Language）IL</strong></strong></h3><h3 id="编译器与解释器的区别"><a href="#编译器与解释器的区别" class="headerlink" title="编译器与解释器的区别"></a>编译器与解释器的区别</h3><ul><li><p>1</p><p>  编译器将用高级语言编写的源程序翻译成可以直接在目标计算机上运行的机器码。</p><p>  解释器直接执行源代码中的每条语句，而不需要将程序编译成机器码。</p></li><li><p>2</p><p>  解释器通常花费较少的时间来分析源代码:他们只是解析每个语句并执行它(例如，Python代码)。</p><p>  相比之下，编译器通常会分析语句之间的关系(例如，控制流和数据流)以实现优化。</p></li><li><p>3</p><p>  解释器继续执行程序，直到遇到第一个错误，在这种情况下它们停止。</p><p>  对于编译语言，程序只有在编译成功后才可执行。</p></li></ul><h2 id="编译器的结构-1"><a href="#编译器的结构-1" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><table><thead><tr><th>Lexical Analyzer</th><th>词法分析</th></tr></thead><tbody><tr><td>Syntax Analyzer</td><td>语法分析</td></tr><tr><td>Semantic Analyzer</td><td>语义分析</td></tr><tr><td>Intermediate Code Generator</td><td>中间代码生成</td></tr><tr><td>Machine-Independent Code Optimizer</td><td>机器无关的代码优化</td></tr><tr><td>Code Generator</td><td>代码生成</td></tr><tr><td>Machine-Dependent Code Optimizer</td><td></td></tr></tbody></table><h3 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h3><ul><li>将源程序分解为多个组成部分，并对其施加语法结构</li><li>使用语法结构创建一个中间表示intermediate representation(IR)的源程序</li><li>收集有关源程序的信息，并将其存储在称为符号表的数据结构中(将通过IR传递给后端)</li></ul><h3 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h3><ul><li>根据IR和符号表中的信息构造目标程序(通常用机器语言)</li><li>在此过程中执行代码优化</li></ul><h3 id="词法分析-Lexical-Analyzer-1"><a href="#词法分析-Lexical-Analyzer-1" class="headerlink" title="词法分析 Lexical Analyzer"></a>词法分析 Lexical Analyzer</h3><p>&lt;token-name, attribute-value&gt;</p><aside>💡 token-name 在语法分析中使用的抽象符号</aside><aside>💡 attribute-value 指向符号表中的一个项。表项中的信息用于语义分析和代码生成</aside><p>position &#x3D; initial + rate * 60</p><p>Lexical Analyzer</p><p>&lt;id, 1&gt;<br>&lt;&#x3D;&gt;<br>&lt;id, 2&gt;<br>&lt;+&gt;<br>&lt;id, 3&gt;<br>&lt;*&gt;<br>&lt;60&gt;</p><h3 id="语法分析-Syntax-Analyzer-1"><a href="#语法分析-Syntax-Analyzer-1" class="headerlink" title="语法分析 Syntax Analyzer"></a>语法分析 Syntax Analyzer</h3><p>语法分析器(解析器)使用词法分析器生成的令牌名称来创建描述令牌流语法结构的中间表示，通常是语法树</p><p>每个内部节点表示一个操作，该节点的子节点表示该操作的参数</p><h3 id="语义分析-Semantic-Analysis-1"><a href="#语义分析-Semantic-Analysis-1" class="headerlink" title="语义分析 Semantic Analysis"></a>语义分析 Semantic Analysis</h3><p>语义分析器使用语法树和符号表中的信息来检查源程序与语言定义的语义一致性</p><p>还收集用于类型检查、类型转换和中间代码生成的类型信息</p><p>编程语言的语法描述了其程序的适当形式</p><p>编程语言的语义描述了其程序的含义，即每个程序在执行时所做的事情</p><h3 id="类型检查-Type-Checking-1"><a href="#类型检查-Type-Checking-1" class="headerlink" title="类型检查 Type Checking"></a>类型检查 Type Checking</h3><p>语义分析的一个重要部分是类型检查编译器检查每个操作符是否有匹配的操作数(类型正确)</p><h3 id="中间代码生成-Machine-Independent-Code-Optimizer-1"><a href="#中间代码生成-Machine-Independent-Code-Optimizer-1" class="headerlink" title="中间代码生成 Machine-Independent Code Optimizer"></a>中间代码生成 Machine-Independent Code Optimizer</h3><ul><li>经过语义分析后，编译器生成一个中间值representation, typically three-address code (Three-address code)</li><li>类汇编指令，每条指令有三个操作数，每个操作数就像一个寄存器</li><li>每个赋值指令在RHS上最多有一个操作符</li><li>易于翻译成目标机器的机器指令</li></ul><h3 id="机器无关的代码优化-Machine-Independent-Code-Optimization-1"><a href="#机器无关的代码优化-Machine-Independent-Code-Optimization-1" class="headerlink" title="机器无关的代码优化 Machine-Independent Code Optimization"></a>机器无关的代码优化 Machine-Independent Code Optimization</h3><p>类似于英文的文章编辑&#x2F;修改，改进中间代码以获得更好的目标代码</p><p>t1 &#x3D; inttofloat(60) </p><p>t2 &#x3D; id3 * t1<br>t3 &#x3D; id2 + t2</p><p>id1 &#x3D; t3</p><p>—&gt;</p><p>t1 &#x3D; id3 * 60.0 </p><p>id1 &#x3D; id2 + t1</p><h3 id="代码生成-Code-Generator-1"><a href="#代码生成-Code-Generator-1" class="headerlink" title="代码生成 Code Generator"></a>代码生成 Code Generator</h3><p>t1 &#x3D; id3 * 60.0 </p><p>id1 &#x3D; id2 + t1</p><p>Code<br>Generation</p><p>LDF R2, id3<br>MULF R2, R2, #60.0 </p><p>LDF R1, id2<br>ADDF R1, R1, R2</p><p> STF id1, R1</p><h3 id="符号表管理-1"><a href="#符号表管理-1" class="headerlink" title="符号表管理"></a>符号表管理</h3><ul><li>由前端执行，符号表与中间代码一起传递到后端</li><li>记录变量名称和存储分配的各种属性、类型、作用域</li><li>记录过程名称和各种属性<ul><li>参数的数量和类型</li><li>传递参数的方式(通过值或引用)</li><li>返回类型</li></ul></li></ul><h3 id="中间语言（Intermediate-Language）IL-1"><a href="#中间语言（Intermediate-Language）IL-1" class="headerlink" title="中间语言（Intermediate Language）IL"></a><strong><strong>中间语言（Intermediate Language）IL</strong></strong></h3><p><img src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%203.png" alt="Untitled"></p><h3 id="编译器与解释器的区别-1"><a href="#编译器与解释器的区别-1" class="headerlink" title="编译器与解释器的区别"></a>编译器与解释器的区别</h3><ul><li><p>1</p><p>  编译器将用高级语言编写的源程序翻译成可以直接在目标计算机上运行的机器码。</p><p>  解释器直接执行源代码中的每条语句，而不需要将程序编译成机器码。</p></li><li><p>2</p><p>  解释器通常花费较少的时间来分析源代码:他们只是解析每个语句并执行它(例如，Python代码)。</p><p>  相比之下，编译器通常会分析语句之间的关系(例如，控制流和数据流)以实现优化。</p></li><li><p>3</p><p>  解释器继续执行程序，直到遇到第一个错误，在这种情况下它们停止。</p><p>  对于编译语言，程序只有在编译成功后才可执行。</p></li></ul><h1 id="第二章词法分析器"><a href="#第二章词法分析器" class="headerlink" title="第二章词法分析器"></a>第二章词法分析器</h1><h2 id="词法分析器的作用"><a href="#词法分析器的作用" class="headerlink" title="词法分析器的作用"></a>词法分析器的作用</h2><ul><li>读取输入字符的源程序，将它们转换为词素，并生成一个标记序列</li><li>必要时向符号表中添加词素去掉注释和空白(空白、换行、制表符等)。</li><li>将错误消息与行号关联(跟踪换行)</li></ul><p>有效执行简单任务、提高编译器效率（比语法分析简单的多）、提高编译器可移植性</p><h3 id="Tokens-Patterns-and-Lexemes"><a href="#Tokens-Patterns-and-Lexemes" class="headerlink" title="Tokens, Patterns, and Lexemes"></a>Tokens, Patterns, and Lexemes</h3><p>token由一对&lt;token name, attribute value&gt;组成，&lt;抽象符号，字符表内容&gt;</p><p>patterns是对tokens的词素可能采取的形式的描述。</p><p>lexeme就是所表示的实例</p><p>例子：printf(“Total &#x3D;%d\n”, score)</p><table><thead><tr><th>Lexeme</th><th>printf</th><th>scorce</th><th>“Total &#x3D;%d\n”</th><th>(</th><th>…</th></tr></thead><tbody><tr><td>Token</td><td>id</td><td>id</td><td>literal</td><td>left_parenthesis</td><td>…</td></tr></tbody></table><h3 id="token属性"><a href="#token属性" class="headerlink" title="token属性"></a>token属性</h3><p>token name：影响属性决策</p><p>attribute value：影响代码分析生成</p><h2 id="令牌规范-正则表达式"><a href="#令牌规范-正则表达式" class="headerlink" title="令牌规范(正则表达式)"></a>令牌规范(正则表达式)</h2><p>Regular expression (正则表达式,regexp)指词素模式的重要符号</p><ul><li>Strings and Languages (串和语言)</li><li>Operations on Languages (语言上的运算)</li><li>Regular Expressions</li><li>Regular Definitions (正则定义)</li><li>Extensions of Regular Expressions</li></ul><h3 id="字符串和语言"><a href="#字符串和语言" class="headerlink" title="字符串和语言"></a>字符串和语言</h3><p>Alphabet(字母表):任何有限的符号集合</p><p>符号的例子:字母、数字和标点符号</p><p>字母的例子:(1,0)，ASCII, Unicode</p><p>string（串)是从字母表中抽取的符号的有限序列</p><p>字符串s的长度，记为Isl，是数符号在s中的出现次数(即基数)</p><p>Empty string（空字符串）:长度为0，ε</p><p><strong>与字符串相关的术语</strong></p><p>Prefix 前缀:从的末尾删除0个或多个符号获得的任何字符串。</p><p>Proper prefix 真前缀:不是ε也不等于s本身的前缀。</p><p>Suffix 后缀:从s 的开头删除0个或多个符号后获得的任何字符串。</p><p>Proper suffix 真后缀:非ε且不等于s的后缀本身</p><p>Substring (子串):从s中删除任何前缀和后缀而得到的任何字符串。</p><p>Proper substring (真子串):不是ε且不等于s本身的子字符串。</p><p>Subsequence (子序列):从s中去掉0个或多个不一定连续的符号而形成的字符串</p><p>Concatenation (连接)：x &#x3D; dog, y &#x3D; house, xy &#x3D; doghouse</p><p>Exponentiation (幂&#x2F;指数运算)：</p><p>$$<br>x &#x3D; dog, x^0 &#x3D; ε,x^1 &#x3D; dog,x^3 &#x3D; dogdogdog<br>$$</p><p>language (语言):任何可数集合的一些固定字母</p><h3 id="Operations-on-Languages-语言的运算"><a href="#Operations-on-Languages-语言的运算" class="headerlink" title="Operations on Languages (语言的运算)"></a>Operations on Languages (语言的运算)</h3><p><img src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%204.png" alt="Untitled"></p><p>优先级:closure*&gt; concatenation &gt; union</p><h2 id="令牌识别-转换图"><a href="#令牌识别-转换图" class="headerlink" title="令牌识别(转换图)"></a>令牌识别(转换图)</h2><p>词法分析器检查输入字符串并找到一个前缀匹配其中一个标记</p><p>构建词法分析器的第一件事是使用常规定义定义令牌的模式</p><p>一个特殊的token: ws→(blank I tab I newline)*</p><h2 id="Transition-Diagrams-状态转换图"><a href="#Transition-Diagrams-状态转换图" class="headerlink" title="Transition Diagrams (状态转换图)"></a>Transition Diagrams (状态转换图)</h2><p>构造词法分析器的一个重要步骤是将模式转换为“转换图”。</p><p>转换图有一组节点，称为状态(state)和边缘(edge)，从一个节点指向另一个节点</p><p><strong>States</strong></p><p>起始状态由标记为“start”的边表示，它从任何地方进入</p><p>接受状态，或者是最终的，表明已经找到了一个词素</p><p><strong>States Cont</strong></p><p>在某些接受状态下，找到的词素可能不包含我们从开始状态看到的所有字符</p><p>这样的状态用*来注释当进入状态时，需要收回指向输入字符串中下一个字符的前向指针。</p><p><strong>Edges</strong></p><p>边从一种状态指向另一种状态</p><p>每条边都用一个或一组符号来标记</p><p><strong>Recognition of Reserved Words and Identifiers (保留字和标识符的识别)</strong></p><p>在许多语言中，保留词或关键字(例如，then)还要匹配标识符的模式</p><h2 id="构建整个词法分析器"><a href="#构建整个词法分析器" class="headerlink" title="构建整个词法分析器"></a>构建整个词法分析器</h2><p>策略1:依次尝试每个令牌的转换图</p><p>Fail()向前重置指针并开始下一个图表</p><p>策略2:并行运行转换图</p><p>需要解决一个图找到一个词素，而其他图仍然能够处理输入的情况。</p><p>解决方案:使用与任何模式匹配的最长的输入前缀</p><p>策略3:将所有转换图组合为一个(首选)</p><p>允许转换图读取输入，直到没有可能下一个状态取与任何模式匹配的最长词素</p><h2 id="词法分析器生成器"><a href="#词法分析器生成器" class="headerlink" title="词法分析器生成器"></a>词法分析器生成器</h2><p>Lex程序有三个部分，用%%分隔</p><ul><li>Declaration (声明)</li><li>Translation rules (转换规则)</li><li>Auxiliary functions section (辅助函数)</li></ul><h2 id="Finite-Automata-有穷自动机"><a href="#Finite-Automata-有穷自动机" class="headerlink" title="Finite Automata (有穷自动机)"></a>Finite Automata (有穷自动机)</h2><h3 id="Nondeterministic-finite-automata-NFA-非确定有穷自动机"><a href="#Nondeterministic-finite-automata-NFA-非确定有穷自动机" class="headerlink" title="Nondeterministic finite automata (NFA, 非确定有穷自动机)"></a>Nondeterministic finite automata (NFA, 非确定有穷自动机)</h3><p>当一个状态面对一个输入符号的时候，所转换到的是一个唯一确定的状态。</p><p>S &#x3D; {0, 1, 2, 3}<br>Start state: 0<br>Accepting states: {3}<br>Transition function<br>▪ (0, a) → {0, 1} (0, b) → {0}<br>▪ (1, b) → {2} (2, b) → {3}</p><p><img src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%205.png" alt="Untitled"></p><h3 id="Transition-Table-转换表"><a href="#Transition-Table-转换表" class="headerlink" title="Transition Table 转换表"></a>Transition Table 转换表</h3><p><img src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%206.png" alt="Untitled"></p><h3 id="Deterministic-finite-automata-DFA-确定有穷自动机"><a href="#Deterministic-finite-automata-DFA-确定有穷自动机" class="headerlink" title="Deterministic finite automata (DFA, 确定有穷自动机)"></a>Deterministic finite automata (DFA, 确定有穷自动机)</h3><p>当一个状态面对一个输入符号的时候，它所转换到的可能不只一个状态，可以是一个状态集合。</p><h1 id="第三章-语法分析"><a href="#第三章-语法分析" class="headerlink" title="第三章:语法分析"></a>第三章:语法分析</h1><h2 id="描述语法"><a href="#描述语法" class="headerlink" title="描述语法"></a>描述语法</h2><blockquote><p>编程语言结构的语法可以通过上下文无关语法或BNF（Backus Naur Form）表示法指定<br>语法为编程语言提供了精确但易于理解的语法规范<br>对于某些语法，我们可以自动构建一个高效的解析器<br>设计得当的语法定义了一种语言的结构，有助于将源程序翻译成正确的目标代码并检测错误<br>语法允许通过添加新的结构来执行新的任务来迭代地进化或开发一种语言</p></blockquote><h3 id="语法分析器的角色"><a href="#语法分析器的角色" class="headerlink" title="语法分析器的角色"></a>语法分析器的角色</h3><ul><li>语法分析器从词法分析器获得token串，并验证token名称是否可以由源语言的语法生成</li><li>以智能的方式报告语法错误</li><li>对于格式良好的程序，语法分析器构建一个语法分析树<br>语法分析树无需显式构建</li></ul><h2 id="语法分析器的分类"><a href="#语法分析器的分类" class="headerlink" title="语法分析器的分类"></a>语法分析器的分类</h2><p>· 通用语法分析器</p><p>· 一些方法（例如，Earley算法1）可以解析任何语法<br>· 然而，它们效率太低，无法在实践中使用</p><p>· 自顶向下语法分析器</p><p>· 构建从顶部（根）到底部（叶）的语法分析树</p><p>· 自底向上语法分析器</p><p>·从底部（叶子）到顶部（根）构建语法分析树</p><p>注意：自上而下和自下而上的解析都从左到右扫描输入，一次扫描一个符号。它们只适用于某些语法，这些语法具有足够的表达能力。</p><h3 id="Context-Free-Grammar-上下文无关文法"><a href="#Context-Free-Grammar-上下文无关文法" class="headerlink" title="Context-Free Grammar (上下文无关文法)"></a>Context-Free Grammar (上下文无关文法)</h3><p>上下文无关语法（CFG）由四个部分组成：<br>· Terminals终结符号: 形成字符串的基本符号（token名称）<br>· Nonterminals非终结符号: 表示字符串集的语法变量 通常对应于一个语言结构，如stmt（statements）      一个非终结符被区分为开始符号 由开始符号表示的字符串集是CFG生成的语言<br>·Productions 产生式: 指定终结符号和非终结符号组合形成字符串的方式<br>     格式：head（左侧）-&gt; body（右侧）<br>     head是非终结符号；body由零个或多个终结符号或非终结符号组成<br>     例如：expression -&gt; expression + term</p><p>下面的语法定义了简单的算术表达式</p><p>Terminal symbols: id, +, -, *, &#x2F;, (, )<br>Nonterminals: expression, term, factor<br>Start symbol: expression<br>Productions:</p><p>expression → expression + term<br>expression → expression – term<br>expression → term<br>term → term * factor<br>term → term &#x2F; factor<br>term → factor<br>factor → ( expression )<br>factor → id</p><blockquote><p>符号简化<br>E → E + T | E – T | T<br>T → T * F | T &#x2F; F | F<br>F → ( E ) | id</p></blockquote><p>“|”是指定备选方案的元符号<br>“(”和”)”不是元符号，而是终结符号</p><h3 id="Derivation-推导"><a href="#Derivation-推导" class="headerlink" title="Derivation (推导)"></a>Derivation (推导)</h3><p>推导: 从开始符号开始，使用产生式重写非终结符，直到只剩下终结符为止</p><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>⇒ 意思是“一步到位”<br>⇒ ∗ 意思是“以零个或多个步骤推导”𝛼 ⇒∗ 𝛼 适用于任何字符串𝛼<br>⇒ “ 意思是“以一个或多个步骤推导”</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>• 如果S⇒ ∗ α, 其中S是语法G的开始符号，我们说α是G文法的句型<br>· 文法的句型可以同时包含终结符号和非终结符号，并且可以为空<br>· 示例𝐸 ⇒ −𝐸 ⇒ −(𝐸)⇒ −(𝐸+𝐸) ⇒ −(𝐢𝐝+𝐸) ⇒ −(𝐢𝐝 + 𝐢𝐝) 这里所有的语法符号串都是文法的句型<br>• 一个G的句子是一个没有非终结符的文法句型<br>· 在上面的例子中，只有最后一个字符串−(𝐢𝐝 + 𝐢𝐝)是一个句子<br>•语法产生的语言是它的一组句子</p><h3 id="最左-最右推导"><a href="#最左-最右推导" class="headerlink" title="最左&#x2F;最右推导"></a>最左&#x2F;最右推导</h3><p>在推导的每一步，我们都需要选择要替换的非终结符<br>在最左推导中,总是选择每个句型中最左边的非终结符来替换<br>在最右推导中, 总是选择最右边的非终结符来替换</p><h3 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h3><p>语法分析树是一种推导的图形表示，它过滤掉了产生式应用的顺序<br>· 根结点是文法的开始符号<br>· 每个叶子结点由终结符或𝜖标记<br>· 每个内部结点由非终结符标记<br>· 每个内部结点代表产生式的应用<br>· 内部节点用产生式的头部中的非终结符进行标记；<br>· 子节点由产生式主体中的符号从左到右进行标记</p><p><img src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%207.png" alt="Untitled"></p><h2 id="Ambiguity-二义性"><a href="#Ambiguity-二义性" class="headerlink" title="Ambiguity (二义性)"></a>Ambiguity (二义性)</h2><p>如果一个语法为某个句子生成了多个语法分析树，则它具有二义性<br>示例：该文法为id+id*id生成了两种语法分析树。</p><p><img src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%208.png" alt="Untitled"></p><p>程序设计语言的语法通常需要明确<br>· 否则，将有多种方法来解释程序<br>· 问题：给定𝐸 → 𝐸 + 𝐸 | 𝐸 ∗ 𝐸 | (𝐸) | 𝐢𝐝, 如何解读 𝑎 + 𝑏 ∗ 𝑐?<br>· 答案：该文法是上一张PPT的示例，根据两种语法分析树，第一种解释：应先处理b*c，然后与a相加；第二种解释：应先处理a+b，然后与c相乘<br>在某些情况下，使用精心选择的歧义语法以及消歧规则来丢弃不需要的语法分析树是很方便的 </p><h2 id="CFG与正则表达式比较-CFG-vs-Regular-Expressions"><a href="#CFG与正则表达式比较-CFG-vs-Regular-Expressions" class="headerlink" title="CFG与正则表达式比较 CFG vs. Regular Expressions"></a>CFG与正则表达式比较 CFG vs. Regular Expressions</h2><p>CFG比正则表达式更具表达能力<br>· 可以用正则表达式描述的每个构造都可以用语法描述，但反之不成立<br>· 每个正则语言都是上下文无关的语言，但反之不成立<br>示例：$𝐿 &#x3D;{𝑎^𝑛𝑏^𝑛 | 𝑛&gt; 0}$<br>语言L可以用CFG：𝑆 → 𝑎𝑆𝑏 | 𝑎𝑏 来描述<br>L不能用正则表达式来描述。换句话说，我们不能构造一个DFA来接受L</p><h3 id="任何正则语言都可以用CFG描述"><a href="#任何正则语言都可以用CFG描述" class="headerlink" title="任何正则语言都可以用CFG描述"></a>任何正则语言都可以用CFG描述</h3><p>（结构证明）NFA可以接受每种常规语言。我们可以构造一个CFG来描述语言：<br>· 对于每个在NFA中的状态 𝑖 ，创建一个非终结符𝐴𝑖<br>· 如果状态𝑖 在碰到输入a转为状态j 时, 添加产生式$𝐴_𝑖→ 𝐴_j$<br>· 如果状态𝑖 是一个接受状态，添加产生式𝐴𝑖→𝜖<br>· 如果状态𝑖 是开始状态，将𝐴𝑖作为文法的开始符号</p><h2 id="语法设计"><a href="#语法设计" class="headerlink" title="语法设计"></a>语法设计</h2><p>CFG能够描述编程语言的大部分（但不是全部）语法<br>· CFG不能描述“使用前应声明标识符”<br>· 后续阶段必须分析解析器的输出，以确保符合此类规则<br>在解析之前，我们通常对语法进行几种转换，使其更适合解析<br>· 消除二义性<br>· 消除左递归<br>· 提取左公因子</p><h3 id="消除二义性"><a href="#消除二义性" class="headerlink" title="消除二义性"></a>消除二义性</h3><p>接近原则：用最接近的未匹配的then匹配else<br>· 重写的想法：出现在then和else之间的语句必须匹配（不能以不匹配的the结束）<br>重写语法以消除歧义是困难的。没有指导这一过程的一般规则。</p><h3 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h3><p>如果语法中存在一个非终结符A，使得某个字符𝛼有相关的产生式𝐴 ⇒+ 𝐴𝛼 ，则该语法为左递归语法<br>立即左递归: 语法有产生式𝐴 -&gt; 𝐴𝛼<br>自顶向下分析方法无法处理左递归语法（自底向上的分析方法可以处理…）</p><p><strong>消除立即左递归</strong><br>简单语法：𝐴 → 𝐴𝛼 | 𝛽 它生成以符号𝛽开头的句子，后面跟零个或更多的𝛼’s<br>将语法替换为：<br>𝐴 → 𝛽A’<br>A’ → 𝛼A’ | 𝜖<br>它现在是右递归了</p><blockquote><p>𝐴 → 𝐴𝛼1|…|𝐴𝛼𝑚|𝛽1|… | 𝛽𝑛<br>将语法替换为：<br>𝐴 →𝛽1A’ | … |𝛽nA’<br>A’ → 𝛼1A’ | … | 𝛼mA’ |𝜖</p></blockquote><p>例子：</p><p><img src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%209.png" alt="Untitled"></p><p>消除左递归<br>消除立即左递归的技术不适用于非立即左递归<br>通用左递归消除算法（迭代）<br>· 输入：没有循环或𝜖-产生式<br>· 输出：没有左递归的等价语法</p><h2 id="Left-Factoring-提取左公因子"><a href="#Left-Factoring-提取左公因子" class="headerlink" title="Left Factoring (提取左公因子)"></a>Left Factoring (提取左公因子)</h2><p>如果我们有以下两个产生式</p><p>𝑠𝑡𝑚𝑡 → 𝐢𝐟 𝑒𝑥𝑝𝑟 𝐭𝐡𝐞𝐧 𝑠𝑡𝑚𝑡 𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡  |𝐢𝐟 𝑒𝑥𝑝𝑟 𝐭𝐡𝐞𝐧 𝑠𝑡𝑚𝑡<br>看到输入时𝐢𝐟, 我们无法立即决定选择哪个产生式<br>一般来说，如果𝐴 → 𝛼𝛽1 | 𝛼𝛽2是两个产生式，并且输入以从𝛼派生的非空字符串开始. 我们可以通过扩大𝐴 到𝛼𝐴‘来推迟选择产生式</p><h2 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h2><p>问题定义：为输入字符串构建一个语法分析树，从根开始，按预序创建语法分析树的节点（深度优先）<br>· 相当于为输入字符串找到最左推导<br>基本思想（两个步骤）：<br>· 预测：在解析的每一步，确定最左边非终结符所用的生产式<br>· 匹配：将所选产生式主体中的终结符与输入字符串相匹配</p><h2 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h2><p>问题定义：为输入字符串构建一个从叶子（终结符）开始并向上延伸到根（语法的开始符号）的语法分析树<br>· 相当于为输入字符串找到最右推导（相反）<br>移入-归约分析技术是自底向上语法分析的通用方式（使用栈来保存语法符号）</p><p>自底向上语法分析可以看作是一个将字符串𝜔“归约”到开始符号的过程<br>在每一个归约步骤中，与产生式主体匹配的特定子串（位于堆栈顶部）都会被产生式的头部替换（与推导步骤相反）</p><h2 id="递归下降的语法分析"><a href="#递归下降的语法分析" class="headerlink" title="递归下降的语法分析"></a>递归下降的语法分析</h2><p>递归下降的语法分析程序对于每个非终结符都有一套程序<br>· 该程序会扫描与非终结符对应的结构（输入的子字符串）<br>从开始符号的程序开始执行<br>· 如果程序扫描整个输入字符串，则宣布成功</p><h2 id="Backtracking-回溯"><a href="#Backtracking-回溯" class="headerlink" title="Backtracking (回溯)"></a>Backtracking (回溯)</h2><p>一般的递归下降语法分析可能需要对输入进行重复扫描（回溯）</p><blockquote><p>算法流程更改：<br>与考察A-产生式不同，我们必须按照一定的顺序尝试每一种可能的产生式。<br>当第7行出现故障时，返回第1行并尝试另一个A产生式<br>为了尝试另一个A-产生式时，我们必须重置指向下一个要扫描的符号的输入指针（失败尝试的消耗符号）</p></blockquote><p>左递归带来的问题<br>如果CFG中有左递归，递归下降的语法分析器可能会进入无限循环，所以需要解析前修改CFG</p><h3 id="𝐹𝐼𝑅𝑆𝑇"><a href="#𝐹𝐼𝑅𝑆𝑇" class="headerlink" title="𝐹𝐼𝑅𝑆𝑇()"></a>𝐹𝐼𝑅𝑆𝑇()</h3><blockquote><p>假设输入字符串为𝒙𝒂<br>假设当前的句型是𝒙𝑨β<br>· 𝑨 是非终结符；β可以同时包含终结符和非终结符<br>如果我们知道产生式𝑨 → 𝑎 | 𝜸的以下事实:<br>·𝑎 ∈ 𝐹𝐼𝑅𝑆𝑇(𝛼) ：𝛼 可以推导以a开头的字符串<br>·𝑎 ∉ 𝐹𝐼𝑅𝑆𝑇(𝛾)：𝛾 不可以推导出以a开头的字符串<br>*𝐹𝐼𝑅𝑆𝑇(𝛼) 表示可从α推导得到的串的首符号的集合</p></blockquote><p>计算FIRST(𝑿) 𝑋 是语法符号<br>· 如果𝑋 是一个终结符，那么FIRST(𝑋) &#x3D; {𝑋}<br>· 如果X是一个非终结符，且𝑋 → 𝑌1𝑌2 … 𝑌𝑘 (𝑘 ≥ 1) 是一个产生式<br>    · 如果对于某个𝑖，𝑎在FIRST(𝑌i)中且𝜖在所有的FIRST(𝑌1), …, FIRST(𝑌i-1)中，就把𝑎加入到FIRST(𝑋)中<br>    · 如果对于所有的FIRST(𝑌1), …, FIRST(𝑌𝑘)，𝜖在其中，那么将𝜖加入到FIRST(𝑋)中<br>· 如果X是一个非终结符，并且存在产生式𝑋 → 𝜖，那么将𝜖加入到FIRST(𝑋)中</p><p>计算FIRST(𝑿𝟏𝑿𝟐 … 𝑿𝒏) 𝑿𝟏𝑿𝟐 … 𝑿𝒏是语法符号的串<br>· 向FIRST(𝑋1𝑋2 … 𝑋𝑛)加入FIRST(𝑋1)中所有的非𝜖符号<br>· 如果𝜖在FIRST(𝑋1)中，再加入FIRST(𝑋2)中所有的非𝜖符号；如果𝜖在FIRST(𝑋1)和FIRST(𝑋2)中，加入FIRST(𝑋3)中的所有非𝜖符号，以此类推。<br>· 最后，如果对于所有的i，𝜖都在FIRST(𝑋i)中，那么将加入到FIRST(𝑋1𝑋2 … 𝑋𝑛)中。</p><blockquote><p>假设输入字符串为𝒙𝒂<br>假设当前的句型是𝒙𝑨β<br>· 𝑨 是非终结符；β可以同时包含终结符和非终结符<br>如果我们知道生产𝑨 →𝛼, 𝜖 ∈ 𝐹𝐼𝑅𝑆𝑇(𝛼), 我们能选择重写A的产生式吗?<br>可以，只有在𝛽 可以推导以𝑎开头的字符串, 即，在一些句型中𝐴 后面可以跟着𝑎 （即，𝒂 ∈ 𝑭𝑶𝑳𝑳𝑶𝑾(𝑨))</p></blockquote><p>计算FOLLOW集<br>计算所有非终结符A的FOLLOW(A)集合<br>· 将$反复到中，其中S是开始符号，二是输入右端的结束标记<br>· 不断应用下面的规则，直到所有FOLLOW集不再改变<br>    · 如果存在一个产生式𝐴 → 𝛼𝐵𝛽，那么FIRST(𝛽)中除𝜖之外的所有符号都在FOLLOW(𝐵)<br>中<br>     · 如果存在一个产生式𝐴 → 𝛼𝐵 ，或存在产生式𝐴 → 𝛼𝐵𝛽且FIRST(𝛽)包含𝜖，那么FOLLOW(𝐴)中的所有符号都在FOLLOW(𝐵)<br>中<br>𝜖不会在任何FOLLOW集中</p><h2 id="LL-1-Grammars"><a href="#LL-1-Grammars" class="headerlink" title="LL(1) Grammars"></a>LL(1) Grammars</h2><p>我们可以为一类称为LL(1)的语法构造不需要回溯的递归下降语法分析器<br>从左到右扫描输入<br>产生最左推导<br>在每一步使用一个前瞻输入符号来作出分析决策</p><blockquote><p>语法𝑮 是LL(1)当且仅当对于任意两个不同的产生式𝐴 → 𝛼 | 𝛽, 以下条件成立：<br>1.不存在终结符𝑎 使得𝛼 和𝛽 都可以推导以𝑎开头的字符串<br>2.𝛼 和𝛽 中最多只有一个可以推导空字符串<br>3.如果𝛽 ⇒* 𝜖, 那么𝛼 不能推导出任何以FOLLOW(𝐴)中某个终结符开头的字符串，反之亦然<br>*这三个条件基本上排除了应用两个产生式的可能性<br>更正式地说：</p></blockquote><ol><li>FIRST(𝛼)∩ FIRST(𝛽)&#x3D; ∅ （上述条件1-2）<br>如果𝜖 ∈ FIRST(𝛽)，那么 FIRST(𝛼)∩ FOLLOW(𝐴)&#x3D; ∅ ，反之亦然<blockquote></blockquote></li></ol><p>对于LL(1)语法，在递归下降语法分析过程中，只需查看当前输入符号，就可以选择应用于非终结符的正确产生式：<br>给定文法<br>给出输入的分析步骤：<br>1.用产生式①重写开始符号stmt： 𝐢𝐟(𝐞𝐱𝐩𝐫)𝑠𝑡𝑚𝑡 𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡<br>2.用产生式②重写最左边的stmt：𝐢𝐟(𝐞𝐱𝐩𝐫)𝐰𝐡𝐢𝐥𝐞(𝐞𝐱𝐩𝐫) 𝑠𝑡𝑚𝑡  𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡<br>3.用产生式③重写最左边的stmt：𝐢𝐟(𝐞𝐱𝐩𝐫)𝐰𝐡𝐢𝐥𝐞(𝐞𝐱𝐩𝐫) 𝐚 𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡<br>4.用产生式③重写最左边的stmt：𝐢𝐟(𝐞𝐱𝐩𝐫)𝐰𝐡𝐢𝐥𝐞(𝐞𝐱𝐩𝐫) 𝐚 𝐞𝐥𝐬𝐞 a</p><h2 id="Parsing-Table-预测分析表"><a href="#Parsing-Table-预测分析表" class="headerlink" title="Parsing Table (预测分析表)"></a>Parsing Table (预测分析表)</h2><p>递归下降语法分析器（或LL分析器）是基于表的解析器<br>预测分析表是一个二维数组，用于确定解析器在看到非终结符A和符号a时应该选择哪个产生式<br>LL(1)解析器的预测分析表没有包含多个产生式的条目</p><h3 id="构造预测分析表"><a href="#构造预测分析表" class="headerlink" title="构造预测分析表"></a>构造预测分析表</h3><p>以下算法可以应用于任何CFG<br>输入：文法G<br>输出：预测分析表M<br>方法：对于每个产生式𝐴 → 𝛼 ，进行以下处理：<br>执行以下操作：<br>    ·对于FIRST(𝛼)中每个终结符𝑎，将𝐴 → 𝛼加入到𝑀[𝐴, 𝑎]<br>    · 如果𝜖在FIRST(𝛼)中，对于FOLLOW(𝐴)中每个终结符b，包括$，将𝐴 → 𝛼加入到𝑀[𝐴, b]<br>将表中的所有空条目设置为错误</p><h2 id="非递归的预测分析"><a href="#非递归的预测分析" class="headerlink" title="非递归的预测分析"></a>非递归的预测分析</h2><p>非递归的预测分析器可以通过显式维护堆栈（而不是通过递归调用隐式维护）来构建<br>· 输入缓冲区包含要解析的字符串，以$结尾<br>· 堆栈包含底部为$的语法符号序列。<br>最初，堆栈只包含$和在$顶部的开始符号𝑆</p><h3 id="表驱动的预测语法分析"><a href="#表驱动的预测语法分析" class="headerlink" title="表驱动的预测语法分析"></a>表驱动的预测语法分析</h3><p>输入：字符串𝜔 和文法G的预测分析表M<br>输出：如果𝜔 在𝐿(𝐺)中, 输出𝜔的一个最左边推导; 否则，给出一个错误指示<br>最初，输入缓冲区包含𝜔$<br>开始符号𝑆 位于堆栈顶部，在$上方。</p><p><img src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%2010.png" alt="Untitled"></p><h2 id="自底向上分析"><a href="#自底向上分析" class="headerlink" title="自底向上分析"></a>自底向上分析</h2><p>自底向上的语法分析<br>问题定义：为输入字符串构建一个从叶子（终结符）开始并向上延伸到根（语法的开始符号）的语法分析树<br>· 相当于为输入字符串找到最右边的推导（相反）<br>移入-归约分析技术是一种自底向上语法分析的通用方式（使用栈来保存语法符号）</p><h3 id="Reductions-归约"><a href="#Reductions-归约" class="headerlink" title="Reductions (归约)"></a>Reductions (归约)</h3><p>自底向上语法分析可以看作是一个将字符串𝜔“归约”到开始符号的过程<br>在每一个归约步骤中，与产生式体匹配的特定子串（位于栈顶部）会被产生式的头部替换（与推导步骤相反）</p><h3 id="Handles-句柄"><a href="#Handles-句柄" class="headerlink" title="Handles (句柄)"></a>Handles (句柄)</h3><p>非正式地讲，句柄是和某个产生式体匹配的子串，对它的归约代表了相应的最右推导中的一个反向步骤<br>正式地讲，如果$S \Rightarrow^*_{rm} \alpha A<br>\omega\Rightarrow^*_{rm} \alpha \beta<br>\omega$，那么紧跟𝛼的产生式𝐴 → 𝛽 （或者简单地𝛽) 是句型𝛼𝛽𝜔的一个句柄</p><h3 id="Handle-Pruning-句柄剪枝"><a href="#Handle-Pruning-句柄剪枝" class="headerlink" title="Handle Pruning (句柄剪枝)"></a>Handle Pruning (句柄剪枝)</h3><p>在最右句型中， 句柄右侧的字符串必须仅包含终结符号<br>如果一个文法是无二义性的，那么该文法的每个右句型都有且只有一个句柄<br>通过句柄剪枝可以得到一个反向的最右推导</p><p>移入-归约语法分析技术是自底向上语法分析的一种通用方式，其中：</p><p>· 使用栈保存文法符号<br>· 使用输入缓冲区保存要进行语法分析的字符串的其余部分<br>· 栈内容（从底部到顶部）和输入缓冲区内容形成最右句型（假设没有错误）</p><p><strong>初始状态：</strong><br>移入-归约过程：<br>· 语法分析器将零个或多个输入符号转移到栈顶上，直到它可以对栈顶的一个文法符号串𝛽进行归约为止<br>· 将𝛽归约为某个产生式的头<br>语法分析器重复上述循环，直到检测到错误或栈包含开始符号且输入为空<br>*在移入-归约解析过程中，句柄最终总是出现在栈的顶部</p><h2 id="简单LR"><a href="#简单LR" class="headerlink" title="简单LR"></a>简单LR</h2><p>LR(k)语法分析器：最流行的自底向上的语法分析器类型<br>   · L： 从左到右扫描输入<br>   · R： 反向构造最右推导<br>   · k： 在做出解析决策时使用k个前瞻性输入符号<br>LR(0)和LR(1)语法分析器具有实际意义<br>当𝑘 ≥ 2时，语法分析器变得太复杂，无法构建（解析表太大，无法管理）</p><p>LR语法分析器的优势<br>· 表驱动（类似于非递归LL语法分析器）、强大<br>    · 尽管手工构建LR语法分析器工作量太大，但也有一些语法分析器生成器可以自动构建语法分析表<br>    · 相比之下，LL语法分析器往往更容易手工编写，但功能较弱（处理的语法较少）<br>· LR语法分析技术是已知的最通用的非回溯移入-归约语法分析方法<br>· LR语法分析器可以被构造为识别几乎所有可以为其编写CFG的编程语言结构<br>· LR语法比LL语法可以描述更多的语言<br>    · 回想文法成为LL(1)的严格条件</p><h2 id="LR-0-Items-LR-0-项"><a href="#LR-0-Items-LR-0-项" class="headerlink" title="LR(0) Items (LR(0)项)"></a>LR(0) Items (LR(0)项)</h2><p>一个LR语法分析器通过维护一些状态来跟踪在语法分析中所处的位置，从而来做出移入-归约的决策。<br>LR(0)项（简称item）是产生式再加上一个位于它的体中某处的点，表示在语法分析过程中的给定点上，我们已经看到了一个产生式的哪些部分。<br>𝐴 →} 𝑋𝑌𝑍        𝐴 → 𝑋 } 𝑌𝑍        𝐴 → 𝑋𝑌 } 𝑍         𝐴 → 𝑋𝑌𝑍 }<br>𝐴 → 𝑋 } 𝑌𝑍: 我们刚刚在输入中看到了一个可以由X推导得到的字符串，我们希望接下来看到一个能从YZ推导得到的字符串<br>状态：LR(0)项集<br>产生式𝐴 → 𝜖 仅生成一个item 𝐴 → ·</p><h3 id="规范LR-0-项集族"><a href="#规范LR-0-项集族" class="headerlink" title="规范LR(0)项集族"></a>规范LR(0)项集族</h3><p>LR(0)项集合的一个集合，称为规范LR(0)项集族, 为构建用于做出语法分析决定的DFA提供了基础<br>为了构造文法的LR(0)项集规范族，我们需要定义：<br>· 增广文法<br>· 两个函数：（1）项集闭包的CLOSURE 和（2）GOTO</p><h3 id="增广文法"><a href="#增广文法" class="headerlink" title="增广文法"></a>增广文法</h3><p>增广一个以S为开始符号的文法G：<br>· 引入一个新开始符号S‘代替S<br>· 增加产生式S‘ -&gt; S<br>明显地𝐿(𝐺)&#x3D;𝐿(𝐺’)<br>优点：通过增广，只有当语法分析器使用𝑆’ → 𝑆进行归约时输入符号串被接受。否则，输入符号串可能在多处被接受，因为可能存在多个𝑆-产生式</p><h3 id="项集闭包"><a href="#项集闭包" class="headerlink" title="项集闭包"></a>项集闭包</h3><p>如果𝐼 是文法𝐺的一组项集, 那么CLOSURE(𝐼)就是按照下面两条规则构造的项集：</p><ol><li>一开始，将𝐼中的各个项加入到CLOSURE(𝐼)</li><li>如果𝐴 → 𝛼 · 𝐵𝛽在CLOSURE(𝐼)中，𝐵 → 𝛾是一个产生式，并且𝐵 → ·𝛾不在CLOSURE(𝐼)中，那么将𝐵 → ·𝛾加入CLOSURE(𝐼)中。不断应用这条规则，直到没有新项可以加入到<br>直观地讲：𝐴 → 𝛼 · 𝐵𝛽 表示我们希望看到从一个能够从𝐵𝛽推导得到的子串。这个子串的某个前缀可以从B推导得到。因此，我们将所有𝐵-产生式加入到项集。</li></ol><h3 id="GOTO函数"><a href="#GOTO函数" class="headerlink" title="GOTO函数"></a>GOTO函数</h3><p>𝐆𝐎𝐓𝐎(𝑰, 𝑿) 其中𝑰是一个项集而𝑿是一个文法符号，被定义为𝑰中所有形如的项所对应的项的集合的闭包。</p><h3 id="LR-0-自动机"><a href="#LR-0-自动机" class="headerlink" title="LR(0)自动机"></a>LR(0)自动机</h3><p>“简单LR语法分析技术”（即SLR分析技术）的中心思想是根据文法构造出LR(0)自动机。<br>· 这个自动机的状态是规范LR(0)项集族<br>· 它的转换由GOTO函数给出<br>· 开始状态是CLOSURE({𝑆’ →· 𝑆})</p><h3 id="LR-0-自动机的使用"><a href="#LR-0-自动机的使用" class="headerlink" title="LR(0)自动机的使用"></a>LR(0)自动机的使用</h3><p>帮助做出移入-归约决定：<br>· 假设文法符号𝛾 使自动机从开始状态0运行到某个状态𝑗<br>· 如果下一个输入符号为𝑎且状态𝑗有一个在𝑎上的转换，那就移入𝑎<br>· 否则，归约；状态𝑗的项将会告诉我们使用哪个产生式进行归约</p><p>栈只保存状态，文法符号可以从相应状态中获取</p><h3 id="LR语法分析器结构"><a href="#LR语法分析器结构" class="headerlink" title="LR语法分析器结构"></a>LR语法分析器结构</h3><p>LR语法分析器由一个输入、一个输出、一个栈、一个驱动程序和一个语法分析表（ACTION+GOTO）组成<br>所有LR语法分析器的驱动程序都是相同的；只有语法分析表随语法分析器的不同而变化<br>栈保存一个状态序列<br>在SLR中，栈保存来自LR(0)自动机的状态<br>语法分析器根据（1）栈顶部的状态和（2）从输入缓冲区读取的终结符来决定下一个动作</p><h3 id="LR语法分析表：ACTION-GOTO"><a href="#LR语法分析表：ACTION-GOTO" class="headerlink" title="LR语法分析表：ACTION + GOTO"></a>LR语法分析表：ACTION + GOTO</h3><p>ACTION函数接受两个参数：（1）状态𝑖 和（2）终结符𝑎 （或$）<br>ACTION[𝒊, 𝒂] 可以具有以下四种形式的值之一：<br>· 移入𝒋: 其中𝑗是一个状态，把输入符号𝑎移入栈中，但使用状态𝑗 代表𝑎<br>· 归约𝑨 →𝛽: 将栈顶的𝛽归约为产生式头A<br>· 接受：语法分析器接受输入并完成语法分析过程<br>· 报错：存在语法错误<br>将定义在项集上的GOTO函数扩展为定义在状态集上的函数：如果GOTO(𝐼𝑖, 𝐴) &#x3D; 𝐼𝑗，那么GOTO也把状态𝑖和一个非终结符A映射到状态𝑗</p><h3 id="LR语法分析器的态势"><a href="#LR语法分析器的态势" class="headerlink" title="LR语法分析器的态势"></a>LR语法分析器的态势</h3><p>“态势”是表示语法分析器完整状态的符号。态势是一个形如：(𝑠0𝑠1 … 𝑠𝑚, 𝑎i𝑎i+1 … 𝑎𝑛$)的对<br>第一个分量是栈中的内容，第二个分量是余下的输入。<br>根据结构，每个状态（除𝑠0）对应于一组项和文法符号（导致状态转换的符号，即传入边上的符号）<br>· 假设𝑋i是状态𝑠i的文法符号<br>· 那么𝑋0𝑋1 … 𝑋𝑚𝑎i𝑎i+1 … 𝑎𝑛是最右句型（假设没有错误）</p><h3 id="构造SLR语法分析表"><a href="#构造SLR语法分析表" class="headerlink" title="构造SLR语法分析表"></a>构造SLR语法分析表</h3><p>SLR语法分析表𝐺以LR(0)项和LR(0)自动机为基础。</p><ol><li>构造增广文法G‘的规范LR(0)项集族{𝐼0, 𝐼1, … , 𝐼𝑛}</li><li>根据𝐼i构造得到状态i，状态i的语法分析动作按照下面的方法决定：<br>· 如果[𝐴 → 𝛼 · 𝑎𝛽]在𝐼𝑖中并且GOTO [𝐼𝑖, 𝑎 ]&#x3D; 𝐼j，那么将ACTION[ 𝑖, 𝑎]设置为“移入j”<br>· 如果[𝐴 → 𝛼·]在𝐼𝑖中，那么对于𝐅𝐎𝐋𝐋𝐎𝐖(𝑨)中的所有𝑎，将设置ACTION[ 𝑖, 𝑎]为“归约𝐴 → 𝛼”。这里𝐴不等于S’<br>· 如果[𝑆’ → 𝑆·]在𝐼𝑖中，那么将设置ACTION[𝑖, $]为“接受”</li><li>状态i对于各个非终结符号A的转换使用下面的规则构造得到：如果GOTO [𝐼i, 𝐴]&#x3D; 𝐼𝑗，那么GOTO[𝑖, 𝐴]&#x3D; 𝑗</li><li>规则2、3没有定义的所有条目都设置为“报错”</li><li>语法分析器的初始状态就是根据[𝑆′ → · 𝑆]所在项集构造得到的状态<br>如果在语法分析构造过程中没有冲突（即，一个表项的多个条目），则语法为SLR（1）</li></ol><p>在SLR中，状态𝑖 要求归约𝐴 → 𝛼，如果项集$𝐼_𝑖$包含项[𝐴 → 𝛼 · ] ，同时输入符号𝑎 在FOLLOW(𝐴)中<br>在某些情况下，归约后𝛽𝛼 在栈顶上会变成𝛽𝐴， 后面跟着的不是𝑎的任何最右句型</p><h2 id="规范LR"><a href="#规范LR" class="headerlink" title="规范LR"></a>规范LR</h2><h3 id="规范LR-1-项"><a href="#规范LR-1-项" class="headerlink" title="规范LR(1)项"></a>规范LR(1)项</h3><p>在状态中携带更多信息以排除一些无效的归约（通过分裂LR（0）状态）<br>LR(1)项的一般形式：[𝐴 → 𝛼 · 𝛽, 𝑎]<br>· 𝐴 → 𝛼𝛽是一个产生式，𝑎是一个终结符或右端结束标记<br>· 1指的是第二个分量𝑎的长度，第二个分量𝑎叫做向前看字符<br>· 当𝛽不为空时，向前看字符没有任何作用因为它决定是否归约<br>· 一个形如[𝐴 → 𝛼· , 𝑎]的项只有在下一个输入符号等于𝑎时，才会按照𝐴 → 𝛼进行归约。这样的𝑎的集合总是的FOLLOW(𝐴)子集<br>𝐴 → 𝛼𝛽 是一个生产和𝑎 是终端还是$“1”是指第二个组成部分的长度：展望(向前看字符)*如果𝛽 不是𝜖 因为它只帮助确定是否减少(𝑎 将在状态转换期间继承）表单中的一项𝐴 → 𝛼· , 𝑎要求减少𝐴 → 𝛼 仅当下一个输入符号𝑎 （𝑎’s是FOLLOW的子集(𝐴))*：LR（0）项没有先行符号，因此它们被称为LR（0</p><blockquote><p>构造LR（1）项集族本质上与构造规范LR（0）项集族相同。唯一的区别在于CLOSURE和GOTO函数。</p></blockquote><p>构造LR（1）项集族本质上与构造规范LR（0）项集族相同。唯一的区别在于CLOSURE和GOTO函数。<br>向前看符号从现有项传递到新项</p><h3 id="构造规范LR-1-语法分析表"><a href="#构造规范LR-1-语法分析表" class="headerlink" title="构造规范LR(1)语法分析表"></a>构造规范LR(1)语法分析表</h3><ol><li>构造增广文法G‘的规范LR(1)项集族{𝐼0, 𝐼1, … , 𝐼𝑛}</li><li>根据𝐼i构造得到状态i，状态i的语法分析动作按照下面的方法决定：<br>· 如果[𝐴 → 𝛼 · 𝑎𝛽, 𝑏 ]在𝐼𝑖中并且GOTO [𝐼𝑖, 𝑎 ]&#x3D; 𝐼j，那么将ACTION[ 𝑖, 𝑎]设置为“移入j”<br>· 如果[𝐴 → 𝛼·, 𝑎 ]在𝐼𝑖中，设置ACTION[ 𝑖, 𝑎]为“归约𝐴 → 𝛼”。这里𝐴不等于S’<br>· 如果[𝑆’ → 𝑆·, $ ]在𝐼𝑖中，那么将设置ACTION[𝑖, $]为“接受”<br>如果以上规则导致任何冲突的动作，我们就说这个文法不是LR(1)的。</li><li>状态i对于各个非终结符号A的转换使用下面的规则构造得到：如果GOTO [𝐼i, 𝐴]&#x3D; 𝐼𝑗，那么GOTO[𝑖, 𝐴]&#x3D; 𝑗</li><li>规则2、3没有定义的所有条目都设置为“报错”</li><li>语法分析器的初始状态就是根据[𝑆′ → · 𝑆, $]所在项集构造得到的状态</li></ol><h2 id="Lookahead-LR-LALR"><a href="#Lookahead-LR-LALR" class="headerlink" title="Lookahead LR (LALR)"></a>Lookahead LR (LALR)</h2><p>SLR(1)的功能不足以处理大量语法（回想一下以前的明确语法）<br>LR(1)在语法分析表中有一组庞大的状态（状态过于细粒度）<br>LALR(1)在实践中经常使用<br>· 在项中保留向前看符号<br>· 它的状态数与SLR(1)的状态数相同<br>· 可以处理现代程序设计语言中最常见的句法结构</p><p>寻找具有相同核心的LR(1)项集<br>LR(1)项集的核心是第一个分量的集合<br>· 𝐼4和𝐼7的核心是{𝐶 → 𝑑 ·}<br>· 𝐼3和𝐼6的核心是{𝐶 → 𝑐·𝐶,𝐶 → ·𝑐𝐶,𝐶 → ·𝑑}</p><blockquote><p>一般而言，一个核心就是LR(0)项集<br>我们可以将具有共同核心的LR(1)项集合并为一组项目<br>由于GOTO的核心(𝐼, 𝑋) 仅取决于𝐼, 合并项集的GOTO目标也具有相同的核心，因此可以合并</p></blockquote><h3 id="状态合并引发的冲突"><a href="#状态合并引发的冲突" class="headerlink" title="状态合并引发的冲突"></a>状态合并引发的冲突</h3><p>合并LR(1)语法分析表中的状态可能会导致冲突<br>合并不会导致移入&#x2F;归约冲突<br>· 假设合并后在向前看符号𝑎上存在移入&#x2F;归约冲突<br>· 有一个项[𝐴 → 𝛼·, 𝑎] 要求归约𝐴 → 𝛼<br>· 有其他项[𝐵 → 𝛽· 𝑎𝛾, ?]要求移入<br>· 由于要合并的集合的核心是相同的，因此合并前必须有一个集合同时包含[𝐴 → 𝛼· , 𝑎] 以及[𝐵 → 𝛽· 𝑎𝛾, ?]<br>· 那么根据LR(1)语法分析表构造算法，在合并之前，已经在𝑎上存在移入&#x2F;归约冲突 。该文法不是LR（1）。<br>合并状态可能导致归约&#x2F;归约冲突</p><p>构造LR(1)项集族$𝐶 &#x3D; {𝐼_0，𝐼_1，𝐼_𝑛}$<br>对于LR(1)项集中的每个核心，找出所有具有这个核心的项集，并将这些项集替换为它们的并集<br>令$𝐶’ &#x3D; {J_0，J_1，J_𝑛}$是合并后得到的项集族。<br>· 状态$𝑖$的语法分析动作是按照LR(1)语法分析表构造算法中的方法根据$𝐽_i$构造得到的<br>· 如果存在一个分析动作冲突，这个算法就不能生成语法分析器，这个文法不是LALR(1)的</p><p><strong>GOTO表构造方法如下：</strong></p><p>· 如果𝐽是一个或多个LR(1)项集的并集。也就是说 𝐽 &#x3D; 𝐼1 𝖴 𝐼2 𝖴 ⋯ 𝖴 𝐼𝑘，那么GOTO(𝐼1, 𝑋), GOTO(𝐼2, 𝑋), …, GOTO(𝐼𝑘, 𝑋)的核心是相同的，因为𝐼1, 𝐼2, … , 𝐼𝑘具有相同的核心<br>· 令𝐾是所有和GOTO(𝐼1, 𝑋)具有相同核心的项集的并集<br>· 那么GOTO(𝐽, 𝑋)&#x3D; 𝐾</p><h2 id="错误恢复"><a href="#错误恢复" class="headerlink" title="错误恢复"></a>错误恢复</h2><p><strong>LR语法分析中的错误恢复</strong></p><p>LR语法分析器应该能够处理错误：<br>· 报告错误的精确位置<br>· 从错误中恢复并继续分析<br>两种典型的错误<br>· 恐慌模式<br>· 短语层次的恢复</p><p><strong>恐慌模式</strong><br>基本思想：丢弃零个或多个输入符号，直到同步词法单元已找到<br>原理：<br>· 语法分析器总是查找可以从非终结符𝐴推导的输入的前缀<br>· 当出现错误时，意味着无法找到这样的前缀<br>· 如果错误仅发生在与𝐴相关的部分, 我们可以通过寻找一个可以合法跟随的符号来跳过这一部分<br>· 示例：如果𝐴 是𝑠𝑡𝑚𝑡, 则同步词法单元可以是分号</p><p><strong>短语层次的恢复</strong><br>基本思路：<br>· 检查语法分析表中的每个错误条目，并确定最有可能导致错误的程序员错误<br>· 修改栈顶部或第一个输入符号，并向程序员发出消息<br>短语层次的恢复示例：<br>· 删除右侧的）<br>· 提示“不匹配的右括号”。</p><h2 id="语法分析器生成工具"><a href="#语法分析器生成工具" class="headerlink" title="语法分析器生成工具"></a><strong>语法分析器生成工具</strong></h2><p>本节将介绍如何使用语法分析器生成工具来帮助构造一个编译器的前端，我们将使用LALR语法分析生成工具Yacc作为讨论的基础。Yacc，又一个编译器的编译器<br>Yacc在UNIX系统中是以命令的方式出现的，它已经用于实现多个编译器产品。Bison 是GNU项目的一部分，是对Yacc的扩展和改进。</p><p><strong>声明</strong><br>· 通常的C声明<br>· 对词法单元的声明<br><strong>翻译规则</strong><br>· 翻译规则 &#x3D; 产生式 + 语义动作<br><strong>辅助性C语言例程</strong><br>· 将会被直接拷贝至y.tab.c<br>· 可以在语义动作中调用<br>· 必须提供yylex()这一词法分析器，它将返回一个由词法单元和相关属性组成的词法单元<br>· 可以添加错误恢复例程等其他过程</p><blockquote><p><strong>翻译规则</strong><br>第一个产生式头符号被视为开始符号<br>一个语义动作是一个C语句的序列<br>· $$表示和相应产生时头部的非终结符关联的属性值<br>· $i表示和相应产生式体中第i个文法符号关联的属性值<br>当我们按照一个产生式归约时就会执行盒盖产生式相关联的语义动作<br>· 我们通常根据$i的值来计算$$的值</p></blockquote><h3 id="Yacc的冲突解决"><a href="#Yacc的冲突解决" class="headerlink" title="Yacc的冲突解决"></a>Yacc的冲突解决</h3><p>默认策略：<br>· 移入&#x2F;归约冲突：始终移入<br>· 归约&#x2F;归约冲突：归约第一个列出的产生式<br>指定终结符的优先级和结合性：<br>· 结核性：%left、%right、%nonassoc<br>· 移入𝒂&#x2F;归约𝑨 → 𝑎 冲突：比较的优先级𝑎 和𝐴 →𝛼 （优先级不够时使用结合性）<br>· 终结符的声明顺序决定了它们的优先级<br>· 一个产生式的优先级等于它最右边终结符的优先级。也可以使用%prec<terminal>指定，它将产生式的优先级定义为与终结符相同</p><h3 id="Yacc的错误恢复"><a href="#Yacc的错误恢复" class="headerlink" title="Yacc的错误恢复"></a>Yacc的错误恢复</h3><p>在Yacc中，错误恢复使用一种错误产生式的形式：<br>· 一般形式：𝐴 → 𝐞𝐫𝐫𝐨𝐫 𝛼<br>· 用户可以决定哪些非终结符（例如，生成表达式、语句、块等的非终结符）将具有错误产生式<br>错误示例：𝒔𝒕𝒎𝒕 → 𝐞𝐫𝐫𝐨𝐫 ;<br>· 该错误产生式规定当语法分析器遇到错误时，它要跳到下一个分号之后，并假设已经找到一条语句<br>· 将调用错误产生式的语义动作不需要处理输入，只需生成诊断消息</p><h1 id="Chapter-4-Syntax-Directed-Translation"><a href="#Chapter-4-Syntax-Directed-Translation" class="headerlink" title="Chapter 4:  Syntax-Directed Translation"></a>Chapter 4:  Syntax-Directed Translation</h1><h3 id="语法制导的翻译"><a href="#语法制导的翻译" class="headerlink" title="语法制导的翻译"></a><strong>语法制导的翻译</strong></h3><p>• 读取源程序的输入字符，将其归类为词素，并生成词素序列<br>• 必要时将词目添加到符号表中<br>• 删除注释和空白（空格、换行符、制表符等）<br>• 将错误信息与行号关联起来（跟踪换行符）</p><p>语法制导定义（SDD）是一种无上下文语法，同时包含属性和规则。<br>  一组属性（attributes）与每个语法符号相关联*。<br>    可以是任何属性，例如表达式的数据类型，# 生成代码中的指令<br>  语义规则（semantic rule）与语法生成相关联，描述如何计算属性<br>  属性代码表示结构体的后缀符号<br>  || 是字符串连接操作符</p><h3 id="合成属性"><a href="#合成属性" class="headerlink" title="合成属性"></a><strong>合成属性</strong></h3><p>如果一个属性在解析树节点 N 上的值仅由 N 的子节点和 N 本身的属性值决定，则称该属性为合成属性；</p><h3 id="SDD-不指定解析树上属性的计算顺序"><a href="#SDD-不指定解析树上属性的计算顺序" class="headerlink" title="SDD 不指定解析树上属性的计算顺序"></a><strong>SDD 不指定解析树上属性的计算顺序</strong></h3><p>任何顺序，只要能在依赖的所有其他属性之后计算一个属性就可以了合成属性有一个很好的特性，<br>即它们可以在解析树的一次自下而上的遍历中进行评估（通常不需要显式创建解析树）。</p><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a><strong>继承属性</strong></h3><p>继承属性在解析树节点上的值由该节点本身、其父节点和解析树中同级节点的属性值决定<br>回答：继承属性在处理与上下文相关的问题时仍然是非常有用的。它为我们提供了一种在语法树中考虑外部信息的方法，从而使得我们可以更为精确和灵活地描述语法制导定义的属性</p><p>给定解析树节点 $N,M_1,M_2,M_3,…,M_k，$如果 N 的属性 a 定义为 $N.a &#x3D; f(M_1,a_1,M_2,a_2,…,M_k,a_k)$，那么为了计算 N.a，我们必须先计算 $M_1. a_1$。<br>依赖图 (依赖图) 是确定评估顺序的有用工具<br>    描述特定解析树中属性实例之间的信息流<br>    为属性实例之间的部分顺序建模</p><p>从一个属性实例$（a_1）$到另一个属性实例$（a_2）$的边表示计算 $a_2$ 的值需要 $a_1$ 的值。<br>如果依赖关系图中存在循环，我们就无法找到计算所有属性实例值的顺序ε</p><h3 id="S-属性定义"><a href="#S-属性定义" class="headerlink" title="S 属性定义"></a>S 属性定义</h3><p>如果每个属性都是合成的，那么语法制导定义就是 S 属性的<br>直观地说，任何解析树的依赖关系图中都不可能存在循环，因为边总是从子节点到父节点，而不是相反。</p><p>当 SDD 具有 S 属性时，我们可以按照解析树节点的任何自下而上的顺序评估其属性。<br>例如，解析树的后序遍历（postorder traversal)<br>S 属性定义可以在自下而上的解析过程中轻松实现（相当于后序遍历）</p><h3 id="L-属性定义"><a href="#L-属性定义" class="headerlink" title="L 属性定义"></a>L 属性定义</h3><p>如果对于每个产品 $A → X_1X_2…X_n$，对于每个 J &#x3D; 1 … n，$x_j$ 的每个继承属性仅取决于以下属性，则 SDD 是 L 属性 SDD：<br>$x_1,…x_{j-1}$ 的属性（合成的或继承的），<br>或 A 的继承属性<br>依赖关系图的边可以从左到右（对于解析树而言），但不能从右到左（因此称为 “L-属性”）。</p><h3 id="L-属性定义的属性评估"><a href="#L-属性定义的属性评估" class="headerlink" title="L 属性定义的属性评估"></a>L 属性定义的属性评估</h3><p>输入: 解析树 T 中的节点 n<br>输出: 以 n 为根的子树属性的评估顺序<br>程序 depth_first(n)*<br>开始<br>      对于 n 的每个子节点 m，从左到右依次执行 开始<br>      评估 m 的继承属性；<br>      depth_first(m); &#x2F;&#x2F; 这里将评估 m 的合成属性<br>      结束<br>      评估 n 的合成属性；<br>      保证：在评估节点的继承属性时，已评估了其左侧节点的属性<br>end</p><h2 id="构建语法树"><a href="#构建语法树" class="headerlink" title="构建语法树"></a>构建语法树</h2><p><strong>抽象语法树</strong></p><p>每个内部节点 N 代表一个结构体（对应一个运算符）<br>N 的子节点代表 N 所代表结构的有意义成分（相当于操作数）</p><p><strong>语法树与解析树</strong></p><p>在语法树中，内部节点代表编程结构，而在解析树中，内部节点代表非终结符*。<br>解析树也称为具体语法树，其底层语法称为语言的具体语法</p><p>为简单表达式构建语法树的 S 属性 SDD<br>语法树的每个节点都是一个对象，其中有一个字段 op（代表节点的标签）和一些附加字段<br>叶节点：一个包含词法值的附加字段<br>内部节点：额外的字段数量等于子节点的数量</p><h2 id="计算类型的结构"><a href="#计算类型的结构" class="headerlink" title="计算类型的结构"></a>计算类型的结构</h2><p>• 正则语言（regular language）是一种可由 regexp<br>• 如果两个 regexps r 和 s 表示相同的语言，那么它们是等价的，写成 r &#x3D; s</p><p><strong>合成属性</strong>：这种属性通常用于将信息从叶子节点向上传递到父节点。在这里，合成属性t代表一个类型，这意味着某个节点（可能是一个变量或表达式）的类型可以通过计算其子节点的属性来确定，并将这个类型作为其自己的t属性。<br><strong>继承属性</strong>：这种属性是从父节点传递给子节点的。在这个描述中，继承属性t在解析树中向下传递一个基本类型。这通常意味着上层节点（例如，声明或类型定义的上下文）已经确定了某种基本类型，这个类型需要向下传递给子节点，以确保子节点可以根据这个类型进行相应的操作或检查。</p><h2 id="Syntax-Directed-Translation-Schemes"><a href="#Syntax-Directed-Translation-Schemes" class="headerlink" title="Syntax-Directed Translation Schemes"></a>Syntax-Directed Translation Schemes</h2><p>SDD 告诉我们在翻译中要做什么（高级规范），但不告诉我们如何做<br>语法制导的翻译方案（SDT’s，Syntax-directed translation schemes）规定了如何进行翻译的更多细节。<br>SDT 是一种无上下文语法，其语义动作（程序片段）嵌入在生产体中 ：<br>与 SDD 的语义规则不同<br>语义动作可以出现在制作体的任何地方</p><p>任何 SDT 都可以通过以下方式实现：</p><p>首先构建一棵解析树<br>将语义操作视为 “虚拟 “解析树节点<br>执行从左到右的深度优先（即预排序）树遍历，并在访问相应节点时触发操作</p><p><strong>SDD（Syntax Directed Definition）</strong>：<br>SDD定义了与语法产生式关联的属性和规则。它为每个语法产生式指定一个或多个属性计算或语义动作。<br>SDD关注于如何为语法树中的节点计算属性值，但不一定涉及产生中间代码或目标代码的具体操作。<br>它可以有合成属性和继承属性，因此可以描述为S属性的（只有合成属性）或L属性的（允许继承属性但有限制）。<br><strong>SDT（Syntax Directed Translation）</strong>：<br>SDT是SDD的一个特例，它专门用于生成中间代码或目标代码。换句话说，SDT的目的是翻译，它定义了与语法产生式关联的动作，这些动作通常在解析时执行。<br>当解析器在处理产生式时，与该产生式关联的SDT动作被执行，从而生成代码或进行其他翻译工作。<br>动作可以嵌入到产生式中，例如，在YACC或Bison这样的工具中，可以直接在语法规则中插入C代码作为动作。<br><strong>总结差异</strong>：<br>SDD更为通用，关注于为语法树的节点计算属性。这些属性可以用于多种目的，如类型检查、变量绑定等。<br>SDT特化于翻译任务，即将源代码转换为中间代码或目标代码。它通常涉及在解析过程中执行特定的动作。<br>尽管有这些区别，但在实际应用中，SDD和SDT的界限可能会模糊，因为编译器的语义分析和翻译阶段通常是交织在一起的</p><p>$$<br>B-&gt;X{a}Y<br>$$</p><p>动作 a 应在我们识别完 X（如果 X 是终端）或由 X 派生的所有终端（如果 X 是非终端）后执行<br>如果解析是自下而上的，那么一旦 X 出现在解析栈顶端，我们就执行操作 a<br>如果解析是自上而下的，我们在尝试扩展 Y（如果 Y 是非终端）或检查输入中的 Y（如果 Y 是终端）之前执行操作 a</p><blockquote><p><strong>底层语法是LR，而SDD是S属性的</strong>：<br><strong>LR语法</strong>：这是一种可以用自底向上的方式进行解析的语法。LR解析器从左到右读取输入，但决策是基于右侧的上下文进行的。它使用一个堆栈来存储已经读取的符号，并在适当的时候进行规约。<br><strong>S属性的SDD</strong>：这意味着所有属性都是合成属性，它们只从子节点传递给父节点，没有从父节点传递给子节点的继承属性。这对于自底向上的LR解析是非常合适的，因为我们从叶子节点开始构建并向上移动，因此只需要合成属性即可。<br>底层语法是LL，而SDD是L属性的：<br><strong>LL语法</strong>：这是一种可以用自顶向下的方式进行解析的语法。LL解析器从左到右读取输入，并基于左侧的上下文来进行决策。它通常使用递归下降的方法，直接从起始符号开始，并尝试应用各种产生式。</p></blockquote><p>如果 SDD 的语法是 LR，而且 SDD 是 S 属性的，那么我们就可以构造一个后缀 SDT（后缀 SDT），在自下而上的解析中实现 SDD 语义动作总是出现在制作的末尾（因此称为 “后缀”）。</p><h3 id="SDT’s-for-L-Attributed-SDD’s"><a href="#SDT’s-for-L-Attributed-SDD’s" class="headerlink" title="SDT’s for L-Attributed SDD’s"></a>SDT’s for L-Attributed SDD’s</h3><p>如果基础语法是 LL，那么 L 归因 SDD 可以在自上而下的解析过程中实现。<br>将 L 属性 SDD 转化为 SDT 的方法是将语义动作放在相关语篇 A → X1X2…Xn 的适当位置上。<br>将计算非终端 Xi 的继承属性的动作紧接在生产体中 Xi 的前面<br>将为语篇头部计算合成属性的操作放在语篇主体的末尾</p><h3 id="构建整个词法分析器-1"><a href="#构建整个词法分析器-1" class="headerlink" title="构建整个词法分析器"></a>构建整个词法分析器</h3><p>• 策略 1：依次尝试每个标记的过渡图<br>fail() 重置指针并开始下一个图表<br>• 策略 2：并行运行过渡图<br>需要解决一个图找到一个词素，而其他图仍能处理输入的情况。<br>▪ 解决方法：取输入中与任何模式匹配的最长前缀<br>• 策略 3：将所有过渡图合并为一张图（首选）<br>允许过渡图读取输入，直到没有可能的下一个状态为止<br>取与任何模式匹配的最长词素<br>语义操作：<br>a) L1 &#x3D; new()；L2 &#x3D; new()；<br>b) C.false &#x3D; S.next; C.true &#x3D; L2；<br>c) S1.next &#x3D; L1；<br>d) S.code &#x3D; ⋯ ；<br>根据动作位置规则，<br>b) 应放在制作体之前，c) 应放在制作体之前，d) 应放在制作体末尾<br>a) 可以放在开头；没有限制条件</p><h2 id="Implementing-L-Attributed-SDD’s"><a href="#Implementing-L-Attributed-SDD’s" class="headerlink" title="Implementing L-Attributed SDD’s"></a>Implementing L-Attributed SDD’s</h2><p>许多翻译应用都可以使用 L 归因 SDD 来解决。如下所示，我们可以扩展递归-后裔解析器来实现 L 归因 SDD：<br>递归-迭代解析器为每个非终端 A 都有一个函数 A<br>使用函数 A 的参数传递 A 的继承属性<br>当函数 A 完成时，返回 A 的合成属性<br>通过上述扩展，在函数 A 的主体中，我们需要同时解析和处理属性</p><h1 id="Chapter-5-Intermediate-Code-Generation"><a href="#Chapter-5-Intermediate-Code-Generation" class="headerlink" title="Chapter 5: Intermediate-Code Generation"></a>Chapter 5: Intermediate-Code Generation</h1><h2 id="中间表示法"><a href="#中间表示法" class="headerlink" title="中间表示法"></a>中间表示法</h2><p>编译器的前端分析源程序并创建中间表示（IR，intermediate representation），后端据此生成目标代码。<br>理想情况下，源语言的细节仅限于前端，目标机的细节仅限于后端</p><h2 id="编译器可构建-IR-序列"><a href="#编译器可构建-IR-序列" class="headerlink" title="编译器可构建 IR 序列"></a>编译器可构建 IR 序列</h2><p>语法树等高级 IR 接近源语言。它们描述了源程序的结构，适用于静态类型检查等任务<br>低级 IR 接近目标机器，适用于寄存器分配和指令选择等与机器相关的任务。<br>三地址代码可以是高级或低级的，取决于运算符的选择</p><p>有趣的事实：C 经常被用作中间形式。第一个 C++ 编译器的前端生成 C，后端是 C 编译器</p><h2 id="DAG’s-for-Expressions"><a href="#DAG’s-for-Expressions" class="headerlink" title="DAG’s for Expressions"></a>DAG’s for Expressions</h2><p>在语法树中，一个普通子表达式的语法树将按该子表达式出现的次数复制</p><p>Example: $𝑎+𝑎∗(𝑏−𝑐)+(𝑏−c)∗𝑑$会重复两次，而$（b-c）$也重复了两次</p><p>有向无环图 (DAG, 有向无环图) 识别共同的子表达式，并简洁地表示表达式</p><p>蓝圈节点有两个父节点</p><p><img src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%2011.png" alt="Untitled"></p><p>DAG 可以用构造语法树的 SDD 来构造<br>区别：在构建 DAG 时，只有当且仅当没有现存的相同节点时，才会创建新节点</p><h2 id="Three-Address-Code-三地址代码"><a href="#Three-Address-Code-三地址代码" class="headerlink" title="Three-Address Code (三地址代码)"></a>Three-Address Code (三地址代码)</h2><p>在三地址代码中，指令右侧最多只有一个运算符<br>指令的形式通常是 $𝑥 &#x3D; 𝑦\ 𝑜𝑝\ 𝑧$<br>运算符（或地址）可以是：</p><p>源程序中的名称<br>常量：编译器必须处理多种类型的常量<br>编译器生成的临时名称</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>赋值指令：</strong><br>𝑥 &#x3D; 𝑦 op 𝑧，其中 op 是二进制算术&#x2F;逻辑运算<br>𝑥&#x3D; op 𝑦，其中 op 是一元运算<br><strong>复制指令：</strong> 𝑥 &#x3D; 𝑦<br><strong>无条件跳转指令：</strong>goto 𝐿，其中 𝐿 是跳转目标的标记<br><strong>有条件跳转指令：</strong><br>if 𝑥 goto 𝐿<br>if Flase 𝑥 goto 𝐿<br>if 𝑥 relop 𝑦 goto 𝐿</p><p><strong>程序调用和返回：</strong></p><p>param 𝑥1<br>…<br>param 𝑥𝑛<br>call 𝑝, 𝑛 (procedure call)<br>y &#x3D; call p, n (function call)<br>return y<br><strong>索引复制指令：</strong> 𝑥 &#x3D; 𝑦[𝑖] 𝑥[𝑖] &#x3D; 𝑦<br>这里，𝑦[𝑖] 表示位置 𝑖 存储单元中超出位置 𝑦 的值。这里，𝑦[𝑖] 表示位置 𝑖存储单元中超出位置 𝑦 的值。<br><strong>地址和指针赋值指令：</strong><br>𝑥 &#x3D; &amp;𝑦 ，𝑥 &#x3D;∗ 𝑦， ∗ 𝑥 &#x3D; 𝑦</p><blockquote><p>对三地址指令的描述说明了每种指令的组成部分，但没有说明指令的表示方法。<br>在编译器中，这些指令可以作为对象&#x2F;记录来实现，并为运算符和操作数设置字段<br>三种典型的表示法:</p><p>四元式表示方法<br>三元式表示方法<br>间接三元式表示方法</p></blockquote><h3 id="Quadruples-四元式"><a href="#Quadruples-四元式" class="headerlink" title="Quadruples (四元式)"></a>Quadruples (四元式)</h3><p>一个四元组（或 “四元组”）有四个字段<br>    一般形式： op arg1 arg2 result<br>    op 包含运算符的内部代码<br>    arg1、arg2、result 是地址（操作数）<br>一元运算符（如 x &#x3D; 减 y 或 x &#x3D; y）不使用 arg2<br>参数运算符既不使用 arg2 也不使用 result<br>条件&#x2F;非条件跳转将目标标签放在 result 中</p><h3 id="Triples-三元式"><a href="#Triples-三元式" class="headerlink" title="Triples (三元式)"></a>Triples (三元式)</h3><p>三元组只有三个字段：操作、参数 1、参数 2。<br>我们用操作 x 操作 y 的位置来表示操作结果，而无需生成临时名称（这是对四元组的优化）</p><h3 id="Indirect-Triples-间接三元式"><a href="#Indirect-Triples-间接三元式" class="headerlink" title="Indirect Triples (间接三元式)"></a>Indirect Triples (间接三元式)</h3><p>间接三元组由一个指向三元组的指针列表（下面的指令数组）<br>优化可以通过重新排序指令列表来移动指令（无需修改三元组）<br>交换后，列表中的第一条和第二条指令仍然指向正确的指令</p><p>静态单赋值形式静态单赋值形式（SSA，Static Single-Assignment ForStatic single-assignment form）是一种 IR，有助于某些代码优化。<br>在 SSA 中，每个名称只接受一次赋值</p><p>SSA 使用一种称为 𝜙 函数的符号惯例来合并 x 的两个定义</p><h2 id="Types-and-Type-Checking"><a href="#Types-and-Type-Checking" class="headerlink" title="Types and Type Checking"></a>Types and Type Checking</h2><p>数据类型或简单的类型告诉编译器或解释器程序员打算如何使用数据<br>类型信息的作用<br>    查找源代码中的错误<br>    在运行时确定名称所需的存储空间<br>    计算数组元素的地址<br>    插入类型转换<br>选择算术运算符的正确版本（如 fadd、iadd）<br>类型检查(类型检查) 使用逻辑规则确保操作数的类型与运算符所期望的类型匹配</p><h2 id="Type-Expressions-类型表达式"><a href="#Type-Expressions-类型表达式" class="headerlink" title="Type Expressions (类型表达式)"></a>Type Expressions (类型表达式)</h2><p>类型具有结构，可以用类型表达式来表示<br>    类型表达式要么是基本类型，要么是通过对类型表达式应用类型构造算子而形成<br>array(2, array (3, integer ))是 int[2][3] 的类型表达式<br>    array 是一个类型构造函数，有两个参数：一个数字，一个类型表达式</p><h2 id="Name-Equivalence-名等价"><a href="#Name-Equivalence-名等价" class="headerlink" title="Name Equivalence (名等价)"></a>Name Equivalence (名等价)</h2><p>将命名的类型视为基本类型；类型表达式中的名称不会被其定义的类型表达式所替换<br>当且仅当两个类型表达式完全相同时，它们的名称才是等价的(由相同的语法树表示，具有相同的标签）</p><h2 id="Structural-Equivalence-结构等价"><a href="#Structural-Equivalence-结构等价" class="headerlink" title="Structural Equivalence (结构等价)"></a>Structural Equivalence (结构等价)</h2><p>对于已命名的类型，用其类型表达式替换类型名，并递归检查替换后的树</p><h2 id="Declarations-类型的声明"><a href="#Declarations-类型的声明" class="headerlink" title="Declarations (类型的声明)"></a>Declarations (类型的声明)</h2><p>下面的语法涉及基本类型、数组类型和记录类型</p><p>非终端 𝐷生成声明序列<br>𝑇 生成基本类型、数组类型或记录类型，记录类型是记录字段的声明序列，由大括号包围<br>𝐵 生成基本类型之一：int 和 float<br>𝐶 生成一个或多个整数的序列，每个整数都由大括号包围</p><h2 id="Storage-Layout-for-Local-Names-局部变量的存储布局"><a href="#Storage-Layout-for-Local-Names-局部变量的存储布局" class="headerlink" title="Storage Layout for Local Names (局部变量的存储布局)"></a>Storage Layout for Local Names (局部变量的存储布局)</h2><p>根据名称的类型，我们可以决定运行时名称所需的内存量。运行时名称所需的内存量<br>    类型的宽度（宽度）： 该类型对象所需的 # 内存单位<br>    对于长度不等的数据（如字符串），或在运行前无法确定大小的数据（如动态数组），我们只为数据指针预留固定的内存量。<br>    对于函数的局部名称，我们总是分配连续的字节*。<br>    对于每个这样的名称，我们可以在编译时计算出一个相对地址<br>类型信息和相对地址存储在符号表中</p><h2 id="表达式的翻译"><a href="#表达式的翻译" class="headerlink" title="表达式的翻译"></a>表达式的翻译</h2><p>包含多个运算符的表达式：𝑎 + 𝑏 ∗ 𝑐<br>转换为多条指令，每条指令最多使用一个运算符𝑡1 &#x3D; 𝑏 ∗ 𝑐,𝑡2 &#x3D; 𝑎 + 𝑡1<br>数组引用𝐴[𝑖][𝑗] 将扩展为一系列三地址指令，用于计算引用的地址</p>]]></content>
    
    
    <summary type="html">编译原理与技术的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://shuita2333.github.io/project/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://shuita2333.github.io/project/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>复杂网络课程笔记</title>
    <link href="https://shuita2333.github.io/project/2024/01/10/BUPT_note/Notes_on_Complex_network/"/>
    <id>https://shuita2333.github.io/project/2024/01/10/BUPT_note/Notes_on_Complex_network/</id>
    <published>2024-01-10T13:00:00.000Z</published>
    <updated>2024-07-07T08:10:49.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复杂网络-彭海朋"><a href="#复杂网络-彭海朋" class="headerlink" title="复杂网络 彭海朋"></a>复杂网络 彭海朋</h1><h2 id="虫口方程"><a href="#虫口方程" class="headerlink" title="虫口方程"></a>虫口方程</h2><h1 id="第零讲"><a href="#第零讲" class="headerlink" title="第零讲"></a>第零讲</h1><p>$$<br>x_{n+1}&#x3D;\gamma x_n(1-x_n)<br>$$</p><p>在不控制的条件下，人口每25年增加一倍，即按几何级数增长。<em>xn</em>+1 &#x3D; <em>𝛾xn</em>。修正就是计入限制虫口增长的负因素。虫口数目太多时，由于争夺有限的食物和生存空间发生咬斗，由于接触传染而导致疾病蔓延，争斗使虫口数目减少的事件，这些事件的数目比例于<em>xn^</em>2。</p><h2 id="Logistic映射（Logistic-Map）"><a href="#Logistic映射（Logistic-Map）" class="headerlink" title="Logistic映射（Logistic Map）"></a>Logistic映射（Logistic Map）</h2><p>$$<br>x_{n+1}&#x3D;rx_n(1-x_n)<br>$$</p><p>分叉与周期倍增（Bifurcation &amp; Period Doubling）</p><p>對初始值的敏感性</p><p>混沌内部的自相似结构</p><h1 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h1><h2 id="复杂网络的数学描述"><a href="#复杂网络的数学描述" class="headerlink" title="复杂网络的数学描述"></a>复杂网络的数学描述</h2><p>网络G&#x3D;（V, E），由点集V（G）和边集E（G）组成的一个图，可分为无向、有向和加权网络<br>令ei∈ E（G），每条边ei有V（G）中的一对点(u,v)与之对应；如果任意(u,v)与(v,u)对应同一条边，则称为无向网络，否则为有向网络；如果任意∣ei ∣ &#x3D;1，则称为无权网络，否则为加权网络。</p><p>——复杂网络是对复杂系统的一种抽象</p><h2 id="对网络拓扑结构的描述"><a href="#对网络拓扑结构的描述" class="headerlink" title="对网络拓扑结构的描述"></a>对网络拓扑结构的描述</h2><p><strong>几何量及其分布</strong></p><p>度（Degree）：朋友的个数<br>集聚系数（群系数）（Clustering coefficient）：朋友的朋友还是不是朋友的情况<br>最短路径（Shortest path）：两个顶点之间边数最少的路径<br>介数（Betweenness）：经过我的最短路径的条数</p><h2 id="网络的基本模型"><a href="#网络的基本模型" class="headerlink" title="网络的基本模型"></a>网络的基本模型</h2><ul><li>规则网<br>(a) 完全连接; (b) 最近邻居连接; (c) 星形连接; (d) Lattice; … (z) Layers</li><li>随机图</li><li>小世界网络</li><li>Scale-Free 网络</li></ul><h3 id="ER-随机图模型"><a href="#ER-随机图模型" class="headerlink" title="ER 随机图模型"></a>ER 随机图模型</h3><p>特征:<br>连通性:Poisson 分布<br>齐次特征:每个节点大约有相同的<br>连接数:节点数不增加</p><p><img src="/../../images/BUPT_note/Notes_on_Complex_network/Untitled.png" alt="Untitled"></p><h3 id="小世界网络"><a href="#小世界网络" class="headerlink" title="小世界网络"></a>小世界网络</h3><p>特征:<br>齐次性:每个节点有大约相同的连接数<br>节点不增加</p><h3 id="Scale-Free网络的基本特征"><a href="#Scale-Free网络的基本特征" class="headerlink" title="Scale Free网络的基本特征"></a>Scale Free网络的基本特征</h3><p>Power Law Degree Distribution（幂律度分布）</p><p>$$<br>P(k)\propto k^{-\gamma} \ \ \ \ \ln P(k)\propto -\gamma\ln k\P(\lambda k)\propto(\lambda k)^{-\gamma}&#x3D;\lambda^{-\gamma}k^{-\gamma}&#x3D;\lambda^{-\gamma}P(k)<br>$$</p><p>1、自相似结构<br>2、两极分化，高度弥散</p><p><strong>六度分隔（Six Degrees of Separation）理论</strong>。简单地说：“你和任何一个陌生人之间所间隔的人不会超六个，也就是说，最多通过六个人你就能够认识任何一个陌生人。”</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table><thead><tr><th></th><th>E&#x2F;R随机图模型</th><th>现实生活的复杂网络</th></tr></thead><tbody><tr><td>平均距离</td><td>小&#x2F;大</td><td>小</td></tr><tr><td>聚类系数</td><td>大&#x2F;小</td><td>大(Small-world feature)</td></tr><tr><td>度分布</td><td>二项式&#x2F;Poisson</td><td>幂指数(Scale-free feature)</td></tr></tbody></table><p>直径：两点间最短距离的最大值</p><h2 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h2><p>分形和不规则形状的几何有关。</p><p>分形（Fractal)：局部与整体具有相似性，或者说在标度变换下具有相似性的几何形体。</p><p>曼德勃鲁集</p><p>分形音乐</p><h3 id="分维"><a href="#分维" class="headerlink" title="分维"></a>分维</h3><p>假设ε是小立方体一边的长度， N （ε）是用此小立方体覆盖被测形体所得的数目，维数公式意味着通过用边长为ε的小立方体覆盖被测形体来确定形体的维数。对于通常的规则物体 ，覆盖一根单位 长度的线 段所需 的数目要 N （ε）＝1／ε，覆盖一个单位边长的正方形，N(ε)＝（1／ε）2 ，覆盖单位边 长的立方体，N （ε）＝（1／ε）3。从这三个式子可见维数公式也适用于通常的维数含义。</p><h1 id="复杂网络病毒的行为分析"><a href="#复杂网络病毒的行为分析" class="headerlink" title="复杂网络病毒的行为分析"></a>复杂网络病毒的行为分析</h1><h3 id="恶意代码的基础知识"><a href="#恶意代码的基础知识" class="headerlink" title="恶意代码的基础知识"></a>恶意代码的基础知识</h3><p>恶意代码是最头痛的安全问题之一，它甚至是整个软件安全的核心。虽然单独对付某台设备上的指定恶意代码并不难，但是，网上各种各样的海量恶意代码，却像癌细胞一样，危害着安全，而且，既杀之不绝，又严重消耗正常体能。</p><blockquote><p>狭义上说，恶意代码是指故意编制或设置的、会产生威胁或潜在威胁的计算机代码（软件）。最常见的恶意代码有计算机病毒、特洛伊木马、计算机蠕虫、后门、逻辑炸弹等。<br>广义上说，恶意代码还指那些没有作用却会带来危险的代码，比如，流氓软件和广告推送等。</p></blockquote><p>恶意代码的入侵手段主要有三类：利用软件漏洞、利用用户的误操作、前两者的混合。</p><p>恶意代码的主要传播方式是病毒式传播</p><h2 id="死亡型病毒的动力学分析"><a href="#死亡型病毒的动力学分析" class="headerlink" title="死亡型病毒的动力学分析"></a>死亡型病毒的动力学分析</h2><blockquote><p>设网络的用户数为N，在t时刻，已经受害的用户数为T(t)，暂未受害的用户数为S(t)，那么，有恒等式S(t)+T(t)&#x3D;N。<br>再令f(S,T)为在“已有T人受害，S人暂未受害”条件下，受害事件发生率，于是，有下面两个微分方程<br>dT(t)&#x2F;dt&#x3D;f(S,T) 和 dS(t)&#x2F;dt&#x3D;-f(S,T)</p></blockquote><p>在生物医学的流行病学中，有一个可借鉴的概念是传染力λ(T)，它表示在已有T台设备中毒的情况下，暂未中毒的设备与中毒者相连接的概率，所以，f(S,T)&#x3D;λ(T)S；<br>另一个概念是传染率β，它表示一个未中毒设备在连接到中毒者后，被传染的概率；所以，λ(T)&#x3D;βT。于是，f(S,T)&#x3D;λ(T)S&#x3D;βTS，即，它是一个双线性函数。</p><h2 id="康复型病毒的动力学分析"><a href="#康复型病毒的动力学分析" class="headerlink" title="康复型病毒的动力学分析"></a>康复型病毒的动力学分析</h2><blockquote><p>与死亡型模型不同，在康复型模型中，受害用户在经过救治后，又可以康复成为暂未受害的用户，当然，该用户也可能再次受害。<br>其实，绝大部分恶意代码，特别是诱骗类恶意代码，都是这种康复型的。</p></blockquote><p>在此，除了10.2节中的S、T、F(S,T)和N等概念外，我们再引入另一个概念，即g(T)，它表示在T个受害者中，有g(T)个用户被康复成正常健康用户，从而，变成暂未受害用户。<br>若用γ表示康复率（生物医学经验告诉我们：每个受害者，在下一小段时间δt内，被康复的概率为γδt+0(δt)2。并且受害者被康复的时间，服从均值为1&#x2F;γ的指数分布。）那么：g(T)&#x3D;γT</p><p>由此，我们可以得到微分方程组：<br>dT(t)&#x2F;dt&#x3D;f(S,T)-g(T)&#x3D;βTS-γT和 dS(t)&#x2F;dt&#x3D;-f(S,T)+g(T)&#x3D;-βTS+γT<br>若令u(t)&#x3D;S(t)&#x2F;N， v(t)&#x3D;T(t)&#x2F;N， t’&#x3D;γt和R0&#x3D;βN&#x2F;γ，那么，上面的两个微分方程就变为：<br>du&#x2F;dt&#x3D;-(R0u-1)v 和dv&#x2F;dt&#x3D;(R0u-1)v<br>其定义域为：D&#x3D;{0≤u≤1,0≤v≤1,u+v&#x3D;1}</p><p><strong>定理10.1：针对康复型恶意代码，如果R0&lt;1，那么，康复型恶意代码就会最终被消灭，即，无人受害；反过来，如果R0&gt;1，那么，康复型恶意代码就会在一定范围内长期为害，具体地说，受害者人数将长期徘徊在N(1-1&#x2F;R0)附近。</strong></p><h2 id="免疫型病毒的动力学分析"><a href="#免疫型病毒的动力学分析" class="headerlink" title="免疫型病毒的动力学分析"></a>免疫型病毒的动力学分析</h2><p>设S、T、γ、β和N等概念与10.3节相同，又记R(t)为t时刻被康复（具有了免疫力）的用户数。于是，在任何一个时刻，都恒有N&#x3D;S(t)+T(t)+R(t)<br>为了使相关公式看起来简单一些，分别用S(t)&#x2F;N、T(t)&#x2F;N和R(t)&#x2F;N去代替S(t)、T(t)和R(t)并且仍然采用原来的记号来表示S(t)、T(t)和R(t)，此时便有S(t)+T(t)+R(t)&#x3D;1<br>简单来说，S(t)、T(t)和R(t)分别代表暂未受害、正受害和受害康复且具有免疫力的用户，各占总用户数的比例。</p><p><strong>定理10.2：针对免疫型恶意代码，当F0&lt;1时，此恶意代码不会爆发，并随着时间的推移，会自动消灭；当F0&gt;1时，该恶意代码会在一定的时段内爆发，受害者人数达到一个最大值Tmax后，才开始递减，并最终消灭。更深入地，Tmax在总人数中所占的比例为1-ρ+ρln(ρ&#x2F;S0)<br>在这里S0表示刚开始时，暂未受害的人数比例。</strong></p><h2 id="开机和关机对免疫型病毒的影响"><a href="#开机和关机对免疫型病毒的影响" class="headerlink" title="开机和关机对免疫型病毒的影响"></a>开机和关机对免疫型病毒的影响</h2><blockquote><p>以上所有小节的分析，都假定活跃用户数固定为N。但是，在实际情况下，当然有例外。比如，某用户主动关机后，任何恶意代码对他都不构成威胁，此时活跃用户就减少一个；当某用户终端中毒后被宕（dang）机，这里活跃用户数也减少一个；当新用户开机（或进入网络）后，他又可能成为恶意代码的攻击对象，这时，活跃用户数又增加一个等。</p></blockquote><p><strong>定理10.3：记P0&#x3D;β&#x2F;(γ+μ)，那么，在情况1之下，<br>当P0≤1时，该免疫型恶意代码一定会随着时间的推移，最终自动消灭；<br>当P0≥1时，该免疫型恶意代码一定会随着时间的推移，最终在$S&#x3D;1&#x2F;P_0、T&#x3D;μ(P_0-1)&#x2F;β、R&#x3D;1-1&#x2F;P_0-μ(P_0-1)&#x2F;β$点处达到全局渐近稳定，即，最终健康终端的比例为$S&#x3D;1&#x2F;P_0$，受害终端的比例为$T&#x3D;μ(P_0-1)&#x2F;β$，获得免疫力的终端比例为$R&#x3D;1-1&#x2F;P_0-μ(P_0-1)&#x2F;β$。</strong></p><h2 id="预防措施的效果分析"><a href="#预防措施的效果分析" class="headerlink" title="预防措施的效果分析"></a>预防措施的效果分析</h2><p>我们虽然不能强求全体用户都采取预防措施，但是，如果有比例为p的用户采取了预防措施（比例为q的用户偷了懒，此处，p+q&#x3D;1），那么，我们发现：只要当p足够大时，仍然能够消灭该恶意代码。</p><p><strong>定理10.5：在10.5节的情况1中，如果在暂未受害的终端中，采取了预防措施终端数的比例p≥1-1&#x2F;P0，这里P0&#x3D;β&#x2F;(γ+μ)，那么，该免疫型恶意代码一定会随着时间的推移，最终自动消灭。</strong><br>此定理告诉我们：对付恶意代码，虽然不能指望全体人员都及时采取预防措施，但是，只要有足够多的人（占总人数比例超过P0&#x3D;β&#x2F;(γ+μ)）重视安全，并及时采取了预防措施，那么，该恶意代码就一定是可控的，甚至会最终被消灭。</p><h1 id="回声状态网络"><a href="#回声状态网络" class="headerlink" title="回声状态网络"></a>回声状态网络</h1><p>人工神经网络（Artificial Neural Network）是由大量处理单元互联组成的非线性、自适应信息处理系统 。</p><p>人工神经网络按照性能分为两类：<br>（1）静态神经网络 Static Neural Network<br>（2）动态神经网络 Recurrent Neural Network<br>其中，动态神经网络又称为递归神经网络</p><p>两种网络对比：</p><p>静态网络数学表达式：</p><p>$$<br>y&#x3D;\sigma(\sum^n_{i&#x3D;1}\omega_1x_1+\sigma_1)<br>$$</p><p>静态网络数学表达式：</p><p>$$<br>y&#x3D;\sigma(\sum^n_{i&#x3D;1}\omega_1x_1(t-\tau_i)+\sigma_1)<br>$$</p><p>对比表达式，我们可以看出：动态网络内部存在带延迟因子的反馈连接，可以更好的反映动态系统的特性和演化行为 。而静态网络没有这种能力。</p><p>回声状态状态网络作为一种新型的递归神经网络，无论是建模还是学习算法，都已经与传统的递归神经网络差别很大。<br>ESN网络特点：<br>（1） 它的核心结构是一个随机生成、且保持不 变的储备池（Reservoir）<br>（2）其输出权值是唯一需要调整的部分<br>（3）简单的线性回归就可完成网络的训练</p><h2 id="ESN的结构和运行机理"><a href="#ESN的结构和运行机理" class="headerlink" title="ESN的结构和运行机理"></a>ESN的结构和运行机理</h2><p>ESN网络的核心结构是一个“储备池”。所谓的储备池就是随机生成的、大规模的、稀疏连接（SD通常保持1%~5%连接 ）的递归结构。<br>注：SD是储备池中相互连接的神经元占总的神经元N的百分比</p><p>从结构上讲，ESN是一种特殊类型的递归神经网络，其基本思想:使用大规模随机连接的递归网络，取代经典神经网络中的中间层，从而简化网络的训练过程。<br>我们假设系统具有M个输入单元，N个内部处理单元（Processing Elements，PE），即N个内部神经元，同时具有L个输出单元。</p><p>那么输入单元u（n）内部状态x（n）以及输出单元y（n）在n时刻值分别为：</p><p>$$<br>u(n)&#x3D;[u_1(n),u_2(n),\dots,u_M(n)]^T\ x(n)&#x3D;[x_1(n),x_2(n),\dots,x_N(n)]^T\ y(n)&#x3D;[y_1(n),y_2(n),\dots,y_L(n)]^T<br>$$</p><p>则回声状态网络状态方程为：</p><p>$$<br>x(n+1)&#x3D;f(Wx(n)+W_{in}u(n)+W_{back})y(n)\ y(n+1)&#x3D;f_{out}(W_{out}[x(n+1),u(n+1),y(n)]+W_{bias}^{out})<br>$$</p><h2 id="ESN的储备池"><a href="#ESN的储备池" class="headerlink" title="ESN的储备池"></a>ESN的储备池</h2><p>虽然有大量的研究是关于如何获得与具体问题相关的“好”的储备池，但是并没有形成一个系统的方法，多数研究是从实验的角度进行的。这也是目前ESN方法遇到的最大的挑战。<br>ESN的最终性能是由储备池的各个参数决定的，下面首先简要介绍储备池的四个关键参数。</p><p><strong>储备池内部连接权谱半径SR</strong></p><p><strong>储备池规模N</strong></p><p><strong>储备池输入单元尺度IS</strong></p><p><strong>储备池稀疏程度SD</strong></p><p>关于IS的规则：<br>如果需要处理的任务的非线性越强，那么输人单元尺度越大。<br>该原则的本质是通过输入单元尺度IS，将输入变换到神经元激活函数funtion相应的范围。<br>注：神经元激活函数的不同输入范围，其非线性程度不同。</p><h1 id="智能优化算法"><a href="#智能优化算法" class="headerlink" title="智能优化算法"></a>智能优化算法</h1><p>牛顿迭代法、共轭梯度法、单纯形法、黄金分割</p><h2 id="课上重点"><a href="#课上重点" class="headerlink" title="课上重点"></a>课上重点</h2><p>求</p><p>$$<br>\min(x_1^2+2x_2^2)&#x3D;E<br>$$</p>]]></content>
    
    
    <summary type="html">复杂网络的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://shuita2333.github.io/project/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://shuita2333.github.io/project/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>信息论与编码课程笔记</title>
    <link href="https://shuita2333.github.io/project/2024/01/10/BUPT_note/Notes_on_Information_heory_and_Coding/"/>
    <id>https://shuita2333.github.io/project/2024/01/10/BUPT_note/Notes_on_Information_heory_and_Coding/</id>
    <published>2024-01-10T13:00:00.000Z</published>
    <updated>2024-07-07T08:06:56.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息论与编码"><a href="#信息论与编码" class="headerlink" title="信息论与编码"></a>信息论与编码</h1><h1 id="第一章-信息论与编码理论概述"><a href="#第一章-信息论与编码理论概述" class="headerlink" title="第一章 信息论与编码理论概述"></a>第一章 信息论与编码理论概述</h1><h2 id="信息论与编码理论概述"><a href="#信息论与编码理论概述" class="headerlink" title="信息论与编码理论概述"></a>信息论与编码理论概述</h2><p>自从汉明码开始，各种信道编码获得了长足的发展，如</p><ul><li>格雷码，Reed-Muller码，循环码，Reed-Solomon码,BCH码</li><li>卷积码，Turbo码，LDPC码，Polar码</li><li>级联码，网格编码调制，代数几何码</li><li>编织卷积码，纠删码，空时码</li><li>网络编码，量子纠错码，二维码</li><li>基于信息论与编码理论的安全技术</li></ul><h3 id="编码机制"><a href="#编码机制" class="headerlink" title="编码机制"></a>编码机制</h3><ul><li>编码：信息从一种形式或格式转换为另一种形式的过程。</li><li>编码机制：用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。</li></ul><h3 id="信源编码"><a href="#信源编码" class="headerlink" title="信源编码"></a>信源编码</h3><p>目的：提高通信的有效性，即以更少的符号来表示原始消息</p><p>通过减少消息符号序列中的冗余度，提高平均信息量</p><h3 id="随机错误"><a href="#随机错误" class="headerlink" title="随机错误"></a>随机错误</h3><ul><li>随机错误：接收序列中的传输错误是随机出现的。</li><li>随机错误信道：这样的信道称为随机错误信道。</li></ul><h3 id="突发错误"><a href="#突发错误" class="headerlink" title="突发错误"></a>突发错误</h3><p>突发错误：不同状态特性下，错误出现的概率不一样，这种错误为突发错误。</p><h3 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h3><p>目的：检测和纠正由于非人为(自然)因素引起的传输错误</p><p>设计机制：通过对消息符号序列加入冗余信息，使得接收方收到信号后，可以通过这些冗余信息进行检错和纠错</p><h2 id="数字通信系统的组成及各种信道"><a href="#数字通信系统的组成及各种信道" class="headerlink" title="数字通信系统的组成及各种信道"></a>数字通信系统的组成及各种信道</h2><h3 id="数字通信系统模型"><a href="#数字通信系统模型" class="headerlink" title="数字通信系统模型"></a>数字通信系统模型</h3><p><img src="/../../images/BUPT_note/Notes_on_Information_heory_and_Coding/Untitled.png" alt="Untitled"></p><h3 id="无记忆信道和有记忆信道"><a href="#无记忆信道和有记忆信道" class="headerlink" title="无记忆信道和有记忆信道"></a>无记忆信道和有记忆信道</h3><p>无记忆信道：如果在给定时间间隔上，检测器的输出只与在该时间间隔上传送的信号有关，而与任何前面时间的传送的信号无关，称此信道为无记忆信道。该信道可以用如下公式表示：</p><p>$$<br>P(Y&#x2F;X)&#x3D; \prod_n p(y_n&#x2F;x_n)<br>$$</p><p>有记忆信道：一种M元输入、Q元输出的信道模型。该信道可以用如下公式表示：</p><p>$$<br>P(y_n&#x2F;x_{n-k+1},…,x_{n-1},x_n)<br>$$</p><h3 id="离散无记忆-DMC-信道"><a href="#离散无记忆-DMC-信道" class="headerlink" title="离散无记忆(DMC)信道"></a>离散无记忆(DMC)信道</h3><p>是一种M元输入、Q元输出的信道模型。</p><p>条件概率P(Y&#x2F;X)是描述该信道的最好方式，也叫做转移概率，其中X表示调制器输入符号，Y表示解调器输出符号，P(Y&#x2F;X)表示发送为X接收为Y的概率。</p><h3 id="二元对称-BSC-信道"><a href="#二元对称-BSC-信道" class="headerlink" title="二元对称(BSC)信道"></a>二元对称(BSC)信道</h3><p>信道矩阵：一个信道也可由它的转移概率组成的矩阵来表示。</p><p><img src="/../../images/BUPT_note/Notes_on_Information_heory_and_Coding/Untitled%201.png" alt="Untitled"></p><h3 id="信道矩阵"><a href="#信道矩阵" class="headerlink" title="信道矩阵"></a>信道矩阵</h3><p>一般离散单符号信道的信道矩阵为：</p><p>$$<br>\begin{bmatrix} P(b_1|a_1) &amp; P(b_2|a_1) &amp; \dots &amp; P(b_s|a_1) \ P(b_1|a_2) &amp; P(b_2|a_2) &amp; \dots &amp; P(b_s|a_2) \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \P(b_1|a_r) &amp; P(b_2|a_r) &amp; \dots &amp; P(b_s|a_r)  \end{bmatrix}<br>$$</p><h3 id="加性高斯白噪声-AWGN-信道"><a href="#加性高斯白噪声-AWGN-信道" class="headerlink" title="加性高斯白噪声(AWGN)信道"></a>加性高斯白噪声(AWGN)信道</h3><ul><li>加性噪声：叠加在信号上的一种噪声。</li><li>白噪声：噪声的功率谱密度在所有的频率上均为一常数。</li><li>高斯白噪声：白噪声取值的概率分布服从高斯分布，其自相关系数为无延时的冲击函数。</li></ul><h2 id="通信系统涉及的一些基本概念"><a href="#通信系统涉及的一些基本概念" class="headerlink" title="通信系统涉及的一些基本概念"></a>通信系统涉及的一些基本概念</h2><h3 id="信息传输率"><a href="#信息传输率" class="headerlink" title="信息传输率"></a>信息传输率</h3><ul><li>符号传输率：为1&#x2F;T，每T秒传输一个编码符号，即单位时间内传输的符号个数。</li><li>码速率：编码后的数据流中有用部分的比例，对于(n,k)线性分组码，码速率为R&#x3D;k&#x2F;n，即k个信息比特对应于传送n个符号。</li><li>信息传输率(数据率)：在编码系统中，若码速率是R&#x3D;k&#x2F;n，则信息传输率(数据率)为R&#x2F;T(bit&#x2F;s)。</li></ul><h3 id="信道带宽"><a href="#信道带宽" class="headerlink" title="信道带宽"></a>信道带宽</h3><p>除了噪声的作用造成信号改变外，所有的通信系统都会因为带宽有限而造成信号失真。</p><ul><li>最小信道带宽：为基本保证信号不因带宽原因而失真，粗略估计等于W&#x3D;1&#x2F;(2T)(Hz)。</li><li>未编码系统：数据率1&#x2F;T&#x3D;2W，受到带宽影响。</li><li>二元编码系统：数据率R&#x2F;T&#x3D;2RW。同未编码系统相比，若要保持数据率不变，则要求带宽扩展1&#x2F;R倍。</li></ul><h3 id="AWGN信道的分组编码系统"><a href="#AWGN信道的分组编码系统" class="headerlink" title="AWGN信道的分组编码系统"></a>AWGN信道的分组编码系统</h3><p>译码器的条件错误概率：已知接收序列Y时</p><p>$$<br>P_e(H_m&#x2F;Y),P_e(X_m&#x2F;Y)<br>$$</p><p>译码器的错误概率：</p><p>$$<br>P_e(H_m)&#x3D;P_e(X_m)&#x3D;\sum_Y P_e(X_m&#x2F;Y)P(Y)<br>$$</p><h3 id="最佳译码规则和最大后验概率译码"><a href="#最佳译码规则和最大后验概率译码" class="headerlink" title="最佳译码规则和最大后验概率译码"></a>最佳译码规则和最大后验概率译码</h3><ul><li><p><strong>最佳译码规则</strong>：能够使译码错误概率P(E)达到最小的译码规则</p></li><li><p>由于接收序列Y是译码前产生的，所以P(Y)与译码规则无关</p></li><li><p>最佳译码规则必须对所有Y，使得</p><p>  $$<br>  P(E&#x2F;Y)\cong P(Y \neq X&#x2F;Y)<br>  $$</p><p>  &#96;最小，即 P(Y&#x3D;X&#x2F;Y) 最大。</p></li><li><p><strong>最大后验概率译码</strong>：对于每个输入Y，如果译码器能在码字集合中选择一个码字，作为发送码字的估值，并且使P(X&#x2F;Y)最大，则这种译码规则一定能使译码器输出的错误概率最小。</p></li></ul><h3 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h3><p>Bayes公式：</p><p>$$<br>\uparrow P(X&#x2F;Y)&#x3D;\frac{P(Y&#x2F;X)P(X)}{P(Y)} \公式(1)<br>$$</p><ul><li>对于给定的Y，可选择能使公式(1)右边最大的向量作为X的估计值。</li><li>如果所有码字都是等可能的，即P(X)是常数，那么公式(1)左边最大，就推导出P(Y&#x2F;X)最大。</li><li>P(Y&#x2F;X)：叫做似然函数、信道转移概率。</li></ul><h3 id="最大似然译码"><a href="#最大似然译码" class="headerlink" title="最大似然译码"></a>最大似然译码</h3><ul><li><p>定义：若能在码字集合选择合适的码字X，使得P(Y&#x2F;X)最大，则这种译码规则被称为最大似然译码。</p></li><li><p>对数似然函数：由于lnx与x是单调关系，故有lnP(Y&#x2F;X)。</p></li><li><p>对于离散无记忆信道，由于</p><p>  $$<br>  P(Y&#x2F;X)&#x3D;\sum_n P(y_i&#x2F;x_i)<br>  $$</p><p>  所以</p><p>  $$<br>  \ln P(Y&#x2F;X)&#x3D;\sum_n \ln P(y_i&#x2F;x_i)<br>  $$</p></li><li><p>MLD：对应的译码器称为最大似然译码器。</p></li><li><p>MLD规则：是最为可行的一种译码规则。</p></li><li><p>对于DMC和BSC信道是一种最佳译码准则。但是在某些情况下并不是最佳的译码规则，如当发送端不是以等概率发送码字的时候。</p></li></ul><h3 id="BSC信道的最大似然译码"><a href="#BSC信道的最大似然译码" class="headerlink" title="BSC信道的最大似然译码"></a>BSC信道的最大似然译码</h3><p>$$<br>P(y_i&#x2F;x_i)&#x3D;\begin{cases} 1-p&amp;  y_i&#x3D;x_i\p&amp; y_i\neq x_i \end{cases}<br>$$</p><p>Y为二元序列，用d(Y, X)表示Y和X之间的距离，即不同位数的个数</p><p>$$<br>\ln P(Y&#x2F;X)&#x3D;d(y,X)\ln p+(n-d(Y,X))\ln (1-p) &#x3D;\ d(Y,X)\ln \frac {p}{1-p} +n\ln(1-p)<br>$$</p><p>即想要P(Y&#x2F;X)最大，则需要d(Y, X)最小</p><p>最小距离译码器：在BSC中，MLD规则变成了选择能使Y和X之间的汉明距离为最小的向量，作为码字X的估计值</p><h1 id="数据安全中的数学问题"><a href="#数据安全中的数学问题" class="headerlink" title="数据安全中的数学问题"></a>数据安全中的数学问题</h1><p>语义</p><p>语法：01比特</p><p>语用</p><h2 id="信道编码"><a href="#信道编码" class="headerlink" title="信道编码"></a>信道编码</h2><p>y&#x3D;Ax+b mod  q</p><p>分组码</p><p>循环码</p><p>卷积码</p><h2 id="LDPC码"><a href="#LDPC码" class="headerlink" title="LDPC码"></a>LDPC码</h2><p>有低密度的稀疏矩阵，就表示是LDPC码</p><h2 id="压缩感知"><a href="#压缩感知" class="headerlink" title="压缩感知"></a>压缩感知</h2><p>y&#x3D;Ax+b</p><p>如果x稀疏，A满足一定的条件，通过y A可以找到x</p><p>由于A不可逆，无法通过求找到x</p><p>现实中的x一般并不稀疏，进过一个变化之后，再一组正交基上可以进行稀疏表示</p><h3 id="矩阵A与x维数不匹配"><a href="#矩阵A与x维数不匹配" class="headerlink" title="矩阵A与x维数不匹配"></a>矩阵A与x维数不匹配</h3><p>格密码，编码，压缩感知都有对测量矩阵尺寸多样性的需求</p><h3 id="半张量积压缩感知"><a href="#半张量积压缩感知" class="headerlink" title="半张量积压缩感知"></a>半张量积压缩感知</h3><p>$$<br>y&#x3D;a\ltimes x+b<br>$$</p><h1 id="第二章-信息论基础与信源编码理论"><a href="#第二章-信息论基础与信源编码理论" class="headerlink" title="第二章 信息论基础与信源编码理论"></a>第二章 信息论基础与信源编码理论</h1><p>信息的定义：信息是事物运动状态或存在方式不确定性的描述</p><h2 id="自信息"><a href="#自信息" class="headerlink" title="自信息"></a>自信息</h2><p>定义：考虑离散随机变量X，其样本空间为{xi, i&#x3D;1, 2,…,n}，则事件X&#x3D;xi的自信息的定义为</p><p>$$<br>I(x_i)&#x3D;log(\frac{1}{P(x_i)})&#x3D;-logP(x_i)<br>$$</p><blockquote><p>自信息的单位由对数的底来决定，以2为底，单位就是比特(bits)，以e为底就是奈特(nats)。自信息非负。</p></blockquote><h2 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h2><p>定义： xi和yi之间的互信息定义为</p><p>$$<br>I(x_i;y_i)&#x3D;log(\frac{P(x_i|y_i)}{P(x_i)})<br>$$</p><p>互信息的性质：</p><p>性质1：互易性 I(xi;yi)&#x3D; I(yi;xi)。<br>性质2：当xi和yi是统计上独立的，即P(xi|yi)&#x3D; P(xi)，则I(xi;yi)&#x3D;0。<br>性质3：互信息量可以是正的，也可以是负的。</p><blockquote><p>思考题：计算二元对称(BSC)信道的互信息量?</p><p>计算二元对称信道（Binary Symmetric Channel，BSC）的互信息量（Mutual Information）可以使用以下的LaTeX公式表示：</p><p><em>I</em>(<em>X</em>;<em>Y</em>)&#x3D;<em>H</em>(<em>Y</em>)−<em>H</em>(<em>Y</em>∣<em>X</em>)</p><p>其中：</p><ul><li><p><em>I</em>(<em>X</em>;<em>Y</em>) 表示信道输入 <em>X</em> 和输出 <em>Y</em> 之间的互信息量。</p></li><li><p><em>H</em>(<em>Y</em>) 表示接收端输出 <em>Y</em> 的熵（Entropy），可以用以下公式计算：</p><p>  $$<br>  H(Y) &#x3D; -\sum_{i&#x3D;1}^{2} P(Y&#x3D;y_i) \cdot \log_2(P(Y&#x3D;y_i))<br>  $$</p></li></ul><p>这里的 <em>y</em>1 和 <em>y</em>2 分别表示接收到的0和1的可能性，<em>P</em>(<em>Y</em>&#x3D;<em>yi</em>) 是接收到符号 <em>yi</em> 的概率。</p><ul><li><p><em>H</em>(<em>Y</em>∣<em>X</em>) 表示在已知输入 <em>X</em> 的条件下，接收端输出 <em>Y</em> 的条件熵（Conditional Entropy），可以用以下公式计算：</p><p>  $$<br>  H(Y|X) &#x3D; -\sum_{i&#x3D;1}^{2} \sum_{j&#x3D;1}^{2} P(X&#x3D;x_j, Y&#x3D;y_i) \cdot \log_2\left(\frac{P(X&#x3D;x_j, Y&#x3D;y_i)}{P(X&#x3D;x_j)}\right)<br>  $$</p></li></ul><p>对于二元对称信道（BSC），错误概率 p 相等，即 P(Y&#x3D;0∣X&#x3D;1)&#x3D;P(Y&#x3D;1∣X&#x3D;0)&#x3D;p，而 P(Y&#x3D;0∣X&#x3D;0)&#x3D;P(Y&#x3D;1∣X&#x3D;1)&#x3D;1−p。因此，可以使用这些概率值来计算上述公式中的各项。</p></blockquote><h2 id="平均自信息量-信息熵"><a href="#平均自信息量-信息熵" class="headerlink" title="平均自信息量(信息熵)"></a>平均自信息量(信息熵)</h2><p>定义：离散随机变量X的平均自信息定义为，其样本空间为{xi, i&#x3D;1, 2,…,n}，则事件X&#x3D;xi的平均自信息量的定义为</p><p>$$<br>H(X)&#x3D;E{log(\frac{1}{P(x_i)})}&#x3D;\sum^n_{i&#x3D;1}P(x_i)I(x_i)&#x3D;-\sum^n_{i&#x3D;1}P(x-_i)logP(x_i)<br>$$</p><p>其中H(X)表示每个信源符号的平均信息量。</p><h2 id="平均条件自信息量-条件熵"><a href="#平均条件自信息量-条件熵" class="headerlink" title="平均条件自信息量(条件熵)"></a>平均条件自信息量(条件熵)</h2><p>定义：平均条件自信息H(X|Y)定义为</p><p>$$<br>H(X|Y)&#x3D;\sum^n_{i&#x3D;1}\sum^m_{j&#x3D;1}P(x_iy_i)log\frac{1}{P(x_i|y_i)}<br>$$</p><blockquote><p>思考题：计算二元对称(BSC)信道的平均条件自信息量(条件熵)?</p></blockquote><h2 id="无失真信源编码"><a href="#无失真信源编码" class="headerlink" title="无失真信源编码"></a>无失真信源编码</h2><h3 id="等长信源编码定理"><a href="#等长信源编码定理" class="headerlink" title="等长信源编码定理"></a>等长信源编码定理</h3><p>定理: 一个熵为H(X)的离散无记忆信源，若对信源长为N的符号序列进行等长编码，设码字是从r个字母的码符号集合中，选取l个码元组成。对于任意的ε&gt;0，只要满足</p><p>$$<br>\frac{l}{N}\geq \frac{H(X)+\varepsilon}{log\gamma}<br>$$</p><p>则当N足够大时，可实现几乎无失真编码，即译码错误概率可为任意小。</p><h3 id="变长码"><a href="#变长码" class="headerlink" title="变长码"></a>变长码</h3><table><thead><tr><th>字母</th><th>码字</th><th>字母</th><th>码字</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>E</td><td>10</td></tr><tr><td>B</td><td>1</td><td>F</td><td>11</td></tr><tr><td>C</td><td>00</td><td>G</td><td>000</td></tr><tr><td>D</td><td>01</td><td>H</td><td>111</td></tr></tbody></table><p>若对字母序列ABADCAB进行编码，则得到0 1 0 01 00 0 1<br>译码不唯一：可能被译为DADAAAB(01 0 01 0 0 0 1)<br>或者AEDGB(0 10 01 000 1)</p><blockquote><p>注：变长码必须是惟一可译码，才能实现无失真编码。</p></blockquote><h3 id="变长信源编码定理"><a href="#变长信源编码定理" class="headerlink" title="变长信源编码定理"></a>变长信源编码定理</h3><p>定理:一个熵为H(X)的离散无记忆信源，并有r个码元的码符号集合，总可以找到一种无失真编码方法，构成惟一可译码，使其平均码长满足</p><p>$$<br>\frac{H(X)}{logr}\leq\bar{L}&lt;\frac{H(X)}{logr}+1<br>$$</p><p>则当N足够大时，可实现几乎无失真编码，即译码错误概率可为任意小。</p><h3 id="信道的信息传输率"><a href="#信道的信息传输率" class="headerlink" title="信道的信息传输率"></a>信道的信息传输率</h3><p>变长信源编码定理中的极限值H(X)&#x2F;logr同等长信源编码定理中的极限值是一致的。</p><p>定义：信道的信息传输率(码率)为</p><p>$$<br>R&#x3D;\frac{H(X)}{logr}<br>$$</p><p>得到编码后信道的信息传输率为</p><p>$$<br>R\le\bar{L}<br>$$</p><h2 id="经典的信源编码方法"><a href="#经典的信源编码方法" class="headerlink" title="经典的信源编码方法"></a>经典的信源编码方法</h2><h3 id="信源编码—霍夫曼-Huffman-编码"><a href="#信源编码—霍夫曼-Huffman-编码" class="headerlink" title="信源编码—霍夫曼(Huffman)编码"></a>信源编码—霍夫曼(Huffman)编码</h3><p>一个离散无记忆信源有7个符号xi, i&#x3D;1,..,7，P(X&#x3D;x1)&#x3D;0.37, P(X&#x3D;x2)&#x3D;0.33, P(X&#x3D;x3)&#x3D;0.16, P(X&#x3D;x4)&#x3D;0.07, P(X&#x3D;x5)&#x3D;0.04, P(X&#x3D;x6)&#x3D;0.02, P(X&#x3D;x7)&#x3D;0.01, 将7个信源符号按照概率递减的顺序进行排序，构造如图8所示的霍夫曼树。<br>按照编码路径从后往前返回，就得到对应的码字x7&#x3D;111111, x6&#x3D;111110, x5&#x3D;11110, x4&#x3D;1110，x3&#x3D;110, x2&#x3D;10，x1&#x3D;0。</p><p><img src="/../../images/BUPT_note/Notes_on_Information_heory_and_Coding/Untitled%202.png" alt="Untitled"></p><blockquote><p>思考题：如何编程序实现霍夫曼编码?</p><ol><li>构建霍夫曼树：<ul><li>统计输入数据中每个字符的频率。</li><li>创建叶子节点，每个叶子节点代表一个字符，并将频率作为节点的权重。</li><li>将叶子节点放入一个优先队列（最小堆）中，以便频率最低的节点位于队列的前面。</li><li>重复以下步骤，直到只剩下一个节点为止：<ul><li>从队列中弹出两个频率最低的节点。</li><li>创建一个新的节点，其权重等于这两个节点的权重之和。</li><li>将新节点插入队列中。</li></ul></li><li>最后队列中剩下的节点就构成了霍夫曼树。</li></ul></li><li>生成霍夫曼编码：<ul><li>遍历霍夫曼树，从根节点开始，分别向左和向右遍历树的边。</li><li>每次向左移动时，将编码中添加一个 0，每次向右移动时，将编码中添加一个 1。</li><li>当到达叶子节点时，您就得到了字符的霍夫曼编码。</li></ul></li><li>构建编码表：<ul><li>将每个字符与其对应的霍夫曼编码存储在一个编码表中，以便在编码和解码过程中使用。</li></ul></li><li>编码和解码：<ul><li>使用编码表将输入数据编码为霍夫曼编码。</li><li>使用霍夫曼树将霍夫曼编码解码为原始数据。</li></ul></li></ol></blockquote><h3 id="游程编码"><a href="#游程编码" class="headerlink" title="游程编码"></a>游程编码</h3><p>游程：信源输出的字符序列中，各种字符连续的重复出现的字符串的个数。<br>游程编码：就是将这种字符序列映射成字符串的长度和字符串的位置的标志序列。<br>游程编码常用作图形文件的编码方式，如.bmp和.tiff。</p><blockquote><p>例子：考虑比特序列11111111111111100000000000000000001111，可以被表示成(15,1),(19,0),(4,1)，字符最长的重复的数目为19，因此，把该比特序列编码为(01111,1), (10011,0), (00100,1)，此时压缩率为18:38&#x3D;1:2.11。</p></blockquote><blockquote><p>思考题：如何编程序实现游程编码?</p><ol><li><strong>统计字符频率</strong>：<ul><li>首先，需要扫描输入文本并统计每个字符的频率。这是构建霍夫曼树的基础，因为频率高的字符将具有较短的编码。</li></ul></li><li><strong>构建霍夫曼树</strong>：<ul><li>基于字符频率，构建霍夫曼树。通常，使用一个优先队列（最小堆）来管理节点，每个节点代表一个字符及其频率。在构建过程中，反复合并两个最小频率的节点，创建一个新的节点，并将其插入回队列，直到队列中只剩下一个节点，即根节点，表示整个霍夫曼树已构建完成。</li></ul></li><li><strong>生成霍夫曼编码</strong>：<ul><li>遍历霍夫曼树，从根节点开始，每当沿着左子树移动时添加0，沿着右子树移动时添加1。当到达叶子节点时，记录下当前路径所对应的字符的编码。</li></ul></li><li><strong>构建编码表</strong>：<ul><li>将每个字符和它对应的霍夫曼编码存储在一个编码表中，以便在编码和解码过程中使用。</li></ul></li><li><strong>编码文本</strong>：<ul><li>使用编码表将输入文本中的字符编码为霍夫曼编码。</li></ul></li><li><strong>解码文本</strong>：<ul><li>使用霍夫曼树将霍夫曼编码解码为原始文本。</li></ul></li></ol></blockquote><h3 id="LZ-Lemple-Ziv-编码"><a href="#LZ-Lemple-Ziv-编码" class="headerlink" title="LZ(Lemple-Ziv)编码"></a>LZ(Lemple-Ziv)编码</h3><p>分段的方法：1)游程先取第一个符号作为第一段，然后再继续分段；2)若有出现与前面符号一样时，就再添加紧跟后面的一个符号一起组成一段；3)尽可能取最少个连着的符号并保证各段都不相同；4)以此类推，直至信源符号序列结束。<br>编码方法：首先去掉最后一个符号，然后看剩下的字符串在字典中的排序，这个排序值转换成二进制数作为指针X的值，最后一个信源符号作为码字第2项d的值，即得到码字(X, d)。</p><blockquote><p>例子：考虑比特序列101011011010101011，根据上面的编码方法可把该比特序列分段为1, 0, 10, 11, 01, 101, 010, 1011。<br>码字为：(000,1),( 000,0), (001,0), (001,1), (010,1), (011,1), (101,0), (110,1)。</p></blockquote><blockquote><p>思考题：如何编程序实现LZ编码?</p><ol><li><strong>初始化字典</strong>：创建一个空的字典，其中包含所有可能的单个字符作为初始词条。</li><li><strong>扫描输入数据</strong>：从左到右扫描输入数据，逐步构建编码输出。开始时，当前扫描位置指向输入数据的第一个字符。</li><li><strong>查找最长匹配</strong>：在字典中查找与当前扫描位置匹配的最长字符串（前缀），这个字符串必须存在于字典中。如果找到匹配，就将扫描位置移动到匹配字符串的末尾，否则将当前字符作为一个字典词条。</li><li><strong>输出编码</strong>：将匹配字符串的索引（或编码）输出到结果中，并将匹配字符串后的字符作为下一个字典词条的一部分。</li><li><strong>更新字典</strong>：将新的字典词条添加到字典中，以便下次匹配时使用。</li><li><strong>重复步骤3到步骤5</strong>，直到扫描完成整个输入数据。</li></ol></blockquote><h2 id="纠错码的理论基础"><a href="#纠错码的理论基础" class="headerlink" title="纠错码的理论基础"></a>纠错码的理论基础</h2><h3 id="信道容量"><a href="#信道容量" class="headerlink" title="信道容量"></a>信道容量</h3><p>定义：考虑某种概率分布为P(x)的离散无记忆信源，对于一个固定的信道，信道容量被定义为最大的平均互信息，此时传输每个符号平均获得的信息量最大，即对于每个固定的信道可以达到最大的信息传输率，即</p><p>$$<br>C&#x3D;\max_{P(X_j)}I(X;Y)&#x3D;\max_{P(X_J)}\sum^{q-1}<em>{j&#x3D;1}\sum^{r-1}</em>{i&#x3D;o}P(x_j)P(y_i|x_j)\log \frac {P(y_i|x_j)}{P(y_i)}<br>$$</p><p>其约束条件为</p><p>$$<br>P(x_j)\ge0\ ,\sum^{q-1}_{j&#x3D;0}P(x_j)&#x3D;1<br>$$</p><blockquote><p>思考题：如何计算给定某种信道的信道容量?</p><ol><li><p><strong>确定信道模型</strong>：首先，需要明确定义所使用的信道模型。不同的信道（例如二进制对称信道、高斯信道、无线信道等）具有不同的数学表示和特性。你需要了解信道的概率分布和噪声性质。</p></li><li><p><strong>计算信道容量</strong>：使用香农-哈特利定理来计算信道容量。该定理的公式如下：</p><p> $$<br> C+B·\log_2(1+SNR)<br> $$</p><p> 其中，</p><ul><li><em>C</em> 表示信道容量（比特每秒，bps）。</li><li><em>B</em> 表示信道的带宽（赫兹，Hz），它表示信号传输的频率范围。</li><li>SNRSNR 表示信噪比，定义为信号功率与噪声功率之比。通常以对数（以分贝为单位）表示。</li></ul></li><li><p><strong>SNR计算</strong>：计算信噪比（SNR）是信道容量计算的关键。SNR的计算方式取决于信道的特性。例如，在高斯信道中，SNR通常表示为信号功率与噪声功率之比。</p></li><li><p><strong>确定带宽</strong>：带宽（B）是信号传输的频率范围，通常以赫兹（Hz）表示。带宽的选择与具体的通信系统和应用有关。</p></li></ol></blockquote><h3 id="纠错编码的理论基础"><a href="#纠错编码的理论基础" class="headerlink" title="纠错编码的理论基础"></a>纠错编码的理论基础</h3><p>香农编码定理：如果系统的传输率小于信道容量，那么适当选择编码技术就能实现可靠通信，即可以将差错率减小到任意小的程度。</p><h3 id="信道编码定理"><a href="#信道编码定理" class="headerlink" title="信道编码定理"></a>信道编码定理</h3><p>定理：假设DMS有信源字符集X，熵为每信源符号H(X)比特，而且信源每Ts秒产生一个符号，那么信源的平均信息率为每秒H(X)&#x2F;Ts比特，假设信道可以每Tc秒使用一次，而信道容量为每次信道使用C比特，那么每单位时间的信道容量为每秒钟C&#x2F;Tc比特。如果H(X)&#x2F;Ts≤ C&#x2F;Tc，那么就存在编码方案使得在有噪声的信道上传输的信源消息，能够以任意小的错误概率进行恢复。</p><h1 id="第三章-线性分组"><a href="#第三章-线性分组" class="headerlink" title="第三章 线性分组"></a>第三章 线性分组</h1><h2 id="分组码"><a href="#分组码" class="headerlink" title="分组码"></a>分组码</h2><blockquote><p><strong>分组码：将消息序列分组进行编码</strong></p></blockquote><p>每组消息u有k个信息位，共有$2^k$个不同的消息</p><blockquote><p><strong>码字：编码器按照一定规则将每个输入消息u变换成二元n重v，n&gt;k，这个二元n重v称作消息u的码字或码矢。</strong></p></blockquote><p>所有$2^k$个码字组成的集合称作是分组码</p><blockquote><p>为什么在分组码中码字的个数是$2^k$个?<br>当编码字的位数是$2^k$时，这些码字可以更容易地排列成矩阵，例如二维数组，以便进行操作和计算。这种排列方式在编码和解码时通常更加高效。</p></blockquote><h2 id="线性分组码"><a href="#线性分组码" class="headerlink" title="线性分组码"></a>线性分组码</h2><p>线性分组码即具有线性性质的分组码</p><p><strong>定义：长为n，有$2^k$个码字的分组码，当且仅当其$2^k$个码字构成GF(2)上所有n重矢量空间的一个k维子空间时，称作线性(n, k)分组码。</strong></p><h2 id="生成矩阵"><a href="#生成矩阵" class="headerlink" title="生成矩阵"></a>生成矩阵</h2><p>∵ 线性(n,k)分组码C是一个k维子空间<br>∴ 在码C中能找到k个线性独立的码字$g_0, g_1,…, g_{k-1}，$使得C中的每个码字v都是这k个码字的一种线性组合，即 $v&#x3D;u_0g_0+u_1g_1+…+u_{k-1}g_{k-1}$</p><blockquote><p>生成矩阵：将k个线性独立的码字作为行，得到k×n阶矩阵</p><p>$$<br>G&#x3D;<br>\begin{pmatrix}<br>g_0\g_1\ \vdots \g_{k-1}<br>\end{pmatrix}&#x3D;\begin{pmatrix}<br>g_{00}&amp;g_{01}&amp;\dots&amp;g_{0n-1}\g_{10}&amp;g_{11}&amp;\dots&amp;g_{1n-1}\ \vdots \g_{(k-1)0}&amp;g_{(k-1)1}&amp;\dots&amp;g_{(k-1)n-1}<br>\end{pmatrix}<br>$$</p></blockquote><h2 id="一致校验-监督-矩阵"><a href="#一致校验-监督-矩阵" class="headerlink" title="一致校验(监督)矩阵"></a>一致校验(监督)矩阵</h2><p>∵ (n,k)线性码有r(r&#x3D;n-k)个校验码元<br>∴ 必须有r个独立的线性方程</p><p>对于任一码字c, 有cHT&#x3D;0</p><p>$∵c&#x3D;iG\<br>∴ GH^T&#x3D;0$</p><blockquote><p>校验矩阵：该矩阵由r行n列组成，即</p><p>$$<br>H&#x3D;\begin{pmatrix}<br>h_{1,n}&amp;h_{1,n-1}&amp;\dots&amp;h_{1,1}\h_{2,n}&amp;h_{2,n-1}&amp;\dots&amp;h_{2,1}\ \vdots \h_{r,n}&amp;h_{r,n-1}&amp;\dots&amp;h_{r,1}<br>\end{pmatrix}<br>$$</p></blockquote><p>一致校验矩阵的标准形式：经过初等变换，得到$H&#x3D;[Q I_r]$</p><h2 id="线性系统分组码"><a href="#线性系统分组码" class="headerlink" title="线性系统分组码"></a>线性系统分组码</h2><p><strong>定义：若(n,k)线性分组码C的生成矩阵形如$G&#x3D;[P I_k]$或$G&#x3D;[I_k P])$，此时称C为线性系统分组码。</strong></p><p>$$<br>G&#x3D;<br>\begin{pmatrix}<br>g_0\g_1\ \vdots \g_{k-1}<br>\end{pmatrix}&#x3D;[P \ I_k]&#x3D;\begin{pmatrix}<br>p_{0,0}&amp;p_{0,1}&amp;\dots&amp;p_{0,n-k-1}&amp; \vdots&amp;1&amp;0&amp;0&amp;\dots&amp;0 \p_{1,0}&amp;p_{1,1}&amp;\dots&amp;p_{1,n-k-1}&amp; \vdots&amp;0&amp;1&amp;0&amp;\dots&amp;0 \ p_{2,0}&amp;p_{2,1}&amp;\dots&amp;p_{2,n-k-1}&amp; \vdots&amp;0&amp;0&amp;1&amp;\dots&amp;0\ \vdots\ p_{k-1,0}&amp;p_{k-1,1}&amp;\dots&amp;p_{k-1,n-k-1}&amp; \vdots&amp;0&amp;0&amp;0&amp;\dots&amp;1<br>\end{pmatrix}<br>$$</p><p>此时，如果用任意消息u同G做乘法，就会发现每个码字都可以被分成两个部分：消息部分和冗余部分</p><h2 id="一致校验方程"><a href="#一致校验方程" class="headerlink" title="一致校验方程"></a>一致校验方程</h2><p>对于线性系统分组码</p><p>$$<br>v&#x3D;u·G&#x3D;(u_0,u_1,\dots,u_{k-1})·\begin{pmatrix}<br>p_{0,0}&amp;p_{0,1}&amp;\dots&amp;p_{0,n-k-1}&amp; \vdots&amp;1&amp;0&amp;0&amp;\dots&amp;0 \p_{1,0}&amp;p_{1,1}&amp;\dots&amp;p_{1,n-k-1}&amp; \vdots&amp;0&amp;1&amp;0&amp;\dots&amp;0 \ p_{2,0}&amp;p_{2,1}&amp;\dots&amp;p_{2,n-k-1}&amp; \vdots&amp;0&amp;0&amp;1&amp;\dots&amp;0\ \vdots\ p_{k-1,0}&amp;p_{k-1,1}&amp;\dots&amp;p_{k-1,n-k-1}&amp; \vdots&amp;0&amp;0&amp;0&amp;\dots&amp;1<br>\end{pmatrix}<br>$$</p><p>对应于消息$u&#x3D;(u_0,u_1,\dots,u_{k-1})$的码字是$v&#x3D;(v_0,v_1,\dots,v_{n-1})&#x3D;u·G$，即$v_{n-k+i}&#x3D;u_i , 0≤i≤k-1$</p><p>$v_j&#x3D;u_0p_{0j}+u_1p{1j}+…+u_{k-1}p_{k-1j}, 0≤j≤n-k-1$</p><p>上面两个式子正好反映系统的组成特性，最后这n-k个方程称为码C的一致校验方程。</p><h2 id="对偶码"><a href="#对偶码" class="headerlink" title="对偶码"></a>对偶码</h2><p><strong>定义：令S是$V_n$的k维子空间，并令$S_d$是$V_n$中这样矢量的集合，即对S中的任意u和$S_d$中的任意v，有u·v&#x3D;0，则$S_d$也是$V_n$的一个子空间，它称为S的对偶空间或零化空间。</strong></p><p>定理：令S是$V_n$中的一个k维子空间，则S的对偶空间的维数是n-k。</p><p>对偶码：以H为生成矩阵得到的(n,n-k)码称为码C的对偶码,记为$C_d$。</p><h2 id="系统码的一致校验矩阵"><a href="#系统码的一致校验矩阵" class="headerlink" title="系统码的一致校验矩阵"></a>系统码的一致校验矩阵</h2><p>若码C的生成矩阵具有系统形式$G&#x3D;[P I_k]$或$[I_k P]$，则其一致校验矩阵形如H&#x3D;$[I_{n-k} P^T]$或$H&#x3D;[P^T I_{n-k}]$。</p><h2 id="伴随式"><a href="#伴随式" class="headerlink" title="伴随式"></a>伴随式</h2><p>伴随式：当接收到r后，译码器计算下述n-k重$S&#x3D;r·H……T &#x3D;(s_0, s_1,…, s_{n-k-1})$则称S为r的伴随式。</p><p>当且仅当是一个码字(即无传输错误)时有S&#x3D;0，否则错误矢量本身就是一个码字，此时出现了不可检错误。只要码C设计适当，就几乎不会出现不可检错误。</p><h2 id="伴随式纠错"><a href="#伴随式纠错" class="headerlink" title="伴随式纠错"></a>伴随式纠错</h2><p>根据伴随式定义， 我们有$S&#x3D;r·H^T &#x3D;(v+e)·H^T&#x3D;v·H^T+e·H^T&#x3D;e·H^T$</p><p>可以看出，伴随式是错误图样的组合，即伴随式包含了一定程度的错误图样信息，因而可以用来纠错——伴随式纠错。</p><blockquote><p>考虑某(7,3)码，该码的生成矩阵G和H为</p><p>$$<br>G&#x3D;\begin{pmatrix}   0&amp;1&amp;1&amp;1&amp;1&amp;0&amp;0\     1&amp;0&amp;1&amp;1&amp;0&amp;1&amp;0\      1&amp;1&amp;1&amp;0&amp;0&amp;0&amp;1\end{pmatrix}, H&#x3D;\begin{pmatrix}   1&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1\     0&amp;1&amp;0&amp;0&amp;1&amp;0&amp;1\      0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0\       0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0\end{pmatrix}<br>$$</p><p>令u&#x3D;(101),v&#x3D;(1001101)是发送码字，r&#x3D;(0001101)是接收矢量，收到r后首先计算S&#x3D;r·HT &#x3D;(1000)≠0，由伴随式和错误图样的关系方程有：1&#x3D;e0+e5+e6, 0&#x3D;e1+e4+e6, 0&#x3D;e2+e4+e5+e6, 0&#x3D;e3+e4+e5, 则得到23&#x3D;8个错误图样(1000000), (1010111), (1101011), … …, 其中(1000000)是非零分量最少的图样，考虑BSC信道，则(1000000)是最为可能的错误矢量，因而确定v&#x3D;r+e&#x3D;(0001101)+ (1000000)&#x3D;(1001101)</p></blockquote><h2 id="汉明重量"><a href="#汉明重量" class="headerlink" title="汉明重量"></a>汉明重量</h2><p><strong>汉明重量：令v&#x3D;(v0, v1,…, vn-1)是二元n重，v的汉明重量w(v) 定义为v中非零分量的个数。</strong></p><blockquote><p>举例：设有两个码字{0100,1111},则它们的汉明重量为w(0100)&#x3D;1, w(1111)&#x3D;4</p></blockquote><p>重量分布：对于码长为n的一个分组码, 不同的码字可能具有 相同的汉明重量, 若记Ai为该码中汉明重量为i的码字个数, 称{A0, A1,…, An}是该码的重量分布。</p><h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p><strong>定义：令u&#x3D;(u0, u1,…, un-1)和v&#x3D;(v0, v1,…, vn-1)是两个二元n重，则u和v之间的汉明距离d(u, v)定义为u+v的汉明重量。</strong></p><blockquote><p>举例：设有两个码字{0100,1111},则它们的汉明距离d(0100, 1111)&#x3D;3</p></blockquote><p>汉明距离的性质：</p><ol><li>非负性，d(u, v)≥0；</li><li>d(u, v)&#x3D;0，当且仅当u&#x3D;v的时候；</li><li>对称性： d(u, v) &#x3D;d(v, u) ；</li><li>三角不等式： d(u, v)+d(v, w)≥d(u, w)</li></ol><h2 id="距离分布"><a href="#距离分布" class="headerlink" title="距离分布"></a>距离分布</h2><p><strong>定义：在(n,k)码中，任意两个码字之间都有一个汉明距离，两组不同码字之间可能有相同的汉明距离。若记Di(0≤i≤n)为距离为i的码字组数，那么称{D0, D1,…,Dn}为此分组码的距离分布，并且称能够使Di≠0的那个最小整数i为该码的最小码间距离。</strong></p><p>特别的，对于线性分组码，有如下定理：(n,k)线性码的最小码间距离等于非零码字的最小汉明重量。</p><blockquote><p><strong>定理：设(n,k)线性码C的最小码间距离为d，则1)若d≥t+1，则码C能检测t个随机错误；2)若d≥2t+1，则码C能纠正t个随机错误；3)若d≥t+e+1，则码C能纠正t (t≤e)个随机错误，同时还能检测e个随机错误。</strong></p></blockquote><p>定理：(n,k,d*)线性码C的最小码间距离d<strong>满足d</strong>≤n-k+1</p><p><strong>定义：若(n,k)线性码的最小码间距离d满足d&#x3D;n-k+1，那么称该码为最大距离可分码，简称MDS码。</strong></p><h2 id="标准阵"><a href="#标准阵" class="headerlink" title="标准阵"></a>标准阵</h2><p>令(n,k)线性码C的所有码字是接收矢量r是一个n重，则按如下的方式构造码C的标准阵：</p><p>$$<br>\begin{bmatrix}   v_1&#x3D;0&amp;v_2&amp;\dots&amp;v_i&amp;\dots&amp;v_{2^k}\     e_2&amp;e_2+v_2&amp;\dots&amp;e_2+v_i&amp;\dots&amp;e_2+v_{2^k}\      e_3&amp;e_3+v_2&amp;\dots&amp;e_3+v_i&amp;\dots&amp;e_3+v_{2^k}\   \vdots  \ e_{2^{n+k}}&amp;e_{2^{n+k}}+v_2&amp;\dots&amp;e_{2^{n+k}}+v_i&amp;\dots&amp;e_{2^{n+k}}+v_{2^k}\ \end{bmatrix}<br>$$</p><p>性质1：同一行中任意两个n重之和为一个码字。<br>性质2：在标准阵中，同一行没有两个n重是相同的，每个n重在且仅在一行中出现。</p><blockquote><p>性质2的证明：</p></blockquote><ol><li>假设第l行有2个n重是相同的，如对i≠j有$e_l+v_i&#x3D;e_l+v_j$，即$v_i&#x3D;v_j$，这与标准阵的构造相矛盾，故性质2的第一句话得证。</li><li>首先由定义知每个n重至少出现一次，假设一个n重在第l行和第m行(l&lt;m)都出现，则必存在i，使得该n重等于$e_l+v_i$，且存在j，使得该n重等于$e_m+v_j$，即有$e_m&#x3D;e_l+(v_i+v_j)&#x3D;e_l+v_s$，这意味着$e_m$在第l行，这与标准阵的构造定义相矛盾。<blockquote></blockquote></li></ol><h2 id="陪集"><a href="#陪集" class="headerlink" title="陪集"></a>陪集</h2><p>定义：标准阵中共有$2_{n-k}$行，它们称为码C的陪集。<br>陪集首：每个陪集中的第一个n重$e_i$称为陪集首。陪集中的任 何一个元素都可以作为陪集首，需要做置换操作。</p><p>对于一个码字$v_i$, 如果信道造成的错误图样是陪集首, 则接收矢量r在陪集中, 此时, 可以将接收矢量正确的译码为$v_i$; 否则, 若信道造成的错误图样不是陪集首, 则会造成错误译码。</p><blockquote><p>定理：陪集首是可纠正的错误图样，共有2n-k个可纠正的错误图样。</p></blockquote><h2 id="基于标准阵的译码方法"><a href="#基于标准阵的译码方法" class="headerlink" title="基于标准阵的译码方法"></a>基于标准阵的译码方法</h2><p>方法：如果接收矢量r落在标准阵中的第i行第j列，那么就将r译码为vj，同时错误图样为ei，即$r&#x3D;e_i+v_j$。</p><p><img src="/../../images/BUPT_note/Notes_on_Information_heory_and_Coding/Untitled%203.png" alt="Untitled"></p><p>缺点：当所考虑的码C的n和k的值都很大的时候，标准阵列的长度就变得非常的巨大，此时，用标准阵来译码就变得不实用了。</p><h2 id="最小距离译码方法"><a href="#最小距离译码方法" class="headerlink" title="最小距离译码方法"></a>最小距离译码方法</h2><p>方法：对BSC信道，为了使译码错误概率最小，可以选择汉明重量最小的n重做为陪集首，即将接收矢量r译码为与r的汉明距离最小的那个码字。</p><blockquote><p>举例：考虑码C&#x3D;{00000,01010,10101,11111}，<br>该码的最小距离是2。<br>如果传输的码字是11111，接收的矢量是11110，那么，<br>d(11110, 00000)&#x3D;4, d(11110, 01010)&#x3D;2,<br>d(11110, 10101)&#x3D;3, d(11110, 11111)&#x3D;1。<br>用最小距离译码方法可以得出传输的码字就是11111这样的结论。</p></blockquote><blockquote><p>思考题：有办法来给标准阵降阶么?<br>结合前面计算伴随式的例子，可以知道伴随式比标准阵的长度短很多。因此，可以用伴随式译码来代替标准阵译码方法。</p></blockquote><h2 id="伴随式译码"><a href="#伴随式译码" class="headerlink" title="伴随式译码"></a>伴随式译码</h2><p>定理：一个陪集的所有$2^k$个n重有同样的伴随式。不同陪集的伴随式不同。</p><p>证明：如果x,y属于同一个陪集，那么</p><p>$$<br>\Leftrightarrow x+C&#x3D;y+C\ \Leftrightarrow x-y \in C\ \Leftrightarrow(x-y)H^T&#x3D;0\ \Leftrightarrow xH^T&#x3D;yH^T\ \Leftrightarrow S(x)&#x3D;S(y)<br>$$</p><p>伴随式译码举例:</p><p>举例：考虑码C&#x3D;{0000,1011,0101,1110}，对应的标准阵就是</p><p>$$<br>\begin{matrix}   0000&amp;1011&amp;0101&amp;1110&amp;00\ 1000&amp;0011&amp;1101&amp;0110&amp;11\ 0100&amp;1111&amp;0001&amp;1010&amp;01\ 0010&amp;1001&amp;0111&amp;1100&amp;10\ 陪集首&amp;&amp;&amp;&amp;伴随式\end{matrix}<br>$$</p><p>如果接收矢量是v&#x3D;(1101)，先通过公式$S&#x3D;vH^T$求出伴随式(11)，确定对应的陪集首(1000)，这就是错误向量e。然后根据e+v&#x3D;(1000)+(1101)求出传输的码字为(0101)</p><h2 id="完备码"><a href="#完备码" class="headerlink" title="完备码"></a>完备码</h2><p>定义：一个能达到汉明界的码成为完备码，满足</p><p>$$<br>M\begin{Bmatrix}\begin{pmatrix}n\0  \end{pmatrix}+ \begin{pmatrix}n\1  \end{pmatrix}(q-1)+ \begin{pmatrix}n\2  \end{pmatrix}(q-1)^2+ \dots+\begin{pmatrix}n\t  \end{pmatrix}(q-1)^t \end{Bmatrix} &#x3D;q^n<br>$$</p><p>其中, M为码字数目, q是q元, n是码长, t是纠错能力</p><p>特殊的, 对于二元完备码, 满足$2^{n-k}&#x3D;\sum^{t}_{i&#x3D;0}\begin{pmatrix}n\i  \end{pmatrix}$</p><h2 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h2><p>定理：q元汉明码Ham(r,q)是参数为(n,k,d)的线性码，其中,$r&#x3D;n-k, n&#x3D;(q^r-1)&#x2F;(q-1), k&#x3D;(q^r-1)&#x2F;(q-1)-r, d_{min}&#x3D;3$。</p><p>特殊的, 对于二元汉明码, 满足$(n, k)&#x3D;(2^r-1, 2^r-1-r)$。</p><blockquote><p>构造汉明码的两种方法：</p></blockquote><ol><li>构造H阵的标准形式H&#x3D;[Q Ir], Q是构造Ir后剩下的2r-1-r列任意排列。</li><li>H阵的列是按r重表示的二进制数的顺序排列。<blockquote></blockquote></li></ol><h1 id="第四章-循环码"><a href="#第四章-循环码" class="headerlink" title="第四章 循环码"></a>第四章 循环码</h1><p>循环移位：将n重$v&#x3D;(v_{n-1}, v_{n-2}, … , v_1, v_0)$的分量循环左移一位, 得到另一个n重$v(1)&#x3D;(v_{n-2}, … , v_1, v_0, v_{n-1})$, 称为v的循环移位。若v的分量循环左移i位, 得到$v(i)&#x3D;(v_{n-i-1}, … , v_1, v_0, v_{n-1}, … , v_{n-i})$。</p><p>循环码的定义：一个(n, k)线性码C，若它的每个码字的任何循环移位都仍然是一个码字，则称此码为循环码。</p><blockquote><p>循环码的优势：具有许多固有的代数结构，可以找到各种实用的译码方法，使用具有反馈的线性移位寄存器可以容易的实现编码和伴随式计算。</p></blockquote><h2 id="码字多项式"><a href="#码字多项式" class="headerlink" title="码字多项式"></a>码字多项式</h2><p>码字多项式：为研究循环码的代数特性，将码字$v&#x3D;(v_{n-1}, v_{n-2}, … , v_1, v_0)$的各个分量看成是多项式</p><p>$$<br>v(x)&#x3D;\sum^{n-1}<em>{i&#x3D;0}v_ix^i&#x3D;v</em>{n-1}x^{n-1}+\dots+v_1x+v_0<br>$$</p><p>的系数，此多项式称为v的码字多项式。</p><p>对应于码矢v(i)&#x3D;( vn-i-1, … , v1, v0, vn-1, … , vn-i)的码字多项式为$v^{(i)}(x)&#x3D;v_{n-i-1}x^{n-1}+v_{n-i-2}x^{n-2}+…+v_1x^{i+1}+v_0x^i+v_{n-1}x^{i-1}+…+v_{n-i+1}x+v_{n-i}$</p><p>码字多项式$v^{(i)}(x)$就是$x^iv^{(0)}(x)&#x2F;(x^n+1)$的余式。</p><h2 id="循环码的代数性质"><a href="#循环码的代数性质" class="headerlink" title="循环码的代数性质"></a>循环码的代数性质</h2><blockquote><p>定理1：循环码C中次数最低的非零码字多项式是唯一的。</p></blockquote><p>证明：令$g(x)&#x3D;\sum^r_{i&#x3D;0}g_ix_i,g_r&#x3D;1$是C中次数最低的码字多项式，若g(x)不唯一，则存在另一个码字多项式$g*(x)&#x3D;\sum^r_{i&#x3D;0}g^*_ix_i,g^*_r&#x3D;1$ ，由线性性质可知，g(x)+g*(x)也是一个码字多项式，但它的次数小于r，和前提矛盾，因此，循环码C中次数最低的非零码字多项式是唯一的。证毕。</p><blockquote><p>定理2：若$g(x)&#x3D;x^r+g_{r-1}x^{r-1}+…+g_1x+g_0$是(n, k)循环码C中次数最低的非零码字多项式, 则必有$g_0&#x3D;1$。</p></blockquote><p>证明：若$g_0&#x3D;0$，则$g(x)&#x3D;x(x^{r-1}+g_{r-1}x^{r-2}+…+g_2x+g_1)$，将g(x)循环左移n-1位之后，可以得到一个次数更低的码字多项式，其次数为r-1，和前提矛盾，则必有$g_0&#x3D;1$。证毕。<br>结合定理1和定理2，知在(n,k)循环码中，次数最低的非零码字多项式形如$g(x)&#x3D;x^r+g_{r-1}x^{r-1}+…+g_1x+1$。</p><p>考虑多项式$g^{(1)}(x)&#x3D;xg(x), g^{(2)}(x)&#x3D;x^2g(x),…，g^{(n-r-1)}(x)&#x3D;x^{n-r-1}g(x)$都是g(x)的循环移位, 它们都是码字多项式, 次数分别为r+1, r+2, …, n-1。<br>根据码字多项式的线性性质可知，它们的任意线性组合<br>$v(x)&#x3D;u_{n-r-1}x^{n-r-1}g(x)+…+u_1xg(x)+u_0g(x)&#x3D;(u_{n-r-1}x^{n-r-1}+…+u_1x+u_0)g(x)$也是C的码字多项式。<br>(n, k)循环码的码字多项式, 次数分别为r, r+1, r+2, … , n-1，次数小于或等于n-1并且是g(x)的倍式的二元多项式共有$2^{n-r}$个, 它们是(n, k)循环码C的所有码字, 因此, 必有k&#x3D;n-r或r&#x3D;n-k。</p><blockquote><p>定理3：若g(x)是(n, k)循环码C中次数最低的非零码字多项式，一个次数小于或等于n-1的二元多项式f(x)是码字多项式当且仅当f(x)是g(x)的倍式。</p></blockquote><p>证明：反证法。设f(x)是码字多项式且其次数小于或等于n-1,假设f(x)&#x3D;a(x)g(x)+b(x), deg(b(x))&lt;r，<br>由线性性质知b(x)&#x3D;f(x)+a(x)g(x)也是一个码字多项式,而deg(b(x))&lt;deg(g(x))，这和前提矛盾，则只能当f(x)是g(x)的倍式的时候，f(x)是码字多项式。证毕。</p><h2 id="生成多项式"><a href="#生成多项式" class="headerlink" title="生成多项式"></a>生成多项式</h2><blockquote><p>定理1：在(n,k)循环码C中存在且仅存在一个次数为n-k的码字多项式$g(x)&#x3D;x^{n-k}+g_{n-k-1}x^{n-k-1}+…+g_2x^2+g_1x+1$，称为生成多项式，使得每个次数小于或等于n-1的二元多项式是码字多项式当且仅当此多项式是g(x)的倍式。</p></blockquote><blockquote><p>定理2：(n, k)循环码的生成多项式g(x)是$x^n+1$的因式。</p></blockquote><p>证明：根据：码字多项式$v^{(i)}(x)$就是$x^iv^{(0)}(x)&#x2F;(x^n+1)$的余式。则有$x^kg(x)&#x3D;(x^n+1)+g^{(k)}(x)$，而$g^{(k)}(x)$是g(x)的k次循环移位，也是码字多项式，因此，它是g(x)的倍式。</p><blockquote><p>定理3：若g(x)是一个n-k次多项式，并且是$x^n+1$的因式，则g(x)生成一个(n, k)循环码。</p></blockquote><h2 id="循环码的生成矩阵"><a href="#循环码的生成矩阵" class="headerlink" title="循环码的生成矩阵"></a>循环码的生成矩阵</h2><p>考虑以$g(x)&#x3D;\sum^{n-k}_{i&#x3D;0}g_ix^i$为生成矩阵的(n,k)循环码C，由于$g(x), xg(x), … , x^{k-1}g(x)$张成C，将这k个多项式的k个n重做为k×n阶矩阵的行，一般选择前k-1位为0的向量作为g(x)，则得到C的生成矩阵为</p><p>$$<br>G(x)&#x3D;\begin{bmatrix} x^{K-1}g(x)\ \dots \xg(x)\g(x) \end{bmatrix}&#x3D;\begin{bmatrix} g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0&amp;0&amp;0&amp;0&amp;\dots&amp;0\ 0&amp;g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0&amp;0&amp;0&amp;\dots&amp;0\ 0&amp;0&amp;g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0&amp;0&amp;\dots&amp;0\ \dots&amp;&amp;&amp;\dots&amp;&amp;&amp;&amp;&amp;&amp;\dots \ 0&amp;0&amp;\dots&amp;0&amp;0&amp;g_{n-k}&amp;\dots&amp;g_2&amp;g_1&amp;g_0\end{bmatrix}<br>$$</p><p>其中$g_0&#x3D;g_{n-k}&#x3D;1$</p><h2 id="一致校验矩阵"><a href="#一致校验矩阵" class="headerlink" title="一致校验矩阵"></a>一致校验矩阵</h2><p>因为生成多项式g(x)是$x^{n+1}$的因式, 所以存在另一个多项式$h(x)&#x3D;\sum^k_{i&#x3D;0}h_ix^i,h_k&#x3D;h_0&#x3D;1$ , 使得g(x)h(x)&#x3D;xn+1, 此多项式h(x)称为码C的校验多项式h(x), 故可以得到码C的一致校验矩阵H。<br>设$v&#x3D;(v_{n-1}, … , v_1,v_0 )$是C的一个码矢, 则v(x)&#x3D;a(x)g(x), 有$v(x)h(x)&#x3D;a(x)g(x)h(x)&#x3D;a(x)(x^n+1)&#x3D;a(x)x^n+a(x)$, 由于deg(a(x))≤k-1, 故在$a(x)x^n+a(x)$中不会出现$x^{n-1}, … , x^{k+1}, x^k$等各次幂, 于是v(x)h(x)的展开式中$x^{n-1}, … , x^{k+1}, x^k$的系数等于零。<br>因此, 得到以下n-k个方程$h_0v_{n-j}+h_1v_{n-j-1}+…+h_kv_{n-j-k}&#x3D;0, j&#x3D;1, … , n-k$。则码C的一致校验矩阵为</p><p>$$<br>H&#x3D;\begin{bmatrix}     h_k&amp;h_{k-1}&amp;h_{k-2}&amp;\dots&amp;h_0&amp;0&amp;0&amp;\dots&amp;0\ 0&amp;h_k&amp;h_{k-1}&amp;\dots&amp;h_1&amp;h_0&amp;0&amp;\dots&amp;0\ \dots\ 0&amp;0&amp;0&amp;\dots&amp;h_k&amp;h_{k-1}&amp;h_{k-2}&amp;\dots&amp;h_0\end{bmatrix}<br>$$</p><h2 id="系统循环码的编码方法"><a href="#系统循环码的编码方法" class="headerlink" title="系统循环码的编码方法"></a>系统循环码的编码方法</h2><p>给定循环码的生成多项式g(x), 可以使该码成为系统形式。<br>假定待编码的消息是$u&#x3D;(u_{k-1}, … , u_1, u_0 )$, 则对应的消息多项式为$u(x)&#x3D;u_{k-1}x^{k-1}+…+u_2x^2+u_1x+u_0$, 从而有$x^{n-k}u(x)&#x3D;u_{k-1}x^{n-1}+…+u_1x^{n-k+1}+u_0x^{n-k}$。<br>用生成多项式g(x)除xn-ku(x), 得到xn-ku(x)&#x3D; a(x)g(x)+b(x), deg(b(x))&lt;n-k。</p><blockquote><p>循环码的编码是由多项式的乘法、除法以及加法运算完成的, 这些运算都可以由移位寄存器、加法器以及门电路来实现。</p></blockquote><p>系统循环码的编码步骤如下：<br>步骤1：先用xn-k乘以消息多项式$u(x)&#x3D;u_{k-1}x^{k-1}+…+u_2x^2+u_1x+u_0$；<br>步骤2：用生成多项式g(x)除$x^{n-k}u(x)$，得到余式b(x)；<br>步骤3：联合b(x)和$x^{n-k}u(x)$，得到码字多项式$v(x)&#x3D;x^n-ku(x)+b(x)$</p><h2 id="复习：多项式的除法"><a href="#复习：多项式的除法" class="headerlink" title="复习：多项式的除法"></a>复习：多项式的除法</h2><p><img src="/../../images/BUPT_note/Notes_on_Information_heory_and_Coding/Untitled%204.png" alt="Untitled"></p><h2 id="g-x-除法电路编码器"><a href="#g-x-除法电路编码器" class="headerlink" title="g(x)除法电路编码器"></a>g(x)除法电路编码器</h2><p><img src="/../../images/BUPT_note/Notes_on_Information_heory_and_Coding/Untitled%205.png" alt="Untitled"></p><h2 id="伴随式计算和错误检测"><a href="#伴随式计算和错误检测" class="headerlink" title="伴随式计算和错误检测"></a>伴随式计算和错误检测</h2><p>伴随式定义为$S&#x3D;rH^T$<br>对系统循环码而言, $r(x)&#x3D;\sum^{n-1}<em>{i&#x3D;0}r_ix^i$是接收多项式$g(x)&#x3D;\sum^{n-k-1}</em>{i&#x3D;0}g_ix^i$,<br>是生成多项式, 用g(x)去除r(x)所得的余式, 就是伴随式s(x), 即r(x)&#x3D;a(x)g(x)+s(x)。<br>∵ r(x)&#x3D;v(x)+e(x), v(x)&#x3D;q(x)g(x), r(x)&#x3D;a(x)g(x)+s(x)<br>∴ q(x)g(x)+e(x)&#x3D;a(x)g(x)+s(x)<br>∴ e(x)&#x3D;[q(x)+a(x)]g(x)+s(x)</p><h2 id="伴随式的性质"><a href="#伴随式的性质" class="headerlink" title="伴随式的性质"></a>伴随式的性质</h2><p>性质1：令s(x)是接收多项式r(x)的伴随式, 则用生成多项式g(x)除xs(x)所得的余式$s^{(1)}(x)$就是r(x)循环移位一次$r^{(1)}(x)$的伴随式。<br>性质2：(n, k)循环码能够检测长度小于等于n-k的任何突发错误, 换句话说, 每个长度小于等于n-k的突发错误的伴随式不等于0。<br>性质3：伴随式等于生成多项式除错误图样后所得的余式。</p><blockquote><p>伴随式的这些性质对于译码非常有用。举例来说, 若e(x)是可以纠正的错误图样, 则e(x)的循环移位也是可以纠正的错误图样。</p></blockquote><h2 id="循环码的译码"><a href="#循环码的译码" class="headerlink" title="循环码的译码"></a>循环码的译码</h2><blockquote><p>循环码的译码分为3步：1)计算伴随式; 2)由伴随式得到错误图样; 3)纠正错误。</p></blockquote><h1 id="第五章-BCH码"><a href="#第五章-BCH码" class="headerlink" title="第五章 BCH码"></a>第五章 BCH码</h1><h2 id="BCH码简介"><a href="#BCH码简介" class="headerlink" title="BCH码简介"></a>BCH码简介</h2><p>BCH码的优势：纠错能力强, 能够纠正多个随机错误的循环码; 编译码设备不太复杂; 到目前为止, 对于其他线性码的研究方法, 都是先构造一个码, 然后找出它的最小距离, 以估计该码的纠错能力, 对于BCH码, 反过来, 从先指定这个码能纠正多少个随机错误开始进行研究。</p><h3 id="本原元和本原多项式"><a href="#本原元和本原多项式" class="headerlink" title="本原元和本原多项式"></a>本原元和本原多项式</h3><p>本原元：有限域上存在元素a，使得G中的每个非零元素都是a的某次幂的形式，该元素a称为本原元。</p><p>本原多项式：有限域GF(q)上的本原多项式f(x),是系数取自GF(q)上，以扩域$GF(q^m)$中本原元为根的最小多项式。</p><p>定理1：若$b_1,b_2,..,b_{q-1}$是有限域GF(q)上的所有非零元素，则$x^{q-1}-1&#x3D;(x-b_1)(x-b_2)…(x-b_{q-1})$。</p><h3 id="举例-GF-23-上的乘法运算"><a href="#举例-GF-23-上的乘法运算" class="headerlink" title="举例: GF(23)上的乘法运算"></a>举例: GF(23)上的乘法运算</h3><p>选择本原元a&#x3D;x, 本原多项式$p(x)&#x3D;x^3+x+1$</p><table><thead><tr><th>$a^{-\infty}&#x3D;x^{-\infty}&#x3D;0$</th><th>000</th></tr></thead><tbody><tr><td>$a^0&#x3D;x^0&#x3D;1$</td><td>001</td></tr><tr><td>$a^1&#x3D;x$</td><td>010</td></tr><tr><td>$a^2&#x3D;x^2$</td><td>100</td></tr><tr><td>$a^3&#x3D;x+1$</td><td>011</td></tr><tr><td>$a^4&#x3D;x^2+x$</td><td>110</td></tr><tr><td>$a^5&#x3D;x^2+x+1$</td><td>111</td></tr><tr><td>$a^6&#x3D;x^2+1$</td><td>101</td></tr><tr><td>$a^7&#x3D;a^0&#x3D;1$</td><td></td></tr></tbody></table><p>乘法运算：</p><p>$$<br>(010)·(100)<br>\leftrightarrow a^3·a^4&#x3D;1<br>\leftrightarrow001\ (011)·(110)<br>\leftrightarrow a^6·a^5&#x3D;a^4<br>\leftrightarrow110<br>$$</p><p>因为本原元a&#x3D;x, 所以p(a)&#x3D;0</p><p>$$<br>a^3+a+1&#x3D;(x+1)+x+1&#x3D;0\ (011)+(010)+(001)&#x3D;(000)<br>$$</p><h3 id="GF-2-上多项式根的特点"><a href="#GF-2-上多项式根的特点" class="headerlink" title="GF(2)上多项式根的特点"></a>GF(2)上多项式根的特点</h3><p>定理：若f(x)是系数取自GF(2)的多项式, 令b是GF(2)扩域中的元素, 若b是f(x)的根, 则对任意的l≥0, $b^{2l}$也是f(x)的根。</p><blockquote><p>注：元素$b^{2l}$称为b的共轭元，以上定理说明若是b多项式f(x)的根，则b的所有共轭元$b^{2l}$也是f(x)的根。</p></blockquote><p>举例：${a^1, a^2, a^4}$是共轭的元素，因为它们都是极小多项式$f_2(x)&#x3D;x^3+x+1$的根。</p><p>最低公倍式：若f(x)为a(x)与b(x)的所有公倍式中次数最低的，并且首项系数为1，记为LCM(a(x), b(x))。</p><h2 id="BCH码的定义"><a href="#BCH码的定义" class="headerlink" title="BCH码的定义"></a>BCH码的定义</h2><p>BCH码的定义：给定任一有限域GF(q)及其扩域$GF(q^m)$, 其中, q是素数或者素数幂, m为一个正整数。若码元是取自GF(q)上的一个循环码, 它的生成多项式g(x)的根集合R中含有以下2t个连续根${b^p, b^{p+1},.., b^{p+2t-1}}$, 则由g(x)生成的循环码称为q进制的BCH码, 其中$b∈GF(q^m)$是域中的n阶元素, $b^{p+i} ∈GF(q^m) (0≤i≤2t-1)$, p是任意整数。对于常见的情况, p等于0或者1。若p&#x3D;1, 称之为狭义的BCH码。</p><p>本原BCH码的定义：若g(x)的根中有一个是$GF(q^m)$的本原元, 码长$n&#x3D;q^m-1$, 此时就称g(x)生成的BCH码为本原BCH码; 否则就称为非本原BCH码, 其码长是$q^m-1$的因子。</p><h3 id="BCH码的构造"><a href="#BCH码的构造" class="headerlink" title="BCH码的构造"></a>BCH码的构造</h3><p>构造方法：设$f_i(x)$和$q_i$分别是$b^{p+i}(0≤i≤2t-1)$的最小多项式和阶, 则BCH码的生成多项式g(x)和码长n可分别表示为$g(x)&#x3D;LCM(f_0(x), f_1(x),…, f_{2t-1}(x)), n&#x3D;LCM(q_0, q_1,…, q_{2t-1})$。</p><blockquote><p>构造可以纠t个错误的BCH码(其码长$n&#x3D;q^m-1$)的生成多项式的步骤如下：<br>步骤1：选择一个阶数为m的本原多项式, 构造扩域$GF(q^m)$;<br>步骤2：找到对应于$b^i(i&#x3D;1,…,p)$的极小多项式$f_i(x)$;<br>步骤3：能纠t个错误的BCH码的生成多项式为$g(x)&#x3D;LCM(f_1(x), f_2(x),…, f_{2t}(x))$。</p></blockquote><h3 id="BCH码限定理"><a href="#BCH码限定理" class="headerlink" title="BCH码限定理"></a>BCH码限定理</h3><p>定理1：若BCH码的生成多项式g(x)的根含有2t个连续根, 则该码的最小距离d≥2t+1。</p><p>d&#x3D;2t+1称为该码的设计距离。</p><blockquote><p>注：一旦固定n和t, 就可以得到该BCH码的生成多项式, 信息位的长度k可以由生成多项式的阶数得到。</p></blockquote><p>当n不变的情况下，较大的t，就会使得k较小；即冗余度高，可以纠更多的错误。</p><blockquote><p><strong>思考题</strong>：如何在由GF(2)生成的扩域GF(24)上构造BCH码的生成多项式？</p></blockquote><p>考虑本原多项式$p(z)&#x3D;z^4+z+1$, 本原元a&#x3D;z, a的幂次可以生成$GF(2^4)$上的所有非零元素。</p><table><thead><tr><th>a的幂次</th><th>$GF(2^4)$上的非零元素</th><th>极小多项式</th></tr></thead><tbody><tr><td>$a^1$</td><td>$z$</td><td>$x^4+x+1$</td></tr><tr><td>$a^2$</td><td>$z^2$</td><td>$x^4+x+1$</td></tr><tr><td>$a^3$</td><td>$z^3$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^4$</td><td>$z+1$</td><td>$x^4+x+1$</td></tr><tr><td>$a^5$</td><td>$z^2+z$</td><td>$x^2+x+1$</td></tr><tr><td>$a^6$</td><td>$z^3+z^2$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^7$</td><td>$z^3+z+1$</td><td>$x^4+x^3+1$</td></tr><tr><td>$a^8$</td><td>$z^2+1$</td><td>$x^4+x+1$</td></tr><tr><td>$a^9$</td><td>$z^3+z$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^{10}$</td><td>$z^2+z+1$</td><td>$x^2+x+1$</td></tr><tr><td>$a^{11}$</td><td>$z^3+z^2+z$</td><td>$x^4+x+1$</td></tr><tr><td>$a^{12}$</td><td>$z^3+z^2+z+1$</td><td>$x^4+x^3+x^2+x+1$</td></tr><tr><td>$a^{13}$</td><td>$z^3+z^2+1$</td><td>$x^4+x^3+1$</td></tr><tr><td>$a^{14}$</td><td>$z^3+1$</td><td>$x^4+x^3+1$</td></tr><tr><td>$a^{15}$</td><td>1</td><td>x+1</td></tr></tbody></table><p>如果想要构造可以纠1个错误的BCH码的生成多项式, 即t&#x3D;1, 码长n&#x3D;15<br>BCH码的生成多项式为$g(x)&#x3D;LCM(f_1(x), f_2(x),…, f_{2t}(x))$<br>根据上页的表格来获得极小多项式f1(x)和f2(x)<br>因此, 得到如下的可以纠正一个错误的BCH码的生成多项式$g(x)&#x3D;LCM(f_1(x), f_2(x))&#x3D; LCM(x^4+x+1, x^4+x+1)&#x3D;x^4+x+1$<br>∵deg(g(x))&#x3D;4, ∴n-k&#x3D;4, k&#x3D;11, 这样就得到了一个可以纠一个错误的BCH(15, 11)码, 该码的设计距离d&#x3D;2t+1&#x3D;3<br>可以计算出该码的最小距离也是3，即该码的设计距离等于该码的最小距离</p><p>如果想要构造可以纠2个错误的BCH码的生成多项式, 即t&#x3D;2, 码长n&#x3D;15<br>BCH码的生成多项式为$g(x)&#x3D;LCM(f_1(x), f_2(x),…, f_{2t}(x))&#x3D; LCM(f_1(x), f_2(x), f_3(x), f_4(x))$<br>根据11页的表格来获得极小多项式f1(x)-f4(x)<br>于是得到$g(x)&#x3D;LCM(f_1(x), f_2(x) , f_3(x), f_4(x))&#x3D; LCM(x^4+x+1, x^4+x+1, x^4+x^3+x^2+x+1, x^4+x +1)&#x3D;(x^4+x+1)(x^4+x^3+ x^2+x+1) &#x3D;x^8+x^7+x^6+x^4+1$<br>∵deg(g(x))&#x3D;8，∴n-k&#x3D;8，k&#x3D;7, 这样就得到了一个可以纠一个错误的BCH(15,7)码，该码的设计距离d&#x3D;2t+1&#x3D;5<br>可以计算出该码的最小距离也是5。</p><h1 id="第六章-RM码"><a href="#第六章-RM码" class="headerlink" title="第六章 RM码"></a>第六章 RM码</h1><h3 id="RM码的优点和缺点"><a href="#RM码的优点和缺点" class="headerlink" title="RM码的优点和缺点"></a>RM码的优点和缺点</h3><p><strong>缺点</strong>：与BCH码相比，除了一阶RM码和中等码长的RM码外，RM码的最小距离比同样码长的BCH码的最小距离小。RM码的纠错性能不如Turbo码和LDPC码<br><strong>优点</strong>：RM码能用大逻辑译码算法，比BCH码用的迭代算法简单。译码延时短，无错误平层现象，其误码率会随着信噪比增加无限接近于零。因此，RM码可以适应多种不同的信道，满足有实时性要求的应用环境，既可以单独使用，也可以作为内码与RS码等级联使用，从而大大提升纠错性能</p><h2 id="线性码"><a href="#线性码" class="headerlink" title="线性码"></a>线性码</h2><p><strong>定义</strong>：一个码长为n的p元码C叫做线性码，是指C是向量空间$F_p^n$的向量子空间，即C满足如下的性质：对$F_p^n$中任意元素α和β，如果$c_1$和$c_2$属于C，则$αc_1+βc_2$也属于C。<br><strong>定理</strong>：设C是参数为(n,k)的p元线性码。<br>1)若G是C的一个生成矩阵，而H是Fp上一个(n−k)行n列的矩阵。则H是C的一个校验矩阵当且仅当$rank(H)&#x3D;n−k$，并且$HG^T&#x3D;0_{n−k,k}$；<br>2) 若$G&#x3D;(I_k,P), H&#x3D;(−P^T,I_{n−k})，$则G是C的一个生成矩阵当且仅当H是C的一个校验矩阵。</p><h2 id="向量外积"><a href="#向量外积" class="headerlink" title="向量外积"></a>向量外积</h2><p><strong>定义</strong>：设$a&#x3D;(a_{n−1},a_{n−2},···,a_0),b&#x3D;(b_{n−1},b_{n−2},···,b_0)$是GF(2)上的两个n维向量，则向量$(a_{n−1}b_{n−1},a_{n−2}b_{n−2},···,a_0b_0)$称为a与b的外积，记为a×b。</p><h2 id="布尔函数"><a href="#布尔函数" class="headerlink" title="布尔函数"></a>布尔函数</h2><p><strong>定义</strong>：设m为正整数，一个m元布尔函数$f&#x3D;f(x_1,···,x_m)$是由$F_2^m$到$F_2$的映射，即m个变量$x_1,···,x_m$均取值于$F_2$，并且函数值也属于$F_2$。<br>由于$F_2^m$中向量的个数为$2^m$，而f在每个向量的取值均彼此独立地可取1或0，所以m元布尔函数共有$2^{2^m}$个。</p><blockquote><p>例子：一元布尔函数f(x)共有$2^{2^1}&#x3D;4$个，它们是：<br>1）f(0)&#x3D;f(1)&#x3D;0，即f(x)≡0；<br>2）f(0)&#x3D;f(1)&#x3D;1,即f(x)≡1；<br>3）f(0)&#x3D;0,f(1)&#x3D;1，即f(x)&#x3D;x；<br>4）f(0)&#x3D;1,f(1)&#x3D;0，即f(x)&#x3D;x+1。</p></blockquote><p><strong>定理</strong>：每个m元布尔函数$g(x_1,···,x_m)$均可唯一地表示成$g(x_1,···,x_m)&#x3D;c+c_1x_1 + ··· +c_mx_m+c_{12}x_1x_2+c_{13}x_1x_3+ ··· + c_{m-1,m}x_{m-1}x_m+c_{123}x_1x_2x_3+ ··· + c_{12···m}x_1x_2···x_m$，其中所有系数和常数都属于$F_2$。</p><p>令$v_0&#x3D;(0,0,···,0), v_1&#x3D;(1,0,···,0), v_2&#x3D;(0,1,···,0), v_3&#x3D;(1,1,···,0), ··· ,v_n-1&#x3D;(1,1,···,1), n&#x3D; 2^m，$然后便可把每个m元布尔函数$f(x_1,···, x_m)$表示成$F_2^n$中的向量(也叫 f 的真值表或向量表示)，具体为$c_f&#x3D;(f(v_0), f(v_1),···, f(v_{n-1}))∈F_2^n, n&#x3D; 2^m$<br>这时布尔函数相加和相乘分别对应于向量按分量相加和相乘。</p><h2 id="RM码"><a href="#RM码" class="headerlink" title="RM码"></a>RM码</h2><p><strong>定义</strong>：设$m≥1, n&#x3D;2^m, 0≤r≤m$。向量空间$F_2^n$的子集合<br>$RM(r,m)&#x3D;{c_f&#x3D;(f(v_0), f(v_1),···, f(v_{n-1}))∈F_2^n|f∈B_m,deg(f)≤r}$<br>叫做r阶的Reed-Muller码(简称RM码)，这里$v_i∈F_2^m$。</p><p><strong>定理</strong>：RM码RM(r,m)是线性码，基本参数为$(n,k,d)&#x3D;(2^m,∑_{t&#x3D;0}^r\begin{pmatrix}m\t\end{pmatrix}),2^{m-r})$</p><h3 id="生成矩阵-1"><a href="#生成矩阵-1" class="headerlink" title="生成矩阵"></a>生成矩阵</h3><p>对于每一对正整数r和m(m&gt;r),有一个码长为$2^m$的RM码，称为码长为$2^m$的r阶RM码。它的生成矩阵是由矩阵块$G_0,G_1,···,G_r$组成的，即$G&#x3D;\begin{pmatrix}G_0\G_1\\dots\G_r\end{pmatrix}$</p><p>G0是码长为$n&#x3D;2^m$的全“1”向量<br>G1是$m×2^m$阶矩阵，即$G_1$是由所有长度为m的二进制的列向量组成的。$G_1$的最左边一列是全“0”向量，最后一列为全“1”向量，其他各列则是从左至右依递增顺序排列的二进制m重列向量<br>$G_l$的行是由所有$G_l$的l个行向量作外积所得的向量组成，因而$G_l$是一个$\begin{pmatrix} m\l\end{pmatrix}*2^m$阶矩阵。显然在G的行是线性无关的条件下，r阶RM码的信息位为$k&#x3D;1+\begin{pmatrix} m\l\end{pmatrix}+\begin{pmatrix} m\2\end{pmatrix}+\dots+\begin{pmatrix} m\r\end{pmatrix}$。</p><h3 id="RM码的构造"><a href="#RM码的构造" class="headerlink" title="RM码的构造"></a>RM码的构造</h3><p>从RM码的定义可以看出，一个r阶RM码可以通过增广一个(r-1)阶RM码得到，而一个(r-1)阶RM码可以由删信一个r阶RM码而获得，即通过简单计算，增加一个G矩阵分量或直接删除一个G矩阵分量<br>RM码的构造简单，纠错能力强，很容易根据需要设计出不同码长的RM码</p><h2 id="译码算法"><a href="#译码算法" class="headerlink" title="译码算法"></a>译码算法</h2><p>从RM码的生成矩阵G中可以看出，Gl的每行重量为$2^{m-l}$，这个结论对于一般的r阶RM码都是对的，因此，G的每行都有偶重量<br>在GF(2)上，因为两个偶重量向量之和必为偶重量，所以G的行线性组合有偶重量。即RM码的所有码字重量皆为偶数<br>由于Gr行的重量为$2^{m-l}$，因而r阶RM码的最小重量不大于$2^{m-l}$</p><p>里德算法是专门为RM码设计的译码算法<br>里德算法使用择多逻辑判决的方法从接收矢量直接恢复信息，而不计算错误图样<br>里德算法可以纠正r阶RM码出现的$(1&#x2F;2)×2^{m-r}−1$个随机错误，并恢复k位信息。这说明码的最小重量至少为$2^{m-r}−1$，又RM码的最小重量为偶数，因而r阶RM码最小重量至少为$2^{m-r}$<br>综上所述，r阶RM码最小重量为$2^{m-r}$，即RM码最小距离为$2^{m-r}$<br>将信息向量分成r+1段，即写成$m&#x3D;(I_0,I_1,⋯,I_r)$,其中$I_i$包含$\begin{pmatrix} m\l\end{pmatrix}$个信息位，于是编程可表示为$v&#x3D;I_0G_0+I_1G_1+⋯+I_rG_r$  (1.1)<br>如果接收码字$r&#x3D;v+e&#x3D;I_0G_0+I_1G_1+⋯+I_rG_r+e$  (1.2)， 其中e为错误图样<br>通过对r阶RM码的译码计算，由接收码字r恢复了第r段信息Ir，然后计算<br>$r(1)&#x3D;r-I_rG_r&#x3D;I_0G_0+I_1G_1+⋯+I_{r-1}G_{r-1}+e$  (1.3)<br>这就把由接收码字r恢复m的问题简化成由r(1)恢复信息$m^{(1)}&#x3D;(I_0,I_1,⋯,I_{r-1})$的问题<br>继续采用同样方法就可逐步恢复所有信息，最终完成r阶RM码的译码</p><h1 id="第七章-卷积码"><a href="#第七章-卷积码" class="headerlink" title="第七章 卷积码"></a>第七章 卷积码</h1><blockquote><p><strong>卷积码与分组码的区别</strong><br>卷积码有记忆性，分组码无记忆性<br>卷积码充分利用了各组信息之间的相关性，信息序列不被分段，而是被连续处理<br>通常，卷积码的n和k比分组码的n和k要小的多<br>在同样的编码效率下，卷积码的性能优于分组码<br>在相似的纠错能力下，卷积码的实现比分组码简单<br>卷积码必须用序列逻辑电路来实现，更适用于前向纠错系统；分组码是用组合逻辑电路来实现</p></blockquote><h2 id="离散序列的非循环卷积运算"><a href="#离散序列的非循环卷积运算" class="headerlink" title="离散序列的非循环卷积运算"></a>离散序列的非循环卷积运算</h2><p>定义：设f(n)和g(n)是两个序列，则序列f和g的离散卷积运算为</p><p>$$<br>(f*g)(m)&#x3D;\sum_nf(n)g(m-n)<br>$$</p><h2 id="二元-2-1-2-卷积码的编码器"><a href="#二元-2-1-2-卷积码的编码器" class="headerlink" title="二元(2,1,2)卷积码的编码器"></a>二元(2,1,2)卷积码的编码器</h2><p>编码器主要由m&#x3D;2级移位寄存器，n&#x3D;2个模2加法器组成。所有的卷积码编码器都可以用这种类型的线性前馈移位寄存器来实现。</p><p><img src="/../../images/BUPT_note/Notes_on_Information_heory_and_Coding/Untitled%206.png" alt="Untitled"></p><h3 id="冲激响应"><a href="#冲激响应" class="headerlink" title="冲激响应"></a>冲激响应</h3><blockquote><p>冲激响应：编码器的冲激响应就是通过令u&#x3D;(100…)所得到的两个输出序列。</p></blockquote><p>因为编码器有m个存储单元，所以冲激响应(生成序列)至多持续m+1个时间单元，且可以写成</p><p>$$<br>g^{(1)}&#x3D;(g^{(1)}_0,g^{(1)}_1,…,g^{(1)}_m),g^{(2)}&#x3D;(g^{(2)}_0,g^{(2)}_1,…,g^{(2)}_m)<br>$$</p><p>其中上标表示第几个输出端</p><blockquote><p>图6.1的(2,1,2)卷积码的冲激响应为$g^{(1)}&#x3D;(111), g^{(2)}&#x3D;(101)$<br>另外，冲激响应向量还可以表示输入、移位寄存器和输出之间的连接关系，1表示有连接，0表示没有连接</p></blockquote><h3 id="输出序列"><a href="#输出序列" class="headerlink" title="输出序列"></a>输出序列</h3><p>信息序列$u&#x3D;(u_1,u_2,u_3,…)$每次进入编码器1比特，编码器的两个输出序列</p><p>$$<br>v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…)<br>$$</p><p>可以通过输入序列u和编码器的两个冲激响应作卷积运算而得到。</p><blockquote><p>若u&#x3D;(1011), 图6.1的(2,1,2)卷积码的冲激响应为$g……{(1)}&#x3D;(111), g^{(2)}&#x3D;(101)$，则该卷积码的输出序列为$V^{(1)}&#x3D;u^<em>g^{(1)}&#x3D;(110001)$</em>, $V^{(2)}&#x3D;u^<em>g^{(2)}&#x3D;(100111)$</em></p></blockquote><h3 id="码字"><a href="#码字" class="headerlink" title="码字"></a>码字</h3><p>输出序列分别为$v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…)$的$(2,1,m)$的卷积码的码字，为$V^{(1)}$和$V^{(2)}$的交错，即</p><p>$$<br>v&#x3D;(v^{(1)}_0,v^{(2)}_0,v^{(1)}_1,v^{(2)}_1,…)<br>$$</p><blockquote><p>图6.1的(2,1,2)卷积码，若u&#x3D;(1011), 冲激响应为$g^{(1)}&#x3D;(111)$, $g^{(2)}&#x3D;(101)$，该卷积码的输出序列为$V^{(1)}&#x3D;u^<em>g^{(1)}&#x3D;(110001)$</em>, $V^{(2)}&#x3D;u^*g^{(2)}&#x3D;(100111)$*，得到的码字为v&#x3D;(11,10,00,01,01,11)</p></blockquote><p>以u&#x3D;(u1,u2,u3,…)为输入, 以$g^{(1)}&#x3D;(g^{(1)}_0,g^{(1)}_1,…,g^{(1)}_m),g^{(2)}&#x3D;(g^{(2)}_0,g^{(2)}_1,…,g^{(2)}_m)$</p><p>为生成序列的(2,1,m)卷积码的输出序列分别由方程$V^{(1)}&#x3D;u^*g^{(1)}$<em>和$V^{(2)}&#x3D;u^</em>g^{(2)}$*得到。</p><blockquote><p>图6.1的(2,1,2)卷积码的编码方程为<br>另外，编码方程中每一项的系数，还可以表示输入、移位寄存器和输出之间的连接关系，1表示有连接，0表示没有连接。</p><p>$$<br>\begin{cases} V_l^{(1)}&#x3D;u_l+u_{l-1}+u_{l-2}\ V_l^{(2)}&#x3D;u_l+u_{l-2} \end{cases},[V_l^{(1)}V_l^{(2)}]&#x3D;[u_lu_{l-1}u_{l-2}]\begin{bmatrix} 1&amp;1\1&amp;0\1&amp;1\end{bmatrix}<br>$$</p></blockquote><h3 id="生成矩阵-2"><a href="#生成矩阵-2" class="headerlink" title="生成矩阵"></a>生成矩阵</h3><p>(2,1, m)卷积码的生成矩阵：将生成序列g(1)和g(2)交织后形成的半无限矩阵</p><p>$$<br>G&#x3D;\begin{bmatrix}g^{(1)}_0&amp;g^{(2)}_0&amp;g^{(1)}_1&amp;g^{(2)}_1&amp;g^{(1)}_2&amp;g^{(2)}_2&amp;\dots&amp;g^{(1)}_m&amp;g^{(2)}_m&amp;0&amp;0&amp;0&amp;0&amp;\dots\ 0&amp;0&amp;g^{(1)}_0&amp;g^{(2)}_0&amp;g^{(1)}<em>1&amp;g^{(2)}<em>1&amp;\dots &amp;g^{(1)}</em>{m-1}&amp;g^{(2)}</em>{m-1}&amp;g^{(1)}<em>m&amp;g^{(2)}<em>m&amp;0&amp;0&amp;\dots \0&amp;0&amp;0&amp;0&amp;g^{(1)}<em>0&amp;g^{(2)}<em>0&amp;\dots&amp;g^{(1)}</em>{m-2}&amp;g^{(2)}</em>{m-2}&amp;g^{(1)}</em>{m-1}&amp;g^{(2)}</em>{m-1}&amp;g^{(1)}_m&amp;g^{(2)}_m&amp;\dots\ &amp;&amp;&amp;&amp;&amp;&amp;\ddots\end{bmatrix}<br>$$</p><p>以u&#x3D;(u1,u2,u3,…)为输入, G为生成矩阵的(2,1,m)的卷积码的码字为V&#x3D;uG。</p><h3 id="二元-3-2-1-卷积码的编码器"><a href="#二元-3-2-1-卷积码的编码器" class="headerlink" title="二元(3,2,1)卷积码的编码器"></a>二元(3,2,1)卷积码的编码器</h3><p>编码器主要有2个输入，3个输出，主要由m&#x3D;1级移位寄存器，n&#x3D;3个模2加法器组成。</p><h3 id="二元-3-2-m-卷积码的输入序列"><a href="#二元-3-2-m-卷积码的输入序列" class="headerlink" title="二元(3,2,m)卷积码的输入序列"></a>二元(3,2,m)卷积码的输入序列</h3><p>对于一般的(3,2,m)卷积码，由于k&#x3D;2，即每次有2比特进入编码器，所以输入序列u可以写成$v&#x3D;(v^{(1)}_0,v^{(2)}_0,v^{(1)}_1,v^{(2)}_1,…)$或分开写成2个序列$v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…)$</p><p>二元(3,2,m)卷积码的冲激响应$g^{(j)}<em>i&#x3D;(g^{(j)}</em>{i0},g^{(j)}<em>{i1},…,g^{(j)}</em>{im}),i&#x3D;1,2,j&#x3D;1,2,3$</p><p>输出序列分别为</p><p>$$<br>v^{(1)}&#x3D;(v^{(1)}_0,v^{(1)}_1,…), v^{(2)}&#x3D;(v^{(2)}_0,v^{(2)}_1,…), v^{(3)}&#x3D;(v^{(3)}_0,v^{(3)}_1,…)<br>$$</p><p>的(3,2,m)的卷积码的码字为</p><p>$$<br>v&#x3D;(v^{(1)}_0,v^{(2)}_0,v^{(3)}_0,v^{(1)}_1,v^{(2)}_1,v^{(3)}_1,…)<br>$$</p><h2 id="卷积码编码器的存储级数"><a href="#卷积码编码器的存储级数" class="headerlink" title="卷积码编码器的存储级数"></a>卷积码编码器的存储级数</h2><p>对于(n,k,m)卷积码，当k&gt;1时，编码器及用来描述它的符号都比较复杂，并且该编码器所含的k个移位寄存器的长度未必相同。</p><blockquote><p>存储级数：若ki是第i个移位寄存器的长度，则称所有k个移位寄存器中的最大长度为存储级数，即编码器的存储级数m定义为$m&#x3D;\max_{1&lt;i&lt;k}k_i$</p></blockquote><h2 id="卷积码编码器的约束长度和码速率"><a href="#卷积码编码器的约束长度和码速率" class="headerlink" title="卷积码编码器的约束长度和码速率"></a>卷积码编码器的约束长度和码速率</h2><p>对于(n, k, m)卷积码，编码器中每个信息位要保持m+1时间个单位，每个时间单位都可以影响编码器输出中的任何一个，这由移位寄存器的连接决定。</p><blockquote><p>约束长度：对于(n,k,m)卷积码，编码器的约束长度定义为$n_A&#x3D;n(m+1)$</p></blockquote><p>约束长度可以解释成1比特信息对编码器输出可以造成影响的最大数目。</p><blockquote><p>码速率：对于(n,k,m)卷积码，其码速率r&#x3D;k&#x2F;n</p></blockquote><h2 id="2-1-m-卷积码的多项式描述"><a href="#2-1-m-卷积码的多项式描述" class="headerlink" title="(2, 1, m)卷积码的多项式描述"></a>(2, 1, m)卷积码的多项式描述</h2><p>信息序列：$u$表示成$u(x)$</p><p>生成多项式：$g^{(1)}$表示成$g^{(1)}(x)$, $g^{(2)}$表示成$g^{(2)}(x)$</p><p>输出序列：$V^{(1)}$表示成$V^{(1)}(x)$, $V^{(2)}$表示成$V^{(2)}(x),$<br>码字：$V$表示成$V(x)$。于是$V^{(1)}(x)&#x3D;u(x)g^{(1)}(x), V^{(2)}(x)&#x3D;u(x)g^{(2)}(x),$<br>码字：$V(x)&#x3D;V^{(1)}(x^2)+xV^{(2)}(x^2)$</p><h2 id="n-k-m-卷积码的转移函数矩阵"><a href="#n-k-m-卷积码的转移函数矩阵" class="headerlink" title="(n, k, m)卷积码的转移函数矩阵"></a>(n, k, m)卷积码的转移函数矩阵</h2><p>于编码器是线性系统, 同任何有k个输入n个输出的线性系统一样，总共有k×n个转移函数。k×n阶转移函数矩阵为</p><p>$$<br>G(x)&#x3D;\begin{bmatrix}g_1^{(1)}&amp;g_1^{(1)}&amp;\dots&amp;g_1^{(1)}\ g_2^{(1)}&amp;g_2^{(1)}&amp;\dots&amp;g_2^{(1)}\ \dots \ g_k^{(1)}&amp;g_k^{(1)}&amp;\dots&amp;g_k^{(1)}\   \end{bmatrix}<br>$$</p><p>于是，码字$V(x)&#x3D;u(x)G(x)$, 其中, $u(x)&#x3D;(u^{(1)}(x), u^{(2)}(x),…, u^{(k)}(x)), V(x)&#x3D;(V^{(1)}(x), V^{(2)}(x),…, V^{(n)}(x))$, 并路之后, 码字变成$V(x)&#x3D;V^{(1)}(x^n)+xV^{(2)}(x^n)+…+x^{n-1}V^{(n)}(xn)$</p><h2 id="维特比-Viterbi-译码系统"><a href="#维特比-Viterbi-译码系统" class="headerlink" title="维特比(Viterbi)译码系统"></a>维特比(Viterbi)译码系统</h2><p>(n,k,m)卷积码, 如输入序列为x，输出码字为c，经过有噪声的信号传输后，得到接收序列r，然后经过Viterbi译码器，得到序列y。</p><p>对于码率为r的(n,k,m) 卷积码, 输入的信息长度为L，则输入序列为<br>$x&#x3D;(x_0^{(1)}, x_0^{(2)},…, x_0^{(k)}, x_1^{(1)}, x_1^{(2)},…, x_1^{(k)},…, x_{L+m-1}^{(1)}, x_{L+m-1}^{ (2)},…, x_{L+m-1 }^{(k)})$<br>对应输出的码字序列为<br>$c&#x3D;(c_0^{(1)}, c_0^{(2)},…, c_0^{(n)}, c_1^{(1)}, c_1^{(2)},…, c_1^{(n)},…, c_{L+m-1}^{(1)}, c_{L+m-1 }^{(2)},…, c_{L+m-1}^{ (n)})$<br>其中下标表示时间。<br>消息序列的尾部需要m个0比特使得移位寄存器的状态归0。一般的，默认移位寄存器从全零状态开始，最终还是以全零状态结束。</p><h1 id="第八章-Turbo码"><a href="#第八章-Turbo码" class="headerlink" title="第八章 Turbo码"></a>第八章 Turbo码</h1><h3 id="Turbo码的优点"><a href="#Turbo码的优点" class="headerlink" title="Turbo码的优点"></a>Turbo码的优点</h3><p>在信噪比较低的高噪声环境下性能优越（信道条件差的移动通信系统中有很大的应用潜力），而且具有很强的抗衰落、抗干扰能力。<br>Turbo码具有超乎寻常的优异的译码性能，可以纠正高速率数据传输时发生的误码。在直扩（CDMA）系统中采用Turbo码技术可以进一步提高系统的容量。<br>在短帧情况下的仿真结果表明短交织Turbo码在AWGN信道和Rayleigh衰落信道下仍具有接近信道容量的纠错能力。</p><h3 id="Turbo码的缺点"><a href="#Turbo码的缺点" class="headerlink" title="Turbo码的缺点"></a>Turbo码的缺点</h3><p>为获得较高的性能，Turbo码的编译码方式较为复杂。<br>具有较大的译码时延，这是由于block长度较大、译码需要多次迭代造成的。这样非常不利实时业务或高速数据的传输。<br>BER(比特出错概率)在10−5后会出现误码平层，这是由于Turbo码的重量分布造成的。对于某些对BER要求较高的应用就不适合，当然通过交织器的设计能够提供更大的码间最小距离，从而降低误码平层。</p><h3 id="分量码"><a href="#分量码" class="headerlink" title="分量码"></a>分量码</h3><p>卷积码的类型多样，如非递归卷积码(NRC)、非系统卷积码(NSC)、递归系统卷积码(RSC)。<br>在实际的系统中，由于RSC有突出的优点而被广泛采用。RSC码在具有良好的译码性能，且存在较高的交织增益，译码性能也会随着交织长度增加而提高。</p><h3 id="交织器"><a href="#交织器" class="headerlink" title="交织器"></a>交织器</h3><p>交织器的主要功能是使码重分布合理，降低数据序列的相关性，增大输出码字的最小汉明距，实现随机编码。</p><p><strong>分组交织器</strong>：将数据序列按行的顺序写入m×n的矩阵，然后按列的顺序读出，即完成交织过程。相应的解交织过程就是将交织后的数据序列按列写入m×n矩阵，再按照行的顺序读出。</p><p><strong>伪随机交织器</strong>：指交织映射随机生成的交织器，每个长度为N的伪随机交织器共有N！种可能的交织形式。这种交织器采用给定的随机地址交织映射，由这个已知的交织表对输入信息序列进行映射。</p><h3 id="删余处理"><a href="#删余处理" class="headerlink" title="删余处理"></a>删余处理</h3><p>在编码完成后，将分量码输出的两路校验信息输入删余器，按照一定的规则删除一部分校验信息，减小信息的冗余度，从而提高编码效率。</p><h2 id="Turbo码编码器的结构"><a href="#Turbo码编码器的结构" class="headerlink" title="Turbo码编码器的结构"></a>Turbo码编码器的结构</h2><p>三种：并行级联卷积码(PCCC)、串行级联卷积码(SCCC)和混合级联卷积码(HCCC)</p><h3 id="并行级联卷积码-PCCC"><a href="#并行级联卷积码-PCCC" class="headerlink" title="并行级联卷积码(PCCC)"></a>并行级联卷积码(PCCC)</h3><p>随机交织器：将信息序列U进行比特位置重排列得到U1（内容不变）<br>分量编码器：生成校验序列 $X_{p1}$ 和 $X_{p2}$（一般两个编码器结构相同）<br>删余矩阵：为了提高码率，周期地删除一些校验位，形成校验位序列Xp<br>复接：未编码序列Xs与Xp经过复接后，生成Turbo码序列X</p><h2 id="Turbo码的码率"><a href="#Turbo码的码率" class="headerlink" title="Turbo码的码率"></a>Turbo码的码率</h2><p>若两个分量码的码率分别为R1和R2，则Turbo码的码率为</p><p>$$<br>R&#x3D;\frac{R_1R_2}{R_1+R_2-R_1R_2}<br>$$</p><h2 id="Turbo码的译码"><a href="#Turbo码的译码" class="headerlink" title="Turbo码的译码"></a>Turbo码的译码</h2><p>Turbo码有一重要特点是其译码较为复杂，比常规的卷积码要复杂的多。<br>这种复杂不仅在于其译码要采用迭代的过程，而且采用的算法本身也比较复杂。</p><h3 id="译码算法-1"><a href="#译码算法-1" class="headerlink" title="译码算法"></a>译码算法</h3><p><strong>MAP算法</strong>：MAP算法采用递推、迭代方法，将最大似然对数比函数作为软判决的输出。但由于该算法需要多次迭代，复杂度较高，运算量非常大，而且对数和指数的运算在数字电路中比较难以实现，导致其在工程实现上受到了很大程度的限制。<br><strong>Max-log-MAP算法</strong>：即最大值运算，在MAP算法基础上通过减少格图搜索状态来达到简化的目的。Max-log-MAP对MAP所做的修改是在对数域里对一些函数进行计算，这样省去了很多的指数的运算和对数域的运算，很大程度上降低了运算的复杂度，大大简化了运算量；但是由于在计算过程有一些近似处理，所以Max-log-MAP算法不是最优的。<br><strong>Log-MAP算法</strong>：即对数域算法，Robertson等人在Max-log-MAP算法基础上进行了一些修改，使得Log-MAP算法相比于Max-log-MAP算法只多了一些查表及加法运算，尽管提高了一点复杂度但是性能却得到很大的提高。<br><strong>SOVA算法</strong>：即软输出Viterbi译码，SOVA算法在标准Viterbi译码算法上进行了一些修改：在进行最大似然路径选择时必须参考其先验信息；不但需要给出每个比特译码的准确结果，还需要计算出每个比特译码的可靠性，通过一些计算从中获取一些关于译码比特的先验信息，从而为下次迭代做好准备，大大减小了运算量，但性能受到了损失，大约损失了1dB。</p><h1 id="第九章-二维码"><a href="#第九章-二维码" class="headerlink" title="第九章 二维码"></a>第九章 二维码</h1><h2 id="二维码的概念与原理"><a href="#二维码的概念与原理" class="headerlink" title="二维码的概念与原理"></a>二维码的概念与原理</h2><p>行排式二维码，又称堆积式二维码或层排式二维码，其编码原理是建立在一维条码基础之上，按需要堆积成二行或多行。</p><p>矩阵式二维码，又称棋盘式二维码，它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码。</p><h2 id="二维码的特点"><a href="#二维码的特点" class="headerlink" title="二维码的特点"></a>二维码的特点</h2><p><strong>可靠性强</strong><br>条形码的读取准确率远远超过人工记录，平均每15000个字符才会出现一个错误。<br><strong>效率高</strong><br>条形码的读取速度很快，相当于每秒40个字符。<br><strong>易于制作</strong><br>条形码的编写很简单，制作也仅仅需要印刷，被称为“可印刷的计算机语言”。<br><strong>高密度</strong><br>二维码通过利用垂直方向的堆积来提高条码的信息密度，而且采用高密度图形表示。<br><strong>构造简单</strong><br>条形码识别设备的构造简单，使用方便。<br><strong>灵活实用</strong><br>条形码符号可以手工键盘输入，也可以和有关设备组成识别系统实现自动化识别，还可以和其他控制设备联系起来实现整个系统的自动化管理。<br><strong>成本低</strong><br>与其它自动化识别技术相比较，条形码技术仅仅需要一小张贴纸和相对构造简单的光学扫描仪，成本相当低廉。<br><strong>纠错功能</strong><br>二维码不仅能防止错误，而且能纠正错误，即使条形码部分损坏，也能将正确的信息还原出来。<br><strong>多语言形式，可表示图像</strong><br>二维码具有字节表示模式，即提供了一种表示字节流的机制。不论何种语言文字它们在计算机中存储时以机内码的形式表现，而内部码都是字节码，可识别多种语言文字的条码。<br><strong>具有加密体制</strong><br>可以先用一定的加密算法将信息加密，再用二维码表示在识别二维条码时，再加以一定的解密算法，便可以恢复所表示的信息。</p><h2 id="QR码的生成与识别"><a href="#QR码的生成与识别" class="headerlink" title="QR码的生成与识别"></a>QR码的生成与识别</h2><p><img src="/../../images/BUPT_note/Notes_on_Information_heory_and_Coding/Untitled%207.png" alt="Untitled"></p><p><img src="/../../images/BUPT_note/Notes_on_Information_heory_and_Coding/Untitled%208.png" alt="Untitled"></p><p><strong>寻像图形、位置探测图形：</strong><br>协助扫描软件定位QR码并转换坐标系。<br>寻像图形包括三个相同的位置探测图形，分别位于图形中的左上角、右上角和左下角。每个位置探测图形由7*7个模块组成。如图，寻像图形为黑色区域。</p><p><strong>位置探测图形分隔符：</strong><br>区分功能图形和编码区域。<br>每个位置探测图形和编码区域之间有宽度为1个模块的分隔符。位置探测图形分隔符为灰色区域，此区域应为空白。</p><p><strong>定位图形：</strong><br>确定符号的密度和版本，提供决定模块坐标的基准位置。<br>定位图形为图中的茶色区域，水平和垂直的定位图形分别始于第6行和第6列。</p><p><strong>校正图形：</strong><br>在图像有一定程度损坏的情况下，译码软件可以通过它同步图像模块的坐标映像。<br>矫正图形的数量视符号和版本号而定，版本1没有校正图形，版本2及以上均含有校正图形。</p><p><strong>格式信息：</strong><br>存放纠错等级和掩模信息。<br>格式信息是一个15位数据，由2位纠错指示符+3位掩模图形参考+10位纠错码组成，为图中深蓝色区域。</p><p>同时，左下角格式信息编号8上方的橙色区域，此区域永远为深色模块，不用于存放任何信息。</p><p><strong>版本信息：</strong><br>用于存放QR码的版本号。<br>为图中红色区域，两个3*6模块。</p><p><strong>扩展图形：</strong><br>最初的目的是用于将来对QR码功能的扩展，并不用于对数据的编码。<br>扩展图形由位于符号右下角的一个4个模块组成的方块以及位于符号右边和下边的一些8个模块的块组成。8个模块的块的数目取决于符号的版本，计算公式为：<br>8模块的数目&#x3D;2*(N DIV 2)<br>其中N为版本号，DIV表示除法运算。<br>扩展图形为图中红框区域，即版本7中有6个8模块组成的块和1个4模块组成的块。</p><h3 id="QR码的纠错能力："><a href="#QR码的纠错能力：" class="headerlink" title="QR码的纠错能力："></a><strong>QR码的纠错能力：</strong></h3><table><thead><tr><th>级别</th><th>纠错能力</th></tr></thead><tbody><tr><td>L</td><td>约7%</td></tr><tr><td>M</td><td>约15%</td></tr><tr><td>Q</td><td>约25%</td></tr><tr><td>H</td><td>约30%</td></tr></tbody></table><h2 id="举例说明QR码的编码过程。"><a href="#举例说明QR码的编码过程。" class="headerlink" title="举例说明QR码的编码过程。"></a>举例说明QR码的编码过程。</h2><h2 id="识别步骤"><a href="#识别步骤" class="headerlink" title="识别步骤"></a>识别步骤</h2><p>条码定位<br>条码分割<br>解码</p><h3 id="条码定位"><a href="#条码定位" class="headerlink" title="条码定位"></a>条码定位</h3><p>定位采用以下步骤：<br>1.利用点运算的阈值理论将采集到的图像变为二值图像，即对图像进行二值化处理；<br>2.得到二值化图像后，对其进行膨胀运算；<br>3.对膨胀后的图像进行边缘检测得到条码区域的轮廓。<br>4.确定寻像图形<br>5.探测图形中心坐标<br>6.确定两个举例<br>7.确定版本号<br>8.构造位图<br>9.得到纠错等级和掩模图形</p><h3 id="条码分割"><a href="#条码分割" class="headerlink" title="条码分割"></a>条码分割</h3><p>分割采用以下步骤：<br>1.将原图像按比例缩小进行分割，计算其特征值；<br>2.分块继承父块纹理类别，结合其周围纹理类型进行修正；<br>3.重复步骤二直至图像被划分为2*2大小，分割结束；<br>4.分割结束后，图中可能出现的孤立的小区域可作为噪声删除。</p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><pre><code>得到一幅标准的条码图像后，对该符号进行网络取样，对网格每一个交点上的图像像素取样，并根据阈值确定是深色块还是浅色块。构造一个位图，用二进制的“1”表示深色像素，“0”表示浅色像素，从而得到条码的原始二进制序列值，然后对这些数据进行纠错和译码：1.异或处理（XOR）2.确定符号码字3.重新排列码字序列4.执行错误检测和纠错译码程序最后根据条码的逻辑编码规则把这些原始的数据位流转换成数据码字。</code></pre><h1 id="第十章-极化码"><a href="#第十章-极化码" class="headerlink" title="第十章 极化码"></a>第十章 极化码</h1><h2 id="极化码概述与研究现状"><a href="#极化码概述与研究现状" class="headerlink" title="极化码概述与研究现状"></a>极化码概述与研究现状</h2><p>极化码优点：<br>1、是目前唯一的香农信道容量可达的编码方式<br>2、有坚实的理论基础<br>3、编解码复杂度低<br>4、精细的码率调整机制（信息块长度可以一比特一比特的递减）<br>5、极化码的递归特性易于通过硬件实现（母码长度为N的Polar码可以用两个母码长度为N&#x2F;2的Polar码实现）</p><p>极化码缺点：<br>1、汉明距离较小，在短码情况下影响解码性能，一定程度上可以通过选择合适的冻结比特位置进行规避。适合长码编码。<br>2、SC译码延时较大。</p><h3 id="极化（Polar）码起源"><a href="#极化（Polar）码起源" class="headerlink" title="极化（Polar）码起源"></a>极化（Polar）码起源</h3><blockquote><p>截止频率越高，系统响应越快<br>因此Polar码的最初设计的出发点是为了提升截止频率</p></blockquote><p>在随机编码和最大似然条件下，信道截止速率R0决定了相应的码块的错误概率：</p><p>$$<br>P_e&#x3D;2^{−N∙R_0}<br>$$</p><p>其中，N为码块长度。实际信道的传输速率R小于R_0、使用随机编码和ML编码时，信道平均错误概率：</p><p>$$<br>P _e&#x3D;2^{−N（R_0−R）}<br>$$</p><h3 id="极化码的基本原理"><a href="#极化码的基本原理" class="headerlink" title="极化码的基本原理"></a>极化码的基本原理</h3><p>对于Polar码基本原理可以归结为三点：信道合并、信道分离、信道极化。其中信道合并和信道极化是在编码时完成的；信道分离是在解码时完成。</p><p><strong>信道选择：</strong><br>对于编码方案通常根据某种信道设计，Polar码主要考虑以下信道进行分析：</p><p>二进制离散无记忆信道（B-DMC）:二进制删除信道（BEC）;二进制对称信道（BSC）</p>]]></content>
    
    
    <summary type="html">信息论与编码的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://shuita2333.github.io/project/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://shuita2333.github.io/project/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网络安全课程笔记</title>
    <link href="https://shuita2333.github.io/project/2024/01/09/BUPT_note/Notes%20on%20network%20security/"/>
    <id>https://shuita2333.github.io/project/2024/01/09/BUPT_note/Notes%20on%20network%20security/</id>
    <published>2024-01-09T13:00:00.000Z</published>
    <updated>2024-07-07T08:24:38.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络安全-武斌"><a href="#网络安全-武斌" class="headerlink" title="网络安全 武斌"></a>网络安全 武斌</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="网络空间"><a href="#网络空间" class="headerlink" title="网络空间"></a>网络空间</h2><p>物理网络位置→逻辑层面（逻辑网络组件）→社会和认知层面（网络上的人）</p><h2 id="安全共性"><a href="#安全共性" class="headerlink" title="安全共性"></a>安全共性</h2><p>硬件安全</p><p>系统安全</p><p>协议安全</p><p>网络安全</p><p>硬件性能的快速提升促进不同网络逐渐趋同</p><p>硬件趋同→应用技术趋同→安全威胁扩展</p><p>云上问题层出不穷</p><p>共性安全问题：</p><ul><li>漏洞挖掘利用</li><li>协议权限类似：面临Dos等攻击</li><li>安全防护方法类似</li></ul><h2 id="网络安全现状"><a href="#网络安全现状" class="headerlink" title="网络安全现状"></a>网络安全现状</h2><p>略</p><h1 id="网络安全概述"><a href="#网络安全概述" class="headerlink" title="网络安全概述"></a>网络安全概述</h1><h2 id="资产保护"><a href="#资产保护" class="headerlink" title="资产保护"></a>资产保护</h2><ul><li>物理资源：物理资源是具有物理形态的资产</li><li>知识资源：知识资源可以是任何信息的形式，并直在组织的事务处理中起一定的作用</li><li>时间资源</li><li>信誉资源</li></ul><p>损失：</p><ul><li>即时的损失</li><li>长期的恢复所需花费</li></ul><p><strong>安全强度－安全代价的折中</strong>：</p><ul><li>用户方便程度</li><li>管理复杂性</li><li>对现有系统的影响</li><li>对不同平台的支持</li></ul><p><strong>安全强度、安全代价和侵入可能性的关系</strong></p><p><img src="/../../images/BUPT_note/Notes%20on%20network%20security/Untitled.png" alt="Untitled"></p><h1 id="信息安全模型"><a href="#信息安全模型" class="headerlink" title="信息安全模型"></a>信息安全模型</h1><p>信息保密技术的研究基础：</p><p>① 发展各种密码算法及其应用 ：</p><p>DES（数据加密标准）、 RSA（公开密钥体制）、 ECC（椭圆曲线离散对数密码体制）等。</p><p>② 计算机信息系统安全模型和安全评价准则 ：</p><p>访问监视器模型、多级安全模型等；TCSEC（可信计算机系统评价准则）、 ITSEC（信息技术安全评价准则）等。</p><p>信息保障（IA）</p><pre><code>定义：确保信息和信息系统的可用性、完整性、可控性、保密性、不可否认性来保护信息</code></pre><p><strong>信息保障技术框架IATF</strong>：由美国国家安全局制定，提出 “<strong>纵深防御策略</strong>”DiD（ Defense-in-Depth Strategy）。</p><p>强调人、技术、操作这三个核心原则。</p><p>在信息保障的概念下，信息安全保障的<strong>PDRR模型</strong>的内涵已经超出了传统的信息安全保密，而是保护（ Protection）、检测（Detection）、响应（Reaction ）和恢复（Restore）的有机结合。</p><h2 id="网络攻击类型及分类"><a href="#网络攻击类型及分类" class="headerlink" title="网络攻击类型及分类"></a>网络攻击类型及分类</h2><h3 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h3><p>从安全属性来看，攻击类型可分为4类： 阻断攻击、截取攻击、篡改攻击、伪造攻击。</p><p>( 1)阻断攻击</p><p>阻断攻击使系统的资产被破坏，无法提供用户使用，这是一种针对可用性的攻击。例如，破坏硬盘之类的硬件，切断通信线路，使文件管理系统失效等。</p><p>(2)截取攻击<br>截取攻击可使非授权者得到资产的访问，这是一种针对机密性的攻击。非授权者可以是一个人、一个程序或一台计算机，例如， 通过窃昕获取网上数据以及非授权的复制文件和程序。</p><p>(3)篡改攻击<br>篡改攻击是非授权者不仅访问资产，而且能修改信息，这是一种针对完整性的攻击。例如，改变数据文件的值，修改程序以及在 网上正在传送的报文内容。</p><p>(4)伪造攻击<br>伪造攻击是非授权者在系统中插入伪造的信息，这是一种针对真实性的攻击。例如：在网上插入伪造的报文，或在文件中加入一 些记录。</p><h3 id="主动攻击和被动攻"><a href="#主动攻击和被动攻" class="headerlink" title="主动攻击和被动攻"></a>主动攻击和被动攻</h3><p><img src="/../../images/BUPT_note/Notes%20on%20network%20security/Untitled%201.png" alt="Untitled"></p><p><strong>被动攻击</strong></p><p>目的是获取正在传输的信息。<strong>被动攻击包括传输报文内容的泄露 和通信流量分析</strong>。报文内容的泄露易于理解，一次电话通信、一 份电子邮件报文、正在传送的文件都可能包含敏感信息或秘密信息</p><p>对被动攻击的<strong>检测十分困难</strong>，因为攻击并不涉及数据的任何改变。然而阻止这些攻击的成功是可行的，因此，对被动攻击<strong>强调的 是阻止而不是检测</strong>。</p><p><strong>主动攻击</strong></p><p>包含对数据流的某些修改，或者生成一个假的数据流。它可分成4类:</p><p><strong>(1)伪装</strong></p><blockquote><p>伪装是一个实体假装成另一个实体。伪装攻击往往连同另一类主动攻击一 起进行。<br><strong>(2)回答 （重放）</strong><br>回答攻击包含数据单元的被动捕获，随之再重传这些数据，从而产生一个<br>非授权的效果。</p></blockquote><p><strong>(3)修改报文</strong></p><blockquote><p>修改报文攻击意味着合法报文的某些部分已被修改，或者报文的延迟和重<br>新排序，从而产生非授权的效果。</p></blockquote><p><strong>(4)拒绝服务</strong></p><blockquote><p>拒绝服务攻击是阻止或禁止通信设施的正常使用和管理。这种攻击可能针 对专门的 目标(如安全审计服务) ，抑制所有报文直接送到目的站;也可能破 坏整个网络，使网络不可用或网络超负荷，从而降低网络性能。</p></blockquote><blockquote><p>主动攻击和被动攻击具有相反的特性。被动攻击难以检测出来， 然而有阻止其成功的方法。而主动攻击难以绝对地阻止，因为要 做到这些，就要对所有通信设施、通路在任 何时间进行完全的保 护。因此对主动攻击采取检测的方法，并从破坏中</p></blockquote><p><strong>访问攻击</strong><br>攻击者企图获得非授权信息，这种攻击可能发生在信息驻留在计算机系统中或在网络上传输的情况下。是针对信息机密性的攻击。</p><p>常见的访问攻击有3种:</p><blockquote><p>(1)窥探(snooping)：是查信息文件，发现某些攻击者感兴趣的信息。攻击者试图打开计算机系统的文件，直到找到所需信息；<br>(2)窃听(eavesdropping)：是偷听他人的对话，为了得到非授权的信息访问，攻击者必须将自己放在一个信息通过的地方，一般采用电子的窃听方式；<br>(3)截获(interception)：不同于窃听 ，它是一种主动攻击方式。攻击者截获信息是通过将自己插入信息通过的通路，且在信息到达目的地前能事先 捕获这些信息。</p></blockquote><p><strong>篡改攻击</strong><br>篡改攻击是攻击者企图修改信息，而他们本来是无权修改的。这种攻击可能发生在信息驻留在计算机系统中或在网络上传输的情况下 , 是针对信息完整性的攻击。</p><p>常见的篡改攻击有3种:</p><blockquote><p>(1)改变：改变已有的信息 。例如，攻击者改变己存在的员工工资，改变以 后的信息虽然仍存在于该组织，但已经是不正确的信息。这种改变攻击的 目标通常是敏感信息或公共信息。<br>(2)插入 ：插入信息可以改变历史的信息 。例如，攻击者在银行系统中加 一个事务处理，从而将 客户账户的资金转到自己账户上。<br>(3)删除 ：删除攻击是将已有的信息去除，可能是将历史记录的信息删除 。例如，攻击者将一个事务处理记录从银行结账单中删除，从而造成银行 资金的损失。</p></blockquote><p><strong>拒绝服务攻击</strong></p><p>拒绝服务攻击(Denial-of-Service ， DoS)是拒绝合法用户使用系统 、信息、能力等各种资源。可分成以下4种:</p><blockquote><p>(1)拒绝访问信息：使信息不可用 ，信息被破坏或者将信息改变成不可使用状态，也可能信息仍存在，但已经被移到不可访问的位置。<br>(2)拒绝访问应用：目标是操纵或显示信息的应用。通常对正在运行应用程序的计算机系统进行攻击，使应用程序不可用而不能完成任务。<br>(3)拒绝访问系统：通常是使系统宕机，使运行在该计算机系统上的所有应用无法运行，使 存储在该计算机系统上的所有信息不可用。<br>(4)拒绝访问通信：是针对通信的一种攻击，已有很多年历史。这类攻击可能用切断通信电缆、干扰无线电通信以及用过量的通信负载来淹没网络。</p></blockquote><p><strong>否认攻击</strong><br>否认攻击是针对信息的可审性进行的。否认攻击企图给出假的信息或者否认已经发生的现实事件或事务处理。<br>否认攻击包括两类:</p><blockquote><p>(1)假冒：假冒是攻击者企图装扮或假冒别人和别的系统。这种攻击可能发生在个人通信、事务处理或系统对系统的通信中。<br>(2)否认：否认一个事件是简单地抵赖曾经登录和处理的事件。例如，一个人用信用卡在商店 里购物，然而当账单送到时，告诉信用卡公司，他从未到该商店购物。</p></blockquote><h2 id="网络信息安全服务"><a href="#网络信息安全服务" class="headerlink" title="网络信息安全服务"></a>网络信息安全服务</h2><ul><li>机密性服务：提供信息的保密。</li><li>完整性服务：提供信息的正确性。</li><li>可用性服务：提供的信息是可用的。</li><li>可审性服务：本身不针对攻击提供保护，需与其它服务结合。&#96;</li></ul><h3 id="机密性防护"><a href="#机密性防护" class="headerlink" title="机密性防护"></a>机密性防护</h3><p><strong>文件机密性</strong></p><blockquote><p>为实现文件机密性服务，所需提供的机制包括物理安全机制、计算机文件访 问控制以及文件加密。<br>文件机密性的要求包括身份标识和身份鉴别、正确的计算机系统配置，如使 用加密则还需合适的密钥管理。</p></blockquote><p><strong>信息传输机密性</strong></p><blockquote><p>可基于每个报文信息进行加密保护，也可以对链路上的所有 通信进行加密。</p></blockquote><p><strong>通信流机密性</strong></p><blockquote><p>这些信息形式通过通信分析可识别组织之间的通信情况。 例如，很多新闻机构发现某一时刻有大量的快餐送至政 府某重要机关，则可推测某些紧急事件甚至是危机可能发生。</p></blockquote><h3 id="完整性防护"><a href="#完整性防护" class="headerlink" title="完整性防护"></a>完整性防护</h3><p><strong>文件完整性</strong></p><blockquote><p>完整性服务也必须和身份标识、身份鉴别功能结合在一起。</p></blockquote><p><strong>信息传输完整性</strong></p><blockquote><p>信息在传输中也可能被修改，然而如果不实施截获攻击就很难对 传输中的信息进行修改。</p></blockquote><blockquote><p>完整性服务可成功地阻止篡改攻击和否认攻击。任何篡改攻击都可能改变文件或传输中的信息，当完整性服务能检测到非授权者的访问，篡改攻击就不能成功进行。当完整性服务和身份 标识、身份鉴别服务很好地结合，即使组织以外的文件被 改变也能被检测出来。</p></blockquote><h3 id="可用性防护"><a href="#可用性防护" class="headerlink" title="可用性防护"></a>可用性防护</h3><p>可用性是用来对拒绝服务攻击的系统恢复。可用性并不能阻止DoS，但 可用性服务可用来减少这类攻击的影响。</p><h3 id="可审性防护"><a href="#可审性防护" class="headerlink" title="可审性防护"></a>可审性防护</h3><p>身份标识与身份鉴别</p><blockquote><p>有两个目的：其一是对试图执行一个功能的每个人的身份进行标识；其二是验证这些人声称的身份。<br>身份鉴别可使用以下任何一种或其组合的方法 实现:</p></blockquote><p>. (1)知识因子——你知道什么，如口令或PIN(个人身份标识号)。<br>. (2)拥有因子——你有什么，如智能卡或标记。<br>. (3)生物因子——你是什么，如指印、视网膜。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名是通信双方在网上交换信息用公钥密码防止伪造和欺骗的一种身份认证。</p><h3 id="Kerberos鉴别"><a href="#Kerberos鉴别" class="headerlink" title="Kerberos鉴别"></a>Kerberos鉴别</h3><p>Kerberos使用<strong>对称密钥加密算法</strong>来实现，通过可信第三方 密钥分发中心的认证服务，它提供了网络通信方之间相互 的身份认证手段，而且并不依赖于主机操作系统和地址。</p><h2 id="网络安全评估"><a href="#网络安全评估" class="headerlink" title="网络安全评估"></a>网络安全评估</h2><h3 id="1-可信计算机系统评估准则（TCSEC-）"><a href="#1-可信计算机系统评估准则（TCSEC-）" class="headerlink" title="1. 可信计算机系统评估准则（TCSEC ）"></a>1. 可信计算机系统评估准则（TCSEC ）</h3><p>橘皮书</p><blockquote><p>D级，无保护级<br>C1级， 自主安全保护级<br>C2级，受控存取保护级<br>B1级，标记安全保护级<br>B2级，结构化保护级<br>B3级，安全域级<br>A级，验证设计级</p></blockquote><h3 id="2-信息技术安全评估准则（ITSEC-）"><a href="#2-信息技术安全评估准则（ITSEC-）" class="headerlink" title="2. 信息技术安全评估准则（ITSEC ）"></a>2. 信息技术安全评估准则（ITSEC ）</h3><p>白皮书</p><p>ITSEC定义了从E0级（没有任何保证）到E6级（形式化 验证）的七个安全等级。<br>目前，ITSEC已大部分被CC替代</p><h3 id="3-信息安全技术通用评估准则（CC-）"><a href="#3-信息安全技术通用评估准则（CC-）" class="headerlink" title="3. 信息安全技术通用评估准则（CC ）"></a>3. 信息安全技术通用评估准则（CC ）</h3><blockquote><p>简介和一般模型：正文介绍了CC中的有关术语、基本概 念和一般模型以及与评估有关的一些框架，附录部分主 要介绍保护轮廓（PP）和安全目标（ST）的基本内容。<br>安全功能要求：按“类-族-组件 ”的方式提出安全功能要求， 提供了表示评估目标TOE安全功能要求的标准方法。<br>安全保证要求 ：定义了评估保证级别，建立了一系列安 全保证组建作为表示TOE保证要求的标准方法。</p></blockquote><h3 id="4-我国信息安全评估准则"><a href="#4-我国信息安全评估准则" class="headerlink" title="4. 我国信息安全评估准则"></a>4. 我国信息安全评估准则</h3><blockquote><p>第一级：用户自主保护级<br>第二级：系统审计保护级<br>第三级：安全标记保护级<br>第四级：结构化保护级<br>第五级：访问验证保护级</p></blockquote><h2 id="网络安全评估方式"><a href="#网络安全评估方式" class="headerlink" title="网络安全评估方式"></a>网络安全评估方式</h2><ol><li><p>风险评估</p></li><li><p>生存性评估</p></li><li><p>网络安全态势评估</p></li><li><p>网络攻击效果评估</p></li><li><p>安全测评</p></li><li><p>信息安全工程能力评估</p></li><li><p>信息系统审计</p></li></ol><h1 id="网络攻击—ARP-攻击"><a href="#网络攻击—ARP-攻击" class="headerlink" title="网络攻击—ARP 攻击"></a>网络攻击—ARP 攻击</h1><h2 id="嗅探技术"><a href="#嗅探技术" class="headerlink" title="嗅探技术"></a>嗅探技术</h2><p>嗅探技术，是一种常用的收集有用数据信息的网络监听方法，是网络安全攻防技术中很重要的一种。</p><p>以太网嗅探。网卡一般具有四种接收工作模式</p><p>· 广播 (Broadcast) 模式，可以接收局域网内目的地址为广播 地址(全1地址)的所有数据报；<br>· 多 播 (Multicast) 模式，可以接收目的地址为多播地址的所有 数据报;<br>· 直 接 (Directory) 模式，也就是单播 (Unicast) 模式，只接 收目的地址为本机MAC 地址的所有数据报；<br>· 混杂 (Promiscuous) 模式，能够接收通过网卡的所有数据报。</p><p>网卡被设置成混杂模式时，无论监听到的数据帧目的地址如何，网卡能接收所有达到自身的数据。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><blockquote><p>交换机 (Switch) 意为“开关”是一种用于电(光)信号转发的网络设备。它可以为接入交换机的任意两 个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机。</p></blockquote><p>交换机工作于OSI 参考模型的第二层，即数据链路层。交换机内部 的CPU 会在每个端口成功连接时，通过将MAC 地址和端口对应，形成一张MAC 表。</p><h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><blockquote><p>地址解析协议，即ARP(Address Resolution Protocol), 是根据IP地址获取物理地址 的一个TCP&#x2F;IP协议。</p></blockquote><p>网络通信一般以 IP地址为源、目的地址，但工作在数据链路层的交换机、网卡等并不能识别IP地址，需要获取MAC 地址才能通信。</p><p>主机设有一个 ARP高速缓存 ，存放局域网中主机的IP地址和MAC 地址对。当两台主机进行通信时，通过查询ARP 缓 存表来进行IP地址到MAC 地址的转换。缓存表中不存在查 找项时， 运行ARP广播查找目标主机的MAC地址。ARP缓存表中的每一个映射地址项都有生存时间，进行定时更新。</p><p><strong>ARP 协议工作过程</strong></p><p>● 源主机A 首先判断目的主机B是否处于同一子网(根据本子网的子 网掩码和目标主机IP地址)。</p><p>● 若目的主机位于同一子网内</p><blockquote><p>主 机A 先检查ARP 缓存内是否有主机B 的MAC 地址。<br>如果没有，主机A会发送一个ARP 请求广播包，此包内包含着其欲与之通信的主机的IP地址，也就是主机B的IP地址。<br>当 主 机B收到此广播后，会将自己的MAC 地址利用ARP 响应包传给主机A, 并更新自己的ARP 缓存，也就是同时将主机A的IP地 址&#x2F;MAC 地址对保存起来，以供后面使用。<br>主 机A 在得到主机B 的MAC 地址后，就可以与主机B通信了。同时，主机A也将主机B 的IP地址&#x2F;MAC 地址对保存在自己的ARP 缓 存内。</p></blockquote><h2 id="ARP-攻击技术"><a href="#ARP-攻击技术" class="headerlink" title="ARP 攻击技术"></a>ARP 攻击技术</h2><p>● 在交换式网络环境下，通信参与者有三个：</p><blockquote><p>通信双方A和B<br>交换机S<br>攻击者C<br>要想达到嗅探的目的，可以有三个攻击点， (1)交换机S, (2)目标主机A和B,(3) 自 己C。</p></blockquote><p>发送大量虚假MAC 地址数据报</p><blockquote><p>交换机虽然可以维护一张端口-MAC 的地址映射表，但是由于交换机内存有限，地址映射表的大小也就有限。<br>如果主机C 发送大量虚假MAC 地址的数据报，快速填满地址映射表。交换机在地址映射表被填满后，就会像HUB 一样以广播 方式处理数据报。<br>这种方法不适合采用静态地址映射表的交换机，而且也不是所有交换机都采用这种转发处理方式。</p></blockquote><h3 id="ARP-欺骗"><a href="#ARP-欺骗" class="headerlink" title="ARP 欺骗"></a>ARP 欺骗</h3><p>ARP 欺骗利用修改主机ARP 缓存表的方法达到嗅探的目的，是一种中间人攻击。主机C 为了达到嗅探的目的，会向主机A 和主机B分别发送ARP 应答包，告诉它们IP地址为IPB 的主机MAC 地址为MACC,IP 地址为IPA 的主机MAC地址为MACC。<br>这 样 ， 主 机A 和主机B 的ARP 缓存中就会有IPB—MACC 和IPA—MACC 的记录。这样，主机A 和主机B的通信数据都流向了主机C, 主机C 只要再发送到 其真正的目的地就可以了。当然ARP 缓存表项是动态更新的(一般为两分 钟),如果没有更新信息， ARP 映射项会自动删除。所以，主机C 在监听过 程中，还要不断地向主机A 和主机B 发送伪造的ARP 应答包。</p><p><img src="/../../images/BUPT_note/Notes%20on%20network%20security/Untitled%202.png" alt="Untitled"></p><p><strong>修改本地MAC 地址</strong></p><blockquote><p>也可以通过修改本地MAC 地址为目标主机MAC 地址来实现嗅探。把主机C 的MAC 地址修改为目标主机B 的MAC 地址，交换机会将 MACB 和端口c对应起来。<br>在以后收到目的地址为MACB 的数据报后，交换机会将包从端口c发送出去。这样就达到了监听的目的。<br>但同样地，这种方法只适用于动态生成地址映射表的交换机，并且没有采用其它策略。</p></blockquote><h2 id="ARP-攻击溯源"><a href="#ARP-攻击溯源" class="headerlink" title="ARP 攻击溯源"></a>ARP 攻击溯源</h2><h3 id="方法一-：捕包分析"><a href="#方法一-：捕包分析" class="headerlink" title="方法一 ：捕包分析"></a>方法一 ：捕包分析</h3><blockquote><p>在网络内任意一台主机上运行抓包软件，捕获所有到达本机的数据包。如果发现有某个IP不断发送ARP Request请求包，那么这台电脑一般就是攻击源。<br>原 理 ：ARP 攻击行为方式主要有两种， 一是欺骗网关，二是欺骗网内的所有主机。最终的结果是，在网关的ARP 缓存表中，网内所有活动主机 的MAC 地址均为中毒主机的MAC 地址；网内所有主机的ARP 缓存表中， 网关的MAC 地址也成为中毒主机的MAC 地址。前者保证了从网关到网 内主机的数据包被发到中毒主机，后者相反，使得主机发往网关的数据 包均发送到中毒主机。</p></blockquote><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>使用arp-a 命令任意选两台不能上网的主机，在DoS 命令窗口下运行arp-a命令。例如在结果中，两台电脑除了网关的IP, MAC 地址对应项，都包含了192.168.0.186的这个IP, 则可以断定 192.168.0.186这台主机就是攻击源。<br>原理： 一般情况下，网内的主机只和网关通信。正常情况下， 一台主机的ARP 缓存中应该只有网关的MAC 地址。如果有其他主机 的MAC 地址，说明本地主机和这台主机最后有过数据通信发生。 如果某台主机(例如上面的192.168.0.186)既不是网关也不是服 务器，但和网内的其他主机都有通信活动，且此时又是ARP 攻击 发作时期，那么攻击源也就是它了。</p><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>使用tracert 命令在任意一台受影响的主机上，在DoS 命令窗口下运行如下命令： tracert 61.135.179.148。<br>● 假定设置的缺省网关为10.8.6.1,在跟踪一个外网地址时， 第一跳却是10.8.6.186,那么， 10.8.6.186就是攻击源。<br>● 原理：中毒主机在受影响主机和网关之间，扮演了“中间人” 的角色。所有本应该到达网关的数据包，由于错误的MAC地址，均被发到了中毒主机。此时，中毒主机越俎代庖，起了缺省网关的作用。</p><h2 id="ARP-攻击防御方法"><a href="#ARP-攻击防御方法" class="headerlink" title="ARP 攻击防御方法"></a>ARP 攻击防御方法</h2><h3 id="方法一：减少过期时间"><a href="#方法一：减少过期时间" class="headerlink" title="方法一：减少过期时间"></a>方法一：减少过期时间</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ndd -set /dev/arp arp cleanup interval <span class="number">60000</span></span><br><span class="line">#ndd -set /dev/ip ip ire flush interval <span class="number">60000</span></span><br><span class="line"><span class="number">60000</span>=<span class="number">60000</span>毫秒默认是<span class="number">300000</span></span><br></pre></td></tr></table></figure><p>加快过期时间，并不能避免攻击，但是使得攻击更加困难，带来的影响是在网络中会大量的出现 ARP 请求和回复，请不 要在繁忙的网络上使用。</p><h3 id="方法二：建立静态ARP表"><a href="#方法二：建立静态ARP表" class="headerlink" title="方法二：建立静态ARP表"></a>方法二：建立静态ARP表</h3><p>这是一种很有效的方法，而且对系统影响不大。缺点是破坏了动<br>态ARP 协议。可以建立如下的文件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[test.<span class="property">nsfocus</span>.<span class="property">com</span>](<span class="attr">http</span>:<span class="comment">//test.nsfocus.com/) 08:00:20:ba:a1:f2</span></span><br><span class="line">user. [nsfocus.<span class="property">com</span>](<span class="attr">http</span>:<span class="comment">//nsfocus.com/) 08:00:20:ee:de:1f</span></span><br></pre></td></tr></table></figure><p>使用arp -f filename加载进去，这样的ARP 映射将不会过期和被新<br>的ARP 数据刷新，除非使用arp-d 才能删除。但是一旦合法主机的 网卡硬件地址改变，就必须手工刷新这个arp文件。这个方法，不 适合于经常变动的网络环境。</p><h3 id="方法三：禁止ARP"><a href="#方法三：禁止ARP" class="headerlink" title="方法三：禁止ARP"></a>方法三：禁止ARP</h3><p>可以通过ipconfig interface-arp 完全禁止ARP, 这样， 网卡不会发送ARP 和接受ARP 包。但是使用前提是使用 静态的ARP 表，如果不在ARP 表中的计算机，将不能通 信。<br>这个方法不适用与大多数网络环境，因为这增加了网络管理的成本。但是对小规模的安全网络来说，还是有效 可行的。</p><h1 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a><strong>拒绝服务攻击</strong></h1><h2 id="典型DoS—Ping-of-Death"><a href="#典型DoS—Ping-of-Death" class="headerlink" title="典型DoS—Ping of Death"></a><strong>典型DoS—Ping of Death</strong></h2><p>攻击者故意在ICMP Echo数据包(Ping包)之后附加非常多的冗余信息，使数据包的尺寸超过65535个字节的上限。</p><p>接收方对这种数据包进行处理时就会出现内存分配错误，导致TCP&#x2F;IP堆栈溢出，从而引起系统崩溃，挂起或重启。</p><h2 id="典型DoS——Teardrop"><a href="#典型DoS——Teardrop" class="headerlink" title="典型DoS——Teardrop"></a><strong>典型DoS——Teardrop</strong></h2><p>Teardrop指的是向目标机器发送损坏的IP包，诸如重叠的包或过大的包载荷，该攻击通过TCP&#x2F;IP协议栈中分片重组代码中的bug来瘫痪各种不同的操作系统。</p><h2 id="典型DoS——Land攻击"><a href="#典型DoS——Land攻击" class="headerlink" title="典型DoS——Land攻击"></a><strong>典型DoS——Land攻击</strong></h2><p>Land攻击：利用特殊的TCP封包传送至目标主机，使其因无法判别而当机或被迫重新启动。</p><p>攻击原理是：用一个特别构造的SYN包，<strong>它的源地址和目标地址都被设置成某一个服务器地址</strong>。此举将导致接受服务器向它自己的地址发送SYN一ACK消息，结果这个地址又发回ACK消息并创建一个空连接。被攻击的服务器每接收一个这样的连接都将保留，直到超时。</p><h2 id="典型DoS—SYN洪水"><a href="#典型DoS—SYN洪水" class="headerlink" title="典型DoS—SYN洪水"></a><strong>典型DoS—SYN洪水</strong></h2><p><strong>原理：</strong></p><ul><li>每个机器都需要为半开连接分配一定的资源</li><li>这种半开连接的数量是有限制</li><li>攻击方利用TCP连接三次握手过程，打开大量的半开TCP连接</li><li>目标机器不能进一步接受TCP连接。机器就不再接受进来的连接请求。</li></ul><h2 id="典型DoS—Smurf"><a href="#典型DoS—Smurf" class="headerlink" title="典型DoS—Smurf"></a><strong>典型DoS—Smurf</strong></h2><p><strong>原理：</strong></p><ul><li>攻击者向一个广播地址发送ICMP Echo请求，并且用受害者的IP地址作为源地址</li><li>广播地址网络上的每台机器响应这些Echo请求，同时向受害者主机发送ICMP Echo-Reply应答</li><li>受害者主机会被这些大量的应答包淹没</li></ul><h2 id="传统DoS的变化"><a href="#传统DoS的变化" class="headerlink" title="传统DoS的变化"></a><strong>传统DoS的变化</strong></h2><h3 id="CC攻击：Challenge-Collapsar"><a href="#CC攻击：Challenge-Collapsar" class="headerlink" title="CC攻击：Challenge Collapsar"></a><strong>CC攻击：Challenge Collapsar</strong></h3><p>原理：CC攻击的原理就是攻击者控制某些主机不停地发大量数据包给对方服务器造成服务器资源耗尽，一直到宕机崩溃。</p><h3 id="慢速攻击"><a href="#慢速攻击" class="headerlink" title="慢速攻击"></a><strong>慢速攻击</strong></h3><p>对HTTP服务器，先建立了一个连接，指定一个比较大的content-length，然后以非常低的速度发包，比如1-10s发一个字节，然后维持住这个连接不断开。</p><p>如果客户端持续建立这样的连接，那么服务器上可用的连接将一点一点被占满，从而导致拒绝服务。</p><h2 id="基于误用的DDoS检测"><a href="#基于误用的DDoS检测" class="headerlink" title="基于误用的DDoS检测"></a><strong>基于误用的DDoS检测</strong></h2><p>基于误用方法依赖于<strong>攻击特征的选取</strong>, 一般用于检测利用漏洞型的DDoS攻击。</p><p>基于误用的DDoS检测主要是利用了<strong>特征匹配</strong>、<strong>模型推理</strong>、<strong>状态转换</strong>和<strong>专家系统</strong>的方法</p><h2 id="基于异常的DDoS检测"><a href="#基于异常的DDoS检测" class="headerlink" title="基于异常的DDoS检测"></a><strong>基于异常的DDoS检测</strong></h2><p>基于异常的DDoS检测取决于<strong>检测模型的建⽴</strong>，不同的模型对应着不同的检测⽅式，主要包括<strong>统计检测、模式预测、⼈⼯智能检测、机器学习检测</strong>四种⽅法</p><h2 id="按算法部署位置分类的检测方法"><a href="#按算法部署位置分类的检测方法" class="headerlink" title="按算法部署位置分类的检测方法"></a><strong>按算法部署位置分类的检测方法</strong></h2><p>l源端检测</p><p>Ø源端DDoS攻击检测指的是将检测算法布置在发出攻击数据包的主机所处⽹络的边界路由器上。</p><p>Ø将DDoS攻击检测系统部署在源端, 可以使得攻击数据流在进⼊⽹络之前被阻⽌。</p><p>l中间⽹络检测</p><p>Ø中间⽹络DDoS攻击检测是指将攻击检测算法部署在整个⽹络上, 包括路由器、交换机或其他⽹络设备。</p><p>Ø在中间⽹络进⾏检测,通常是在核⼼路由器上部署分布式的DDoS防御检测系统。</p><p>l⽬的端检测</p><p>Ø⽬的端DDoS攻击检测是指将攻击检测算法部署在被攻击的主机和相关⽹络设备上。⽬前应⽤得最多的攻击检测都是在⽬的端(即受害端)进⾏的。</p><h2 id="低速率拒绝服务-low-rate-denial-of-service"><a href="#低速率拒绝服务-low-rate-denial-of-service" class="headerlink" title="低速率拒绝服务(low-rate denial of service)"></a><strong>低速率拒绝服务(low-rate denial of service)</strong></h2><p>当前研究的LDoS攻击：针对TCP 拥塞控制机制的攻击不需要维持持续的高速攻击流，利用网络协议或应用服务协议的<strong>自适应机制中</strong>存在的安全漏洞，通过周期性地发送高速脉冲攻击数据包，达到降低受害端的服务性能的目的。</p><p>TCP拥塞控制机制</p><p>Ø 慢启动(slow start)、拥塞避免(congestion avoidance)<br>Ø 快速重传(fast retransmit)、快速恢复(fast recovery)<br>Ø 发送端会根据当前的链路拥塞情况动态地调整发送报文的速率</p><h2 id="LDoS-攻击的检测"><a href="#LDoS-攻击的检测" class="headerlink" title="LDoS 攻击的检测"></a><strong>LDoS 攻击的检测</strong></h2><p>一般传统的 DoS 攻击检测方法：针对网络数据流和服务器<strong>负荷激增等特征</strong>进行检测</p><h3 id="特征检测"><a href="#特征检测" class="headerlink" title="特征检测"></a><strong><strong>特征检测</strong></strong></h3><p>lLDoS攻击的脉冲强度、持续时间和攻击周期等特征也很明显，特别是结合其<strong>周期性特征和短时高速脉冲特征，</strong>能够很好检测到攻击。</p><p>l最常见的防御策略就是<strong>改进路由器的主动队列管理</strong>(active queuemanagement, AQM)</p><p>l目标：一是丢弃符合设定攻击特征的数据流的数据包；二是重新进行带宽分配，尽量保护TCP 数据流，抑制LDoS 攻击流。</p><h3 id="动态时间封装-Dynamic-time-warping-DTW"><a href="#动态时间封装-Dynamic-time-warping-DTW" class="headerlink" title="动态时间封装(Dynamic time warping,DTW)"></a>动态时间封装(Dynamic time warping,DTW)</h3><p>五元组(T,L,R,S,N)描述攻击特征</p><p>ØT 表示攻击的周期<br>ØL 表示一个突发攻击流持续的时间<br>ØR表示突发攻击流量的峰值速率<br>ØS 表示计时开始到第一个突发攻击流量开始之间的时间差<br>ØN 表示背景流量的等级</p><h1 id="DNS威胁与防范"><a href="#DNS威胁与防范" class="headerlink" title="DNS威胁与防范"></a><strong>DNS威胁与防范</strong></h1><h2 id="DNS-概述"><a href="#DNS-概述" class="headerlink" title="DNS 概述"></a><strong>DNS 概述</strong></h2><p>域名系统（Domain Name System，DNS)在Internet上具有举足轻重的作用，负责<strong>在域名和IP地址之间进行转换</strong>。</p><p>因特网的<strong>域名系统</strong>被设计成为一个<strong>联机分布式数据库系统</strong>，并采用客户服务器方式运行。</p><p>DNS使用的大多数名字都可在本地解析，仅有少量解析需要在因特网上通信，因此系统效率很高。</p><p>因特网域名系统采用<strong>层次树状结构</strong>的命名方法，任何一个连接到因特网的主机或路由器都有一个<strong>唯一的层次结构的名字</strong>，即域名（Domain Name）。这里，“域”是名字空间中的一个可被管理的划分。域还可以继续划分为子域，如：二级域、三级域等</p><h2 id="DNS-资源记录"><a href="#DNS-资源记录" class="headerlink" title="DNS 资源记录"></a><strong>DNS 资源记录</strong></h2><p>理论上对于每一个域名我们只需要在域名服务器上保存一条记录即可。这里的记录一般叫作<strong>域名资源记录</strong>，它是一个<strong>五元组</strong>，可以用以下格式表示：</p><p>1.Domain_name: 指出这条记录适用于哪个域名；</p><p>2.Time_to_live: 用来表明记录的生存周期，也就是说最多可以缓存该记录多长时间（后面会讲到缓存机制）；</p><p>3.Class: 一般总是IN；</p><p>4.Type: 记录的类型；</p><p>5.Value: 记录的值，如果是A记录，则value是一个IPv4地址。</p><h2 id="WHOIS的概念"><a href="#WHOIS的概念" class="headerlink" title="WHOIS的概念"></a><strong>WHOIS的概念</strong></h2><p>“WHOIS”是当前域名系统中不可或缺的一项信息服务。</p><p>很多用户希望进一步了解域名、名字服务器的详细信息，这就会用到WHOIS。</p><p>对于域名的注册服务机构（registrar）而言，要确认域名数据是否已经正确注册到域名注册中心（registry），也经常会用到WHOIS。</p><p>直观来看，WHOIS就是<strong>链接到域名数据库的搜索引擎</strong>，一般来说是属于网络信息中心（NIC）所提供和维护的名字服务之一。</p><h2 id="DNS工作流程"><a href="#DNS工作流程" class="headerlink" title="DNS工作流程"></a><strong>DNS工作流程</strong></h2><p><strong>递归查询：</strong>一般客户机和服务器之间是递归查询，DNS服务器如果未能在本地找到相应的信息，就代替用户向其它服务器进行查询，这时它是代替用户扮演了解析器（resolver）的角色，直到最后把结果找到，也可能根本没有结果，那就返回错误，并返回给用户为止。</p><p><strong>迭代查询：</strong>一般服务器之间属于反复查询。DNS服务器返回的要么是本地存在的结果信息，要么是一个错误码，告诉查询者你要的信息这里没有，然后再返回一个可能会有查询结果的DNS服务器地址，让查询者到那里去查一查。</p><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a><strong>DNS协议</strong></h2><p>DNS既可以使用TCP，又可以使用UDP，端口为53.</p><p>Ø DNS主从服务器之间区传送传输时使用TCP协议<br>Ø 客户端与DNS服务器之间传输时用的是UDP协议</p><p><strong>头部：</strong></p><p><strong>会话标识（2字节）：</strong>是DNS报文的ID标识，对于请求报文和其对应的应答报文，这个字段是相同的，通过它可以区分DNS应答报文是哪个请求的响应</p><p><strong><strong>标志位：</strong></strong></p><table><thead><tr><th>QR</th><th>opcode</th><th>AA</th><th>TC</th><th>RD</th><th>RA</th><th>(zero)</th><th>rcode</th></tr></thead><tbody><tr><td>1</td><td>4</td><td>1</td><td>1</td><td>1</td><td>1</td><td>3</td><td>4</td></tr></tbody></table><p><strong><strong>数量字段：</strong></strong></p><p><strong><strong>数量字段（总共8字节）：Questions、Answer RRs、Authority RRs、Additional RRs 各自表示后面的四个区域的数目。Questions表示查询问题区域节的数量，Answer RRs表示回答区域的数量，Authority RRs表示授权区域的数量，Additional RRs表示附加区域的数</strong></strong></p><h3 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h3><p>Ø <strong>QR– 识别查询和答复消息的1位字段： 0 查询；1 应答；</strong></p><p>Ø <strong>Opcode – 描述消息类型的4位字段：</strong></p><p>0 标准查询（由名字到地址）；<br>1 逆向查询；<br>2 服务状态请求 ；</p><p>Ø <strong>AA – 授权回答：1位字段。当设置为1时，识别由命令名字服务器作出的答复</strong></p><p>Ø <strong>TC – 可切断。1位字段。当设置为1，表明消息已被切断。</strong></p><p>Ø <strong>RD – 1位字段。由名字服务器设置为1请求递归服务。</strong></p><p>Ø <strong>RA –1位字段。由名字服务器设置表示递归服务的可用性。</strong></p><p>Ø <strong>Z –3位字段。备用，设置为0.</strong></p><p>Ø <strong>Rcode – 响应代码，</strong>由名字服务器设置的4位字段用以识别查询状态。表示返回码，0表示没有差错，3表示名字差错，2表示服务器错误（Server Failure）</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h3><p><strong>查询名：</strong>长度不固定，且不使用填充字节，一般该字段表示的就是需要查询的域名（如果是反向查询，则为IP，反向查询即由IP地址反查域名）</p><p><strong>域名（2字节或不定长）：</strong>格式和Queries区域的查询名字字段是一样的。。</p><p><strong>查询类型：</strong>表明资源记录的类型，同Queries。</p><p><strong>查询类：</strong>对于Internet信息，总是1。</p><h3 id="DNS安全威胁"><a href="#DNS安全威胁" class="headerlink" title="DNS安全威胁"></a><strong>DNS安全威胁</strong></h3><p><strong>DNS的安全漏洞主要体现在以下三个方面。</strong></p><p>(1) DNS报文只使用<strong>序列号</strong>来进行有效性鉴别，序列号由客户程序设置并由服务器返回结果，客户程序通过它来确定响应与查询是否匹配，这就引入了序列号攻击的危险。</p><p>(2) 从协议定义上来看，在DNS应答报文中可以<strong>附加信息</strong>，该信息可以和所请求的信息没有直接关系，这样，攻击者就可以在应答中随意添加某些信息，如：指示某域的权威域名服务器的域名及IP，导致在被影响的域名服务器上查询该域的请求都会被转向攻击者所指定的域名服务器上去，从而对网络的完整性构成威胁。</p><p>(3) DNS的<strong>缓存机制</strong>，当一个客户端&#x2F;DNS服务器，收到有关域名和IP的映射信息时，它会将该信息存放在缓存中，当再次遇到对此域名的查询请求时就直接使用缓存中的结果而无需重新查询。可以通过ipconfig &#x2F;displaydns命令查看本地DNS缓存信息。</p><p><strong>缓冲区溢出攻击</strong></p><p>1、更改MX记录，造成邮件被截获、修改或删除。</p><p><strong>2、更改A记录，将www服务器的域名指向黑客具有的同样www</strong>内容的主机，诱使访问者登陆，获取访问者的密码等相关信息</p><p><strong>3、利用这台主机作为攻击其他机器的跳板</strong></p><p><strong>拒绝服务攻击</strong></p><p>造成的危害是：域名无法解析为IP地址，用户无法访问互联网</p><p><strong>信息泄露</strong></p><p>一旦这些信息泄露，攻击者就可以根据它推测出主域名服务器的网络结构，为进一步攻击提供参考依据。</p><h2 id="DNS安全防范"><a href="#DNS安全防范" class="headerlink" title="DNS安全防范"></a><strong>DNS安全防范</strong></h2><p>应对DNS服务器面临的安全隐患主要依据以下两个准则：</p><p>选择安全的没有缺陷的BIND版本<br>DNS服务器配置正确可靠</p><h1 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a><strong>Web安全</strong></h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a><strong>XSS</strong></h2><p>Xss（cross site scripting）攻击,全称跨站脚本攻击。</p><p>跨站脚本攻击是指通过存在安全漏洞的web网站注册用户的测览器内，运行非法的HTML标签或JavaScript进行的一种攻击.</p><blockquote><p>XSS的原理是恶意攻击者往 web 页面里插入恶意可执行网页脚本代码，当 用户测览该页之时，嵌入其中 web 里面的脚本代码会被执行，从而可以 达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p></blockquote><p><strong>非持久型 Xss（反射型 Xss ）</strong></p><p>反射型XSS，也叫非持久型XSS，是指发生请求时， XSS代码出现在请求URL中， 作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后 测览器解析并执行。</p><p>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击,拿 到用户隐私数据。<br>攻击者需要诱骗点击<br>反馈率低，所以较难发现和响应修复</p><p>具体流程：<br>1、Alice给Bob发送一个恶意构造了Web的URL。<br>2、Bob点击并查看了这个URL。<br>3、恶意页面中的JavaScript打开一个具有漏洞的HTML页面并将其安装在Bob电脑上。<br>4、具有漏洞的HTML页面包含了在Bob电脑本地域执行的JavaScript。<br>5、Alice的恶意脚本可以在Bob的电脑上执行Bob所持有的权限下的命令。</p><p><strong>存储型xss，也叫持久型xss</strong></p><p>持久型 Xss 漏洞，也被称为存储型 Xss 漏洞， 一般存在于 F。rm 表单提交 等交互功能，如发帖留言，提交文本信息等，黑客利用的 Xss 漏洞，将内容 经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出 的注入代码时，恰好将其演染执行。<br>注入页面方式不是来源于 URL，refferer，f。rms 等，而是来源于后端从数 据库中读出来的数据，不需要诱骗点击。</p><p>持久型 Xss 有以下几个特点:</p><blockquote><p>持久性,植入在数据库中<br>危害面广,甚至可以让用户机器变成 DD。S 攻击的肉鸡。<br>盗取用户敏感私密信息。</p></blockquote><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF（Cross-Site ReqUest Forgery）,跨站请求伪造攻击</p><p>CSRF是一种常见的web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p><p><strong>CSRF防御</strong></p><p>一般的 CSRF 防御也都在服务端进行，主要从以下两个方面入手：<br><strong>正确使用 GET，POST 请求和 cookie</strong><br>. GET 请求常用在查看，列举，展示等不需要改变资源属性的时候（数据库 query 查询的时候）<br>. POST 请求常用在 From 表单提交，改变一个资源的属性或者做其他一些事情的时 候（数据库有 insert、update、delete 的时候）<br><strong>在非 GET 请求中增加 token</strong><br>. 为每个用户生成一个唯一的 cookie token，所有表单都包含同一个伪随机值，但 是由于用户的 cookie 很容易由于网站的 XSS 漏洞而被盗取，所以这个方案必须 要在没有 XSS 的情况下才安全。<br>. 每个 POST 请求使用验证码，这个方案算是比较完美的，但是需要用户多次输入 验证码，用户体验比较差，所以不适合在业务中大量运用。<br>. 渲染表单的时候，为每一个表单包含一个 csrfToken，提交表单的时候，带上 csrfToken，然后在后端做 csrfToken 验证。</p><h3 id="OS命令注入"><a href="#OS命令注入" class="headerlink" title="OS命令注入"></a>OS命令注入</h3><p>os命令注入攻击指通过web应用，执行非法的操作系统命令达到攻击的<br>目的。只要在能调用she II函数的地方就有存在被攻击的风险。倘若调 用she II时存在疏漏，就可以执行插入的非法命令。</p><h2 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h2><p>SQL注入攻击的本质<br><strong>把用户输入的数据当做代码执行</strong></p>]]></content>
    
    
    <summary type="html">网络安全的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://shuita2333.github.io/project/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://shuita2333.github.io/project/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析课程笔记</title>
    <link href="https://shuita2333.github.io/project/2024/01/09/BUPT_note/Notes%20on%20Algorithm%20Design%20and%20Analysis/"/>
    <id>https://shuita2333.github.io/project/2024/01/09/BUPT_note/Notes%20on%20Algorithm%20Design%20and%20Analysis/</id>
    <published>2024-01-09T13:00:00.000Z</published>
    <updated>2024-07-07T08:23:06.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法设计与分析-王东滨"><a href="#算法设计与分析-王东滨" class="headerlink" title="算法设计与分析 王东滨"></a>算法设计与分析 王东滨</h1><h1 id="第一章-算法概述"><a href="#第一章-算法概述" class="headerlink" title="第一章 算法概述"></a>第一章 算法概述</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>能够对一定规范的输入，在有限时间内活的所要求的输出。</p><p>不同的算法可能用不同的时间、空间或效率解决问题。</p><p>算法是有穷的指令序列：</p><ul><li>输入：有零或若干个外部提供的量作为算法的输入</li><li>输出：算法产生至少一个量作为输出</li><li>确定性：组成算法的每条指令是清晰，无歧义的</li><li>有穷性：算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的</li></ul><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>程序是算法用某种程序设计语言的具体实现</p><p>程序可能不满足算法的性质。</p><p>操作系统是在一个无限循环中执行的程序，因而不是一个算法</p><h2 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h2><p>理解问题→精确解或近似解选择数据结构算法设计策略→设计算法→证明正确性→分析算法→设计程序</p><h2 id="算法复杂性"><a href="#算法复杂性" class="headerlink" title="算法复杂性"></a>算法复杂性</h2><p><strong><strong>算法复杂性 &#x3D; 算法所需要的计算机资源</strong></strong></p><p>算法时间复杂性T(n)</p><p>算法空间复杂性S(n)</p><p><strong>其中<em>n</em>是问题的规模（输入大小）</strong></p><p>C&#x3D;F(N,I,A)</p><p>C：算法复杂性</p><p>N：解的问题的规模</p><p>I：算法的输入</p><p>A：算法本身</p><p>*F( N，I，A )*：由参数确定的三元函数</p><p>***<em>时间复杂性 <em>T&#x3D; T ( N，I，A ) ；</em>空间复杂性 <em>S&#x3D; S ( N，I，A )</em></em>*</p><p>通常A隐含在复杂性函数名当中，简写为：</p><p><strong>T&#x3D; T ( N，I) ；S&#x3D;S ( N，I)</strong></p><h2 id="算法的时间复杂性"><a href="#算法的时间复杂性" class="headerlink" title="算法的时间复杂性"></a><strong><strong>算法的时间复杂性</strong></strong></h2><p>1）<strong>最坏情况</strong>下的时间复杂性</p><p>$$<br>T_{\max}(n)&#x3D;\max {T(I)|\mathrm{size}(I)＝n}<br>$$</p><p>2）<strong>最好情况</strong>下的时间复杂性</p><p>$$<br>T_{\min}(n)&#x3D;\min {T(I)|\mathrm{size}(I)＝n}<br>$$</p><p>3）<strong>平均情况</strong>下的时间复杂性</p><p>$$<br>T_{\min}(n)&#x3D;\sum_\mathrm{size(I)&#x3D;n} p(I)T(I)<br>$$</p><p>其中I是问题的规模为<em>n</em>的实例，<em>p</em>(I)是实 例I出现的概率算法渐进复杂性</p><h2 id="算法渐近复杂性"><a href="#算法渐近复杂性" class="headerlink" title="算法渐近复杂性"></a><strong><strong>算法渐近复杂性</strong></strong></h2><p>$$<br>T(n)\rightarrow \infty \<br>$$</p><p>$$<br>(T(n)-t(n))&#x2F;T(n)\rightarrow 0 , \mathrm{as}\ n \rightarrow \infty<br>$$</p><p><em>t</em>(<em>n</em>)是<em>T</em>(<em>n</em>)的渐近性态，为算法的渐近复杂性。在数学上，<em>t</em>(<em>n</em>)是<em>T</em>(<em>n</em>)的渐近表达式，是<em>T</em>(<em>n</em>)略去低阶项留下的主项</p><p>$$<br>\mathrm{as}\ n \rightarrow \infty<br>$$</p><p> <em>t</em>(<em>n</em>)渐进于<em>T</em>(<em>n</em>)， <em>t</em>(<em>n</em>)替代<em>T</em>(<em>n</em>)作为算法的复杂性度量</p><h2 id="渐近分析的记号"><a href="#渐近分析的记号" class="headerlink" title="渐近分析的记号"></a><strong><strong>渐近分析的记号</strong></strong></h2><h3 id="渐进上界记号O"><a href="#渐进上界记号O" class="headerlink" title="渐进上界记号O"></a><em><strong><em>渐进上界记号</em>O</strong></em></h3><p><em>f</em>(<em>n</em>) &#x3D; <em>O</em>(<em>g</em>(<em>n</em>))</p><dl><dt>$$<br>{存在正常数c和n_0,使得对所有n\ge n_0有</dt><dd>0 \le cg(n) \le f(n) }<br>$$</dd></dl><h3 id="渐进下界记号Ω"><a href="#渐进下界记号Ω" class="headerlink" title="渐进下界记号Ω"></a><strong><strong>渐进下界记号Ω</strong></strong></h3><p><strong><em>f</em>(<em>n</em>) &#x3D;Ω(<em>g</em>(<em>n</em>))</strong></p><dl><dt>$$<br>{存在正常数c和n_0,使得对所有n\ge n_0有</dt><dd>0 \le f(n) \le cg(n) }<br>$$</dd></dl><h3 id="非紧上界记号o"><a href="#非紧上界记号o" class="headerlink" title="非紧上界记号o"></a><em><strong><em>非紧上界记号</em>o</strong></em></h3><p><em>f</em>(<em>n</em>) &#x3D; o(<em>g</em>(<em>n</em>))</p><p>$$<br>{<br>对于任何正常数c&gt;0，存在正数和n_0 \ge 0<br>使得对所有n \ge n_0有: 0 \le cg(n) &lt; f(n) }\</p><p>等价于  \frac{f(n)}{g(n)} \rightarrow c\ ,\ as \ n \rightarrow \infty<br>$$</p><h3 id="非紧下界记号ω"><a href="#非紧下界记号ω" class="headerlink" title="非紧下界记号ω"></a><strong><strong>非紧下界记号ω</strong></strong></h3><p><em>f</em>(<em>n</em>) &#x3D; <strong><strong>ω</strong></strong>(<em>g</em>(<em>n</em>))</p><p>$$<br>{对于任何正常数c&gt;0，存在正数和n_0 \ge 0使得对所有n \ge n_0有: 0 \le f(n) &lt; bcg(n) }<br>\<br>等价于\frac{f(n)}{g(n)} \rightarrow c\ ,\ as \ n \rightarrow \infty<br>$$</p><p>$$<br>f(n) \in \omega(g(n))\Leftrightarrow g(n) \in o(f(n))<br>$$</p><p><strong><strong>紧渐近界记号Θ</strong></strong></p><p><em><strong>f(n) &#x3D;* Θ *(g(n))</strong></em></p><p><em><em>当且仅当</em>f*(<em>n</em>) &#x3D; <em>O</em>(<em>g</em>(<em>n</em>))且*f</em>(<em>n</em>) &#x3D;ω(<em>g</em>(<em>n</em>)) ， <em>f(n) 与g(n)<em>同阶</em></em></p><p>$$<br>{存在正常数c_1,c_2和n_0使得对所有n \ge n_0有：c_1g(n) \le f(n)<br>\le c2g(n) }<br>$$</p><h3 id="定理1："><a href="#定理1：" class="headerlink" title="定理1："></a>定理1：</h3><p>$$<br>\Theta(g(n)) &#x3D; O(g(n)) \cap \omega(g(n))<br>$$</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>$$<br>算法复杂度定义、 O(g(n))、 \omega(g(n))<br>$$</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>$$<br>O(f(n))+O(g(n)) &#x3D; O(max{f(n),g(n)}) \<br>O(f(n))+O(g(n)) &#x3D; O(f(n)+g(n)) \<br>O(f(n))*O(g(n)) &#x3D; O(f(n)*g(n))<br>$$</p><h1 id="第二章-递归与分治策略"><a href="#第二章-递归与分治策略" class="headerlink" title="第二章 递归与分治策略"></a>第二章 递归与分治策略</h1><blockquote><p>分治法的设计思想是，将一个难以直接解决的大问题， 分割成一些规模较小的相同问题，以便各个击破，分而治之。</p></blockquote><h2 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h2><p>直接或间接地调用自身的算法称为<strong>递归算法</strong>。 </p><p>用函数自身给出定义的函数称为<strong>递归函数</strong>。</p><p>例1 阶乘函数</p><p>阶乘函数</p><p>$$<br>n!&#x3D;\begin{cases}1 &amp;&amp; n&#x3D;0\ n(n-1)!&amp;&amp; n&gt;0\end{cases}<br>$$</p><p>边界条件与递归方程是递归函数的二个要素，递归函 数只有具备了这两个要素，才能在有限次计算后得出 结果。</p><p>例2 Fibonacci数列</p><p>无穷数列1,1,2,3,5, 8 , 13 , 21 , 34 , 55 , … … , 称 为Fibonacci数列。它可以递归地定义为：</p><p>$$<br>F(n)&#x3D;\begin{cases}1 &amp;&amp; n&#x3D;0\ 1&amp;&amp; n&#x3D;1\ F(n-1)+F(n-2)&amp;&amp; n&gt;1\end{cases}<br>$$</p><p>前面例中的函数都可以找到相应的非递归方式定义：</p><p>$$<br>n!&#x3D;1 ·2 · 3 … …(n- 1) ·n\ F(n)&#x3D;\frac{1}{\sqrt{5}}((\frac{1+\sqrt{5}}{2})^{n+1}-\frac{1-\sqrt{5}}{2})^{n+1})<br>$$</p><p>例3 Ackerman函数</p><p>当一个函数及它的一个变量是由函数自身定义时，称这个函数是双递归函数。Ackerman 函数A(n,m) 定义如下：</p><p>$$<br>A(1,0)&#x3D;2\ A(0,m)&#x3D;1 \qquad m\ge 0\ A(n,0)&#x3D;n+2 \qquad n\ge 2\ A(n,m)&#x3D;A(A(n-1,m),m-1)\qquad  n,m\ge 1<br>$$</p><p>A(n,m) 的自变量m 的每一个值都定义了一个单变量函数：<br>■ M&#x3D;0 时， A(n,0)&#x3D;n+2<br>■ M&#x3D;1 时 ，A(n,1)&#x3D;A(A(n-1,1),0)&#x3D;A(n-1,1)+2, 和A(1,1)&#x3D;2故 A(n,1)&#x3D;2*n<br>■ M&#x3D;2 时， A(n,2)&#x3D;A(A(n-1,2),1)&#x3D;2A(n-1,2), 和A(1,2)&#x3D;A(A(0,2),1)&#x3D;A(1,1)&#x3D;2, 故A(n,2)&#x3D; 2^n。</p><p>■ M&#x3D;3 时，类似的可以推出</p><p>$$<br>2^{2^{2^{ \dots^{2} }}}<br>$$</p><p>■ M&#x3D;4 时， A(n,4)的增长速度非常快，以至于没有适当的数学式 子来表示这一函数。</p><p><strong>本例中的Ackerman 函数却无法找到非递归的定义。</strong></p><p>例4 排列问题</p><p>设计一个递归算法生成n个元素{r,r₂ ,…,r}的全排列。<br>设R&#x3D;{r₁ ,r₂…,rn}是要进行排列的n个元素， Ri&#x3D;R- {ri}。 集合X中元素的全排列记为perm(X)。<br>(r)perm(X) 表示在全排列perm(X) 的每一个排列前加上前 缀得到的排列。 R 的全排列可归纳定义如下：</p><p>当n&#x3D;1 时， perm(R)&#x3D;(r), 其 中r是集合R 中唯一的元素；<br>当n&gt;1 时， perm(R) 由(r₁)perm(R₁),(r₂)perm(R₂),., (rn)perm(Rn)构成。</p><p>例5 整数划分问题</p><p>将正整数n表示成一系列正整数之和： n&#x3D;n₁+n₂+…+nk, 其中n₁ ≥n₂ ≥… ≥nx≥1,k≥1。<br>正整数n的这种表示称为正整数n的划分。求正整数n的不 同划分个数。</p><blockquote><p>例如正整数6有如下11种不同的划分：<br>6;<br>5+1;<br>4+2,4+1+1;<br>3+3,3+2+1,3+1+1+1;<br>2+2+2,2+2+1+1,2+1+1+1+1;<br>1+1+1+1+1+1。</p></blockquote><p>在本例中，如果设p(n)为正整数n的划分数，则难以找到递归关 系，因此考虑增加一个自变量：将最大加数n 不大于m 的划分 个数记作q(n,m)。 可以建立q(n,m)的如下递归关系。<br>q(n,n)&#x3D;1+q(n,n- 1);<br>正整数n的划分由n₁&#x3D;n 的划分和n≤n-1 的划分组成。</p><p>q(n,m)&#x3D;q(n,m- 1)+q(n-m,m),n&gt;m&gt;1;<br>正整数n的最大加数n,不大于m 的划分由n₁&#x3D;m 的划分和 n₁ ≤m-1 的划分组成。</p><p>$$<br>q(n,m)&#x3D;\begin{cases}1&amp;&amp; n&#x3D;1,m&#x3D;1 \q(n,n) &amp;&amp; n&lt;m\ 1+q(n,n-1)&amp;&amp; n&#x3D;m\ q(n,m-1)+q(n-m,m)&amp;&amp; n&gt;m&gt;1\end{cases}<br>$$</p><p>例6 Hanoi塔问题</p><p>设a,b,c是3个塔座。开始时，在塔座a上有一叠共n个圆盘，,这 些圆盘自下而上、由大到小地叠在一起。各圆盘从小到大编号 为1,2 n, 现要求将塔座a上的这一叠圆盘移到塔座b 上，并仍按同样顺序叠置。在移动圆盘时应遵守以下移动规则：</p><p>规则1:每次只能移动1个圆盘；</p><p>规则2:任何时刻都不允许将较大的圆盘压在较小的圆盘之上；</p><p>规则3:在满足移动规则1和2的前提下，可将圆盘移至a,b,c中 任一塔座上。</p><h2 id="递归小结"><a href="#递归小结" class="headerlink" title="递归小结"></a>递归小结</h2><p><strong>优点：</strong> 结构清晰，可读性强，而且容易用 数学归纳法来证明算法的正确性，因此它 为设计算法、调试程序带来很天方便。<br><strong>缺点：</strong> 递归算法的运行效率较低，无论是 耗费的讦算时间还是占用的存储空间都比非递归算法要多。</p><p><strong>解决方法</strong>：在递归算法中消除递归调用，使其转化为非递归算法。<br>1 、 采用一个用户定义的栈来模拟系统的递归调用工作栈。该方法通用性强，但本质上还是递归，只不过人工做了本来由编译器做的事情， 优化效果不明显。<br>2、 用递推来实现递归函数。<br>3 、通过变换能将一些递归转化为尾递归，从而迭代求出结果。<br>后两种方法在时空复杂度上均有较大改善， 但其适用范围有限。</p><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><h3 id="分治法的适用条件"><a href="#分治法的适用条件" class="headerlink" title="分治法的适用条件"></a>分治法的适用条件</h3><p>分治法所能解决的问题一般具有以下几个特征：<br>1)该问题的规模缩小到一定的程度就可以容易地解决；<br>2)该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质<br>3)利用该问题分解出的子问题的解可以合并为该问题的解；<br>4)该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p><blockquote><p>人们从大量实践中发现，在用分治法设计算法时， 最好使子问题的规模大致相同。即将一个问题分成 大小相等的k个子问题的处理方法是行之有效的。<br>这种使子问题规模大致相等的做法是出自一种平衡 (balancing) 子问题的思想，它几乎总是比子问题 规模不等的做法要好。</p></blockquote><p>一个分治法将规模为n的问题分成k个规模为n&#x2F;m 的子问题去 解。设分解阀值n0&#x3D;1, 且adhoc 解规模为1的问题耗费1个单位 时间。再设将原问题分解为k个子问题以及用merge 将k个子问 题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分 治法解规模为|P|&#x3D;n的问题所需的计算时间，则有：</p><p>$$<br>T(n)&#x3D;\begin{cases})(1)&amp;&amp; n&#x3D;1\ kT(n&#x2F;m)+f(n)&amp;&amp; n&gt;1\end{cases}<br>$$</p><p>通过迭代法求得方程的解：</p><p>$$<br>T(n)&#x3D;n^{log_m k}+\sum_{j&#x3D;0}^{log_m n-1}k^jf(n&#x2F;m^j)<br>$$</p><h3 id="二分搜索技术"><a href="#二分搜索技术" class="headerlink" title="二分搜索技术"></a>二分搜索技术</h3><p>给定已按升序排好序的n个元素a[0:n-1], 现要在这n个元素中找 出一特定元素x。</p><blockquote><p>分析：很显然此问题分解出的子问题相互独立，即在a[i]的前 面或后面查找x是独立的子问题，因此满足分治法的适用条件。</p></blockquote><p>据此容易设计出二分搜索算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>  Type&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(Type a[], <span class="type">const</span> Type&amp; x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"><span class="title">while</span>  <span class="params">(r&gt;=  I)</span></span>&#123;</span><br><span class="line"><span class="type">int</span>  m  =(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x == a[m]) </span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line"><span class="keyword">if</span>  (x&lt;a[m])  </span><br><span class="line">r  =  m- <span class="number">1</span>;</span><br><span class="line">  elsel=m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>算法复杂度分析：<br>每执行一次算法的while循环， 待搜索数组的大小减少一半。因此，在最坏情况下， while循环被执行了 O(logn)次。循环体内运算需要O(1)时间，因此整个算法在最坏情况下 的计算时间复杂性为O(logn)。</p></blockquote><h3 id="大整数的乘法"><a href="#大整数的乘法" class="headerlink" title="大整数的乘法"></a>大整数的乘法</h3><p>请设计一个有效的算法，可以进行两个n 位大整数的乘法运算</p><p>直接计算： O(n²)</p><p>$$<br>T(n)&#x3D;\begin{cases}O(1)&amp;n&#x3D;1\ 4T(n&#x2F;2)+O(n)&amp;n&gt;1 \end{cases}\T(n)&#x3D;O(n^2)\ \  \ X&#x3D;a2^{n&#x2F;2}+b \ \ \ \ \ Y&#x3D;c2^{n&#x2F;2}+d\ XY&#x3D;ac2^n+(ad+bc)2^{n&#x2F;2}+bd<br>$$</p><blockquote><p>复杂度分析</p><p>$$<br>T(n)&#x3D;\begin{cases}O(1)&amp;n&#x3D;1\ 3T(n&#x2F;2)+O(n)&amp;n&gt;1 \end{cases}\T(n)&#x3D;O(n^{\log3})&#x3D;O(n^{1.59})<br>$$</p></blockquote><h3 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h3><p>传统方法： O(n³)</p><p>A 和B 的乘积矩阵C 中的元素C[i,j]定义为：</p><p>$$<br>c[i][j]&#x3D;\sum^n_{k&#x3D;1}A[i][k]B[k][j]<br>$$</p><blockquote><p>若依此定义来计算A 和B的乘积矩阵C, 则每计算C的一个元素C[i][j], 需要做n次乘法和n-1次加法。因此，算出矩阵C 的个元素所需的计算时间为O(n3)</p></blockquote><p>假设矩阵A</p><p>和矩阵B都是$N*N(N&#x3D;2^n)$的方矩阵，求C&#x3D;AB，如下所示：</p><p>$C_{11}&#x3D;A_{11}B_{11}+A_{12}B_{21}\<br>C_{12}&#x3D;A_{11}B_{12}+A_{12}B_{22}\<br>C_{21}&#x3D;A_{21}B_{11}+A_{22}B_{21}\<br>C_{22}&#x3D;A_{21}B_{12}+A_{22}B_{22}\$</p><p>$$<br>T(n)&#x3D;\begin{cases}O(1)&amp;n&#x3D;2\ 8T(n&#x2F;2)+O(n^2)&amp;n&gt;2 \end{cases}\T(n)&#x3D;O(n^{3})<br>$$</p><p>使用递归算法：</p><p>$$<br>P_1 &#x3D;A_{11} · B_{12} - A_{11} · B_{22}\<br>P_2 &#x3D;A_{11}·B_{22} + A_{12}·B_{22}\<br>P_3 &#x3D;A_{21} · B_{11} + A_{22}· B_{11}\<br>P_4 &#x3D;A_{22} · B_{21} - A_{22} · B_{11}\<br>P_5 &#x3D; A_{11} · B_{11} + A_{11} · B_{22} + A_{22} · B_{11} + A_{22} · B_{22}\<br>P_6 &#x3D; A_{12} · B_{21} + A_{12}· B_{22 }- A_{22} · B_{21} - A_{22} · B_{22}\<br>P_7 &#x3D; A_{11}·B_{11} + A_{11} · B_{12 }- A_{21}·B_{11} - A_{21} · B_{12}<br>$$</p><p>$$<br>C_{11} &#x3D; P_5 + P_4 – P_2 + P_6\<br>C_{12}&#x3D;P_1+P_2\<br>C_{21}&#x3D;P_3 + P_4\<br>C_{22} &#x3D; P_5 + P_1 - P_3 -P_7<br>$$</p><blockquote><p>复杂度分析</p><p>$$<br>T(n)&#x3D;\begin{cases}O(1)&amp;n&#x3D;2\ 7T(n&#x2F;2)+O(n^2)&amp;n&gt;2 \end{cases}\T(n)&#x3D;O(n^{\log7})&#x3D;O(n^{2.81})<br>$$</p></blockquote><h3 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h3><blockquote><p>在一个2k×2k个方格组成的棋盘中，恰有一个方格与其它方格不 同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋 盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的 特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不 得重叠覆盖。</p></blockquote><p>当k&gt;0 时，将2k×2k棋盘分割为4个2k1×2k-1 子棋盘(a)所示。<br>特殊方格必位于4个较小子棋盘之一中，其余3个子棋盘中无特 殊方格。为了将这3个无特殊方格的子棋盘转化为特殊棋盘，可 以用一个L型骨牌覆盖这3个较小棋盘的会合处，如 (b)所示，从 而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这 种分割，直至棋盘简化为棋盘1×1。</p><h3 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h3><blockquote><p>基本思想： 将待排序元素分成大小大致相同的2个子集合，分 别对2个子集合进行排序，最终将排好序的子集合合并成为所 要求的排好序的集合。</p></blockquote><p>最坏时间复杂度： O(nlogn)<br>平均时间复杂度： O(nlogn)<br>辅助空间： O(n)</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>对输入的子数组a[p:r],按以下三个步骤进行排序：<br>1 ) 分 解 (divide): 以a[p]为基准元素将a[p:r]划分为3段a[p:q-1],a[q],a[q+1:r],其 中a[p:q-1]中任何一个元素 小于等于a[q];a[q+1:r]中任何一个元素大于等于a[q]<br> 2)递归求解：通过递归调用快速排序算法，分别对a[p:q-1]和a[q+1:r]进行排序<br>3)合并：由于a[p:q-1]和a[q+1:r]的排序是就地进行的，因此在a[p:q-1]和a[q+1:r]都已排好序了，不需执行任 何计算， a[p:r]则已排好序了。</p><blockquote><p>最坏情况：发生在划分过程产生的两个区域分别包含 n-1个元素和1个元素的时候。<br>最 坏 时 间 复 杂 度 ： O ( n²)<br>最好情况：每次划分所取的基准都恰好为中值。<br>最 好 时 间 复 杂 度 ： O ( n l o g n )</p></blockquote><h2 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h2><p>给定线性序集中n个元素和一个整数k,1≤k≤n,要求找出这n个 元素中第k 小的元素</p><blockquote><p>在最坏情况下，算法randomizedSelect需要$O(n^2)$计算时间 但可以证明，算法randomizedSelect可以在O(n)平均时间内 找出n个输入元素中的第k小元素。</p></blockquote><p>●将n个输入元素划分成[n&#x2F;57个组，每组5个元素，只可能 有一个组不是5个元素。用任意一种排序算法，将每组中的 元素排好序，并取出每组的中位数，共[n&#x2F;5个 。<br>●递归调用select 来找出这[ n&#x2F;57个元素的中位数。如果 「n&#x2F;57是偶数，就找它的2个中位数中较大的一个。以这个元素作为划分基准。</p><p>$$<br>T(n)&#x3D;\begin{cases}C_1&amp;n&lt;75\ C_2n+T(n&#x2F;5)+T(3n&#x2F;4)&amp;n&gt;75\end{cases}\T(n)&#x3D;O(n)<br>$$</p><h3 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h3><p>设计一个满足以下要求的比赛日程表：<br>(1)每个选手必须与其他n-1个选手各赛一次；<br>(2)每个选手一天只能赛一次；<br>(3)循环赛一共进行n-1天。</p><blockquote><p>按分治策略，将所有的选手分为两半， n个选手的比赛日程表 就可以通过为n&#x2F;2个选手设计的比赛日程表来决定。递归地用 对选手进行分割，直到只剩下2个选手时，比赛日程表的制定 就变得很简单。这时只要让这2个选手进行比赛就可以了。</p></blockquote><h1 id="第3章-动态规划"><a href="#第3章-动态规划" class="headerlink" title="第3章 动态规划"></a><strong>第3章 动态规划</strong></h1><h2 id="算法总体思想"><a href="#算法总体思想" class="headerlink" title="算法总体思想"></a><strong>算法总体思想</strong></h2><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分<br>解成若干个子问题<br>但是经分解得到的子问题往往不是互相独立的。不同子问题的<br>数目常常只有多项式量级。在用分治法求解时，有些子问题被<br>重复计算了许多次。</p><h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a><strong>矩阵连乘问题</strong></h2><p>完全加括号的矩阵连乘积可递归地定义为：</p><p>（1）单个矩阵是完全加括号的；<br>（2）矩阵连乘积A是完全加括号的，则A可表示为2个完全加括号的矩阵连乘积 和的乘积并加括号，即A&#x3D;(BC)</p><p>◼ 由于矩阵乘法满足结合律，所以计算矩阵的连乘可以有许多不<br>同的计算次序。这种计算次序可以用加括号的方式来确定。<br>◼ 若一个矩阵连乘积的计算次序完全确定，也就是说该连乘积已<br>完全加括号，则可以依此次序反复调用2个矩阵相乘的标准算<br>法计算出矩阵连乘积<br>◼ 特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。<br>◼ 矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。</p><h3 id="建立递归关系"><a href="#建立递归关系" class="headerlink" title="建立递归关系"></a><strong>建立递归关系</strong></h3><p>设计算$A_i* A_{i+1}<em>…</em> A_j$ 的矩阵连乘积表示为$A[i:j]$，$1≤i≤j≤n$，所需</p><p>要的最少的乘次数为$m[i,j]$，则原问题的最优值可表示为$m[1,n]$</p><p>◼ 当$i&#x3D;j$时，$A[i:j]&#x3D;Ai$，因此，$m[i,i]&#x3D;0，i&#x3D;1,2,…,n$</p><p>◼ 当$i&lt;j$时，</p><p>若$A [i:j]$ 在$A_k$和$A_{k+1}$间断开为最优，则：</p><p>$A[i:j] &#x3D; A[i:k] A[k+1:j], i⩽k&lt;j$</p><p>$A[i:k]$为 $<strong>A[i]$的行数 $x A[k]$的列数</strong> 的矩阵</p><p>$<strong>A[i]$的行 $&#x3D; A[i-1]$的列 $&#x3D; p_{i-1}$</strong> ，$A[k]$的列数$&#x3D; p_k$</p><p>故：$A[i:k]$ 为$<em>p_{i-1}$$</em> p_k$*的矩阵$A[k+1:j]$为$<em>p_k$$</em> p_j$*的矩阵,则所需计算次数： $m[i, j] &#x3D; m[i,k]+ m[k +1, j]+ p_{i−1}p_kp_j$</p><h3 id="用动态规划法求最优解"><a href="#用动态规划法求最优解" class="headerlink" title="用动态规划法求最优解"></a><strong>用动态规划法求最优解</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="type">int</span> *p，<span class="type">int</span> n，<span class="type">int</span> **m，<span class="type">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">2</span>; r &lt;= n; r++) <span class="comment">/* r 为连乘矩阵的数量 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - r+<span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> j=i+r<span class="number">-1</span>;</span><br><span class="line">m[i][j] = m[i+<span class="number">1</span>][j]+ p[i<span class="number">-1</span>]*p[i]*p[j];</span><br><span class="line">s[i][j] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i+<span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line"><span class="type">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i<span class="number">-1</span>]*p[k]*p[j];</span><br><span class="line"><span class="keyword">if</span> (t &lt; m[i][j]) &#123; m[i][j] = t; s[i][j] = k;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划算法的基本要素"><a href="#动态规划算法的基本要素" class="headerlink" title="动态规划算法的基本要素"></a><strong>动态规划算法的基本要素</strong></h2><h3 id="一、最优子结构"><a href="#一、最优子结构" class="headerlink" title="一、最优子结构"></a><strong><strong>一、最优子结构</strong></strong></h3><ul><li>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为<strong>最优子结构性质</strong>。</li><li>在分析问题的最优子结构性质时，所用的方法具有普遍性：首先假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾。</li><li>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。最优子结构是问题能用动态规划算法求解的前提。</li></ul><blockquote><p>同一个问题可以有多种方式刻划它的最优子结构，有些表示方法的求解速度更快（空间占用小，问题的维度低）</p></blockquote><h3 id="二、重叠子问题"><a href="#二、重叠子问题" class="headerlink" title="二、重叠子问题"></a><strong><strong>二、重叠子问题</strong></strong></h3><ul><li>递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为<strong>子问题的重叠性质</strong>。</li><li>动态规划算法，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。</li><li>通常不同的子问题个数随问题的大小呈多项式增长。因此用动态规划算法只需要多项式时间，从而获得较高的解题效率。</li></ul><h3 id="三、备忘录方法"><a href="#三、备忘录方法" class="headerlink" title="三、备忘录方法"></a><strong><strong>三、备忘录方法</strong></strong></h3><p>备忘录方法的控制结构与直接递归方法的控制结构相同，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题的重复求解。</p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><strong>最长公共子序列</strong></h2><p><strong>给定序列$X&#x3D;{x_1,x_2,…, x_m}$，另一序列$Z&#x3D;{z_1,z_2,…, z_m}$。</strong></p><p>若Z是X的子序列，是指存在一个严格递增下标序列$<strong>{i_1,i_2,…,i_k}$，使得对于所有$j&#x3D;1,2,…,k$有：$z_j&#x3D; x_{ij}$ 。</strong></p><p>例如：序列$Z&#x3D;{B，C，D，B}$是序列$X&#x3D;{A，B，C，B，D，A，B}$的子序列，相应的递增下标序列为${2，3，5，7}$。给定2个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。</p><p>给定2个序列$X&#x3D;{x_1,x_2,…, x_m}$和$Y&#x3D;{y_1,y_2,…, y_n}$，找出X和Y的最长公共子序列。</p><p>设序列$X&#x3D;{x_1,x_2,…, x_m}$和$Y&#x3D;{y_1,y_2,…, y_n}$的最长公共子序列为$Z&#x3D;{z_1,z_2,…,z_k}$ 则</p><p>(1)若$x_m&#x3D;y_n$，则$z_k&#x3D;x_m&#x3D;y_n$，且$Z_{k-1}$是$X_{m-1}$和$Y_{n-1}$最长公共子序列。</p><p>(2)若$x_m≠y_n$且$z_k≠x_m$，则$Z$是$X_{m-1}$和$Y$的最长公共子序列。</p><p>(3)若$x_m≠y_n$且$z_k≠y_n$，则$Z$是$X$和$Y_{n-1}$的最长公共子序列</p><p>其中，$<strong>X_{m-1}&#x3D;{x_1,x_2,…,x_{m-1}}$， $Y_{n-1} &#x3D;{y_1,y_2,…,y_{n-1}}$， $Z_k-1 &#x3D;{z_1,z_2,…,z_{k-1}}$</strong></p><p>由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用c[i][j]记录序列和的最长公共子序列的长度。<strong>其中，</strong> $X&#x3D;{x_1,x_2,…, x_m}$;$Y&#x3D;{y_1,y_2,…, y_n}$<strong>。当i&#x3D;0或j&#x3D;0时，空列是X</strong>i<strong>和Y</strong>j<strong>的最长公共子序列。故此时C[i][j]&#x3D;0。其它情况下，</strong>由最优子结构性质可建立递归关系如下：</p><p>$$<br>c[i][j]&#x3D;\begin{cases} 0&amp;i&#x3D;0,j&#x3D;0\ c[i-1][j-1]+1&amp;i,j&gt;0;x_i&#x3D;y_j\ max{c[i][j-i],c[i-1][j]}&amp;i,j&gt;0;x_i\neq y_j\end{cases}<br>$$</p>]]></content>
    
    
    <summary type="html">算法设计与分析的初步总结，供参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://shuita2333.github.io/project/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="学习笔记" scheme="https://shuita2333.github.io/project/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>复杂网络期末复习总结</title>
    <link href="https://shuita2333.github.io/project/2024/01/02/BUPT_note/Review_of_Complex_network/"/>
    <id>https://shuita2333.github.io/project/2024/01/02/BUPT_note/Review_of_Complex_network/</id>
    <published>2024-01-02T13:00:00.000Z</published>
    <updated>2024-07-07T08:08:27.115Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h4 id="度、度分布的概念"><a href="#度、度分布的概念" class="headerlink" title="度、度分布的概念"></a><strong>度、度分布的概念</strong></h4><p>度：在网络中，度是一个用来描述节点（即网络中的个体）的重要性的概念。节点的度是指与该节点直接相连的边的数量。</p><p>度分布：度分布是描述网络中每个节点度数的概率分布。它是一个统计量，可以反映整个网络的结构特征。</p><p>节点 <code>n</code> 的度 <code>k(n) = 该节点的连接数</code></p><p>平均度  <code>&lt;k&gt;</code></p><p>度函数: <code>P(k) ： 一个随机选取的节点有 k 个连接的概率</code></p></li><li><h4 id="介数（中心性）概念"><a href="#介数（中心性）概念" class="headerlink" title="介数（中心性）概念"></a><strong>介数（中心性）概念</strong></h4><p>任意一对节点间最短路径所经过的次数<br>一个节点的介数就是一个节点在网络中所有最短路径中出现的频率<br>介数反映了相应的节点或边在整个网络中的作用和影响力，是一个全局几何量。<br>介数用于描述节点之间的连接强度和在网络中的重要性。介数可以通过计算节点之间的最短路径长度来衡量节点之间的连通性，从而反映节点在网络中的地位和作用。</p><p>介数在现实生活中的意义非常广泛，以下是列举的一些可能的现实意义：</p><ol><li>社交网络分析：介数可以帮助我们分析社交网络中节点之间的连接强度和信息传播效率。例如，高介数的节点可能在网络中扮演着信息传播的关键角色，对于社交网络中的群体动态和信息传播具有重要的影响。</li><li>网络安全：介数可以用于分析网络攻击路径和防御策略。例如，攻击者可以通过寻找高介数的节点来攻击网络，因此了解节点的介数分布可以帮助我们更好地防御网络攻击。</li><li>交通网络分析：介数可以用于分析交通网络中节点之间的连通性和运输效率。高介数的节点可能在网络中扮演着重要的交通枢纽角色，对于交通网络的运行和优化具有重要的意义。</li></ol><p><strong>介数中心性：</strong><br>从每块中的任一节点到其他某块中的任一节点的最短路径必然要经过节点H。<br>这种以经过某个节点的最短路径的数目来刻画节点重要性的指标就称为介数中心性(Betweeness centrality)，简称介数(BC)。</p><p><strong>计算介数中心性：</strong></p><p>计算介数中心性（Betweenness Centrality）通常涉及以下几个步骤：</p><ol><li><p>确定网络的最短路径:</p><ul><li>对于网络中的每一对节点 ( (s, t) )，找出所有最短路径。最短路径可以使用如Dijkstra算法或Floyd-Warshall算法来计算。</li></ul></li><li><p>计算每个节点的介数中心性:</p><ul><li>对于每个节点 ( v )（不包括起点和终点），计算在所有最短路径中 ( v ) 出现的次数。</li><li>对于每一对节点 ( (s, t) )，如果存在多条最短路径，那么每条路径对节点 ( v ) 的贡献应考虑为 ( \frac{1}{\text{路径数}} )。</li><li>对于每个节点 ( v )，其介数中心性 ( C_B(v) ) 定义为它出现在所有最短路径中的次数的总和，通常标准化为 ( \frac{C_B(v)}{(\text{节点数} - 1)(\text{节点数} - 2)&#x2F;2} )。</li></ul></li><li><p>标准化:</p><ul><li>为了使介数中心性的值与网络大小无关，通常对介数中心性进行标准化。</li></ul></li></ol></li><li><h4 id="聚集系数"><a href="#聚集系数" class="headerlink" title="聚集系数"></a><strong>聚集系数</strong></h4><p>聚类系数是一个度量网络中节点聚集成群体的倾向。具体来说，它衡量一个节点的邻居节点之间相互连接的程度。在一个给定的节点上，聚类系数计算的是该节点的邻居之间实际存在的边数与可能存在的最大边数之间的比例。</p><p>例如，在社交网络中，一个人的聚类系数高意味着他们的朋友彼此之间也很可能是朋友。高聚类系数通常表明网络中存在紧密连接的社区或群体。相反，低聚类系数可能表明网络的联系更为分散。</p><p>在复杂网络分析中，聚类系数是理解网络结构特征的重要工具，它有助于揭示网络中的社区结构、小世界特性等。不同类型的网络（如社交网络、生物网络、技术网络）的聚类系数特性可能有显著差异。</p><p>集聚系数（群系数）（Clustering coefficient）： 朋友的朋友还是不是朋友的情况</p><p>集聚系数及其分布<br>$$<br>M&#x3D;\sum_{l\in E;x,y\in N_v}\varphi^x_l\varphi^y_l\C_v&#x3D;\frac{M}{C^2_n}<br>$$<br>正则网络的集聚系数</p><p>(a) 全连接网络   <code>C = 1</code></p><p>(b) 最近邻居网络 <code>C=3/4</code></p><p>(c) 星形网络    $$C_{star}&#x3D;0\ or\ c_{star}&#x3D;1$$</p><p>随机网络的集聚系数<code>C=p=&lt;k&gt;/N&lt;&lt;1</code></p></li><li><h4 id="粒子群算法"><a href="#粒子群算法" class="headerlink" title="粒子群算法"></a><strong>粒子群算法</strong></h4><p><strong>粒子群算法是一种基于鸟群捕食行为的优化算法，它利用群体中的个体对信息的共享和运动的演化来求解问题。</strong></p><p>粒子群优化（Particle Swarm Optimization，PSO）是一种基于种群的随机优化技术，其基本思想是受到鸟群觅食行为的启示。PSO 是一种群体智能（群体智能是一组集体智能，涵盖了多代理环境下的群体交互）。在一个 PSO 算法中，有一个种群在问题空间内飞行，每个个体（在这里被称为“粒子”）都有一个由速度和位置构成的向量。粒子通过追踪最佳粒子（个人的最佳）和整个群体中的最佳粒子（全局最佳）来更新其位置和速度。</p><p>PSO 算法的基本步骤包括初始化、速度和位置的设定、个体最佳和全局最佳的设定、更新速度和位置、以及更新个体最佳和全局最佳。</p><p>PSO 算法的主要优点包括：易于实现、收敛速度快、适用于解决不同类型的问题。这些优点使得 PSO 成为机器学习、神经网络和其他优化领域的重要候选者。</p><p>但是，虽然 PSO 有其优点，但它在算法的具体实现中仍有一些挑战需要克服，如学习率的设计、维数的影响以及全局搜索的难题等。因此，在使用 PSO 时，需要根据具体问题进行调整和优化。</p></li><li><h4 id="什么是小世界网络"><a href="#什么是小世界网络" class="headerlink" title="什么是小世界网络"></a><strong>什么是小世界网络</strong></h4><p><strong>这种网络属性意味着一些彼此并不相识的人，可以通过一条很短的熟人链条被联系在一起</strong></p><p>小世界网络是一种复杂网络模型，它具有两个主要的特点：</p><ol><li>节点度分布遵循幂律分布，即节点的度k（与该节点直接相连的节点数目）服从一个非常窄的小世界网络分布。这使得网络中的很多节点具有相对较高的度，从而保证了网络的聚集程度和连通性。</li><li>网络的平均路径长度非常短，即小世界效应显著。这意味着信息在网络中的传播速度非常快，信息传播的效率非常高。</li></ol><p>这种网络结构可以解释为，在网络中，一个人的朋友的朋友可能也是他的熟人，而网络中的节点数量却远少于实际的网络连接数量。这种特性使得小世界网络模型在社交网络、社交媒体、信息传播等领域得到了广泛的应用和关注。</p></li><li><h4 id="无标度网络特点"><a href="#无标度网络特点" class="headerlink" title="无标度网络特点"></a><strong>无标度网络特点</strong></h4><p>无标度网络是一种特殊的网络模型，其特点是节点的度分布遵循幂律分布，即大多数节点的度数相对较低，但也有少数节点具有非常高的度数，呈现出一种无标度的特性。</p><p>无标度网络的特点主要体现在以下几个方面：</p><ol><li><p>节点度分布的随机性：无标度网络中的节点度数分布是随机的，而且是非均衡的。这意味着节点的度数不是均匀分布的，而是集中分布在少数几个高度的节点上。</p></li><li><p>节点度的随机涨落：无标度网络中的节点度分布存在一个标度因子，而大多数节点的度数接近这个标度因子，但少数节点可能存在较大的偏差，从而导致节点的度数存在随机涨落。</p></li><li><p>网络的自相似性：无标度网络具有自相似性，即网络中的不同尺度具有相似的结构。这意味着在网络中，不同的节点之间存在着相似的关系，而这种关系并不是完全随机的。</p></li></ol><p>总之，无标度网络是一种特殊的网络模型，具有高度聚集性和自相似性等特点。这些特点使得无标度网络在许多领域中得到了广泛的应用和关注，如社交网络、信息传播、互联网等。</p></li><li><h4 id="六度分离概念"><a href="#六度分离概念" class="headerlink" title="六度分离概念"></a><strong>六度分离概念</strong></h4><p>六度分离概念是一个社交概念，指认为世界上任何两个人之间都只有六个人连接。这个概念是由哈佛大学的心理学教授Stanley Milgram在1967年提出的，他通过“小世界理论”认为，通过六度分离，任何两个不相识的人都可以通过熟人朋友等建立联系，形成一个社会网络。这个概念也说明了社交网络中人与人之间的联系的普遍性和重要性。</p></li><li><h4 id="混沌可预测性，混沌可预测吗？可长期预测还是可短期预测"><a href="#混沌可预测性，混沌可预测吗？可长期预测还是可短期预测" class="headerlink" title="混沌可预测性，混沌可预测吗？可长期预测还是可短期预测"></a><strong>混沌可预测性，混沌可预测吗？可长期预测还是可短期预测</strong></h4><p>混沌系统是否可预测取决于预测的时间尺度。一般来说，混沌系统在短期内的行为可能具有一定的可预测性，这是因为混沌系统通常具有敏感依赖于初值的特点，这意味着小的初始扰动在系统的演化过程中可能会放大，从而导致短期内的行为表现出一定的规律性。</p><p>然而，对于长期预测，混沌系统的可预测性变得更为复杂。一方面，混沌系统的动力学性质决定了它在长期内的行为可能呈现出随机性或复杂性，表现出“蝴蝶效应”的特点，即一个小扰动可能会在大范围内产生影响。这使得混沌系统的长期预测变得非常困难，甚至是不可能的。另一方面，对于某些混沌系统，如洛伦茨吸引子和 Rossler 吸引子等，在一定的条件下，长期行为也可能具有一定的可预测性。</p><p>总的来说，混沌系统是否可预测取决于预测的时间尺度。在短期内，混沌系统可能具有一定的可预测性，而在长期内，其行为可能呈现出随机性和复杂性，不可预测。不过，通过数学模型、计算机模拟和经验数据等手段，我们可以尝试对混沌系统进行短期或长期预测，从而为实际应用提供参考。</p></li><li><h4 id="列举复杂网络相关期刊"><a href="#列举复杂网络相关期刊" class="headerlink" title="列举复杂网络相关期刊"></a><strong>列举复杂网络相关期刊</strong></h4><p>复杂网络是一个多学科交叉的研究领域，覆盖物理学、计算机科学、数学和社会科学等多个领域。以下是一些主要的与复杂网络相关的期刊及其特点：</p><ol><li>Physical Review E</li></ol><ul><li><strong>特点</strong>：专注于统计、非线性和软物质物理学的研究。它包括了复杂网络的物理和数学特性的研究。</li></ul><ol start="2"><li>Social Networks</li></ol><ul><li><strong>特点</strong>：专注于社交网络的理论和实证研究。涵盖社交网络分析的方法和应用，包括社交网络中的结构和功能。</li></ul><ol start="3"><li>Network Science</li></ol><ul><li><strong>特点</strong>：涵盖网络科学的广泛主题，包括网络结构、动态和建模。适合跨学科研究，涉及社会学、经济学、计算机科学等领域。</li></ul><ol start="4"><li>Journal of Complex Networks</li></ol><ul><li><strong>特点</strong>：集中在复杂网络的数学、物理和计算机科学方面。包括网络理论的发展和网络模型的应用。</li></ul><ol start="5"><li>Advances in Complex Systems</li></ol><ul><li><strong>特点</strong>：研究复杂系统的多学科期刊，包括复杂网络的理论和应用研究。关注系统之间的相互作用和网络行为。</li></ul><ol start="6"><li>IEEE Transactions on Network Science and Engineering</li></ol><ul><li><strong>特点</strong>：由IEEE出版，集中在网络科学和工程领域的应用研究。包括网络动力学、优化和网络中的数据分析。</li></ul><ol start="7"><li>Chaos: An Interdisciplinary Journal of Nonlinear Science</li></ol><ul><li><strong>特点</strong>：专注于混沌理论及其在各种系统中的应用，包括复杂网络。涉及物理、工程、生物学和其他自然科学领域。</li></ul><ol start="8"><li>European Physical Journal B</li></ol><ul><li><strong>特点</strong>：涵盖凝聚态物理、统计物理、原子分子和光物理等领域，包括复杂网络的物理特性研究。</li></ul><ol start="9"><li>Computational Social Networks</li></ol><ul><li><strong>特点</strong>：专注于计算方法在社交网络分析中的应用。包括网络模型、社交媒体分析和社交网络挖掘等。</li></ul><ol start="10"><li>Discrete Dynamics in Nature and Society</li></ol><ul><li><strong>特点</strong>：涉及自然和社会科学中的离散动态系统，包括网络理论、图论和应用数学在复杂系统中的应用。</li></ul></li><li><h4 id="用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值"><a href="#用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值" class="headerlink" title="用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值"></a><strong>用遗传算法求解函数最大值，课上专门说过。给一个函数，给一个范围，求最大值</strong></h4><p><em>下面解释用遗传算法求函数$$ f(x)&#x3D;x2, x^2[0,31]$$的最大值的一些重要步骤。这里只介绍第一代群体的生成过程与结果</em></p><p>(1) 编码<br>由于在该例中$$x\in [0,31]$$，因此，将变量x编码为5位长的二进制形式。如x&#x3D;13可表示为01101</p><p>(2) 初始群体的生成</p><p> 随机产生初始群体的每个个体，群体的大小为4(如表1).</p><p>(3)适应度计算</p><p> 将每个个体x的函数值 f(x)作为该个体的适应度。如个体01101的适应度为 $$f(13)&#x3D;13^2&#x3D;169$$<br>(4) 选择<br>计算每个个体的适应度所占的比例 $$\frac{f_i}{\sum^n_{j&#x3D;1}f_i}$$</p><p>(5) 交叉与变异</p><p>这里采用简单交叉操作：首先对配对库中的个体进行随机配对；其次，在配对个体中随机设定交叉处，配对个体彼此交换部分信息(如表1)。于是得到4个新个体，这4个新个体就形成了新一代群体。        比较新旧群体，不难发现新群体中个体适应度的平均值和最大值都有明显的提高。由此可见，新群体中的个体的确是朝着期望的方向进化了。</p></li><li><h4 id="利用混沌神经网络求解函数最小值"><a href="#利用混沌神经网络求解函数最小值" class="headerlink" title="利用混沌神经网络求解函数最小值"></a><strong>利用混沌神经网络求解函数最小值</strong></h4><p>例如，求$\min\left( x_{1}^{2} + 2x_{2}^{2} \right) &#x3D; E$</p><ol><li>求偏导</li></ol><blockquote><p>$$\frac{\partial E}{\partial x_{1}} &#x3D; 2x_{1}\frac{\partial E}{\partial x_{2}} &#x3D; 4x_{2}$$</p></blockquote><ol start="2"><li>带入混沌神经网络</li></ol><p>$$\begin{aligned}<br> &amp; x_{1}(t) &#x3D; \frac{1}{1 + e^{- y_{1}(t)\left( 1 + \varepsilon_{1}(t)) \right.\ }} \<br> &amp; y_{1}(t + 1) &#x3D; ky_{1}(t) + \alpha\left( - 2x_{1} \right) - z_{1}(t)\left( x_{1}(t) - I_{0} \right) \<br> &amp; z_{1}(t + 1) &#x3D; (1 - \beta)z_{1}(t) \<br> &amp; \varepsilon_{1}(t + 1) &#x3D; (1 - \gamma)\varepsilon_{1}(t)<br>\end{aligned}$$</p><p>$$\begin{aligned}<br> &amp; x_{2}(t) &#x3D; \frac{1}{1 + e^{- y_{2}(t)\left( 1 + \varepsilon_{2}(t)) \right.\ }} \<br> &amp; y_{2}(t + 1) &#x3D; ky_{2}(t) + \alpha\left( - 4x_{2} \right) - z_{2}(t)\left( x_{2}(t) - I_{0} \right) \<br> &amp; z_{2}(t + 1) &#x3D; (1 - \beta)z_{2}(t) \<br> &amp; \varepsilon_{2}(t + 1) &#x3D; (1 - \gamma)\varepsilon_{2}(t)<br>\end{aligned}$$</p><p>（tips！注意到，偏导的地方要写成偏导的相反数！并且有n个偏导就要写n*4个式子）</p><ol start="3"><li>使用混沌神经网络迭代计算求解，得到最小值时，$x_{1} &#x3D; 0,x_{2} &#x3D; 0$，函数值$E &#x3D; 0$。</li></ol></li><li><h4 id="交叉耦合构造散列函数"><a href="#交叉耦合构造散列函数" class="headerlink" title="交叉耦合构造散列函数"></a><strong>交叉耦合构造散列函数</strong></h4><p>该方法以交叉耦合映象格子为核心,<br>充分利用其不同于普通时空混沌系统的优良的混乱扩散特性 .首先<br>,将明文分组并行注入交叉耦合映象格子的各格点<br>.然后通过多轮混沌迭代使其具有良好的混沌特性 ,并同时利用<br>Logistic映射作为密钥生成器,对结果进行混沌调制。</p><p><strong>主模块：</strong></p><p>①将消息 M分割成 t个消息块 $M_{1}\ldots,M_{t}$ 每个消息块包含 n个字节<br>,且最后一个块填充 Mt &#x3D;＊…＊10… 0l(M).其中,<br>l(M)表示M的长度的二进制形式, 长度为 64 bit,不足 64 bit时高位添 1个介符<br>1再补 0。n可根据实际需要取值。</p><p>②将每个消息块中各字节元素按对应的ASCII码线性变换，线性变换公式为</p><p>$$C_{i,j} &#x3D; \left{ \begin{aligned}<br> &amp; - \frac{M_{i,j}}{128}\ \ \ \  &amp; &amp; 0 \leqslant A\left( M_{i,j} \right) \leqslant 127 \<br> &amp; \frac{M_{i,j} - 128}{128}\ \ \ \  &amp; &amp; 128 \leqslant A\left( M_{i,j} \right) \leqslant 225<br>\end{aligned}\ (1) \right.\ $$</p><p>③令第 i个消息块对应 $C_{i,1}\ldots,C_{i,n}$分别为交叉耦合映象格子中<br>n个格子初值,<br>且$x_{0}(1) &#x3D; C_{i,1},x_{0}(2) &#x3D; C_{i,2},\ldots,x_{0}(n) &#x3D; C_{i,n}.$其中,<br>$x_{0}(0)$和$x_{0}(n + 1)$由密钥生成模块产生.</p><p>④应用交叉耦合映象格子模型进行 R轮初值迭代, 得到<br>$x_{R}(1)\ldots,x_{R}(n).$</p><p>⑤根据式 (1), 对 $x_{R}(1)\ldots,x_{R}(n)$进行逆变换,<br>得到$X_{R}(1)\ldots,X_{R}(n).$</p><p>⑥将$X_{R}(1)\ldots,X_{R}(n).$循环左移$L_{i}$字节，得到<br>$Y_{R}(1)\ldots,Y_{R}(n).$</p><p>⑦每个消息块依次执行 ③ ～ ⑥, t个消息块即可变为 t组<br>$Y_{R}(1)\ldots,Y_{R}(n).$</p><p>⑧将得到的 t组 n字节 $Y_{R}(1)\ldots,Y_{R}(n).$按比特位异或,得到 8n bit的<br>Hash值.</p><p><strong>密钥生成模块：</strong></p><p>①将 128 bit初始密钥线性映射到 0 ～ 1之间, 作为 Logistic映射的初值。</p><p>②第 i组消息在主模块中的子密钥以第 i-1 组中第 2个子密钥的值作为初值,<br>分别迭代 100 + A(i)和 100 +A(i)+n+1轮得到.</p><p>③将最后一组消息所对应的第 2个子密钥作为初值,迭代 t轮, 得到<br>t个实数$s_{1}\ldots,s_{t}$.主模块中移动字节数 $L_{i} &#x3D; s_{i}(n - 1)$</p></li></ol>]]></content>
    
    
    <summary type="html">复杂网络期末考试的初步总结，供学弟学妹参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://shuita2333.github.io/project/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="复习总结" scheme="https://shuita2333.github.io/project/tags/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>编译原理实验期末复习</title>
    <link href="https://shuita2333.github.io/project/2024/01/01/BUPT_note/Review%20of%20Compilation%20principle/"/>
    <id>https://shuita2333.github.io/project/2024/01/01/BUPT_note/Review%20of%20Compilation%20principle/</id>
    <published>2024-01-01T13:00:00.000Z</published>
    <updated>2024-07-07T07:43:57.830Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Project 1: 词法分析和语法分析</strong></p><p>在这个项目中，你将为BUPT编程语言（BPL）实现一个编译器的词法分析器和语法分析器。BPL是一种类C的编程语言，它去除了C标准中的大多数高级特性，比如宏和指针。项目的目标是编译BPL程序到MIPS32汇编代码。以下是关于词法分析和语法分析部分的详细说明。</p><p><strong>1. 词法分析 (Lexical Analysis)</strong>:</p><ul><li><strong>Flex工具</strong>: 你将使用GNU Flex生成词法分析器。Flex是一个快速的词法分析器生成器。你需要指定要匹配的令牌模式和对每个令牌应用的操作。Flex会将这些规格转换成一个NFA，然后将它转换成一个等价的DFA，并尽可能地最小化这个自动机，最终生成实现词法分析器的C代码。</li><li><strong>Flex编码</strong>: 在使用Flex时，你将使用正则表达式来定义模式，并使用C代码来定义动作。你将编写.lex文件，并通过Flex生成一个C源文件，该文件包含一个实现所有规则和相应动作的有限自动机。</li><li><strong>Flex特性</strong>: Flex还提供了一些有用的特性，如行号记录（yylineno）、输入和输出函数（input()和unput()），以及更多用于控制词法分析过程的函数。</li></ul><p><strong>2. 语法分析 (Syntax Analysis)</strong>:</p><ul><li><strong>Bison工具</strong>: 你将使用GNU Bison生成语法分析器。Bison是一个解析器生成器，你提供一个文法规范的输入，Bison将生成一个LALR(1)解析器来识别该文法的句子。这个解析器接受来自Flex的输入令牌流，以识别指定的上下文无关文法。</li><li><strong>Bison编码</strong>: 类似于Flex，Bison的源代码也包含可选的声明、定义和用户例程部分。你将为每个产生式关联一个动作，这允许你在使用该产生式进行规约时执行任何处理。你需要定义文法的每个非终结符，为每个规则指定优先级和结合性，并设置用于在词法分析器和解析器之间通信的全局变量。</li><li><strong>Bison特性</strong>: Bison还提供了一些高级特性，如符号位置信息、错误恢复和冲突解决机制等。这些特性可以帮助你更有效地实现语法分析器，并提供更稳健的错误处理和更精确的语法分析。</li></ul><p><strong>项目要求</strong>:</p><ul><li>你需要实现一个解析器，它接受单个命令行参数（BPL文件路径），并输出语法有效的BPL程序的语法树或报告代码中存在的所有词法&#x2F;语法错误。</li><li>你的解析器应该能够识别未定义字符或标记、结构非法等词法和语法错误，并为语法有效的BPL程序打印出其语法树。</li><li>你可以实现其他功能，如单行&#x2F;多行注释、宏预处理器、文件包含、for语句等。</li></ul><p>通过这个项目，你将学会如何使用现代的编译器工具（Flex和Bison）来自动化词法分析和语法分析过程，从而更深入地理解编译器前端的工作原理。同时，这也是构建编译器其他部分（如语义分析、中间代码生成、目标代码生成等）的基础。</p><p><strong>Project 2: 语义分析</strong></p><p>在Project 2中，你将继续构建BUPT编程语言（BPL）编译器的功能，专注于语义分析阶段。在前一个项目中完成词法和语法分析后，你已经能够生成语法有效的BPL程序的语法树。现在，语义分析阶段将确保程序有一个明确的定义，即验证程序的逻辑正确性，例如变量是否已声明、类型是否匹配等。</p><ol><li><p><strong>语义分析</strong>:</p><ul><li><strong>作用</strong>：语义分析主要确保程序中的所有声明和表达式在逻辑上是有意义和合法的，包括类型检查、变量声明、函数调用等。</li><li><strong>实现方式</strong>：不同于前一个项目中的工具辅助（如Flex和Bison），在这一阶段，你需要手动编写代码来实现语义分析，这可能是实现BPL编译器中最费力的部分。你需要设计各种数据结构（如符号表和数据类型表示）并仔细考虑它们最合适的实现方式。</li></ul></li><li><p><strong>符号表</strong>:</p><ul><li><strong>概述</strong>：符号表是映射名字到其关联信息的数据结构。在语义分析过程中，编译器将不断更新表中的信息以反映作用域内的内容。符号表的两个典型操作是插入和查找特定符号。</li><li><strong>实现</strong>：可以使用各种抽象数据类型来实现符号表，包括链表、二叉搜索树和哈希表。每种数据结构在空间&#x2F;时间复杂性和实现难度方面有所不同。你可以选择适合你需求的数据结构。</li></ul></li><li><p><strong>作用域检查</strong>:</p><ul><li><strong>概述</strong>：作用域检查是确定程序中的标识符是否在该位置可访问的过程。你可以使用不同的方法来实现支持作用域的符号表，比如命令式单一表方法或功能式独立表方法。</li><li><strong>实现</strong>：可以采用单一全局表，每个作用域内的符号在退出时移除；或者使用作用域栈，每个新的作用域开启一个新的符号表，并在作用域关闭时将其弹出。</li></ul></li><li><p><strong>类型检查</strong>:</p><ul><li><strong>类型系统</strong>：在编程语言中，类型是一组值和在这些值上操作的集合。BPL有两类数据类型：基本类型（由硬件直接提供，如int、char和float）和派生类型（由基本类型或派生类型聚合而成，如数组、结构体等）。</li><li><strong>类型等价性</strong>：如何确定两个类型是否等价？对于基本类型，问题很简单，例如int只等价于int。对于派生类型，事情就复杂多了。通常有两种类型等价性：命名等价性和结构等价性。命名等价性考虑类型的名称，而结构等价性考虑类型的结构。</li><li><strong>派生类型表示</strong>：实现层面上，代表原始类型使用常量就足够了。对于派生类型，例如数组和结构体，表示它们就比较复杂了。常见的技术是存储定义类型的基本信息为多级链表。</li></ul></li><li><p><strong>项目要求</strong>:</p><ul><li><strong>输入格式</strong>：与上一个项目相同，即执行文件<code>bplc</code>接受表示BPL程序路径的单个命令行参数。对于语义上合法的BPL程序，你的语义分析器不应该产生任何输出信息；否则，应该打印出有意义的错误信息。</li><li><strong>错误检测</strong>：你的分析器应该能够检测到一系列的语义错误，如未定义变量的使用、类型不匹配、函数调用参数不匹配等，并能够报告错误类型和行号。</li></ul></li></ol><p>通过这个项目，你将学习如何实现一个编译器的语义分析阶段，这是编译器理解程序并检测错误的关键环节。这个阶段需要对语言的类型系统、作用域规则和其他语义规则有深入的理解。</p><p><strong>Project 3: 中间代码生成</strong></p><ol><li><p><strong>概述</strong>：这个阶段的目的是让编译器为给定的源程序生成中间表示（IR），可以进一步优化以获得更好的运行时性能。IR是独立于机器和语言的源代码表示，大多数编译器首先将源程序翻译为某种形式的IR，然后将其转换为机器代码。IR的使用增强了抽象性，并实现了前端和后端之间更清晰的分离。大多数优化都是在中间代码上完成的。</p></li><li><p><strong>中间表示</strong>：中间表示有多种形式，包括线性IR、树IR和图IR等。这个阶段的输出是一种线性IR，特别是三地址代码（TAC），其中每条指令最多可以有三个操作数。这种IR有助于现代编译器优化，例如常量传播和死代码消除。TAC通常存储在一组四元组中，每个四元组包括一个操作符和两个源操作数及一个目标结果。</p></li><li><p><strong>运行时环境</strong>：编程语言提供了对硬件细节的抽象，但现代计算机硬件只能理解低级原语。编译器必须与操作系统配合以支持目标架构上的高级抽象，并生成额外的代码来维护高级功能。此外，编译器应该管理目标机制，以便生成的代码可以在相同的运行时环境中运行。</p></li><li><p><strong>数据表示</strong>：描述了如何在编译器中表示各种基本数据类型，包括字符、整数和布尔值等，以及指针的存储方式。此外，还介绍了如何在低级别上表示数组和结构体等复杂数据类型。</p></li><li><p><strong>函数调用</strong>：描述了函数调用的处理，包括活动函数的激活记录存储在堆栈中的细节以及参数传递的方法。详细介绍了按值传递和按引用传递这两种参数传递方式。</p></li><li><p><strong>翻译方案</strong>：要从解析树生成TAC，需要按后序遍历树，然后根据某些特定模式转换树节点。介绍了如何使用语法制导的翻译来完成此任务，并且为每个非终结符X实现一组translate_X函数。对于表达式和函数调用，提供了详细的翻译方案。</p></li><li><p><strong>项目要求</strong>：描述了项目的输入格式和假设条件，例如所有测试用例没有词法&#x2F;语法&#x2F;语义错误，只有整型原始类型变量等。这些假设意味着您可以在实现代码生成器时忽略它们的违规行为。</p></li></ol><p><strong>Project 4: 目标代码生成</strong></p><ol><li><p><strong>概述</strong>: 这个阶段是编译器工作流的最后一步，即目标代码生成。在前一阶段，三地址代码（TAC）作为中间表示（IR）已经被生成，但更底层的细节还未处理。目标代码生成是将这些三地址代码处理并最终生成可以在MIPS32机器上运行的可执行代码。</p></li><li><p><strong>实验环境</strong>: 描述了目标机器代码可以在模拟器中运行的环境设置。特别提到了SPIM模拟器，它是一个运行MIPS32程序的独立模拟器。</p></li><li><p><strong>指令选择</strong>:</p><ul><li><strong>编写MIPS32汇编</strong>: 介绍了MIPS32架构的基础知识，包括寄存器使用、数据移动和程序案例。讨论了如何将中间表示转换为机器代码，这个过程依赖于机器。</li><li><strong>翻译三地址码</strong>: 指出指令选择实际上是一个模式匹配问题。讨论了如何将TAC转换为数据操作和跳转指令，以及如何进行更优化的代码生成。</li></ul></li><li><p><strong>寄存器分配</strong>:</p><ul><li><strong>本地寄存器分配</strong>: 介绍了变量和寄存器数量的限制，以及如何在基本块内分配寄存器。探讨了寄存器分配的启发式算法，并提供了具体的寄存器分配实现例程。</li><li><strong>全局寄存器分配</strong>: 讨论了跨多个基本块分配寄存器的复杂性，并介绍了活性分析和图着色分配作为解决方案。这部分详细讨论了如何通过活性分析和图着色算法来进行有效的全局寄存器分配。</li></ul></li><li><p><strong>过程调用约定</strong>:</p><ul><li><strong>堆栈布局</strong>: 描述了堆栈帧的布局以及如何在过程调用中传递参数和返回值。讨论了寄存器和堆栈的使用约定，以及如何在过程调用中保存和恢复寄存器值。</li><li><strong>调用和返回序列</strong>: 详细说明了调用者和被调用者在过程调用中的责任，包括寄存器的保存和恢复，参数的传递，以及返回值的处理。</li></ul></li><li><p><strong>项目要求</strong>:</p><ul><li><strong>基本要求</strong>: 概述了项目的基础要求和假设条件，如中间代码的逻辑正确性，没有结构体或数组变量，以及所有整数常量都可以由MIPS32立即数表示。</li><li><strong>所需任务</strong>: 指出需要完成的两项主要任务，即寄存器分配和TAC翻译。讨论了如何设计和实现寄存器分配算法，以及如何翻译一些特定的TAC指令。</li></ul></li></ol><p>这份文档为目标代码生成阶段提供了详细的指导，包括理论知识、具体实施策略和项目要求，使学生能够理解并实现编译器的这一关键部分。<br>#</p>]]></content>
    
    
    <summary type="html">编译原理实验部分期末考试的初步总结，供学弟学妹参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://shuita2333.github.io/project/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="复习总结" scheme="https://shuita2333.github.io/project/tags/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="编译原理" scheme="https://shuita2333.github.io/project/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>信息系统安全期末复习总结</title>
    <link href="https://shuita2333.github.io/project/2024/01/01/BUPT_note/Review_of_Information_System_Security/"/>
    <id>https://shuita2333.github.io/project/2024/01/01/BUPT_note/Review_of_Information_System_Security/</id>
    <published>2024-01-01T13:00:00.000Z</published>
    <updated>2024-07-07T07:58:22.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h1><h2 id="信息系统概论"><a href="#信息系统概论" class="headerlink" title="信息系统概论"></a>信息系统概论</h2><h3 id="什么是信息系统"><a href="#什么是信息系统" class="headerlink" title="什么是信息系统"></a>什么是信息系统</h3><ul><li>信息系统是一个集成的组件集合，用于收集、存储和处理数据，以及传递信息、知识和数字产品。商业公司和其他组织依靠信息系统来执行和管理他们的运营、与客户和供应商互动，以及在市场上竞争。</li><li>信息系统是支持数据密集型应用程序的软件和硬件系统。</li></ul><h3 id="信息系统的架构、架构的复杂度"><a href="#信息系统的架构、架构的复杂度" class="headerlink" title="信息系统的架构、架构的复杂度"></a>信息系统的架构、架构的复杂度</h3><h4 id="单机架构"><a href="#单机架构" class="headerlink" title="*单机架构*"></a><em><strong>*单机架构*</strong></em></h4><p>在网站开设初期，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。</p><h4 id="第一次演进：Tomcat与数据库分开部署"><a href="#第一次演进：Tomcat与数据库分开部署" class="headerlink" title="*第一次演进：Tomcat与数据库分开部署*"></a><em><strong>*第一次演进：Tomcat与数据库分开部署*</strong></em></h4><p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能</p><h4 id="第二次演进：引入本地缓存和分布式缓存"><a href="#第二次演进：引入本地缓存和分布式缓存" class="headerlink" title="*第二次演进：引入本地缓存和分布式缓存*"></a><em><strong>*第二次演进：引入本地缓存和分布式缓存*</strong></em></h4><p>在Tomcat服务器增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的HTML页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力</p><h4 id="第三次演进：引入反向代理实现负载均衡"><a href="#第三次演进：引入反向代理实现负载均衡" class="headerlink" title="*第三次演进：引入反向代理实现负载均衡*"></a><em><strong>*第三次演进：引入反向代理实现负载均衡*</strong></em></h4><p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发</p><h4 id="第四次演进：数据库读、写分离"><a href="#第四次演进：数据库读、写分离" class="headerlink" title="*第四次演进：数据库读、写分离*"></a><em><strong>*第四次演进：数据库读、写分离*</strong></em></h4><p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据</p><h4 id="第五次演进：数据库按业务分库"><a href="#第五次演进：数据库按业务分库" class="headerlink" title="*第五次演进：数据库按业务分库*"></a><em><strong>*第五次演进：数据库按业务分库*</strong></em></h4><p>把不同业务的数据保存到不同的数据库中，降低业务之间的资源竞争，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决</p><h4 id="第六次演进：把大表拆分为小表"><a href="#第六次演进：把大表拆分为小表" class="headerlink" title="*第六次演进：把大表拆分为小表*"></a><em><strong>*第六次演进：把大表拆分为小表*</strong></em></h4><p>这种做法显著增加了数据库运维的难度，对DBA的要求较高!!!</p><p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀地分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能</p><h4 id="第七次演进：使用LVS或F5使多个Nginx负载均衡"><a href="#第七次演进：使用LVS或F5使多个Nginx负载均衡" class="headerlink" title="*第七次演进：使用LVS或F5使多个Nginx负载均衡*"></a><em><strong>*第七次演进：使用LVS或F5使多个Nginx负载均衡*</strong></em></h4><p>LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。</p><h4 id="第八次演进：通过DNS轮询实现机房间的负载均衡"><a href="#第八次演进：通过DNS轮询实现机房间的负载均衡" class="headerlink" title="*第八次演进：通过DNS轮询实现机房间的负载均衡*"></a><em><strong>*第八次演进：通过DNS轮询实现机房间的负载均衡*</strong></em></h4><p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href="http://www.taobao.com时,dns服务器会使用轮询策略或其他策略,来选择某个ip供用户访问/">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问</a></p><h4 id="第九次演进：引入NoSQL数据库和搜索引擎等技术"><a href="#第九次演进：引入NoSQL数据库和搜索引擎等技术" class="headerlink" title="*第九次演进：引入NoSQL数据库和搜索引擎等技术*"></a><em><strong>*第九次演进：引入NoSQL数据库和搜索引擎等技术*</strong></em></h4><p>针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key&#x2F;value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决</p><h4 id="第十次演进：大应用拆分为小应用"><a href="#第十次演进：大应用拆分为小应用" class="headerlink" title="*第十次演进：大应用拆分为小应用*"></a><em><strong>*第十次演进：大应用拆分为小应用*</strong></em></h4><p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决</p><h4 id="第十一次演进：复用的功能抽离成微服务"><a href="#第十一次演进：复用的功能抽离成微服务" class="headerlink" title="*第十一次演进：复用的功能抽离成微服务*"></a><em><strong>*第十一次演进：复用的功能抽离成微服务*</strong></em></h4><p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理</p><h4 id="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"><a href="#第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异" class="headerlink" title="*第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异*"></a><em><strong>*第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异*</strong></em></h4><p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构</p><h2 id="信息系统安全概论"><a href="#信息系统安全概论" class="headerlink" title="信息系统安全概论"></a>信息系统安全概论</h2><h3 id="信息系统常见的安全威胁"><a href="#信息系统常见的安全威胁" class="headerlink" title="信息系统常见的安全威胁"></a>信息系统常见的安全威胁</h3><h4 id="自然威胁"><a href="#自然威胁" class="headerlink" title="自然威胁"></a>自然威胁</h4><p>自然威胁通常不是故意造成的，但它们会对信息系统产生破坏性影响。</p><ol><li><p><strong>自然灾害</strong>：</p><ul><li>地震：可能破坏服务器室、数据中心和其他基础设施。</li><li>洪水：可能泛滥至关键设施，导致硬件损坏和数据丢失。</li><li>风暴和雷击：可能引起停电或电力浪涌，损坏设备。</li></ul></li><li><p><strong>火灾</strong>：</p><ul><li>火灾可能会摧毁物理设施，包括服务器、网络设备等。</li></ul></li><li><p><strong>环境变化</strong>：</p><ul><li>温度变化或湿度过高或过低都可能对敏感设备造成损害。</li></ul></li></ol><h4 id="人为威胁"><a href="#人为威胁" class="headerlink" title="人为威胁"></a>人为威胁</h4><p>人为威胁通常是有意为之的，旨在从中获利或者对信息系统产生破坏。</p><ol><li><strong>恶意软件攻击</strong>：<ul><li>病毒、蠕虫、特洛伊木马、勒索软件等。</li></ul></li><li><strong>网络钓鱼和社会工程</strong>：<ul><li>攻击者诱导用户提供敏感数据或执行不安全操作。</li></ul></li><li><strong>内部威胁</strong>：<ul><li>滥用权限、数据泄露或内部破坏活动。</li></ul></li><li><strong>数据泄露</strong>：<ul><li>由于不当的数据处理或安全措施不足导致敏感信息外泄。</li></ul></li><li><strong>篡改和破坏</strong>：<ul><li>数据或软件的故意篡改，以及对硬件的物理破坏。</li></ul></li><li><strong>拒绝服务（DoS&#x2F;DDoS）攻击</strong>：<ul><li>通过大量请求使网络服务不可用。</li></ul></li><li><strong>身份盗窃和冒用</strong>：<ul><li>盗用他人身份访问受限资源。</li></ul></li><li><strong>刻意的信息分发</strong>：<ul><li>例如，泄露机密文件，可能是出于政治、个人利益或其他原因.</li></ul></li></ol><h3 id="信息系统安全的概念"><a href="#信息系统安全的概念" class="headerlink" title="信息系统安全的概念"></a>信息系统安全的概念</h3><p>（1）基于信息保障的理解，信息系统安全保障是在信息系统的整个生命周期中，通过对信息系统的风险分析，制定并执行相应的安全保障策略，从技术、管理、工程和人员等方面提出安全保障要求，确保信息系统的保密性、完整性和可用性，降低安全风险到可接受的程度，从而保障系统实现组织机构的使命;</p><p>（2）基于风险控制的理解，即把系统的风险控制到一个可以接受的范围之内；</p><p>（3）基于状态迁移的理解，即系统的状态无论怎么迁移，也不可能进入对应不安全</p><p>状态的空间；</p><p>（4）基于时间的理解，即发现攻击的时间+做出响应的时间&lt;黑客实现攻击的时间；</p><p>（5）基于安全体系架构的理解，以云计算为例，讲稿提供了多种典型安全架构，它</p><p>们要么提供很好的隔离性，要么以可信、可控的方式，可以保证信息系统的业务连</p><p>续性。</p><p>（6）基于安全策略的理解，即一个信息系统是“安全系统”，指的是该系统达到了</p><p>当初设计时所制定的安全策略的要求。</p><h2 id="安全需求和安全策略"><a href="#安全需求和安全策略" class="headerlink" title="安全需求和安全策略"></a>安全需求和安全策略</h2><h3 id="安全需求，一般性的安全需求"><a href="#安全需求，一般性的安全需求" class="headerlink" title="安全需求，一般性的安全需求"></a>安全需求，一般性的安全需求</h3><p><strong>安全需求</strong>：就是在设计一个安全系统时<strong>期望得到的安全保障</strong></p><p><strong>一般性的安全需求</strong></p><p><strong>机密性需求</strong>，防止信息被泄漏给未授权的用户</p><p>​自主安全策略、强制安全策略；需知原则</p><p><strong>完整性需求，</strong>防止未授权用户对信息的修改</p><p>​维护系统资源在一个有效的、预期的状态，防止资源被不正确、不适当的修改；维</p><p>​护系统不同部分的一致性；防止在涉及记账或审计的事件中“舞弊”行为的发生。</p><p><strong>可用性需求，</strong>保证授权用户对系统信息的可访问性</p><p>​“授权用户的任何正确的输入，系统会有相应的正确的输出”</p><p><strong>可记账性需求，</strong>防止用户对访问过某信息或执行过某一操作以否认</p><p>​可对发生的事件、操作等进行回溯</p><h3 id="安全策略：访问控制策略（包括-DAC、MAC-等），如何从安全策略的角度理解信息系统安全"><a href="#安全策略：访问控制策略（包括-DAC、MAC-等），如何从安全策略的角度理解信息系统安全" class="headerlink" title="安全策略：访问控制策略（包括 DAC、MAC 等），如何从安全策略的角度理解信息系统安全"></a>安全策略：访问控制策略（包括 DAC、MAC 等），如何从安全策略的角度理解信息系统安全</h3><p>最典型的安全策略是自主访问控制策略DAC和强制访问控制策略MAC，它们描绘了大部分系统的实际需求，并且这两类策略在多数安 全系统中都提供了相应的实施机制。</p><p><strong>自主访问控制策略</strong></p><p>允许系统中信息的拥有者按照自己的意愿去指定谁可以以何种访问模式去访问该客体</p><p>❖ 自主访问控制策略通常</p><p>➢ 基于系统内用户（如用户ID），加上对用户的访问授权（如权能表），或者客体的访问属性（如访问控制表ACL）来决定该用户是否有某权限访问该客体</p><p>❖ 或者基于要访问信息的内容</p><p>❖ 或者基于用户当时所处的角色</p><p><strong>强制访问控制策略</strong></p><p>在强制访问控制系统中，所有主体（用户，进程）和客体（文件，数据）都被分配了安全标签，安全标签标识一个安全等级。</p><p>➢ 主体（用户，进程）被分配一个安全等级</p><p>➢ 客体（文件，数据）也被分配一个安全等级</p><p>➢ 访问控制执行时对主体和客体的安全级别进行比较</p><p><strong>访问控制策略的组成</strong></p><p><strong>主体</strong></p><p>系统内行为的发起者。通常是用户发起的进程</p><p><strong>客体</strong></p><p>系统内所有主体行为的直接承担者</p><p><strong>系统环境（上下文）</strong></p><p>系统主、客体属性之外的某些状态</p><p>从安全策略的角度理解信息系统安全涉及到制定一套全面的指导原则和框架，这些原则和框架能够指导组织在技术、流程和人力层面上采取措施，以确保信息系统的保密性、完整性和可用性。</p><h3 id="主体、客体及其属性"><a href="#主体、客体及其属性" class="headerlink" title="主体、客体及其属性"></a>主体、客体及其属性</h3><p><strong>主体是系统内行为的发起者，通常是用户发起的进程</strong></p><p>​<strong>信息的访问者（用户）</strong></p><p>​一个获得授权可以访问系统资源的自然人。</p><p>​授权包括：对信息的读&#x2F;写&#x2F;删除&#x2F;追加&#x2F;执行以及授予&#x2F;撤销另外一个用户对信息的访问权限等。</p><p>​<strong>信息的拥有者</strong></p><p>​该用户拥有对此信息的完全处理权限，除非该信息被系统另外加以访问控制。</p><p>​<strong>系统管理员</strong></p><p>​为使系统能正常运转，而对系统的运行进行管理的用户</p><p><strong>主体属性</strong></p><p>​<strong>用户ID&#x2F;组ID</strong> </p><p>​例如用于Unix按位的访问控制、常规自主访问控制</p><p>​<strong>用户访问许可级别</strong></p><p>​例如用于强制访问控制。</p><p>​<strong>权能表</strong></p><p>​例如用于强制访问控制。</p><p>​<strong>角色</strong></p><p>​例如用于Unix按位的访问控制、常规自主访问控制</p><p><strong>访问控制策略的相关方⎯⎯客体</strong></p><p>​<strong>一般客体</strong></p><p>​在系统内以客观、具体的形式存在的信息实体，如文件、目录等</p><p>​<strong>设备客体</strong></p><p>​指系统内的设备，如软盘、打印机等</p><p>​<strong>特殊客体</strong></p><p>​某些主体</p><p><strong>客体属性</strong></p><p>​<strong>敏感性标签</strong></p><p>​一个敏感性标签由2部分组成：信息的敏感性级别和范畴</p><p>​<strong>访问控制列表</strong></p><p>​表示系统中哪些用户可以对此信息进行何种访问</p><p>​由信息的拥有者加以管理</p><h3 id="访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码"><a href="#访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码" class="headerlink" title="访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码"></a>访问控制列表：标准访问控制列表，扩展访问控制列表，通配掩码</h3><p><strong>标准ACL_靠近目的地址</strong></p><p>只使用数据包的源地址作为测试条件。所有决定是基于源IP地址的。</p><p>标准访问列表的创建根据 “动作”＋“源地址” ，即允许谁、拒绝谁的方法来创建</p><p><strong>扩展ACL——基于源地址、目的地址、协议、端口_靠近源地址</strong></p><p>可以测试IP包的第3层和第4层报头中的字段。包括源IP地址、目的IP地址、网络层报头中的协议字段（如，TCP、UDP、ICMP等）以及位于传输层报头中的端口号。</p><p><strong>通配掩码</strong></p><p>路由器使用<strong>IP地址</strong>和<strong>通配掩码</strong>（wildcard-mask）一起来分辨匹配的地址范围，它跟子网掩码刚好相反。</p><p>它不像子网掩码告诉路由器IP地址的哪一位属于网络号一样，通配符掩码告诉路由器为了判断出匹配，它需要检查IP地址中的多少位。</p><p><strong>通配掩码某位是0</strong>表示检查相应bit位的值</p><p><strong>通配掩码某位是1</strong>表示不检查（忽略）相应位的值</p><h2 id="信息系统的风险评估"><a href="#信息系统的风险评估" class="headerlink" title="信息系统的风险评估"></a>信息系统的风险评估</h2><h3 id="风险的概念"><a href="#风险的概念" class="headerlink" title="风险的概念"></a>风险的概念</h3><p>风险指在某一特定环境下，在某一特定时间段内，特定的威胁利用资产的一种或一组薄弱点，导致资产的丢失或损害的潜在可能性，即特定威胁事件发生的可能性与后果的结合。</p><h3 id="什么是安全风险评估"><a href="#什么是安全风险评估" class="headerlink" title="什么是安全风险评估"></a>什么是安全风险评估</h3><p><strong>安全风险组成的四要素：</strong>信息系统资产（Asset）、信息系统脆弱性（Vulnerability）、信息安全威胁（Threat）、信息系统安全保 护措施（Safeguard）。</p><h3 id="风险评估的要素"><a href="#风险评估的要素" class="headerlink" title="风险评估的要素"></a>风险评估的要素</h3><p><strong>风险评估围绕着资产、威胁、脆弱性和安全措施这些基本要素展开。</strong></p><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231220191732221.png" alt="image-20231220191732221"></p><h2 id="信息系统等级保护"><a href="#信息系统等级保护" class="headerlink" title="信息系统等级保护"></a>信息系统等级保护</h2><h3 id="什么是等级保护，等级保护是《网络安全法》规定的一项基本制度"><a href="#什么是等级保护，等级保护是《网络安全法》规定的一项基本制度" class="headerlink" title="什么是等级保护，等级保护是《网络安全法》规定的一项基本制度"></a>什么是等级保护，等级保护是《网络安全法》规定的一项基本制度</h3><p><strong>网络安全等级保护是指对国家重要信息、法人和其他组织及公民的专有信息以及公开信息和存储、传输、处理这些信息的信息系统分等级实行安全保护，对信息系统中使用的信息安全产品实行按等级管理，对信息系统中发生的信息安全事件分等级响应、处置。</strong></p><p><strong>网络安全等级保护工作包括定级、备案、建设整改、等级测评、监督检查五个阶段。</strong></p><h2 id="信息系统的物理安全"><a href="#信息系统的物理安全" class="headerlink" title="信息系统的物理安全"></a>信息系统的物理安全</h2><h3 id="物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等"><a href="#物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等" class="headerlink" title="物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等"></a>物理安全的概念，包括环境安全、介质安全、线路安全、供电安全等</h3><p><strong>环境安全</strong></p><p>对系统所在环境的安全保护</p><p>​<strong>机房三度要求</strong></p><p>​温度&#x2F;湿度&#x2F;洁净度</p><p>​<strong>防火与防水要求</strong></p><p>​为避免火灾、水灾，应采取如下具体措施:</p><p>​（1）隔离</p><p>​（2）火灾报警系统</p><p>​（3）灭火设施</p><p>​（4）管理措施</p><p>​<strong>机房防盗要求</strong></p><p>​<strong>机房防鼠</strong></p><p>​<strong>防静电措施</strong></p><p>​<strong>接地要求</strong></p><p>​<strong>防雷击措施</strong></p><p>​<strong>机房选址要求</strong></p><p><strong>线路安全</strong></p><p>窃听&#x2F;搭线窃听&#x2F;海底电缆窃听</p><p>光纤通信技术</p><p><strong>电源系统安全</strong></p><p>不间断电源（UPS）</p><p><strong>介质安全：</strong>电磁战</p><h3 id="电磁泄漏"><a href="#电磁泄漏" class="headerlink" title="电磁泄漏"></a>电磁泄漏</h3><p>电磁分析攻击作为最有效的旁路攻击技术之一，是通过在密码芯片周围放置线圈，测量芯片在运算期间辐射的电磁信号，研究电磁场与内部处理数据之间的相关性而获取内部秘密参量。</p><h3 id="电源调整器，不间断电源（UPS）"><a href="#电源调整器，不间断电源（UPS）" class="headerlink" title="电源调整器，不间断电源（UPS）"></a>电源调整器，不间断电源（UPS）</h3><h2 id="信息系统的可靠性"><a href="#信息系统的可靠性" class="headerlink" title="信息系统的可靠性"></a>信息系统的可靠性</h2><h3 id="可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）"><a href="#可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）" class="headerlink" title="可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）;"></a>可靠性及其度量指标（MTBF，MTTF，失效率，可靠度）;</h3><h3 id="可维修产品、不可维修产品的可靠性指标，可用度"><a href="#可维修产品、不可维修产品的可靠性指标，可用度" class="headerlink" title="可维修产品、不可维修产品的可靠性指标，可用度"></a>可维修产品、不可维修产品的可靠性指标，可用度</h3><h4 id="可靠性的定义"><a href="#可靠性的定义" class="headerlink" title="*可靠性的定义*"></a><em><strong>*可靠性的定义*</strong></em></h4><p>在规定的条件下、在给定的时间内，系统能实施应有功能的能力。</p><h4 id="可靠性参数"><a href="#可靠性参数" class="headerlink" title="*可靠性参数*"></a><em><strong>*可靠性参数*</strong></em></h4><p>$T_{MTTF}：$平均失效前时间  <strong>不可修系统</strong></p><p>$T_{MTBF}：$平均故障间隔时间  <strong>可修系统</strong></p><p>$R：$<em><strong>*可靠度*</strong></em></p><p>$λ：$<em><strong>*失效率*</strong></em></p><h4 id="寿命"><a href="#寿命" class="headerlink" title="*寿命*"></a><em><strong>*寿命*</strong></em></h4><p>通常用一个非负随机变量$X$来描述产品的寿命。</p><p>$X$的分布函数为</p><p>$F(t) &#x3D; P{X \le t}，t\ge0$</p><p>有了寿命分布<em>F</em>(<em>t</em>) ，就知道产品的平均寿命</p><p>$EX&#x3D;\int_0^\infty tdF(t)$</p><h4 id="可靠度R"><a href="#可靠度R" class="headerlink" title="可靠度R"></a>可靠度R</h4><p>产品在时刻 <em>t</em> 之前都正常工作（不失效）的概率，即产品在时刻 <em>t</em>的生存概率，称为无故障工作概率（可靠度函数）</p><p>$$ R(t)&#x3D;P{X&gt;t}&#x3D;\int_0^\infty dF(t)&#x3D;\int_0^\infty f(t)dt \ 𝑹(t) +F(t)&#x3D;1$$</p><blockquote><p>假设 C 是一个具有 <em>N</em> 个元器件的数字系统，在一定的条件和环境（如温度、湿度、电压等）下运行，并且随着时间 <em>t</em> 的推移质量逐步下降</p></blockquote><p>系统<strong>C</strong>在时刻 <em>t</em> 能正常工作的概率<em>R(t)&#x3D;S(t)&#x2F;N</em></p><p>**<em>R</em>(<em>t</em>)**称为系统 <strong>C</strong> 在时刻 <em>t</em> 的可靠度。</p><h4 id="失效率λ"><a href="#失效率λ" class="headerlink" title="失效率λ"></a>失效率λ</h4><p>假设<em>F</em>(<em>t</em>)是绝对连续的，即存在分布密度函数$<em>f(t)&#x3D;F’(t)</em>$且$F(t)&#x3D;\int_0^tf(x)dx$</p><blockquote><p>将发生故障的条件概率密度叫做失效率。 $λ(t)&#x3D;f(t)&#x2F;R(t)&#x3D;-R’(t)&#x2F;R(t)$ 失效率**λ(<em>t</em>)**表示系统中元器件失效的速率。</p></blockquote><h4 id="λ-t-的浴缸形曲线（Bathtub-curve）"><a href="#λ-t-的浴缸形曲线（Bathtub-curve）" class="headerlink" title="λ(t)的浴缸形曲线（Bathtub-curve）"></a>λ(t)的浴缸形曲线（Bathtub-curve）</h4><p><strong>第一阶段 早期失效期（Infant Mortality）</strong></p><p>器件在开始使用时失效率很高，但随着产品工作时间的增加，失效率迅速降低。这一阶段失效的原因大多是由于设计、原材料和制造过程中的缺陷造成的。为了缩短这一阶段的时间，产品应在投入运行前进行试运转，以便及早发现、修正和排除故障；或通过试验进行筛选，剔除不合格品。</p><p><strong>第二阶段 偶然失效期，也称随机失效期（Random Failures）</strong></p><p>这一阶段的特点是失效率较低，且较稳定，往往可近似看作常数。这一时期是产品的良好使用阶段。由于在这一阶段中，产品失效率近似为一常数，故设<em></em>(<em>t</em>)&#x3D;<em>λ</em>（常数）由可靠度计算公式得$R(t)&#x3D;e^{-λt}$ 这一式表明<strong>设备的可靠性与失效率成指数关系</strong>。</p><p><strong>第三阶段 耗损失效期（Wearout）</strong></p><p>该阶段的失效率随时间的延长而急速增加，主要原因是器件的损失己非常的严重，寿命快到尽头了，可适当的维修或直接更换。</p><p>R(t)和λ的关系</p><p>可靠性不仅是时间<em>t</em>的函数，而且与失效率****λ****有着密切的关联。</p><p>$$ R(t)&#x3D;e^{\int^t_0\lambda(t)dt } $$</p><h4 id="可维修产品的平均维修时间"><a href="#可维修产品的平均维修时间" class="headerlink" title="*可维修产品的平均维修时间*"></a><em><strong>*可维修产品的平均维修时间*</strong></em></h4><p>可维修产品的可维护性平均维修时间（MTTR，Mean Time To Repair）来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间（即设备处于故障状态时间的平均值，或设备修复时间的平均值）。系统的可维护性越好，平均维修时间越短</p><p>$$ MTTR&#x3D;\int^\infty _0t\mu(t)dt$$</p><blockquote><p>$<em>\mu(t)</em>$是维修时间的概率密度函数</p></blockquote><h4 id="可维修产品的维修性指标：可用性"><a href="#可维修产品的维修性指标：可用性" class="headerlink" title="*可维修产品的维修性指标：可用性*"></a><em><strong>*可维修产品的维修性指标：可用性*</strong></em></h4><p>可维修产品的可用性定义为：</p><p>$$ \frac{MTBF}{MTBF+MTTR}*100% $$</p><p><strong>计算机系统可靠性举例</strong></p><p>已知世界上第一代电子管计算机ENIAC有20000个电子管，假 设每个电子管的失效率为&#x3D;0.5%&#x2F;kh（千小时），试求： （1）该计算机的MTTF； （2）若要求计算机的可靠性在95%以上，则至多可以工作多久？</p><p>$$ MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i}&#x3D;\frac{1}{\frac{0.05}{100}*\frac{1}{1000}*20000}&#x3D;\frac{1}{0.01}&#x3D;100H\ R(t)&#x3D;e^{-\frac{t}{MTTF}}\ t&#x3D;5H $$</p><h3 id="容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术"><a href="#容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术" class="headerlink" title="容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术"></a>容错技术，故障检测和诊断技术，故障屏蔽技术，冗余技术</h3><h4 id="故障检测和诊断"><a href="#故障检测和诊断" class="headerlink" title="故障检测和诊断"></a><strong>故障检测和诊断</strong></h4><p>故障检测（Fault Detection）：判断系统是否存在故障的过程故障检测的作用是确认系统是否发生了故障，指示故障的状态，即查找故障源和故障性质。一般来说，故障检测只能找到错误点（错误单元），不能准确找到故障点。</p><p>故障诊断（Fault Diagnosis）：检测出系统存在故障后要进行故障的定位，找出故障所在的位置。</p><h4 id="故障屏蔽技术"><a href="#故障屏蔽技术" class="headerlink" title="故障屏蔽技术"></a><strong>故障屏蔽技术</strong></h4><p>故障屏蔽技术是防止系统中的故障在该系统的信息结构中产生差错的各种措施的总称，其实质是在故障效应达到模块的输出以前，利用冗余资源将故障影响掩盖起来，达到容错目的。</p><h4 id="冗余技术"><a href="#冗余技术" class="headerlink" title="冗余技术"></a><strong>冗余技术</strong></h4><p>硬件冗余</p><p>时间冗余</p><p>软件冗余</p><p>信息冗余:<strong>奇偶校验</strong></p><p>所谓冗余就是超过系统实现正常功能的额外资源。</p><p><strong>硬件冗余：三模冗余</strong></p><p>三模冗余可以由用户手动完成，也可以依靠工具完成。Xilinx推出了XIlInXtMrtool ，可以方便地实现三模冗余设计，并且可以方便地配置被冗余项，大大方便了用户。</p><p><strong>时间冗余技术</strong></p><p>基本思想：重复执行指令或者一段程序来消除故障的影响，以达到容错的效果，它是用消耗时间来换取容错的目的</p><p><strong>三模冗余（TMR）</strong>是一种常见的容错技术，通过三个相同的系统或组件并行工作，并使用投票逻辑来确定最终输出。这种方式可以容忍一个子系统的故障，因为即便有一个子系统产生错误输出，另外两个正确的输出可以通过多数表决来决定正确的响应。</p><p>然而，TMR也有潜在的弱点，例如如果两个系统同时失败并产生了相同的错误输出，TMR可能会选择错误的结果。为了改进TMR的容错能力，可以采取以下措施：</p><h5 id="1-错误检测与恢复"><a href="#1-错误检测与恢复" class="headerlink" title="1. 错误检测与恢复"></a>1. 错误检测与恢复</h5><ul><li><strong>自我检查</strong>：在TMR系统中加入自检逻辑，使得每个模块在表决过程之前进行错误检查。</li><li><strong>错误恢复</strong>：当检测到错误时，启动错误恢复机制，如重置或重新同步该模块。</li><li><strong>动态重新配置</strong>：如果确定某个模块故障，可以动态将其从系统中移除并替换。</li></ul><h5 id="2-多数表决器与冗余"><a href="#2-多数表决器与冗余" class="headerlink" title="2. 多数表决器与冗余"></a>2. 多数表决器与冗余</h5><ul><li><strong>增加冗余级别</strong>：使用四模或更多模冗余系统来提高容错能力，如N模冗余可以容忍N&#x2F;2-1个错误。</li><li><strong>改进表决逻辑</strong>：采用更复杂的表决机制，例如加权表决、模糊逻辑表决或基于信任度的表决，以识别最可靠的模块输出。</li></ul><h5 id="3-组合多种容错技术"><a href="#3-组合多种容错技术" class="headerlink" title="3. 组合多种容错技术"></a>3. 组合多种容错技术</h5><ul><li><strong>时间冗余</strong>：在TMR系统中加入时间冗余技术，如回滚恢复或检查点，以便在出现错误时回到之前的状态。</li><li><strong>软件冗余</strong>：在不同的模块上运行不同版本的软件或算法（N版本编程），以降低软件故障的影响。</li></ul><h5 id="4-故障隔离与恢复"><a href="#4-故障隔离与恢复" class="headerlink" title="4. 故障隔离与恢复"></a>4. 故障隔离与恢复</h5><ul><li><strong>故障隔离</strong>：在系统中加入故障隔离机制，如隔离故障模块，阻止其影响其他模块。</li><li><strong>定期测试与维护</strong>：定期进行系统测试，以确保每个模块都在正常工作状态，并进行必要的维护和更新。</li></ul><h5 id="5-使用先进算法"><a href="#5-使用先进算法" class="headerlink" title="5. 使用先进算法"></a>5. 使用先进算法</h5><ul><li><strong>预测性故障处理</strong>：使用人工智能或机器学习算法来预测故障并提前处理，以减少故障的影响。</li><li><strong>比较和分析系统行为</strong>：对系统的行为进行实时分析，比较其与预期行为的差异来预测潜在的故障。</li></ul><p>通过结合这些改进措施，可以提高TMR系统的可靠性和容错能力，减少判决错误的可能性。然而，每种措施都可能带来额外的成本和复杂性，因此需要根据应用的关键性和可用资源来平衡设计选择。</p><h3 id="RAID-56重要"><a href="#RAID-56重要" class="headerlink" title="RAID(56重要)"></a>RAID(56重要)</h3><p>廉价磁盘冗余阵列（Redundant Arrays of Inexpensive Disks），以多个低成本磁盘构成磁盘子系统，提供比单一硬盘更完备的可靠性和高性能</p><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231220230358791.png" alt="image-20231220230358791"></p><p><strong>数据基带条阵列（RAID0）</strong></p><p>分块无校验型，无冗余存储。简单将数据分配到各个磁盘上，不提供真正容错性。带区化至少需要2个硬盘，可支持8&#x2F;16&#x2F;32个磁盘</p><p>优点</p><p>➢ 允许多个小区组合成一个大分</p><p>➢ 更好地利用磁盘空间，延长磁盘寿命</p><p>➢ 多个硬盘并行工作，提高了读写性能</p><p>缺点</p><p>➢ 不提供数据保护，任一磁盘失效，数据可能丢失，且不能自动恢复。</p><p><strong>磁盘镜象（RAID1）</strong></p><p>每一组盘至少两台，数据同时以同样的方式写到两个盘上，两个盘互为镜象。磁盘镜象可以是分区镜象、全盘镜象。容错方式以空间换取，实施可以采用镜象或者双工技术</p><p>优点</p><p>➢ 可靠性高，策略简单，恢复数据时不必停机。</p><p>缺点</p><p>➢ 有效容量只有总容量的1&#x2F;2，利用率50%。由于磁盘冗余，硬件开销较大，成本较高</p><p><strong>循环奇偶校验阵列（RAID5）</strong></p><p>与RAID4类似，但校验数据不固定在一个磁盘上，而是循环地依次分布在不同的磁盘上，也称块间插入分布校验。它是目前采用最多、最流行的方式，至少需要3个硬盘。</p><p>优点</p><p>➢ 校验分布在多个磁盘中，写操作可以同时处理；</p><p>➢ 为读操作提供了最优的性能；</p><p>➢ 一个磁盘失效，分布在其他盘上的信息足够完成数据重建 </p><p>缺点</p><p>➢ 数据重建会降低读性能；</p><p>➢ 每次计算校验信息，写操作开销会增大，是一般存储操作时间的3倍。</p><p><strong>二维奇偶校验阵列（RAID6）</strong></p><p>RAID6是指带有两种分布存储的检验信息的磁盘阵列，它是对RAID5的扩展，主要是用于要求数据绝对不能出错的场合，使用了二种奇偶校验方法，需要N+2个磁盘</p><h3 id="纠删码（Erasure-Code）"><a href="#纠删码（Erasure-Code）" class="headerlink" title="纠删码（Erasure Code）"></a>纠删码（Erasure Code）</h3><p>是一种前向错误纠正技术（Forward ErrorCorrection，FEC），主要应用在网络传输中避免包的丢失，存储系统利用它来提高存储可靠性。相比多副本复制而言， 纠删码能够以更小的数据冗余度获得更高数据可靠性， 但编码方式较复杂，需要大量计算 。</p><p>EC的定义：Erasure Code是一种编码技术，它可以将n份原始数据，增加m份数据，并能通过n+m份中的任意n份数据，还原为原始数据。即如果有任意小于等于m份的数据失效，仍然能通过剩下的数据还原出来。</p><h2 id="计算机取证"><a href="#计算机取证" class="headerlink" title="计算机取证"></a>计算机取证</h2><h3 id="什么是计算机取证"><a href="#什么是计算机取证" class="headerlink" title="什么是计算机取证"></a>什么是计算机取证</h3><p><strong>计算机取证不过是简单地将计算机调查和分析技术应用于对潜在的、有法律效力的证据的确定与获取上。</strong></p><p><strong>计算机取证是使用软件和工具，按照一些预先定义的程序全面地检查计算机系统，以提取和保护有关计算机犯罪的证据。</strong></p><p>综合：<strong>计算机取证是指对能够为法庭接受的、足够可靠和有说服性的，存在于计算机和相关外设中的计算机证据的确认、保护、提取和归档的过程。</strong></p><h3 id="潜在证据"><a href="#潜在证据" class="headerlink" title="潜在证据"></a>潜在证据</h3><p><strong>证据通常都是在可以存储数据的硬件驱动器、存储设备或媒体中发现的。</strong></p><p>计算机取证是指使用科学方法和技术收集、保存、分析计算机系统、网络、通信设备中的数据，以作为法庭上的证据。在计算机取证过程中，潜在证据可能包括各种形式的数据和信息，这些数据可能存储在不同的地方，包括但不限于：</p><ol><li><p><strong>硬盘驱动器：</strong> 存储在硬盘上的文件、删除的文件、隐藏或未分配的磁盘空间中的数据、日志文件、系统恢复点和磁盘映像。</p></li><li><p><strong>移动存储设备：</strong> 如USB闪存驱动器、外部硬盘、SD卡、手机及其他便携式存储媒介中的数据。</p></li><li><p><strong>操作系统日志：</strong> 包括系统事件日志、安全日志、应用程序日志，它们记录了用户活动、系统错误、登录尝试和其他系统事件。</p></li><li><p><strong>网络设备：</strong> 如路由器、交换机、防火墙的日志文件，以及其他网络传输数据，可能包括网络流量、IP地址、MAC地址、传输的数据包等。</p></li><li><p><strong>云存储和服务：</strong> 云端的数据，包括在线文档、电子邮件、日历、通讯录、上传的照片和视频等。</p></li><li><p><strong>电子邮件：</strong> 电子邮件内容、附件、邮件头信息、已删除的邮件等。</p></li><li><p><strong>浏览器历史记录：</strong> 包括网页浏览历史、下载历史、书签、Cookies、缓存文件等。</p></li><li><p><strong>社交媒体：</strong> 社交网络上的帐户信息、聊天记录、发布的内容、好友列表、登录时间等。</p></li><li><p><strong>软件和应用程序：</strong> 安装在系统上的软件和应用程序可能包含有关用户行为的信息。</p></li><li><p><strong>内存：</strong> RAM中可以找到许多运行时的信息，如正在或最近运行的程序、系统状态、打开的文件等。</p></li><li><p><strong>元数据：</strong> 文件和文档的元数据，如创建时间、最后修改时间、作者信息等。</p></li><li><p><strong>加密的数据：</strong> 加密文件、硬盘或设备，需要破解密码才能访问其中的数据。</p></li><li><p><strong>日志文件：</strong> 各种系统和应用程序生成的日志文件记录了许多系统事件和用户活动。</p></li><li><p><strong>注册表信息：</strong> Windows注册表包含了系统和应用程序的配置信息，用户活动和设备使用记录。</p></li></ol><p>在进行计算机取证时，不仅要收集上述信息，还需要保持证据的完整性和可用性。这通常涉及到创建原始数据的完整副本（即制作镜像）并使用哈希值来保证数据未被更改。取证分析人员应该遵循严格的程序和协议，确保证据链完整且在法律程序中可以接受。</p><h2 id="操作系统安全"><a href="#操作系统安全" class="headerlink" title="操作系统安全"></a>操作系统安全</h2><h3 id="操作系统安全的概念"><a href="#操作系统安全的概念" class="headerlink" title="操作系统安全的概念"></a>操作系统安全的概念</h3><p>操作系统安全是指一系列的措施和技术，旨在保护操作系统免受未经授权访问、使用、泄露、破坏、修改或拒绝服务攻击。操作系统是计算机硬件和用户之间的接口，它管理着计算机资源和应用程序的执行。由于操作系统在计算机网络中的核心作用，其安全性对整个计算系统的安全至关重要。（chat）</p><h3 id="操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道"><a href="#操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道" class="headerlink" title="操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道"></a>操作系统面临的一个主要威胁⎯⎯隐通道：时间隐通道和存储隐通道</h3><p><strong>Lampson关于隐通道的定义</strong>按常规不会用于传送信息但却被利用于泄漏信息的信息传送渠道。</p><p><strong>TCSEC关于隐通道的定义</strong>可以被进程利用来以违反系统安全策略的方式进行非法传输信息的通信通道</p><p>➢ 存储隐通道<br>❖ 限制：进程P不能与进程Q通信。<br>❖ 共享：文件系统。<br>❖ 目的：进程P想发送一条消息给进程Q。<br>❖ 一种使用存储隐通道的方法：<br>    ➢ 进程P在两进程都能读的一个目录中创建一个名为“send”的文件<br>    ➢ 进程Q要读消息前，Q删除文件send➢ 进程P创建一个文件，命名为0bit或者1bit来代表要传输的比特；<br>    ➢ 进程Q记录这个比特，并删除这个文件<br>    ➢ …<br>    ➢ 最后进程P创建一个名为“end”的文件。通信结束。</p><p>➢ 时间隐通道</p><p>❖ 针对KVM&#x2F;370系统的研究发现，可以基于两个虚拟机接收的CPU时间片来建立隐通道<br>    ➢ 若发送方想要发送比特0，则立即释放CPU<br>    ➢ 否则它将使用全部的时间片<br>    ➢ 接收方通过获得CPU的速度可以推断出前者发送的是0还是1<br>❖ 共享资源：CPU时间</p><h3 id="基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU-等概念"><a href="#基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU-等概念" class="headerlink" title="基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU 等概念"></a>基于活动目录的域管理模式（提供一种集中的资源管理模式）：域，域控制器，OU 等概念</h3><p><strong>活动目录（Active Directory，缩写为AD）</strong>是微软公司开发的一种目录服务，用于Windows域网络。它主要提供授权和认证的服务，使用LDAP（轻量级目录访问协议）、Kerberos和DNS等标准协议。活动目录允许管理员在网络范围内管理权限和控制对网络资源的访问。</p><h4 id="域"><a href="#域" class="headerlink" title="域"></a><strong>域</strong></h4><p><strong>就是共享用户账号、计算机账号和安全策略的计算机集合</strong></p><p><strong>域是一个安全边界</strong>：资源在一个域中参与共享。</p><p>域中集中存储用户账号的计算机就是域控制器，域控制器存储着目录数据并管理用户域的交互关系，包括用户登录过程、身份验证和目录搜索等。</p><h4 id="活动目录和域控制器"><a href="#活动目录和域控制器" class="headerlink" title="活动目录和域控制器"></a><strong>活动目录和域控制器</strong></h4><p><strong>一个域中可有一个或多个域控制器，各域控制器间可以相互复制活动目录</strong></p><h4 id="组织单元-（OU）"><a href="#组织单元-（OU）" class="headerlink" title="组织单元 （OU）"></a>组织单元 （OU）</h4><p>OU是一种类型的目录对象⎯⎯容器，其作用主要用来委派对用户、组及资源集合的管理权限<br>    ◼ 控制用户&#x2F;组对资源的访问<br>    ◼ 建立&#x2F;应用组策略对象<br>    ◼ 实现管理委派<br>    ◼ 组织具有公共属性的对象，如打印机</p><h3 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h3><p><strong>组策略GPMC</strong>⎯⎯“一对多”的管理</p><p>组策略是Windows Server 2003操作系统中提供的一种重要的更新和配置管理技术。<br>     系统管理员使用组策略来为计算机和用户组管理桌面配置指定的选项<br>     组策略很灵活，它包括如下的一些选项：基于注册表的策略设置、安全设置、软件安装、脚本、计算机启动与关闭、用户登录和注销，文件重定向等<br>     Windows Server 2003包括几百种可以配置的组策略设置。组策略设置允许企业管理员通过增强和控制用户桌面来减少总的开销</p><p>• 策略提供大量定制桌面的管理<br>• 组策略管理控制台（GPMC）让管理工作更简单<br>• RsOP得到组策略应用的结果<br>• 主要优势：<br>• 降低管理、支持与培训成本<br>• 提升用户工作效率<br>• 允许极大量的定制项目 – 其扩展性不会牺牲定制的灵活性</p><h1 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2. 基本原理"></a>2. 基本原理</h1><h2 id="信息系统概论-1"><a href="#信息系统概论-1" class="headerlink" title="信息系统概论"></a>信息系统概论</h2><h3 id="针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术"><a href="#针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术" class="headerlink" title="针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术"></a>针对“秒杀”及百万级并发等情况的架构设计，需要采用的关键技术</h3><p><strong>秒杀架构设计思路</strong></p><p><strong>将请求拦截在系统上游，降低下游压力：</strong>秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，甚至导致死锁，最终请求超时。</p><p><strong>充分利用缓存：</strong>利用缓存可极大提高系统读写速度。</p><p><strong>消息中间件：</strong>消息队列可以削峰，将拦截大量并发请求，这是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。</p><p><strong>限流，削峰，异步处理，内存缓存，可拓展</strong></p><p><strong>关键技术：</strong></p><ol><li><p><strong>负载均衡</strong>：通过使用负载均衡器分散流量至多个服务器，可以提高系统的处理能力</p></li><li><p><strong>分布式缓存</strong>：使用如Redis或Memcached这样的分布式缓存系统可以极大地减少数据库的压力，通过缓存热点数据来快速响应用户请求。</p></li><li><p><strong>数据库分离</strong>：将读操作和写操作分离，通过读写分离和数据库集群来提高数据库的并发处理能力。</p></li><li><p><strong>消息队列</strong>：引入消息队列，可以平衡负载和解耦服务，通过异步处理来提高系统的响应速度和吞吐量。</p></li><li><p><strong>限流与降级</strong>：通过限流算法防止系统超载，确保系统稳定性。在高流量情况下，及时的服务降级也很关键。</p></li><li><p><strong>数据分片与分区</strong>：对数据库进行水平分区或使用分布式数据库，可将数据分散在不同的节点上，减少单点负载。</p></li><li><p><strong>服务的无状态设计</strong>：确保服务无状态，这样可以无缝扩展服务实例以处理更多的并发请求。</p></li><li><p><strong>CDN</strong>：使用内容分发网络（CDN）可以将静态资源缓存到离用户更近的地方，减少主服务器的负担。</p></li><li><p><strong>动静分离</strong>：通过将动态内容和静态内容分开处理，可以提高处理速度和效率。</p></li><li><p><strong>弹性伸缩</strong>：云服务提供了基于需求自动扩展和缩减服务器实例数量的能力，可以根据流量的实时变化来调整资源。</p></li><li><p><strong>数据库优化</strong>：包括数据库索引优化、查询优化和合理的数据库架构设计，以减少查询时间和提高效率。</p></li><li><p><strong>应用性能监控（APM）</strong>：使用各种监控工具来实时监控应用程序的性能，快速定位并解决性能瓶颈问题。</p></li></ol><h2 id="信息系统安全概论-1"><a href="#信息系统安全概论-1" class="headerlink" title="信息系统安全概论"></a>信息系统安全概论</h2><h3 id="信息系统为什么是脆弱的？"><a href="#信息系统为什么是脆弱的？" class="headerlink" title="信息系统为什么是脆弱的？"></a>信息系统为什么是脆弱的？</h3><p><strong>硬件组件</strong></p><p>信息系统硬件组件的安全隐患多来源于设计，主要表现为物理安全方面的问题。</p><p><strong>软件组件</strong></p><p>软件组件的安全隐患来源于设计和软件工程中的问题。</p><p>➢ 漏洞</p><p>➢ 不必要的功能冗余引起安全脆弱性；</p><p>➢ 未按安全等级要求进行模块化设计，安全等级不能达到预期</p><p><strong>网络和通信协议</strong></p><p>➢ TCP&#x2F;IP协议族本身的缺陷</p><p>➢ 基于TCP&#x2F;IP协议Internet的安全隐患</p><p>• 缺乏对用户身份的鉴别</p><p>• 缺乏对路由协议的鉴别认证</p><p>• TCP&#x2F;UDP的缺陷</p><h3 id="攻防不对称性及应对思路，拟态主动防御"><a href="#攻防不对称性及应对思路，拟态主动防御" class="headerlink" title="攻防不对称性及应对思路，拟态主动防御"></a>攻防不对称性及应对思路，拟态主动防御</h3><p>攻防不对称性是指在网络安全中，攻击者和防御者所面临的条件和需求不同，进而导致的力量不平衡。具体来说，攻击者只需找到系统中的一个漏洞即可实施攻击，而防御者则需要保护系统的所有潜在脆弱点，这显然是一项更艰巨的任务。</p><p>攻防不对称性的特点包括：</p><ul><li><strong>成本不对称</strong>：攻击者通常花费较少资源就能发起有效攻击，而防御者则需要投入大量资源来防御潜在的多样化攻击。</li><li><strong>知识不对称</strong>：攻击者只需要知道特定的漏洞信息就可以发起攻击，而防御者则需要全面了解整个信息系统的安全状况。</li><li><strong>倡议不对称</strong>：攻击者可以挑选时间和地点发起攻击，而防御者则需要时刻准备应对意料之外的攻击。</li></ul><h4 id="应对思路"><a href="#应对思路" class="headerlink" title="应对思路"></a>应对思路</h4><p>在面对攻防不对称性的挑战时，防御者可以采取以下策略来增强安全防御能力：</p><ol><li><p><strong>分层防御</strong>：通过多层安全措施来保护信息系统，即使攻击者突破了一层防御，其他层次的安全措施仍然可以阻止攻击的进一步发展。</p></li><li><p><strong>最小权限原则</strong>：只授予用户或系统完成其职责所必需的信息访问权限，以此减少攻击面。</p></li><li><p><strong>持续监测和审计</strong>：实施实时监控和定期审计，确保对系统的异常行为和安全事件能够及时发现并响应。</p></li><li><p><strong>定期更新和补丁管理</strong>：确保所有系统和软件都安装了最新的安全更新和补丁。</p></li><li><p><strong>安全意识教育</strong>：提高组织内部用户的安全意识，减少因用户失误导致的安全事件。</p></li><li><p><strong>事故响应计划</strong>：制定并实施有效的事故响应计划，以便在发生安全事件时能够迅速采取行动，减轻损失。</p></li></ol><h4 id="拟态主动防御"><a href="#拟态主动防御" class="headerlink" title="拟态主动防御"></a>拟态主动防御</h4><p>拟态防御是一种新型的安全防御技术，其基本思想是通过动态变换系统的攻击面，使攻击者无法准确掌握目标系统的真实状态，从而增加攻击者的不确定性和攻击成本。拟态防御可以通过以下方式实现：</p><ul><li><strong>动态变换</strong>：定期或根据某种算法自动更改系统配置，如IP地址、端口号、协议等，使攻击者难以确定有效攻击向量。</li><li><strong>混淆技术</strong>：在系统中部署虚假的信息和服务，迷惑攻击者，引导其走向陷阱或死胡同。</li><li><strong>强化随机性</strong>：采用随机化技术在系统设计和运行中引入不确定性，比如随机分配资源和任务，让攻击路径变得难以预测。</li><li><strong>主动应对</strong>：系统能够监测到攻击行为时，主动调整策略或者改变系统行为，对攻击者造成反制。</li></ul><p>采用拟态防御可以显著提高攻击的难度，从而在一定程度上缓解攻防不对称的问题。然而，这也需要更高级的设计和管理能力，确保系统在变换的过程中不会影响正常服务。</p><h3 id="5G-对信息系统安全带来的挑战"><a href="#5G-对信息系统安全带来的挑战" class="headerlink" title="5G 对信息系统安全带来的挑战"></a>5G 对信息系统安全带来的挑战</h3><p>5G网络是第五代移动通信技术，它为用户提供了更高的数据传输速率、更低的延迟和更高的连接密度。尽管这些优点为用户带来了许多便利，但5G技术的引入也给信息系统安全带来了新的挑战：</p><ol><li><p><strong>更大的攻击面</strong>：5G网络支持更多的设备连接，包括物联网(IoT)设备，这大大扩展了潜在的攻击面。每个设备都可能成为攻击者的目标。</p></li><li><p><strong>供应链风险</strong>：5G网络涉及复杂的供应链，其中包括多家供应商的设备和软件。供应链的安全弱点可能会影响整个网络。</p></li><li><p><strong>端到端加密挑战</strong>：随着5G网络对加密和隐私保护的要求提高，确保端到端加密的有效实施变得更加困难。</p></li><li><p><strong>更高的带宽和低延迟带来的问题</strong>：虽然这些特性改善了用户体验，但它们也使得发起大规模、高速度的攻击（比如DDoS攻击）更加容易。</p></li><li><p><strong>设备鉴别和管理问题</strong>：随着设备数量的激增，有效地识别和管理这些设备，确保它们都是安全的和符合政策的，变得更加困难。</p></li><li><p><strong>切片管理的复杂性</strong>：5G网络采用了网络切片技术，为不同的服务需求提供定制化的网络环境。每个切片都需要单独管理，提出了对安全策略和隔离机制的高要求。</p></li><li><p><strong>移动边缘计算(MEC)的安全性</strong>：5G促进了MEC的发展，将计算能力带到网络边缘靠近用户。这种分散型计算架构带来了数据存储和处理的安全性问题。</p></li><li><p><strong>物理层和无线接口的威胁</strong>：5G网络的无线接口和物理层也可能面临攻击，例如通过嗅探、欺骗和重放攻击来威胁数据的保密性和完整性。</p></li></ol><h4 id="应对措施"><a href="#应对措施" class="headerlink" title="应对措施"></a>应对措施</h4><p>针对以上挑战，可以采取以下措施来提高5G网络的信息系统安全：</p><ul><li><strong>增强设备安全</strong>：确保所有接入网络的设备都符合严格的安全标准。</li><li><strong>多层安全策略</strong>：实现针对不同网络层次和业务类型的安全策略，包括物理、网络、应用层的安全措施。</li><li><strong>身份管理和访问控制</strong>：强化用户和设备的身份管理系统，实施有效的访问控制策略。</li><li><strong>网络监控和异常检测</strong>：使用先进的监控工具和机器学习技术来检测异常行为和潜在的安全威胁。</li><li><strong>加强供应链安全</strong>：对供应链合作伙伴进行严格的安全审查，确保所有组件都符合安全标准。</li><li><strong>安全架构设计</strong>：在设计网络和服务时，将安全作为核心考虑因素。</li><li><strong>隔离和随机性</strong>：运用网络切片和虚拟化技术，确保不同服务之间的隔离，以及在安全配置中加入随机性，提高攻击的难度。</li></ul><h3 id="信息系统安全保障模型：CMM-框架"><a href="#信息系统安全保障模型：CMM-框架" class="headerlink" title="信息系统安全保障模型：CMM 框架"></a>信息系统安全保障模型：CMM 框架</h3><p>在安全技术上，不仅要考虑具体的产品和技术，更要考虑信息系统的安全技术体系架构。</p><p>建立相应的安全保障管理体系，形成长效和持续改进的安全管理机制。</p><p>建立相应的安全保障管理体系，形成长效和持续改进的安全管理机制。</p><p>注重人的安全意识以及安全专业技能和能力等。</p><p><strong>安全保障能力维</strong></p><p>第一能力级别0：未实施</p><p>第二能力级别1：基本执行</p><p>第三能力级别2：计划跟踪</p><p>第四能力级别3：充分定义</p><p>第五能力级别4：量化控制</p><p>第六能力级别5：持续改进</p><h2 id="安全需求和安全策略-1"><a href="#安全需求和安全策略-1" class="headerlink" title="安全需求和安全策略"></a>安全需求和安全策略</h2><h3 id="常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）"><a href="#常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）" class="headerlink" title="常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）"></a>常见的自主访问控制模型：访问能力表（CL），访问控制列表（ACL）</h3><h4 id="访问能力表（Capability-List-CL）"><a href="#访问能力表（Capability-List-CL）" class="headerlink" title="访问能力表（Capability List, CL）"></a>访问能力表（Capability List, CL）</h4><p>访问能力表是一种基于能力的访问控制机制，它将权限与用户（或用户的程序）关联起来，而不是与资源关联。每个用户都有一个能力列表，指明了该用户能够访问的资源以及相应的访问权限。</p><p><strong>主要特点</strong>：</p><ul><li>每个用户或进程都有一个与之关联的能力列表。</li><li>能力列表指出用户可以访问的资源及其访问权限（如读、写、执行）。</li><li>能力可以被传递或委托，使得用户可以将某些权限授予其他用户或进程。</li></ul><p><strong>优势</strong>：</p><ul><li>权限的分发和管理与具体的资源分离开来。</li><li>可以方便地为用户配置一组资源的权限。</li><li>更容易实现权限的细粒度控制。</li></ul><p><strong>劣势</strong>：</p><ul><li>管理能力列表可能会变得复杂，尤其是在用户数目众多、系统资源广泛的情况下。</li><li>如果能力列表被泄露或未受到妥善保护，可能会产生安全风险。</li></ul><h4 id="访问控制列表（Access-Control-List-ACL）"><a href="#访问控制列表（Access-Control-List-ACL）" class="headerlink" title="访问控制列表（Access Control List, ACL）"></a>访问控制列表（Access Control List, ACL）</h4><p>访问控制列表是一种更为常见的访问控制机制，它将权限与资源关联起来。对于系统中的每个资源（如文件、目录或设备），都有一个对应的ACL，列出了具有访问该资源权限的所有用户及其访问级别。</p><p><strong>主要特点</strong>：</p><ul><li>每个资源（如文件或目录）都有一个与之关联的访问控制列表。</li><li>ACL列出了具有访问权限的用户或用户组以及各自的权限。</li><li>管理者可以对每个资源设置不同用户或用户组的不同权限。</li></ul><p><strong>优势</strong>：</p><ul><li>权限与资源直接关联，容易理解和管理。</li><li>适用于需要对单个资源进行精细访问控制的情况。</li><li>多数操作系统和文件系统都原生支持ACL。</li></ul><p><strong>劣势</strong>：</p><ul><li>对于需要大量权限变更的环境，维护ACL可能会变得繁琐。</li><li>对于每个资源，都需要独立设置和维护权限，难以批量操作。</li></ul><p>总的来说，CL提供了一种以用户或进程为中心的权限管理方式，而ACL则是以资源为中心的权限管理方式。在实现安全策略时，选择哪一种机制取决于特定的应用场景、安全需求以及管理复杂性的考虑。</p><h3 id="常见的强制访问控制模型：Bell-LaPadula、BIBA-原理、优缺点及其应用"><a href="#常见的强制访问控制模型：Bell-LaPadula、BIBA-原理、优缺点及其应用" class="headerlink" title="常见的强制访问控制模型：Bell-LaPadula、BIBA 原理、优缺点及其应用"></a>常见的强制访问控制模型：Bell-LaPadula、BIBA 原理、优缺点及其应用</h3><p>Bell-LaPadula和Biba模型都是传统的访问控制模型，旨在保护信息系统的安全。这两个模型是为了不同的安全目标而设计的，分别关注保密性和完整性。</p><h3 id="Bell-LaPadula模型"><a href="#Bell-LaPadula模型" class="headerlink" title="Bell-LaPadula模型"></a>Bell-LaPadula模型</h3><p><strong>原理</strong>:<br>Bell-LaPadula模型是第一个用于计算机安全性的形式数学模型，主要关注保护数据的保密性。它是在军事和政府环境中应对机密信息泄露问题而创建的。Bell-LaPadula模型通过以下两个核心规则来实现保密性目标：</p><ol><li><p><strong>简单安全性属性（Simple Security Property，也称为”no read up”，NRU）</strong>:<br>用户不得读取高于其安全级别的数据，防止泄露敏感信息。</p></li><li><p><strong>星形安全性属性（Star Property，也称为”no write down”，NWD）</strong>:<br>用户不得写入低于其安全级别的数据，防止敏感信息流向较低安全级别。</p><p>BLP 保密模型基于两种规则来保障数据的机密度与敏感度：</p><p>➢ 不上读（NRU）⎯⎯主体不可读安全级别高于它的数据</p><p>➢ 不下写（NWD）⎯⎯主体不可写安全级别低于它的数据</p></li></ol><p><strong>优点</strong>:</p><ul><li>提供了明确的安全性规则，易于实施在需要严格访问控制的环境中。</li><li>对于保密性要求非常严格的系统，如军事或政府秘密项目，模型提供了坚实的理论基础。</li></ul><p><strong>缺点</strong>:</p><ul><li>过分强调安全性，可能会限制信息的合法共享和灵活性。</li><li>不处理数据完整性和可用性问题。</li></ul><p><strong>应用</strong>:<br>Bell-LaPadula模型主要适用于需要严格保密性控制的环境，例如军事、情报和政府部门的高安全级别系统。</p><h3 id="Biba模型"><a href="#Biba模型" class="headerlink" title="Biba模型"></a>Biba模型</h3><p><strong>原理</strong>:<br>Biba模型是另一种经典的安全性模型，它的设计目的是保护数据的完整性，防止未授权的信息修改。它通过以下两个主要的规则来实施：</p><ol><li><p><strong>简单完整性属性（Simple Integrity Property，也称为”no write up”，NWU）</strong>:<br>用户不得写入高于其安全级别的数据，防止将错误或低质量的信息传递到更高的完整性级别。</p></li><li><p><strong>星形完整性属性（Star Property，也称为”no read down”，NRD）</strong>:<br>用户不得读取低于其安全级别的数据，以免受到低质量数据的影响。</p><p>BIBA模型基于两种规则来保障数据的完整性的保密性：</p><p>➢ <strong>不下读（NRU）属性主体不能读取安全级别低于它的数据</strong></p><p>➢<strong>不上写（NWD）属性主体不能写入安全级别高于它的数据</strong></p></li></ol><p><strong>优点</strong>:</p><ul><li>强调了数据的完整性和一致性。</li><li>适用于需要保持数据不变性和准确性的应用场景。</li></ul><p><strong>缺点</strong>:</p><ul><li>与Bell-LaPadula模型类似，Biba也不处理系统的可用性问题。</li><li>在实际中可能会限制数据的正常使用和共享。</li></ul><p><strong>应用</strong>:<br>Biba模型适用于那些对数据完整性要求极高的场所，如银行系统、医疗记录系统和任何需要确保数据不被未经授权篡改的环境。</p><p>总的来说，Bell-LaPadula模型和Biba模型各自针对信息系统安全的不同方面提供了理论框架和保护措施。然而，它们在现代信息系统中的应用可能受限于其在灵活性和完整性（Bell-LaPadula）或保密性（Biba）方面的局限性。实际应用中，可能需要结合其他模型和策略，如Clark-Wilson模型（数据完整性和商业决策的正确性）或角色基访问控制（RBAC）模型（基于用户角色的权限分配），以满足现代信息系统的多样性安全需求。</p><p>从这两个属性来看，BIBA与BLP模型的两个属性是相反的：</p><p>➢ BLP模型提供保密性；</p><p>➢ BIBA模型对于数据的完整性提供保障。</p><h3 id="安全策略如何应用到防火墙等安全设备中"><a href="#安全策略如何应用到防火墙等安全设备中" class="headerlink" title="安全策略如何应用到防火墙等安全设备中"></a>安全策略如何应用到防火墙等安全设备中</h3><p><strong>Internet</strong>上用户的安全级别为“公开”，依照<strong>BIBA</strong>模型，Web服务器上数据的完整性将得</p><p>到保障，<strong>Internet</strong>上的用户只能读取服务器上的数据而不能更改它。因此，任何<strong>POST</strong>操作</p><p>将被拒绝。</p><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231220191040383.png" alt="image-20231220191040383"></p><h2 id="信息系统的风险评估-1"><a href="#信息系统的风险评估-1" class="headerlink" title="信息系统的风险评估"></a>信息系统的风险评估</h2><h3 id="风险处置策略"><a href="#风险处置策略" class="headerlink" title="风险处置策略"></a>风险处置策略</h3><p><strong>降低风险（Reduce Risk）</strong></p><p>采取适当的控制措施来降低风险，包括技术手段和管理手段，如安装防火墙，</p><p>杀毒软件，或是改善不规范的工作流程、制定业务连续性计划，等等。</p><p><strong>避免风险（Avoid Risk）</strong></p><p>通过消除可能导致风险发生的条件来避免风险的发生，如将公司内外网隔离</p><p>以避免来自互联网的攻击，或是将机房安置在不可能造成水患的位置，等等。</p><p><strong>转移风险（Transfer Risk)</strong></p><p>将风险全部或者部分地转移到其他责任方，例如购买商业保险。</p><p><strong>接受风险（Accept Risk）</strong></p><p>在实施了其他风险应对措施之后，对于残留的风险，可以有意识地选择接受。</p><h3 id="信息系统安全风险计算模型"><a href="#信息系统安全风险计算模型" class="headerlink" title="信息系统安全风险计算模型"></a>信息系统安全风险计算模型</h3><p>风险计算模型是对通过风险分析计算风险值过程的抽象，它主要包括资产评估、威胁评估、脆弱性评估。</p><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231220192309588.png" alt="image-20231220192309588"><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231220192334775.png" alt="image-20231220192334775"><em><strong>*资产等级计算公式*</strong></em></p><p>AV&#x3D;F(AC, AI, AA)</p><p>Asset Value 资产价值</p><p>Asset Confidentiality 资产保密性赋值</p><p>Asset Integrity 资产完整性赋值</p><p>Asset Availability 资产可用性赋值</p><p>例1：AV&#x3D;MAX(AC, AI, AA)</p><p>例2：AV&#x3D;AC+AI+AA</p><p>例3：AV&#x3D;AC×AI×AA</p><h4 id="威胁来源列表"><a href="#威胁来源列表" class="headerlink" title="*威胁来源列表*"></a><em><strong>*威胁来源列表*</strong></em></h4><table><thead><tr><th>来源</th><th></th><th>描述</th></tr></thead><tbody><tr><td>环境因素</td><td></td><td>断电、静电、灰尘、潮湿、温度、鼠蚁虫害、电磁干扰、洪灾、火灾、地震、意外 事故等环境危害或自然灾害，以及软件、硬件、数据、通信线路等方面的故障</td></tr><tr><td>人为因素</td><td>恶意人员</td><td>不满的或有预谋的内部人员对信息系统进行恶意破坏；</td></tr><tr><td>采用自主或内外勾结的方式盗窃机密信息或进行篡改，获取利益外部人员利用信息系统的脆弱性,对网络或系统的机密性、完整性和可用性进行破坏，以获取利益或炫耀能力</td><td></td><td></td></tr><tr><td>人为因素</td><td>非恶意人员</td><td>内部人员由于缺乏责任心，或者由于不关心和不专注，或者没有遵循规章制度和操作流程而导致故障或信息损坏；</td></tr><tr><td>内部人员由于缺乏培训、专业技能不足、不具备岗 位技能要求而导致信息系统故障或被攻击</td><td></td><td></td></tr></tbody></table><h4 id="风险计算方法"><a href="#风险计算方法" class="headerlink" title="风险计算方法"></a><strong>风险计算方法</strong></h4><p>$$风险值&#x3D;R(A, T, V) &#x3D; R(L(T, V), F(Ia,Va))$$</p><p><strong>R</strong>安全风险计算函数</p><p><strong>A</strong>资产</p><p><strong>T</strong>威胁</p><p><strong>V</strong>脆弱性</p><p><strong>Ia</strong>安全事件所作用的资产价值</p><p><strong>Va</strong> 脆弱性严重程度</p><p><strong>L</strong>威胁利用资产的脆弱性导致安全事件发生的可能性</p><p><strong>F</strong>安全事件发生后产生的损失</p><h2 id="信息系统等级保护-1"><a href="#信息系统等级保护-1" class="headerlink" title="信息系统等级保护"></a>信息系统等级保护</h2><h3 id="等级保护主要工作流程，定级的流程，备案的流程，备案地点"><a href="#等级保护主要工作流程，定级的流程，备案的流程，备案地点" class="headerlink" title="等级保护主要工作流程，定级的流程，备案的流程，备案地点"></a>等级保护主要工作流程，定级的流程，备案的流程，备案地点</h3><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231220213058592.png" alt="image-20231220213058592"></p><h4 id="等级保护主要工作流程"><a href="#等级保护主要工作流程" class="headerlink" title="*等级保护主要工作流程*"></a><em><strong>*等级保护主要工作流程*</strong></em></h4><p>1 <strong>定级  定级是等级保护的首要环节</strong></p><p>2 <strong>备案 备案是等级保护的核心</strong></p><p>3 <strong>建设整改 建设整改是等级保护工作落实的关键</strong></p><p>4 <strong>等级测评 等级测评是评价安全保护状况的方法</strong></p><h4 id="定级流程"><a href="#定级流程" class="headerlink" title="定级流程"></a><strong>定级流程</strong></h4><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231220213206332.png" alt="image-20231220213206332"></p><h4 id="备案的流程"><a href="#备案的流程" class="headerlink" title="备案的流程"></a><strong>备案的流程</strong></h4><p>运营、使用单位在确定等级后到所在地的市级及以上公安机关备案。</p><p>• 新建二级及以上信息系统在投入运营后30日内、已运行的二级及以上信息系统在等级确定30日内备案。</p><p>• 公安机关对信息系统备案情况进行审核，对符合要求的在10个工作日内颁发等级保护备案证明。</p><p>• 对于定级不准的，应当重新定级、重新备案。对于重新定级的，公安机关一般会建议备案单位组织专家进行重新定级评审，并报上级主管部门审批。</p><h4 id="备案地点"><a href="#备案地点" class="headerlink" title="备案地点"></a><strong>备案地点</strong></h4><p><strong>二级以上信息系统</strong></p><p>由信息系统运营使用单位(备案单位)到地市级以上公安机关网络安全保卫部门办理备案手续，填写《信息系统安全等级保护备案表》 。</p><p><strong>隶属于省级的备案单位</strong></p><p>其跨地（市）联网运行的信息系统，由省级公安机关网络安全保卫部门受理备案</p><p><strong>隶属于中央的在京单位</strong></p><p>其跨省或者全国统一联网运行并由主管部门统一定级的信息系统，由主管部门向公安部备案。</p><p><strong>跨省或者全国统一联网运行的信息系统</strong></p><p>在各地运行、应用的分支系统，由所在地地市级以上公安机关网络安全保卫部门受理备案。</p><p><strong>各部委统一定级信息系统在各地的分支系统</strong></p><p>即使是上级主管部门定级的，也要到当地公安网络安全保卫部门备案。</p><h3 id="等级保护主要工作：定级备案，建设整改，等级测评，监督检查"><a href="#等级保护主要工作：定级备案，建设整改，等级测评，监督检查" class="headerlink" title="等级保护主要工作：定级备案，建设整改，等级测评，监督检查"></a>等级保护主要工作：定级备案，建设整改，等级测评，监督检查</h3><p>等级保护制度是针对信息系统安全的一系列规定和措施，旨在确保信息系统达到一定的安全保护等级。这个制度通常涵盖了信息系统的定级备案、建设整改、等级测评和监督检查等主要工作。接下来，我会逐一详细介绍这些工作。</p><h4 id="1-定级备案"><a href="#1-定级备案" class="headerlink" title="1. 定级备案"></a>1. 定级备案</h4><p>在定级备案阶段，信息系统的管理者或者所有者需要对系统进行安全等级的划分。这个过程包括：</p><ul><li><strong>安全等级的划分</strong>：依据信息系统的业务特点和安全需求，以及系统可能面临的安全威胁，将系统分类到不同的安全等级中。</li><li><strong>风险评估</strong>：对系统可能受到的各种威胁和脆弱性进行评估，以确定系统应达到的安全保护等级。</li><li><strong>文件备案</strong>：将信息系统的安全等级和相关的风险评估结果报告给相关的监管机构，进行备案。</li></ul><h4 id="2-建设整改"><a href="#2-建设整改" class="headerlink" title="2. 建设整改"></a>2. 建设整改</h4><p>一旦完成了系统的定级工作，接下来就是根据评定的安全等级来进行系统的安全建设或者整改。这个阶段的工作包括：</p><ul><li><strong>安全措施的落实</strong>：根据信息系统的安全等级，实施必要的安全保护措施，如物理安全、网络安全、主机安全、应用安全、数据安全和紧急响应等。</li><li><strong>制定安全管理制度</strong>：包括安全操作规程、安全事件处理流程、用户管理规定等。</li><li><strong>人员培训</strong>：对管理人员、操作人员进行安全意识和技能培训，确保相关人员能够理解和遵守安全规程。</li><li><strong>系统整改</strong>：针对安全评估中发现的问题，进行必要的技术整改和管理整改。</li></ul><h4 id="3-等级测评"><a href="#3-等级测评" class="headerlink" title="3. 等级测评"></a>3. 等级测评</h4><p>等级测评是对信息系统实施的安全保护措施进行评价的过程，以确保这些措施能够满足既定的安全需求。这个阶段包括：</p><ul><li><strong>安全测评</strong>：通过内部检查或者聘请外部专业机构来进行系统的安全测评。</li><li><strong>评估报告</strong>：生成测评报告，其中详细说明测评过程、发现的问题以及改进建议。</li><li><strong>整改落实</strong>：根据测评报告中的建议，对系统进行进一步的整改。</li></ul><h4 id="4-监督检查"><a href="#4-监督检查" class="headerlink" title="4. 监督检查"></a>4. 监督检查</h4><p>为了确保信息系统安全保护措施的持续有效，需要进行定期的监督检查。这包括：</p><ul><li><strong>定期审计</strong>：定期对系统的安全状况进行审计，确保持续遵守安全规程和政策。</li><li><strong>监督检查</strong>：监管机构可能会定期进行监督检查，以确保信息系统的安全保护措施得到有效实施。</li><li><strong>连续监控</strong>：实施实时监控系统，以便对安全事件做出快速响应。</li></ul><p>等级保护工作要求信息系统的所有者、管理者和使用者共同参与，它是一个持续的过程，需要随着威胁环境和技术的发展而不断调整和完善。在不同国家和地区，等级保护的具体实施标准和流程可能会有所不同，但上述介绍的核心内容通常是普遍适用的。</p><h2 id="信息系统的物理安全-1"><a href="#信息系统的物理安全-1" class="headerlink" title="信息系统的物理安全"></a>信息系统的物理安全</h2><h3 id="环境安全：机房的三度要求，常见的消防设计、防盗措施等"><a href="#环境安全：机房的三度要求，常见的消防设计、防盗措施等" class="headerlink" title="环境安全：机房的三度要求，常见的消防设计、防盗措施等"></a>环境安全：机房的三度要求，常见的消防设计、防盗措施等</h3><p>温度、湿度和洁净度并称为三度，为保证计算机网络系统的正常运行，对机房内的三度都有明确的要求。为使机房内的三度达到规定的要求，空调系统、去湿机、除尘器是必不可少的设备。重要的计算机系统安放处还应配备专用的空调系统，它比公用的空调系统在加湿、除尘等方面有更高的要求</p><p><strong>温度：机房温度一般应控制在18～22℃</strong></p><p><strong>湿度：相对湿度一般控制在40％～60％为宜</strong></p><p><strong>洁净度：尘埃颗粒直径&lt;0.5微米，含尘量&lt;1万颗&#x2F;升</strong></p><p>《七氟丙烷（HFC-227ea）洁净气体灭火系统设计规范》</p><p><strong>机房防盗要求</strong></p><p>视频监视系统是一种更为可靠的防盗设备，能对计算机网络系统的外围环境、操作环境进行实时全程监控。对重要的机房，还应采取特别的防盗措施，如值班守卫、出入口安装金属探测装置等。</p><p>在需要保护的重要设备、存储媒体和硬件上贴上特殊标签（如磁性标签），当有人非法携带这些重要设备或物品外出时，检测器就会发出报警信号。</p><p>将每台重要的设备通过光纤电缆串接起来，并使光束沿光纤传输，如果光束传输受阻，则自动报警</p><h3 id="供电安全：GB-T-2887-2000-规定的三类供电方式，电源防护措施，接地与防雷要求"><a href="#供电安全：GB-T-2887-2000-规定的三类供电方式，电源防护措施，接地与防雷要求" class="headerlink" title="供电安全：GB&#x2F;T 2887-2000 规定的三类供电方式，电源防护措施，接地与防雷要求"></a>供电安全：GB&#x2F;T 2887-2000 规定的三类供电方式，电源防护措施，接地与防雷要求</h3><p><strong>GB&#x2F;T 2887-2000将供电方式分为三类</strong></p><p>一类供电 需要建立不间断供电系统。兵工厂、大型钢厂、火箭发射基地、医院等.</p><p>二类供电 需要建立带备用的供电系统。</p><p>三类供电 按一般用户供电考虑。</p><p><strong>电源防护措施</strong></p><p>不间断电源</p><p>电源相关操作</p><p>​系统接地、正确开关机、电缆连接和卡的插拔、电源要匹配</p><p>电源调整器</p><p><strong>接地可以为计算机系统的数字电路提供一个稳定的0V参考电位</strong></p><h3 id="电磁泄漏产生的原理、电磁泄漏的途径及防护方法"><a href="#电磁泄漏产生的原理、电磁泄漏的途径及防护方法" class="headerlink" title="电磁泄漏产生的原理、电磁泄漏的途径及防护方法"></a>电磁泄漏产生的原理、电磁泄漏的途径及防护方法</h3><p>电磁泄漏指电子设备的杂散电磁能量通过导线或空间向外扩散。</p><p>任何处于工作状态的电磁信息设备，如计算机、打印机、复印机、传真机、手机电话等，都存在不同程度的电磁泄漏问题，这是无法摆脱的电磁现象。</p><p>如果这些泄漏“夹带”着设备所处理的信息，均可构成了电磁信息泄漏。</p><p><strong>电磁泄漏的途径</strong></p><p>以电磁波形式的辐射泄漏</p><p>电源线、控制线、信号线和地线造成的传导泄漏</p><p><strong>铜网式屏蔽室</strong></p><p>用于电子设备防电磁干扰、高频医疗设备、雷达产品实验测试等计量检测场所。</p><h2 id="信息系统的可靠性-1"><a href="#信息系统的可靠性-1" class="headerlink" title="信息系统的可靠性"></a>信息系统的可靠性</h2><h3 id="失效率的规律，失效率、寿命、可靠度三者之间关系的推导"><a href="#失效率的规律，失效率、寿命、可靠度三者之间关系的推导" class="headerlink" title="失效率的规律，失效率、寿命、可靠度三者之间关系的推导"></a>失效率的规律，失效率、寿命、可靠度三者之间关系的推导</h3><p>失效率（Failure Rate）、寿命（Lifetime）和可靠度（Reliability）是评估产品或系统性能的三个关键指标，并且它们之间存在一定的数学关系。下面是简要推导这些指标之间关系的过程。</p><h3 id="失效率（λ）"><a href="#失效率（λ）" class="headerlink" title="失效率（λ）"></a>失效率（λ）</h3><p>失效率通常表示为单位时间内的故障次数的期望值，通常使用“每小时故障数”（Failures per Hour）来表示。对于许多产品来说，失效率随时间的变化而变化，并且可以通过失效密度函数（failure density function）f(t)来描述。</p><h3 id="寿命（L）"><a href="#寿命（L）" class="headerlink" title="寿命（L）"></a>寿命（L）</h3><p>寿命通常是指产品或系统正常工作直到发生第一次故障所经历的时间。平均寿命可以通过失效率函数λ(t)来计算，如果λ(t)是恒定的，那么平均寿命就是失效率的倒数（1&#x2F;λ）。</p><h3 id="可靠度（R-t-）"><a href="#可靠度（R-t-）" class="headerlink" title="可靠度（R(t)）"></a>可靠度（R(t)）</h3><p>可靠度是指在特定时间t内系统或产品无故障正常工作的概率。它可以通过失效密度函数f(t)和可靠度函数R(t)来描述。可靠度函数是一个从零时刻开始到时间t的累积分布函数（CDF）的补，即：</p><p>$$ R(t) &#x3D; 1 - F(t) $$</p><p>其中，F(t)是累积分布函数，表示在时间t之前发生故障的概率。F(t)可以通过失效密度函数f(t)积分得到：</p><p>$$ F(t) &#x3D; \int_0^t f(x) dx $$</p><p>因此，可靠度R(t)也可以通过积分失效率λ(t)来表示：</p><p> $$R(t) &#x3D; e^{-\int_0^t \lambda(x) dx} $$</p><p>如果失效率是常数λ（即系统处于稳态失效率），则上述关系简化为：</p><p>$$ R(t) &#x3D; e^{-\lambda t} $$</p><p>所以，如果你知道了系统的失效率，你就可以计算出在任何给定时间t的可靠度。反过来，如果你知道了系统的可靠度函数，你也可以求出平均寿命（即平均无故障工作时间，MTTF），它是失效密度函数f(t)的期望值：</p><p>$$ MTTF &#x3D; \int_0^{\infty} t f(t) dt $$</p><p>对于恒定失效率的情况，MTTF简化为失效率的倒数：</p><p>$$MTTF &#x3D; \frac{1}{\lambda}$$</p><p>这些关系和推导基于对失效率和可靠度的连续时间分析。在实际应用中，失效率可能会随时间变化，例如对于新产品可能会遵循所谓的“浴盆曲线”（先下降后上升）。在这种情况下，以上简化的公式可能不适用，需要更复杂的模型来描述失效率随时间的变化。</p><h3 id="可靠性模型：串联，并联模型的寿命、可靠度推导"><a href="#可靠性模型：串联，并联模型的寿命、可靠度推导" class="headerlink" title="可靠性模型：串联，并联模型的寿命、可靠度推导"></a>可靠性模型：串联，并联模型的寿命、可靠度推导</h3><h4 id="串联系统"><a href="#串联系统" class="headerlink" title="*串联系统*"></a><em><strong>*串联系统*</strong></em></h4><p>假设第<em>i</em>个部件的寿命为$X_i$，可靠度为$<em>R_i(t)&#x3D;P{X_i &gt;t}，i&#x3D;1, 2, …,n,</em>$第$<em>i</em>$个部件的失效率为$<em>\lambda_i(t)</em>$$，X_1，X_2 ，…，X_n$相互独立。若</p><p>初始时刻$<em>t&#x3D;0</em>$，所有部件都是新的，且同时开始工作。</p><p>(1) 系统的寿命是： $X&#x3D;min{X_1 ，X_2，…，X_n}$</p><p>(2) 系统的可靠度是：</p><p>$$ R(t)&#x3D;P{min(X_1 ，X_2，…，X_n)&gt;t}&#x3D;\Pi^n_{i&#x3D;1}R_i(t)\ &#x3D;\Pi^n_{i&#x3D;1}exp{-\int^t_0\lambda_i(u)du} $$</p><p>(3) 系统的失效率为：</p><p>$$ \lambda(t)&#x3D;-\frac{R’(t)}{R(t)}&#x3D;\sum^n_{i&#x3D;1}\lambda_i(t) $$</p><p>(4) 系统的平均寿命为:</p><p>$$ MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\int^\infty_0exp{-\int^t_0\lambda(u)du}dt $$</p><p>当$R_i(t)&#x3D;exp{-\lambda_t}，i&#x3D;1, 2, …, n$时（及当第<em>i</em>个部件的命遵从参数为$<em>\lambda_i</em>$的</p><p>指数分布时），系统的可靠度和平均寿命为</p><p>$$ R(t)&#x3D;exp{-\sum^n_{i&#x3D;1}\lambda_it}\ MTTF&#x3D;\frac{1}{\sum^n_{i&#x3D;1}\lambda_i} $$</p><h4 id="并联系统"><a href="#并联系统" class="headerlink" title="*并联系统*"></a><em><strong>*并联系统*</strong></em></h4><p>(1) 系统的寿命是： $X&#x3D;max{X_1，X_2，…，X_n }$</p><p>(2) 系统的可靠度是：</p><p>$$ R(t)&#x3D;P{max(X_1 ，X_2，…，X_n)&gt;t}\ &#x3D;1-P{max(X_1 ，X_2，…，X_n)\le t } \ &#x3D;1-\Pi^n_{i&#x3D;1}[1-R_i(t)] $$</p><p>(3) 系统的平均寿命为：</p><p>$$ MTTF&#x3D;\int^\infty_0R(t)dt&#x3D;\sum^n_{i&#x3D;1}\frac{1}{\lambda_i}\ &#x3D;sum_{1\le&lt;i&lt;j\le n}\frac{1}{\lambda_1+\lambda_j}+…+(-1)^{n-1}\frac{1}{\lambda_1+…+\lambda_n} $$</p><h3 id="硬件可靠性和软件可靠性的不同"><a href="#硬件可靠性和软件可靠性的不同" class="headerlink" title="硬件可靠性和软件可靠性的不同"></a>硬件可靠性和软件可靠性的不同</h3><p>硬件可靠性和软件可靠性在概念上有一些基本的差异，这些差异主要反映了它们的固有属性和它们出错的本质。</p><h4 id="硬件可靠性"><a href="#硬件可靠性" class="headerlink" title="硬件可靠性"></a>硬件可靠性</h4><ol><li><strong>物理耗损</strong>：硬件可靠性受到物理组件老化和环境条件（如温度、湿度、机械应力等）的影响，这些因素会导致硬件随时间而退化。</li><li><strong>失效率</strong>：硬件的失效率可以通过“浴盆曲线”来描述，即开始时有较高的初期故障率（新品早期失效），然后进入一段低故障率的稳定期（有用寿命期），最后由于磨损和老化进入失效率上升的磨损期。</li><li><strong>可预测性</strong>：许多硬件故障是可以预测的，通过定期维护和替换部件可以预防。</li><li><strong>冗余设计</strong>：硬件系统经常通过冗余组件来提高可靠性，如RAID系统中的多硬盘冗余，电源和冷却系统的冗余配置等。</li><li><strong>测试与质量控制</strong>：硬件的质量可以在生产时通过物理测试来控制和保证。</li></ol><h4 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h4><ol><li><strong>设计和逻辑错误</strong>：软件故障通常是由设计不当、编程错误、逻辑漏洞等原因引起的，与物理磨损无关。</li><li><strong>失效行为</strong>：软件的失效率不遵循物理磨损的模式，软件不会因为时间推移而衰老，但软件的失效通常是由于不断发现的新错误或者在新环境中的不适应。</li><li><strong>不确定性和复杂性</strong>：软件系统经常涉及复杂的交互和非确定性的行为，这使得确保软件可靠性成为一项挑战。</li><li><strong>更新和补丁</strong>：软件通过更新和补丁程序来修正已知错误，因此，软件的可靠性可以通过软件更新来提高。</li><li><strong>测试的限制</strong>：由于软件的复杂性和使用情境的多样性，不可能测试软件的所有可能路径，因此总有未知错误的可能性。</li></ol><h4 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h4><ul><li><strong>稳态和动态行为</strong>：硬件通常在一定条件下具有稳定的行为，而软件则更多表现出动态和多变的行为。</li><li><strong>故障模式</strong>：硬件故障通常是随机的，而软件故障则是系统性的，一旦触发了软件中的某个错误，通常它总是在相同的条件下发生。</li><li><strong>修复方式</strong>：硬件故障的修复可能包括更换或修理物理组件，而软件故障的修复通常是修改代码或配置。</li></ul><p>总的来说，虽然两者都关注于减少故障并提高系统的整体可靠性，但由于硬件和软件在本质上有所不同，它们的可靠性策略和实施方法也不相同。硬件可靠性更多关注于物理特性和冗余设计，而软件可靠性则更侧重于设计、测试和持续的维护。</p><h3 id="软件的四种常见的可靠性模型及其主要思想"><a href="#软件的四种常见的可靠性模型及其主要思想" class="headerlink" title="软件的四种常见的可靠性模型及其主要思想"></a>软件的四种常见的可靠性模型及其主要思想</h3><p><strong>失效时间间隔模型</strong></p><p>这类模型最常用的方法是假定第i个失效到第i+1个失效间隔时间服从某一分布，而分布的参数依赖于各间隔时间内程序中的残留错误数。通过测试所得到的失效间隔时间数据来估计模型的参数，由获得的模型可以估算软件的可靠度以及各失效间的平均工作时间等；</p><p>另一种方法是把失效间隔时间看作随机过程，然后通过适当的时间序列模型来分析和描述软件的失效过程。这类模型有Jelinski-Moranda的非增长模型 、 Schick-Wolverton 模 型 、 Littlewood-Verrall 的 贝 叶 斯 模 型 和 GoelOkumoto的不完善模型等。</p><p><strong>缺陷计数模型</strong></p><p>这类模型关心的是在特定的时间间隔内软件的错误数或失效数，并假定故障累计数服从某个己知的随机过程，过程强度是时间的离散或连续函数，根据在给定的测试时间间隔发现的错误数或失效数来估计故障强度、均值等参数。随着错误的不断排除，在单位时间内发现的失效数将不断减少。当时间间隔事先确定时，在每个间隔时间内的失效次数就是随机变量。这类模型有Shooman模型、Musa的执行时间模型、Goel-Okumoto的NHPP模型、Goel的NHPP 模型和Musa-Okumoto的对数泊淞执行时间模型等等。</p><p><strong>基于输入域错误</strong></p><p>这类模型的基本思路是通过将一组已知的错误人为地植入到一个固有错误总数尚不清楚的程序中，然后在程序的测试中观察并统计发现的植入错误数和程序总的错误数，通过计数的比值估计程序的固有错误总数，从而得到软件可靠度及其有关指标。这类模型的代表是Mills的超几何分布模型。</p><p><strong>植入模型的模型</strong></p><p>这类模型的基本研究方法是根据程序的使用情况，找出程序可能输入的概率分布，根据这种分布产生一个测试用例的集合。由于得到输入的分布难度较大，一般将输入域划分成等价类，每个等价类与程序的一条执行路径相联。在输入域上随机抽取测试用例，执行相应的程序测试，观测故障，从而推断出各项指标。这类模型以Nelson模型为代表，还有Brown-Lipow的基于输入域模型和Ramamoorthy-Bastani的基于输入域模型。</p><h3 id="冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的-N-Version-Programming-和-Recovery-Block-的对比"><a href="#冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的-N-Version-Programming-和-Recovery-Block-的对比" class="headerlink" title="冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的 N-Version Programming 和 Recovery Block 的对比"></a>冗余技术：时间冗余，信息冗余，硬件冗余，软件冗余，三模冗余（硬件冗余）原理及优缺点，软件冗余技术的 N-Version Programming 和 Recovery Block 的对比</h3><p>冗余是提高可靠性、可用性和系统鲁棒性的一种技术，通常通过在系统中加入额外的信息或组件来实现。不同类型的冗余有着不同的实现原理和相应的优缺点。</p><h4 id="时间冗余（Time-Redundancy）"><a href="#时间冗余（Time-Redundancy）" class="headerlink" title="时间冗余（Time Redundancy）"></a>时间冗余（Time Redundancy）</h4><p><strong>原理：</strong> 时间冗余通过在系统中多次执行同一操作来提高可靠性。如果第一次执行产生了错误，系统可以回滚到一个已知的良好状态，并重新执行该操作。</p><p><strong>优点：</strong></p><ul><li>不需要额外的硬件，节约成本。</li><li>可以动态应对偶发性错误。</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的响应时间，降低了性能。</li><li>对于持续性错误无效，如由设计缺陷引起的软件错误。</li></ul><h4 id="信息冗余（Information-Redundancy）"><a href="#信息冗余（Information-Redundancy）" class="headerlink" title="信息冗余（Information Redundancy）"></a>信息冗余（Information Redundancy）</h4><p><strong>原理：</strong> 信息冗余利用额外的数据位（如校验位、奇偶校验、校验和、Hamming码等）来检测和&#x2F;或纠正错误。这在数据传输和存储系统中非常常见。</p><p><strong>优点：</strong></p><ul><li>能够检测或修正数据中的错误，提高数据完整性。</li><li>适用于数据通信和存储操作。</li></ul><p><strong>缺点：</strong></p><ul><li>需要额外的存储空间或带宽。</li><li>复杂的纠错码可能需要额外的计算资源。</li></ul><h4 id="硬件冗余（Hardware-Redundancy）"><a href="#硬件冗余（Hardware-Redundancy）" class="headerlink" title="硬件冗余（Hardware Redundancy）"></a>硬件冗余（Hardware Redundancy）</h4><p><strong>原理：</strong> 硬件冗余通过增加备用的物理组件（如备用服务器、电源、网络连接等）来提高系统可靠性。当一个组件失败时，备用组件可以接管其功能。</p><p><strong>优点：</strong></p><ul><li>提供即时的故障切换，提高系统的可用性。</li><li>增加的组件可以在检测到故障时即刻接管，减少了系统停机时间。</li></ul><p><strong>缺点：</strong></p><ul><li>成本高昂，因为需要购买额外的硬件设备。</li><li>物理空间要求可能增加。</li></ul><h4 id="软件冗余（Software-Redundancy）"><a href="#软件冗余（Software-Redundancy）" class="headerlink" title="软件冗余（Software Redundancy）"></a>软件冗余（Software Redundancy）</h4><p><strong>原理：</strong> 软件冗余通常指的是运行多个软件副本或使用不同算法实现相同功能，以便在一个副本失败时另一个可以接管。</p><p><strong>优点：</strong></p><ul><li>可以在不更改硬件的情况下增加可靠性。</li><li>能够应对软件缺陷和系统性错误。</li></ul><p><strong>缺点：</strong></p><ul><li>如果所有软件副本含有相同的缺陷，那么冗余可能无效。</li><li>对资源的需求增加（如内存和CPU时间）。</li></ul><h4 id="三模冗余（TMR-Triple-Modular-Redundancy）"><a href="#三模冗余（TMR-Triple-Modular-Redundancy）" class="headerlink" title="三模冗余（TMR, Triple Modular Redundancy）"></a>三模冗余（TMR, Triple Modular Redundancy）</h4><p><strong>原理：</strong> TMR是一种特殊类型的硬件冗余，它涉及三个相同的系统或组件并行工作，并通过表决逻辑来确定最终输出。如果一个组件故障，另外两个正确的输出可以通过多数表决得出正确的结果。</p><p><strong>优点：</strong></p><ul><li>可以容忍单个组件的故障而不影响整体系统。</li><li>提供了自动故障检测和修正能力。</li></ul><p><strong>缺点：</strong></p><ul><li>高昂的成本，因为需要三倍的硬件。</li><li>如果两个组件同时失败，系统可能无法正确决策。</li></ul><p>冗余的应用需根据系统要求、环境、故障模型以及成本效益分析来选择。在实际应用中，经常会组合使用不同类型的冗余策略来达到最佳的可靠性和成本效益平衡。</p><p><strong>“N-Version Programming”（N版本编程）和”Recovery Block”（恢复块）</strong>是两种不同的软件冗余技术，它们的目的都是为了提供容错能力并提高软件的可靠性。尽管目标类似，但它们的设计哲学、实现方式和适用场景有所不同。</p><h4 id="N版本编程（N-Version-Programming）"><a href="#N版本编程（N-Version-Programming）" class="headerlink" title="N版本编程（N-Version Programming）"></a>N版本编程（N-Version Programming）</h4><p><strong>原理：</strong></p><ul><li>N版本编程是通过独立地开发多个软件版本（称为“版本”），这些版本由不同的团队使用不同的工具和技术开发，以实现相同的规格和功能。</li><li>运行时，所有版本并行运行，它们的输出通过一个投票系统来决定最终结果。</li></ul><p><strong>优点：</strong></p><ul><li>提高了可靠性，因为不太可能所有版本都会在相同的输入下失败。</li><li>由于各个版本是独立开发的，它们可能会有不同的错误模式，从而降低全局故障的风险。</li></ul><p><strong>缺点：</strong></p><ul><li>成本高昂，需要多组开发团队和多倍的开发资源。</li><li>如果所有版本遵循相同的错误规格或理解，错误可能会在所有版本中重现。</li><li>投票机制的设计和实施可能复杂且需要精确。</li></ul><h4 id="恢复块（Recovery-Block）"><a href="#恢复块（Recovery-Block）" class="headerlink" title="恢复块（Recovery Block）"></a>恢复块（Recovery Block）</h4><p><strong>原理：</strong></p><ul><li>恢复块在设计上包含了主程序块和一个或多个备用程序块。每个块都试图完成相同的任务，但是如果主程序块失败（通过某种形式的验收测试来判定），控制就会传递到备用块。</li><li>备用块按顺序执行，直到一个块通过验收测试或所有块都失败为止。</li></ul><p><strong>优点：</strong></p><ul><li>实现简单，只有在主块失败时才会尝试执行备用块，从而节约了资源。</li><li>可以在不同级别的粒度上实现，例如，可以在整个程序、单个函数或者代码段的层面上应用恢复块。</li></ul><p><strong>缺点：</strong></p><ul><li>如果验收测试不能准确地检测到所有类型的错误，那么故障可能仍会被传递下去。</li><li>需要额外的时间来执行验收测试以及在块之间切换，可能会导致性能开销。</li><li>可能会增加编程复杂性，特别是在设计验收测试时。</li></ul><p><strong>对比：</strong><br>N版本编程和恢复块两种方法在实践中有不同的适用性和效果。N版本编程更注重在不同版本间提供多样性，从而减少共同故障的可能性，但成本高昂且实现复杂。恢复块则侧重于在一个版本失败时有序地退回到备用方案，通常实现起来更简单，成本较低，但其对验收测试的依赖性较高。</p><p>选择哪种技术取决于特定应用的需求、可用资源、预期的可靠性水平以及对性能的影响。在安全关键和高可靠性需求的系统中，这些技术或它们的组合可能是提高软件容错能力的有效方法。</p><h3 id="RAID5-RAID6-的原理"><a href="#RAID5-RAID6-的原理" class="headerlink" title="RAID5&#x2F;RAID6 的原理"></a>RAID5&#x2F;RAID6 的原理</h3><p>RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列）是一种数据存储虚拟化技术，旨在提高数据存储的可靠性和性能。RAID通过将多块硬盘组合成一个或多个阵列来工作，数据被分散在这些硬盘上，以实现冗余和&#x2F;或提高速度。</p><h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><p><strong>原理：</strong></p><ul><li>RAID 5至少需要三块硬盘。它通过分布式奇偶校验来提供数据冗余。这意味着每个数据块和一个校验块被分布在不同的硬盘上。</li><li>数据和校验信息被分割成等大小的块，在所有驱动器上均匀分布。校验块由当前所有硬盘上的数据块计算得出，使用的是异或（XOR）操作。</li><li>如果一个硬盘出现故障，可以通过剩余硬盘上的数据块和校验块，使用XOR运算来重建丢失的数据。</li></ul><p><strong>优点：</strong></p><ul><li>提供了单块硬盘冗余，任何一块硬盘故障都能重建数据。</li><li>相对于RAID 1，RAID 5在使用更少的额外存储容量提供冗余的同时，还提供了良好的读取性能。</li></ul><p><strong>缺点：</strong></p><ul><li>写入性能由于要更新校验信息而受到影响。</li><li>当硬盘出现故障时，重建过程会占用大量的I&#x2F;O资源，并且在此期间，数据处于无冗余保护的状态，如果再有硬盘失败，数据会丢失。</li></ul><h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p><strong>原理：</strong></p><ul><li>RAID 6类似于RAID 5，但它使用两个独立的奇偶校验块，而不是一个。这样，RAID 6可以容忍两块硬盘同时故障而不丢失数据。</li><li>RAID 6至少需要四块硬盘。它采用了更复杂的校验算法，通常是基于两个不同的异或运算。</li><li>与RAID 5一样，数据和校验块在所有驱动器上分布。但由于有两个校验块，RAID 6在处理校验时需要更多的计算。</li></ul><p><strong>优点：</strong></p><ul><li>相比RAID 5，RAID 6提供了更高的数据冗余，能够容忍两块硬盘同时故障。</li><li>适用于大容量硬盘和大型阵列，因为这些环境中硬盘故障的概率更高。</li></ul><p><strong>缺点：</strong></p><ul><li>写入性能损失比RAID 5更大，因为需要计算和写入两个校验块。</li><li>由于额外的校验块，RAID 6牺牲了更多的存储容量。</li></ul><p><strong>总结：</strong><br>RAID 5和RAID 6都是通过在硬盘之间分配数据和校验信息来提供冗余，但它们的冗余级别和性能特点不同。RAID 5在提供冗余和性能方面做了平衡，而RAID 6则更注重在更高的冗余级别。选择哪种RAID阵列取决于用户对性能、存储效率和数据安全的具体需求。</p><h3 id="Reed-Solomon-纠删码的基本原理及其在通信和大规模数据存储中的应用"><a href="#Reed-Solomon-纠删码的基本原理及其在通信和大规模数据存储中的应用" class="headerlink" title="Reed-Solomon 纠删码的基本原理及其在通信和大规模数据存储中的应用"></a>Reed-Solomon 纠删码的基本原理及其在通信和大规模数据存储中的应用</h3><p>erasure code有很多种，其中RS code是最基本的一种。RS codes是基于 Galois Field 的一种编码算法，在RS codes中使用$$GF(2^w)$$，其中$$2^w&gt;n+m$$.</p><p>因此，对每一段的<em>n</em>份数据，我们都可以通过B * D 得到：</p><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231220235445622.png" alt="image-20231220235445622"></p><p>假如D1、D4、C2 失效，那么我们可以同时从矩阵B和B*D中，去掉响应的行，得到下面的等式</p><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231220235501565.png" alt="image-20231220235501565"><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231220235507658.png" alt="image-20231220235507658"></p><h2 id="计算机取证-1"><a href="#计算机取证-1" class="headerlink" title="计算机取证"></a>计算机取证</h2><h3 id="取证的范围"><a href="#取证的范围" class="headerlink" title="取证的范围"></a>取证的范围</h3><p>首先依据搜查令或其他授权，根据案件的细节、硬件和软件系统的性质、潜在证据以及整个获取证据现场的环境来确定哪些证据将要进行重点检查。</p><h3 id="取证过程应该遵循的原则"><a href="#取证过程应该遵循的原则" class="headerlink" title="取证过程应该遵循的原则"></a>取证过程应该遵循的原则</h3><ol><li>取证过程中不能对目标设备有任何改动，读取硬盘数据必须用“只读锁”</li><li>所有提取的文件都要经过签名，保证不被篡改</li><li>保存证据的硬盘每次使用前都要“洗盘”——清零操作（Erases）</li><li>尽可能优先提取易失性数据——内存、网络数据包等等</li><li>分析证据的工作应该在工作副本(对目标硬盘逐位、逐字节的镜像）上进行</li></ol><h3 id="取证的一般过程"><a href="#取证的一般过程" class="headerlink" title="取证的一般过程"></a>取证的一般过程</h3><ol><li>记录被检查系统的硬件和软件配置，确认被检查系统所包含的硬件和软件。</li><li>拆开被检查计算机，检查计算机的硬盘。注意：在这个过程中要注意避免静电和强磁场</li><li>确认将要收集的存储设备，这些存储设备既可能是内置的也可能是外置的，有的系统可能同时拥有这两种设备。</li><li>记录内置存储设备和硬件配置，包括：<br>驱动情况(例如，品牌、型号、尺寸、跳线、硬件接口等)<br>内部部件(例如，声卡、显卡、网卡、视频采集卡等。)</li><li>通过受控制的引导程序恢复可疑系统的配置信息</li><li>尽可能地将存储器从可疑计算机中拆卸下来，使用预先准备好的监测系统来进行证据的提取</li></ol><h3 id="常见的取证工具"><a href="#常见的取证工具" class="headerlink" title="常见的取证工具"></a>常见的取证工具</h3><p>确定系统的审核策略auditpol</p><p>转储Windows系统注册表中的特定信息（键）reg</p><p>以文本文件格式转储注册表regdump</p><p>转储SAM数据库，可破解密码pwdump6</p><p>监控成功和失败的系统登录NTLast</p><p>侦测隐藏在NTFS文件流中的文件Sfind</p><p>扫描文件系统找出在某时段内被访问过的文件Afind</p><p>转储Windows系统的事件日志Dumpel</p><h2 id="操作系统安全-1"><a href="#操作系统安全-1" class="headerlink" title="操作系统安全"></a>操作系统安全</h2><h3 id="操作系统的一般性安全机制：隔离，访问控制，审计，加密"><a href="#操作系统的一般性安全机制：隔离，访问控制，审计，加密" class="headerlink" title="操作系统的一般性安全机制：隔离，访问控制，审计，加密"></a>操作系统的一般性安全机制：隔离，访问控制，审计，加密</h3><h4 id="隔离控制"><a href="#隔离控制" class="headerlink" title="隔离控制"></a><strong>隔离控制</strong></h4><p><strong>物理隔离</strong>：例如，把不同的打印机分配给不同安全级别的用户。</p><p><strong>时间隔离：</strong>例如，以不同安全级别的程序在不同的时间使用计算机。</p><p><strong>加密隔离</strong>：例如，把文件、数据加密，使无关人员无法阅读。</p><p><strong>逻辑隔离</strong></p><p>首先要对存储单元的地址进行保护：使非法用户不能访问那些受到保护的存储单元</p><p>其次要对被保护的存储单元提供各种类型的保护：最基本的保护类型是“读&#x2F;写”和“只读”。复杂一些的保护类型还包括“只执行”、“不能存取”等操作。不能存取的存储单元，若被用户存取时，系统要及时发出警报或中断程序执行。</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a><strong>访问控制</strong></h4><p>访问控制是操作系统的安全控制核心。访问控制是确定谁能访问系统，能访问系统何种资源以及在何种程度上使用这些资源。访问控制包括对系统各种资源的存取控制</p><p><strong>身份认证、确定访问权限、实施访问控制的权限</strong></p><h4 id="安全审计"><a href="#安全审计" class="headerlink" title="安全审计"></a><strong>安全审计</strong></h4><p>要求任何影响系统安全性的行为都被跟踪和记录在案，安全系统拥有把用户标识与它被跟踪和记录的行为联系起来的能力。<br>• 审计信息必须有选择性的保留和保护，所有与安全相关的事件记录在审计日志文件中，所有审计数据必须防止受到未授权的访问、修改和破坏，以作为日后对事件调查的依据。<br>• 审计系统能记录以下事件：和标识与鉴别机制相关的事件、将客体导入用户地址空间的操作、删除客体、系统管理员执行的操作及其他与安全相关的事件。</p><h4 id="安全加密"><a href="#安全加密" class="headerlink" title="安全加密"></a>安全加密</h4><p><strong>加密机制用于安全传输</strong></p><p>一个IPSee安全策略由IP筛选器和筛选器操作两部分构成。其中IP筛选器决定哪些报文应当引起IPSee安全策略的关注，筛选器操作是指“允许”还是“拒绝”报文的通过。在Windows 2003Server系统的服务端和客户端都提供了对IPSee的支持，从而增强了安全性。</p><p><strong>加密机制用于文件安全</strong></p><p>EFS加密实际上综合了对称加密和不对称加密</p><h3 id="国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色"><a href="#国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色" class="headerlink" title="国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色"></a>国产主流操作系统相对国外主流操作系统，在安全机制设计方面有什么特色</h3><p>国产操作系统的发展主要是为了满足本国的法律法规要求、信息安全等级保护标准、以及本地化支持的需求。相对于国外的主流操作系统，国产操作系统在安全机制设计方面可能具有以下特色：</p><h4 id="1-符合本地法规"><a href="#1-符合本地法规" class="headerlink" title="1. 符合本地法规"></a>1. 符合本地法规</h4><p>国产操作系统往往更加符合本国的法律法规和政策要求，比如数据保护法、信息内容监管等，以保证操作系统及其应用的合规性。</p><h4 id="2-安全加固"><a href="#2-安全加固" class="headerlink" title="2. 安全加固"></a>2. 安全加固</h4><p>部分国产操作系统可能针对特定的安全威胁进行了加固，以应对国内网络环境中的特定安全挑战，如更高级别的身份验证、加密技术和访问控制等。</p><h4 id="3-可信计算"><a href="#3-可信计算" class="headerlink" title="3. 可信计算"></a>3. 可信计算</h4><p>为了增强系统的信任度，国产操作系统可能内置了支持可信计算的技术，包括硬件身份验证、系统完整性验证等。</p><h4 id="4-可审核性"><a href="#4-可审核性" class="headerlink" title="4. 可审核性"></a>4. 可审核性</h4><p>国产操作系统可能会提供更加透明的审计功能，方便对系统行为和数据流向进行监控、记录和审计，以追踪潜在的安全问题。</p><h4 id="5-私有化定制"><a href="#5-私有化定制" class="headerlink" title="5. 私有化定制"></a>5. 私有化定制</h4><p>国产操作系统可能提供更多的定制服务，以符合国内企业或政府部门的特定需求，包括私有云部署、定制化的安全策略和服务等。</p><h4 id="6-支持国产硬件和加密算法"><a href="#6-支持国产硬件和加密算法" class="headerlink" title="6. 支持国产硬件和加密算法"></a>6. 支持国产硬件和加密算法</h4><p>国产操作系统可能会有更好的支持国产CPU架构（如龙芯、飞腾等）和国产加密算法（如国密SM系列算法）的能力。</p><h4 id="7-系统更新与维护"><a href="#7-系统更新与维护" class="headerlink" title="7. 系统更新与维护"></a>7. 系统更新与维护</h4><p>在维护和系统更新方面，国产操作系统可能会强调更快的本地化响应速度，及时补丁发布和定制化的更新服务。</p><h4 id="8-本地化支持"><a href="#8-本地化支持" class="headerlink" title="8. 本地化支持"></a>8. 本地化支持</h4><p>国产操作系统提供更深层次的本地化支持，不仅限于语言包，还可能包括本地化的用户界面、帮助文档以及用户支持服务。</p><h4 id="9-应对国内网络环境"><a href="#9-应对国内网络环境" class="headerlink" title="9. 应对国内网络环境"></a>9. 应对国内网络环境</h4><p>国产操作系统可能会内置特定的功能和服务，以更好地应对中国特有的网络环境，如对国内常用应用和服务的优化。</p><p>需要指出的是，这些特色并不是说国外的主流操作系统不具备，而是国产操作系统可能会在这些方面做出更多本地化和定制化的设计。另外，不同的国产操作系统，在安全机制上的具体实现和特色会有所不同。</p><h3 id="基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU"><a href="#基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU" class="headerlink" title="基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU"></a>基于活动目录的域管理（提供一种集中的资源管理模式）：域，域控制器，OU</h3><p>见上</p><h3 id="物联网和虚拟化技术对操作系统带来的安全挑战"><a href="#物联网和虚拟化技术对操作系统带来的安全挑战" class="headerlink" title="物联网和虚拟化技术对操作系统带来的安全挑战"></a>物联网和虚拟化技术对操作系统带来的安全挑战</h3><p>伴随着大数据和云时代的到来，虚拟化技术的应用已经越来越成熟。如何运用虚拟化技术给终端客户提供一个安全、稳定、高效的桌面环境，成为了一个日益热门的话题。</p><p>物联网（IoT）和虚拟化技术是近年来信息技术领域的两个重要趋势，它们对操作系统的安全性提出了新的挑战。</p><h4 id="物联网（IoT）带来的安全挑战："><a href="#物联网（IoT）带来的安全挑战：" class="headerlink" title="物联网（IoT）带来的安全挑战："></a>物联网（IoT）带来的安全挑战：</h4><h5 id="1-设备多样性和管理难度"><a href="#1-设备多样性和管理难度" class="headerlink" title="1. 设备多样性和管理难度"></a>1. 设备多样性和管理难度</h5><p>物联网环境中，设备种类繁多，从传感器到智能家电，再到工业控制系统，这些设备运行的操作系统多样，且往往资源受限，这增加了维护和管理的复杂性。</p><h5 id="2-面向设备的安全攻击"><a href="#2-面向设备的安全攻击" class="headerlink" title="2. 面向设备的安全攻击"></a>2. 面向设备的安全攻击</h5><p>物联网设备由于资源有限，可能无法运行复杂的安全软件，这使得它们更容易受到攻击，如固件劫持、物理篡改等。</p><h5 id="3-数据安全和隐私保护"><a href="#3-数据安全和隐私保护" class="headerlink" title="3. 数据安全和隐私保护"></a>3. 数据安全和隐私保护</h5><p>物联网设备通常会收集大量个人或敏感数据，安全地存储和传输这些数据成为了一大挑战。</p><h5 id="4-网络安全问题"><a href="#4-网络安全问题" class="headerlink" title="4. 网络安全问题"></a>4. 网络安全问题</h5><p>物联网设备通常需要连接到互联网，这可能导致网络层面的安全问题，如DDoS攻击利用了大量未加密的物联网设备。</p><h5 id="5-更新和补丁分发"><a href="#5-更新和补丁分发" class="headerlink" title="5. 更新和补丁分发"></a>5. 更新和补丁分发</h5><p>物联网设备的更新机制往往不如传统 IT 系统那样成熟，这意味着安全漏洞可能长时间得不到修复。</p><h4 id="虚拟化技术带来的安全挑战："><a href="#虚拟化技术带来的安全挑战：" class="headerlink" title="虚拟化技术带来的安全挑战："></a>虚拟化技术带来的安全挑战：</h4><h5 id="1-虚拟化平台的安全"><a href="#1-虚拟化平台的安全" class="headerlink" title="1. 虚拟化平台的安全"></a>1. 虚拟化平台的安全</h5><p>虚拟化平台（如VMware、Xen、KVM等）本身的安全性至关重要，因为它们成为了多个虚拟机共享的基础设施。</p><h5 id="2-虚拟机逃逸攻击"><a href="#2-虚拟机逃逸攻击" class="headerlink" title="2. 虚拟机逃逸攻击"></a>2. 虚拟机逃逸攻击</h5><p>如果攻击者成功实施虚拟机逃逸，他们可以从一个虚拟机访问宿主机或者其他虚拟机，从而破坏整个虚拟化环境的隔离性。</p><h5 id="3-虚拟网络安全"><a href="#3-虚拟网络安全" class="headerlink" title="3. 虚拟网络安全"></a>3. 虚拟网络安全</h5><p>在虚拟化环境中，传统网络安全解决方案可能难以直接应用，因为虚拟机之间的网络交互可能完全在软件定义的网络内部进行。</p><h5 id="4-资源池共享安全问题"><a href="#4-资源池共享安全问题" class="headerlink" title="4. 资源池共享安全问题"></a>4. 资源池共享安全问题</h5><p>虚拟化环境中不同虚拟机共享相同的物理资源，如CPU和内存，这可能导致资源竞争以及隔离性的问题。</p><h5 id="5-快照和移动性带来的数据安全问题"><a href="#5-快照和移动性带来的数据安全问题" class="headerlink" title="5. 快照和移动性带来的数据安全问题"></a>5. 快照和移动性带来的数据安全问题</h5><p>虚拟机的快照和移动性功能，虽然带来了便利，但也带来了数据泄露的风险。</p><h5 id="6-管理和配置的复杂性"><a href="#6-管理和配置的复杂性" class="headerlink" title="6. 管理和配置的复杂性"></a>6. 管理和配置的复杂性</h5><p>虚拟化环境增加了管理和配置的复杂性，不当的配置可能导致安全漏洞。</p><p>为了应对这些挑战，操作系统需要集成更多的安全特性，比如增强的访问控制、隔离机制、加密技术以及实时的监控和响应系统。同时，对于物联网和虚拟化环境中的安全事件，需要有专门的检测和应对策略。此外，开发和维护适用于这些环境的安全准则和最佳实践也同样重要。</p><h3 id="身份认证协议，一次性口令（OTP），Kerberos-协议的原理"><a href="#身份认证协议，一次性口令（OTP），Kerberos-协议的原理" class="headerlink" title="身份认证协议，一次性口令（OTP），Kerberos 协议的原理"></a>身份认证协议，一次性口令（OTP），Kerberos 协议的原理</h3><p><strong>OTP的主要思路是</strong>：在登录过程中加入不确定因素，使每次登录过程中传送的口令信息都不相同，以提高登录过程安全性。</p><p>例如：登录密码&#x3D;MD5(用户名＋密码 ＋时间）系统接收到登录口令后做一个验算即可验证用户的合法性。</p><p><strong>Kerberos认证</strong></p><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231222205144084.png" alt="image-20231222205144084"></p><p><strong>交换第一轮：获取票据许可票据</strong></p><p>​<strong>Step (1) 用户请求票据许可票据</strong></p><p>➢ 用户请求票据许可票据的工作在登录工作站时进行。<br>➢ 登录时用户被要求输入用户名，输入后系统会向认证服务器AS以明文方式发送一条包含用户和TGS服务两者名字的请求。<br>$$<br>C\to AS:ID_C||ID_{tgs}||TS_1<br>$$<br>​<strong>Step (2) AS发放票据许可票据和会话密钥</strong></p><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231222213355240.png" alt="image-20231222213355240"></p><p><strong>第二轮：获取访问票据</strong></p><p>​<strong>Step (3) C请求服务器票据</strong></p><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231222213404437.png" alt="image-20231222213404437"></p><p>​<strong>Step (4) TGS发放服务器票据和会话密钥</strong></p><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231222213412913.png" alt="image-20231222213412913"></p><p><strong>第三轮：获取服务</strong></p><p>​<strong>Step (5) 工作站将票据和认证符发给服务器</strong></p><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231222213419461.png" alt="image-20231222213419461"></p><p>​<strong>Step (6) 服务器验证票据TicketS和认证符中的匹配，然后许可访问服务。</strong><br>$$<br>S\to C:E_{Kc,s}[TS_5+1]<br>$$</p><h3 id="组策略的主要优势，组策略和-OU-的关系"><a href="#组策略的主要优势，组策略和-OU-的关系" class="headerlink" title="组策略的主要优势，组策略和 OU 的关系"></a>组策略的主要优势，组策略和 OU 的关系</h3><p><strong>主要优势：</strong></p><p>• <strong>降低管理、支持与培训成本</strong></p><p>• <strong>提升用户工作效率</strong></p><p>• <strong>允许极大量的定制项目</strong> <strong>–</strong> <strong>其扩展性不会牺牲定制的灵活性</strong></p><p>组策略是一种用于中央管理和配置操作系统、应用程序和用户设置的工具，而组织单位（OU）是在Active Directory中用来组织用户、组和设备的容器。通过将组策略应用于特定的OU，管理员能够对网络中的不同用户和计算机群组进行精确和灵活的管理，同时利用OU的层级结构实现策略的继承和覆盖，从而实现高效的策略部署和权限控制。</p><h2 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h2><h3 id="数据库面临的安全威胁"><a href="#数据库面临的安全威胁" class="headerlink" title="数据库面临的安全威胁"></a>数据库面临的安全威胁</h3><p><strong>按照导致的后果分类</strong></p><p>• 信息泄露：未授权的用户有意&#x2F;无意得到的信息。</p><p>• 数据修改：未授权的数据修改，违反信息完整性。</p><p>• 拒绝服务：影响用户访问和数据库资源的使用。</p><p><strong>按照发生的方式分类</strong></p><p>​<strong>偶然的、无意的侵犯或破坏</strong></p><p>​• 自然或意外的灾害</p><p>​• 硬件或软件的故障&#x2F;错误导致的数据丢失和泄露</p><p>​• 人为的失误系和安全机制</p><p>​<strong>蓄意的侵犯或敌意的攻击</strong></p><p>​• 授权用户滥用、误用其权限</p><p>​• 病毒、特洛伊木马、天窗（后门）、隐通道</p><p>​• 绕过DBMS直接对数据进行读写</p><p>​• 为了某种目的，故意把错误数据注入数据库，使之保存错误信息并随着时间的推移扩散</p><p><strong>按照表现形式的分类</strong></p><p>• 滥用过高权限</p><p>• 滥用合法权限</p><p>• 权限提升</p><p>• 平台漏洞</p><p>• SQL注入</p><p>• 审计记录不足</p><p>• 拒绝服务</p><h3 id="数据库的安全防御纵深体"><a href="#数据库的安全防御纵深体" class="headerlink" title="数据库的安全防御纵深体"></a>数据库的安全防御纵深体</h3><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231222212721493.png" alt="image-20231222212721493"><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231222212738244.png" alt="image-20231222212738244"></p><h3 id="数据库的安全漏洞"><a href="#数据库的安全漏洞" class="headerlink" title="数据库的安全漏洞"></a>数据库的安全漏洞</h3><p>数据库安全漏洞通常指的是那些可能被恶意用户利用以非法访问、窃取、损坏或篡改数据的系统弱点。数据库中的安全漏洞可能以不同形式存在，以下是一些常见的数据库安全漏洞类型：</p><ol><li><p><strong>SQL注入</strong>：这是一种常见的攻击手段，攻击者通过在应用程序的输入字段中输入恶意SQL代码，企图对数据库执行未授权的查询或操作。</p></li><li><p><strong>不恰当的权限配置</strong>：如果用户或应用程序被授予过多权限，它们就可能进行不应当的数据库修改，或访问不该访问的数据。</p></li><li><p><strong>敏感数据暴露</strong>：敏感信息未经加密或不正确的加密存储在数据库中，容易被泄漏。</p></li><li><p><strong>配置缺陷</strong>：数据库的默认配置可能不够安全，例如默认账户和密码未更改，导致易于被攻破。</p></li><li><p><strong>未更新的数据库系统</strong>：未及时安装数据库软件的补丁和更新可能会留下安全漏洞，易受已知漏洞的攻击。</p></li><li><p><strong>注入漏洞</strong>：不仅限于SQL注入，还包括其它形式的注入，如LDAP注入、ORM注入等。</p></li><li><p><strong>缓冲区溢出</strong>：当输入数据超出数据库引擎预期的处理能力时，可能会导致执行任意代码。</p></li><li><p><strong>不安全的存储过程和触发器</strong>：如果存储过程或触发器编写不当，它们可能成为执行不受控制的SQL代码的途径。</p></li><li><p><strong>信息泄露</strong>：系统错误信息包含敏感信息，如数据库结构细节、系统路径等，有助于攻击者构造攻击。</p></li><li><p><strong>身份认证绕过</strong>：如果认证机制有漏洞，攻击者可能无需合法凭据就能访问数据库。</p></li><li><p><strong>跨站脚本攻击（XSS）</strong>：如果数据库中存储的数据用于网页内容，未经适当清理就插入HTML页面，可能会执行恶意脚本。</p></li><li><p><strong>未充分保护的备份</strong>：数据库备份如果未加密或存储在不安全的位置，可能被攻击者访问。</p></li></ol><p>为了保护数据库免受安全漏洞的影响，重要的措施包括定期更新和打补丁、实施最小权限原则、加密敏感数据、使用入侵检测系统、进行安全审计以及提供安全意识培训等。</p><h1 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a><strong>3.</strong> <strong>基本操作</strong></h1><h2 id="信息系统概述"><a href="#信息系统概述" class="headerlink" title="信息系统概述"></a>信息系统概述</h2><h3 id="能进行简单的信息系统架构设计，可参考讲义提供的阿里架构"><a href="#能进行简单的信息系统架构设计，可参考讲义提供的阿里架构" class="headerlink" title="能进行简单的信息系统架构设计，可参考讲义提供的阿里架构"></a>能进行简单的信息系统架构设计，可参考讲义提供的阿里架构</h3><p>简单的信息系统架构设计参考阿里巴巴的架构，显然需要考虑到系统的可扩展性、可靠性和高并发处理能力。以下是一个高层次的架构设计概要：</p><h4 id="基础设施层"><a href="#基础设施层" class="headerlink" title="基础设施层"></a>基础设施层</h4><ol><li><p><strong>云服务提供商</strong>：选择云服务，如阿里云，以便利用其弹性计算、存储和网络资源。</p></li><li><p><strong>全球负载均衡</strong>：使用DNS级别的负载均衡或阿里云的全局负载均衡服务确保跨地域的流量分配。</p></li></ol><h4 id="数据持久层"><a href="#数据持久层" class="headerlink" title="数据持久层"></a>数据持久层</h4><ol><li><p><strong>数据库</strong>：采用分布式数据库解决方案，如阿里云的PolarDB或RDS来处理高并发读写操作，实现读写分离和数据分片。</p></li><li><p><strong>缓存</strong>：使用Redis或Memcached作为缓存层减少对数据库的访问频率。</p></li><li><p><strong>存储</strong>：使用对象存储服务（如阿里云OSS）来存储和分发静态内容。</p></li></ol><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ol><li><p><strong>微服务架构</strong>：划分微服务，每个服务负责具体的业务功能，相互独立，通过阿里云的容器服务和Kubernetes进行管理。</p></li><li><p><strong>消息队列</strong>：采用RocketMQ等消息系统处理异步任务和解耦服务间的通信。</p></li><li><p><strong>API网关</strong>：使用API网关管理微服务的入口，提供认证、授权、流量控制等功能。</p></li></ol><h4 id="业务逻辑层"><a href="#业务逻辑层" class="headerlink" title="业务逻辑层"></a>业务逻辑层</h4><ol><li><p><strong>业务微服务</strong>：根据不同的业务功能划分服务，如订单处理、用户管理、产品目录等。</p></li><li><p><strong>定时任务服务</strong>：处理需要周期性执行的业务逻辑。</p></li></ol><h4 id="客户端层"><a href="#客户端层" class="headerlink" title="客户端层"></a>客户端层</h4><ol><li><p><strong>Web前端</strong>：使用现代JavaScript框架（如React或Vue.js）构建用户友好的单页面应用（SPA）。</p></li><li><p><strong>移动端</strong>：开发原生或混合移动应用。</p></li></ol><h4 id="辅助层"><a href="#辅助层" class="headerlink" title="辅助层"></a>辅助层</h4><ol><li><p><strong>CDN</strong>：内容分发网络缓存静态资源，减轻后端服务的压力。</p></li><li><p><strong>监控和日志</strong>：集成监控工具（如Prometheus）和日志服务（如ELK Stack）进行系统监控和日志分析。</p></li><li><p><strong>安全</strong>：实现网络安全策略、数据加密、DDoS防护等。</p></li></ol><h4 id="运维层"><a href="#运维层" class="headerlink" title="运维层"></a>运维层</h4><ol><li><p><strong>自动化部署</strong>：使用CI&#x2F;CD工具（如Jenkins）自动化部署流程。</p></li><li><p><strong>容器编排</strong>：使用Docker和Kubernetes进行容器化部署和管理。</p></li></ol><p>确保在设计时考虑到系统的可观测性、可维护性和灾难恢复能力。此外，对于“秒杀”类型的场景，还需要特别设计限流、熔断机制以及足够的预热和压力测试来确保系统在高负载下的稳定性。</p><h3 id="能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术"><a href="#能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术" class="headerlink" title="能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术"></a>能针对特定的信息系统及其业务需求，设计相应的抗“秒杀”、“大并发”技术</h3><p><strong>将请求拦截在系统上游，降低下游压力：</strong>秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，甚至导致死锁，最终请求超时。</p><p><strong>充分利用缓存：</strong>利用缓存可极大提高系统读写速度。</p><p><strong>消息中间件：</strong>消息队列可以削峰，将拦截大量并发请求，这是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。</p><h2 id="信息系统安全概论-2"><a href="#信息系统安全概论-2" class="headerlink" title="信息系统安全概论"></a>信息系统安全概论</h2><h3 id="根据业务使命、工作环境进行信息系统安全威胁分析"><a href="#根据业务使命、工作环境进行信息系统安全威胁分析" class="headerlink" title="根据业务使命、工作环境进行信息系统安全威胁分析"></a>根据业务使命、工作环境进行信息系统安全威胁分析</h3><p>进行信息系统安全威胁分析时，考虑业务使命和工作环境是至关重要的。以下是一个分析框架，它考虑了这些因素，并帮助识别和评估潜在的安全威胁。</p><h4 id="1-理解业务使命"><a href="#1-理解业务使命" class="headerlink" title="1. 理解业务使命"></a>1. 理解业务使命</h4><ul><li><strong>业务目标</strong>：确定业务的主要目标和目的，分析哪些信息系统对实现这些目标至关重要。</li><li><strong>关键资产</strong>：识别业务运作的关键资产，包括重要的数据类型、系统、技术和人力资源。</li><li><strong>业务流程</strong>：了解业务流程及其对信息系统的依赖程度，以及流程被破坏时对业务的影响。</li><li><strong>合规要求</strong>：考虑行业标准和法规要求，如GDPR、HIPAA、PCI-DSS等对信息安全管理的影响。</li></ul><h4 id="2-分析工作环境"><a href="#2-分析工作环境" class="headerlink" title="2. 分析工作环境"></a>2. 分析工作环境</h4><ul><li><strong>物理环境</strong>：评估信息系统所在的物理环境，包括访问控制、灾害风险（如洪水、火灾）和其他相关因素。</li><li><strong>网络环境</strong>：理解网络架构，包括互联网接入方式、内部网络隔离以及远程访问的安全性。</li><li><strong>技术栈</strong>：识别使用的所有技术（软件、硬件、云服务等），包括它们的安全状态和历史漏洞。</li><li><strong>操作环境</strong>：涉及日常操作中可能出现的风险，例如员工的安全意识水平、数据处理和存储的安全性等。</li></ul><h4 id="3-安全威胁分析"><a href="#3-安全威胁分析" class="headerlink" title="3. 安全威胁分析"></a>3. 安全威胁分析</h4><ul><li><strong>威胁识别</strong>：列出可能影响信息系统的所有潜在威胁，包括恶意软件、黑客攻击、内部威胁、物理盗窃等。</li><li><strong>威胁评估</strong>：针对每项威胁，评估其可能性和对业务的潜在影响。这通常涉及风险评估矩阵。</li><li><strong>脆弱性评估</strong>：识别系统的脆弱点，包括未打补丁的软件、弱密码政策、员工培训缺失等。</li></ul><h4 id="4-采取防御措施"><a href="#4-采取防御措施" class="headerlink" title="4. 采取防御措施"></a>4. 采取防御措施</h4><ul><li><strong>预防措施</strong>：根据分析结果实施必要的安全措施，如加强访问控制、更新和打补丁、安全配置和加密措施。</li><li><strong>监控和检测</strong>：部署监控系统以检测可疑行为和迹象，确保能够及时响应潜在攻击。</li><li><strong>应急计划</strong>：制定并练习应急响应计划，以便在安全事件发生时能迅速采取行动。</li></ul><h4 id="5-持续改进"><a href="#5-持续改进" class="headerlink" title="5. 持续改进"></a>5. 持续改进</h4><ul><li><strong>审计和复审</strong>：定期进行安全审计，以评估现有措施的有效性，并根据新出现的威胁和漏洞进行调整。</li><li><strong>教育与培训</strong>：定期对员工进行安全培训，提高他们的安全意识和应对安全威胁的能力。</li></ul><h3 id="能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构"><a href="#能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构" class="headerlink" title="能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构"></a>能进行简单的信息系统安全架构设计，可参考讲义提供的云安全架构</h3><p><img src="/../../images/BUPT_note/Review_of_Information_System_Security/image-20231219230840678.png" alt="image-20231219230840678"></p><h2 id="安全需求和安全策略-2"><a href="#安全需求和安全策略-2" class="headerlink" title="安全需求和安全策略"></a>安全需求和安全策略</h2><h3 id="根据安全威胁分析安全需求"><a href="#根据安全威胁分析安全需求" class="headerlink" title="根据安全威胁分析安全需求"></a>根据安全威胁分析安全需求</h3><p>根据安全威胁分析安全需求是一个重要的步骤，用于确保信息系统的安全性。这个过程涉及识别可能影响系统安全的潜在威胁，并基于这些威胁制定相应的安全需求和措施。以下是这一过程中的关键步骤：</p><h4 id="1-威胁建模"><a href="#1-威胁建模" class="headerlink" title="1. 威胁建模"></a>1. 威胁建模</h4><p>威胁建模通常是分析安全威胁的第一步，旨在识别系统可能面临的安全威胁。它可以帮助确定攻击者可能利用的弱点和系统可能受到的攻击类型。常见的威胁建模方法包括STRIDE模型，它涵盖以下威胁类型：</p><ul><li><strong>Spoofing</strong>（身份冒充）</li><li><strong>Tampering</strong>（数据篡改）</li><li><strong>Repudiation</strong>（否认）</li><li><strong>Information Disclosure</strong>（信息泄露）</li><li><strong>Denial of Service</strong>（服务拒绝）</li><li><strong>Elevation of Privilege</strong>（提权）</li></ul><h4 id="2-风险评估"><a href="#2-风险评估" class="headerlink" title="2. 风险评估"></a>2. 风险评估</h4><p>在威胁建模的基础上，进行风险评估以确定哪些威胁具有最高的风险。风险通常根据两个因素评估：威胁的可能性和威胁的影响。这可以通过不同的风险评估框架进行，如FAIR（Factor Analysis of Information Risk）或传统的风险矩阵。</p><h4 id="3-定义安全需求"><a href="#3-定义安全需求" class="headerlink" title="3. 定义安全需求"></a>3. 定义安全需求</h4><p>通过识别最高风险的威胁，可以定义系统的安全需求。这些需求应该旨在减轻或消除风险。安全需求通常包括以下几个方面：</p><ul><li><strong>保密性</strong>：确保信息不被未授权的个人或系统访问。</li><li><strong>完整性</strong>：保护数据免受未授权的修改。</li><li><strong>可用性</strong>：确保在需要时能够访问信息和资源。</li><li><strong>认证</strong>：确保参与者的身份得到确认。</li><li><strong>授权</strong>：确保只有授权用户才能访问资源。</li><li><strong>审计</strong>：记录和监控系统活动，以便在问题发生时可以进行检查。</li></ul><h4 id="4-实施安全控制"><a href="#4-实施安全控制" class="headerlink" title="4. 实施安全控制"></a>4. 实施安全控制</h4><p>根据定义的安全需求，选择和实施合适的安全控制措施。控制措施可以是技术性的，比如使用防火墙、加密和入侵检测系统；也可以是管理性的，比如制定安全策略、培训和应急计划；还可以是物理性的，比如安全门禁系统和监控摄像头。</p><h4 id="5-验证和测试"><a href="#5-验证和测试" class="headerlink" title="5. 验证和测试"></a>5. 验证和测试</h4><p>实施安全控制后，需要验证和测试它们的有效性。这可以通过安全审计、渗透测试、漏洞扫描等方式进行。</p><h4 id="6-持续监控和评估"><a href="#6-持续监控和评估" class="headerlink" title="6. 持续监控和评估"></a>6. 持续监控和评估</h4><p>安全需求的制定并不是一次性的活动。必须定期监控系统以检测新的安全威胁，并对安全需求进行评估和更新。</p><p>通过这个连续的循环过程，组织可以确保他们的安全措施保持最新，能够应对不断变化的威胁环境。这个过程不仅适用于信息技术系统，还适用于物理安全和组织的各个方面。</p><h3 id="可根据需要编写标准-ACL-或扩展-ACL，特别是通配掩码的使用"><a href="#可根据需要编写标准-ACL-或扩展-ACL，特别是通配掩码的使用" class="headerlink" title="可根据需要编写标准 ACL 或扩展 ACL，特别是通配掩码的使用"></a>可根据需要编写标准 ACL 或扩展 ACL，特别是通配掩码的使用</h3><p><strong>创建标准ACL实例</strong></p><p>Router(config)# access-list 1 permit 192.168.1.0 0.0.0.255</p><p>Router(config)# access-list 1 permit 192.168.2.2 0.0.0.0</p><p>允许192.168.1.0&#x2F;24和主机192.168.2.2的流量通过</p><p><strong>Examples:</strong> <strong>扩展****ACL</strong></p><ol><li><strong>Lab_A(config)#access-list 110 deny tcp any host 172.16.30.2 eq www</strong></li></ol><p>含义：拒绝任何IP地址通过TCP协议访问主机172.16.30.2的www服务。隐含的意思是主机可以访问172.16.30.2的其它服务，限制更为细致。</p><ol start="2"><li><strong>Lab_A(config)#access-list 110 permit tcp 192.168.10.0 0.0.0.255 host</strong></li></ol><p><strong>172.16.30.2 eq 23 log</strong></p><p>含义：允许网段192.168.10.0 255.255.255.0通过TCP协议访问主机172.16.30.2的23端口的服务即Telnet服务，且记录访问日志。</p><ol start="3"><li><strong>Lab_A(config)#access-list 110 permit ip any any</strong></li></ol><p>含义：允许所有使用IP协议的IP访问其它所有IP，即允许所有。</p><h2 id="信息系统的风险评估-2"><a href="#信息系统的风险评估-2" class="headerlink" title="信息系统的风险评估"></a>信息系统的风险评估</h2><h3 id="给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等"><a href="#给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等" class="headerlink" title="给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等"></a>给定某信息系统的业务使命及操作环境，可进行安全风险评估，包括：风险分析方法，资产分类方法及识别模型，威胁赋值，脆弱性赋值等</h3><p>进行安全风险评估是一个系统化的过程，涉及对可能影响信息系统的风险进行识别、评估和优先级排序。这个过程通常包括以下几个关键步骤：</p><h4 id="1-风险分析方法"><a href="#1-风险分析方法" class="headerlink" title="1. 风险分析方法"></a>1. 风险分析方法</h4><p>选择一个适合组织需求的风险分析方法是重要的第一步。常见的方法包括：</p><ul><li><strong>定性分析</strong>：依赖于专业知识和经验来评估风险的概率和影响，结果通常使用诸如”低”、”中”、”高”这样的等级来描述。</li><li><strong>定量分析</strong>：使用数值方法来计算风险概率和影响，通常依赖于历史数据和统计技术。</li><li><strong>半定量分析</strong>：结合定性和定量分析的优点，通过打分系统来量化风险。</li></ul><h4 id="2-资产分类方法及识别模型"><a href="#2-资产分类方法及识别模型" class="headerlink" title="2. 资产分类方法及识别模型"></a>2. 资产分类方法及识别模型</h4><p>对于信息系统来说，资产是指所有的信息资源和相关的组件，如硬件、软件、数据和人力资源。资产分类和识别是风险评估的基础。常用的分类方法包括：</p><ul><li><strong>按照功能</strong>：例如，服务器、用户终端、网络设备等。</li><li><strong>按照数据类型</strong>：如个人身份信息、财务报告、知识产权等。</li><li><strong>按照重要性</strong>：关键资产、重要资产和非关键资产。</li></ul><h4 id="3-威胁赋值"><a href="#3-威胁赋值" class="headerlink" title="3. 威胁赋值"></a>3. 威胁赋值</h4><p>威胁赋值是指识别可能对资产造成损害的所有潜在威胁，并对这些威胁的严重性进行评估。威胁可以来自多个来源，如自然灾害、技术故障、人为错误或恶意攻击。为了评估威胁，组织通常会：</p><ul><li><strong>列出威胁来源</strong>：包括内部和外部来源。</li><li><strong>评估威胁发生的可能性</strong>：通常分为“不太可能”、“可能”、“很可能”等。</li><li><strong>考虑威胁的潜在影响</strong>：对业务的影响，如财务损失、声誉损害等。</li></ul><h4 id="4-脆弱性赋值"><a href="#4-脆弱性赋值" class="headerlink" title="4. 脆弱性赋值"></a>4. 脆弱性赋值</h4><p>脆弱性是指系统、程序或网络中的弱点，可以被威胁所利用。脆弱性赋值包括以下步骤：</p><ul><li><strong>脆弱性扫描</strong>：使用自动工具检测系统的已知脆弱性。</li><li><strong>脆弱性评估</strong>：分析扫描结果，评估每个脆弱性被利用的可能性和潜在的影响。</li><li><strong>脆弱性优先级排序</strong>：确定哪些脆弱性最值得注意。</li></ul><h4 id="5-风险评估"><a href="#5-风险评估" class="headerlink" title="5. 风险评估"></a>5. 风险评估</h4><p>最后，结合威胁赋值和脆弱性赋值的结果来评估风险。风险可以定义为威胁和脆弱性相结合的概率与其潜在影响的乘积。对于每个风险，评估其：</p><ul><li><strong>概率</strong>：风险出现的可能性有多大。</li><li><strong>影响</strong>：如果风险实际发生，会对组织造成多大的损害。</li></ul><p>根据评估的结果，组织可以确定哪些风险需要优先处理，并制定相应的风险缓解措施。这可能包括技术控制（如加密和访问控制）、管理控制（如策略和流程）和物理控制（如安全门和监控相机）。</p><p>风险评估是一个动态的过程，需要定期更新，以反映新的威胁、脆弱性和业务环境的变化。</p><h2 id="信息系统等级保护-2"><a href="#信息系统等级保护-2" class="headerlink" title="信息系统等级保护"></a>信息系统等级保护</h2><h3 id="给定某信息系统的业务使命及操作环境，可进行定级和备案"><a href="#给定某信息系统的业务使命及操作环境，可进行定级和备案" class="headerlink" title="给定某信息系统的业务使命及操作环境，可进行定级和备案"></a>给定某信息系统的业务使命及操作环境，可进行定级和备案</h3><p>北京邮电大学教务系统是一个关键的信息系统，它处理学生的注册、课程分配、成绩记录等重要数据。进行定级和备案操作需遵循以下步骤：</p><h4 id="1-业务使命和操作环境分析"><a href="#1-业务使命和操作环境分析" class="headerlink" title="1. 业务使命和操作环境分析"></a>1. 业务使命和操作环境分析</h4><ul><li><strong>业务使命</strong>：教务系统的业务使命是管理学生的教育相关信息，包括课程注册、成绩管理、学位认证等。</li><li><strong>操作环境</strong>：教务系统在北京邮电大学校园内部署，在校园网络环境下运行，并由学校的IT部门维护。</li></ul><h4 id="2-定级"><a href="#2-定级" class="headerlink" title="2. 定级"></a>2. 定级</h4><h5 id="信息资产识别和价值评估"><a href="#信息资产识别和价值评估" class="headerlink" title="信息资产识别和价值评估"></a>信息资产识别和价值评估</h5><ul><li>确认教务系统中所有的硬件和软件资源，以及它们的配置。</li><li>评估学生和教职工的个人信息、成绩资料、课程信息等数据的价值和敏感性，因为这些信息通常包含个人隐私。</li></ul><h5 id="威胁和脆弱性分析"><a href="#威胁和脆弱性分析" class="headerlink" title="威胁和脆弱性分析"></a>威胁和脆弱性分析</h5><ul><li>确定可能对教务系统构成威胁的各种因素，包括网络攻击、内部数据泄露、自然灾害等。</li><li>分析系统存在的脆弱性，如软件漏洞、硬件故障或人为错误。</li></ul><h5 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h5><ul><li>结合资产价值、威胁和脆弱性来评估风险。</li><li>评估数据泄露、系统中断等对学校运营及声誉可能造成的影响。</li></ul><h5 id="安全等级划分"><a href="#安全等级划分" class="headerlink" title="安全等级划分"></a>安全等级划分</h5><ul><li>根据以上评估的结果，参照国家或行业的标准，给教务系统定一个合适的安全等级。</li><li>根据中国的相关标准，教务系统可能被定为三级或四级信息系统，因为它处理大量的个人敏感数据。</li></ul><h4 id="3-备案"><a href="#3-备案" class="headerlink" title="3. 备案"></a>3. 备案</h4><h5 id="编制备案材料"><a href="#编制备案材料" class="headerlink" title="编制备案材料"></a>编制备案材料</h5><ul><li>准备详细的系统描述，包括它的功能、数据流、用户访问模式等。</li><li>包含定级的相关文档，比如风险评估报告、安全保护措施描述、安全管理制度等。</li></ul><h5 id="提交备案"><a href="#提交备案" class="headerlink" title="提交备案"></a>提交备案</h5><ul><li>将所有准备好的材料提交给北京市海淀区公安局的信息网络安全监管部门。</li><li>包括备案申请表、系统等级评估报告、风险管理方案等。</li></ul><h5 id="后续跟进"><a href="#后续跟进" class="headerlink" title="后续跟进"></a>后续跟进</h5><ul><li>等待海淀区公安局审核并确认备案。</li><li>根据公安局的要求，可能需要提供额外的信息或对系统进行必要的安全改进。</li><li>在备案通过后，定期更新备案信息，如系统升级、安全事件等均可能需要重新评估和备案。</li></ul><p>进行定级和备案操作是为了确保教务系统的安全性，防护措施的适当性，并且遵守中国的法律法规要求，保护学生和教职工的个人信息安全。</p><h2 id="信息系统的物理安全-2"><a href="#信息系统的物理安全-2" class="headerlink" title="信息系统的物理安全"></a>信息系统的物理安全</h2><h3 id="机房设计和建设中应该考虑的安全因素"><a href="#机房设计和建设中应该考虑的安全因素" class="headerlink" title="机房设计和建设中应该考虑的安全因素"></a>机房设计和建设中应该考虑的安全因素</h3><p>在机房设计和建设中考虑的安全因素非常广泛，既包括物理安全措施，也包括环境控制、电源管理等。以下是一些关键的安全因素：</p><h4 id="物理安全"><a href="#物理安全" class="headerlink" title="物理安全"></a>物理安全</h4><ol><li><strong>门禁系统</strong>：确保只有授权人员能够进入机房。门禁系统通常包括卡片读取器、生物识别系统等。</li><li><strong>监控系统</strong>：安装视频监控设备监视机房内外的活动，以防止未授权的访问或其他安全事件。</li><li><strong>安全门和窗户</strong>：使用坚固的材料制作门和窗户，防止非法闯入。</li><li><strong>物理隔离</strong>：机房应与其他非关键区域物理隔离，减少潜在的物理风险。</li></ol><h3 id="火灾防护"><a href="#火灾防护" class="headerlink" title="火灾防护"></a>火灾防护</h3><ol><li><strong>自动喷水灭火系统</strong>：在必要时可采用，但不适用于高端电子设备。</li><li><strong>化学灭火系统</strong>：使用FM200或其他适用于机房的化学灭火剂。</li><li><strong>烟雾探测器和报警系统</strong>：确保一旦发生火情，立即发出警报并启动灭火系统。</li></ol><h4 id="环境控制"><a href="#环境控制" class="headerlink" title="环境控制"></a>环境控制</h4><ol><li><strong>温度和湿度控制</strong>：维持适宜的温度和湿度水平以保护设备免受损害。</li><li><strong>空调系统</strong>：设计高效的空调系统，并具备备用冷却系统以防主系统故障。</li></ol><h4 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h4><ol><li><strong>不间断电源（UPS）</strong>：确保在市电断电的情况下，关键设备能够继续运行。</li><li><strong>备用发电机</strong>：在长时间的电力中断时，能够供应机房所需的电力。</li><li><strong>电源分配单元（PDU）</strong>：合理分配电源，确保电力供应的稳定性与安全性。</li></ol><h4 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h4><ol><li><strong>网络安全设备</strong>：部署适当的防火墙和入侵检测系统来保障网络安全。</li><li><strong>数据备份</strong>：定期备份重要数据，并将备份保存在安全的离线位置。</li></ol><h4 id="管理措施"><a href="#管理措施" class="headerlink" title="管理措施"></a>管理措施</h4><ol><li><strong>访问记录</strong>：记录所有访问机房人员的详情，包括时间和日期。</li><li><strong>维护和操作程序</strong>：建立严格的维护和操作流程，确保每项操作都能追溯并符合安全规范。</li></ol><h4 id="法规遵从"><a href="#法规遵从" class="headerlink" title="法规遵从"></a>法规遵从</h4><ol><li><strong>符合当地法规</strong>：确保机房设计符合当地建筑、电力、消防等相关法规。</li><li><strong>行业标准遵从</strong>：遵循行业标准如TIA-942、ISO&#x2F;IEC 27001等。</li></ol><h4 id="灾害恢复"><a href="#灾害恢复" class="headerlink" title="灾害恢复"></a>灾害恢复</h4><ol><li><strong>灾害恢复计划</strong>：制定并定期测试灾害恢复计划，确保在灾难发生时能够快速恢复操作。</li></ol><p>这些安全因素的考虑能够确保机房免受各种潜在风险的影响，保障信息系统的稳定与数据的安全。在实际应用中，应根据机房的规模、功能和位置，以及所支持的业务的重要性，来确定上述安全措施的具体要求和实施方案。</p><h2 id="计算机取证-2"><a href="#计算机取证-2" class="headerlink" title="计算机取证"></a>计算机取证</h2><h3 id="知道常见的取证工具"><a href="#知道常见的取证工具" class="headerlink" title="知道常见的取证工具"></a>知道常见的取证工具</h3><p>确定系统的审核策略auditpol</p><p>转储Windows系统注册表中的特定信息（键）reg</p><p>以文本文件格式转储注册表regdump</p><p>转储SAM数据库，可破解密码pwdump6</p><p>监控成功和失败的系统登录NTLast</p><p>侦测隐藏在NTFS文件流中的文件Sfind</p><p>扫描文件系统找出在某时段内被访问过的文件Afind</p><p>转储Windows系统的事件日志Dumpel</p><h3 id="制定一个简单的取证方案"><a href="#制定一个简单的取证方案" class="headerlink" title="制定一个简单的取证方案"></a>制定一个简单的取证方案</h3><p>制定一个简单的计算机取证方案包括多个步骤，每个步骤都需要遵循特定的协议和最佳实践。以下是一个基础的计算机取证方案示例：</p><h4 id="1-准备阶段"><a href="#1-准备阶段" class="headerlink" title="1. 准备阶段"></a>1. 准备阶段</h4><ul><li><strong>取证计划：</strong> 制定详细的取证分析计划，包括目标、作业范围、所需工具和资源等。</li><li><strong>法律考虑：</strong> 确保有合法权限进行取证调查，了解相关法律、法规和标准。</li><li><strong>取证工具和软件：</strong> 准备必要的取证工具，如磁盘镜像工具、文件恢复工具、取证分析软件等。</li><li><strong>取证团队：</strong> 确定参与取证分析的团队成员的角色和责任。</li></ul><h4 id="2-采集阶段"><a href="#2-采集阶段" class="headerlink" title="2. 采集阶段"></a>2. 采集阶段</h4><ul><li><strong>现场评估：</strong> 如果是实际现场，首先进行现场评估，记录现场情况，拍照或录像。</li><li><strong>证据保护：</strong> 确保证据不被篡改，避免在取证过程中电磁干扰或物理损坏。</li><li><strong>创建数据镜像：</strong> 对存储设备进行物理或逻辑镜像，并验证镜像的完整性（使用哈希值）。</li><li><strong>文档记录：</strong> 记录详细的证据采集过程，包括时间、日期、位置、人员、操作步骤等。</li></ul><h4 id="3-分析阶段"><a href="#3-分析阶段" class="headerlink" title="3. 分析阶段"></a>3. 分析阶段</h4><ul><li><strong>初步审查：</strong> 初步审查镜像文件以确认潜在的证据文件。</li><li><strong>文件恢复：</strong> 使用恢复工具寻找删除、隐藏或丢失的文件。</li><li><strong>日志文件分析：</strong> 分析系统、网络和应用程序的日志文件。</li><li><strong>关键词搜索：</strong> 执行关键词搜索，以查找相关的文件和通讯记录。</li><li><strong>时间线分析：</strong> 构建时间线，以了解事件发生的顺序。</li><li><strong>数据整理：</strong> 整理和分类发现的证据，准备报告。</li></ul><h4 id="4-文档和报告阶段"><a href="#4-文档和报告阶段" class="headerlink" title="4. 文档和报告阶段"></a>4. 文档和报告阶段</h4><ul><li><strong>报告编写：</strong> 编写详细的取证报告，包括方法、发现、结论和推荐。</li><li><strong>证据保管：</strong> 确保所有证据物品得到妥善保存，避免未授权访问和损坏。</li><li><strong>审阅和分析：</strong> 让同行或法律专家审阅报告，确保报告的准确性和完整性。</li></ul><h4 id="5-呈现阶段"><a href="#5-呈现阶段" class="headerlink" title="5. 呈现阶段"></a>5. 呈现阶段</h4><ul><li><strong>法庭陈述：</strong> 准备在法庭上作为证人陈述的材料，包括可视化展示证据。</li><li><strong>证据链维护：</strong> 在法庭上清晰地展示证据链，确保每一环都能够得到证明。</li></ul><h4 id="6-结束阶段"><a href="#6-结束阶段" class="headerlink" title="6. 结束阶段"></a>6. 结束阶段</h4><ul><li><strong>案件复盘：</strong> 审查整个案件处理过程，总结经验教训。</li><li><strong>数据销毁：</strong> 如果法律要求或客户同意，安全销毁敏感数据。</li></ul><p>在执行上述任何步骤时，都需要遵守诚信、保密和合法性的原则，确保证据的可靠性和法庭的可接受性。此外，整个过程中，团队成员应该接受定期培训，以确保他们的技能和知识与行业标准保持同步。</p>]]></content>
    
    
    <summary type="html">信息系统安全期末考试的初步总结，供学弟学妹参考</summary>
    
    
    
    <category term="课程笔记" scheme="https://shuita2333.github.io/project/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="复习总结" scheme="https://shuita2333.github.io/project/tags/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>软件安全作业二——安全的sprintf函数</title>
    <link href="https://shuita2333.github.io/project/2023/12/31/Information_Security_Experiment/software_security/SSH2/"/>
    <id>https://shuita2333.github.io/project/2023/12/31/Information_Security_Experiment/software_security/SSH2/</id>
    <published>2023-12-31T01:00:00.000Z</published>
    <updated>2024-07-07T11:20:41.472Z</updated>
    
    <content type="html"><![CDATA[<ol><li>详述函数编写思路和流程</li></ol><p>本次实现的sprintf函数需要实现以下功能：</p><p>a) 不会产生缓冲区溢出</p><p>b) 不能被格式字符串控制输出内容</p><p>c) 实现安全的变参</p><p>为实现以上功能：<br>函数首先检查传入的目标缓冲区指针和大小是否有效，若无效则返回 -1 表示参数无效。</p><p>使用 va_list 类型的变量 args 来处理可变数量的参数，通过 va_start 宏初始化。</p><p>使用一个循环遍历格式化字符串 format，逐个处理其中的字符：</p><p>对于普通字符，直接将其复制到目标缓冲区中；对于 %s 格式符，从参数中获取字符串，计算其长度，然后将其复制到目标缓冲区中；对于 %d 格式符，从参数中获取整数，将其转换为字符串，然后复制到目标缓冲区中。</p><p>在复制字符串时，会检查缓冲区是否足够大，若不足则返回 -1。</p><p>循环结束后，添加字符串终止符 \0 到目标缓冲区的末尾。</p><p>最后，释放可变参数列表并返回写入目标缓冲区的字符数量（不包括终止符）。如果参数不匹配或缓冲区不足，也返回 -1。</p><ol start="2"><li><p>函数源代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">safe_sprintf</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">size_t</span> sizeOfBuffer, <span class="type">const</span> <span class="type">char</span>* format, ...)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">NULL</span> || sizeOfBuffer == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 参数无效</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">va_list args;</span><br><span class="line"><span class="built_in">va_start</span>(args, format);</span><br><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;  <span class="comment">// 记录写入字符的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*format != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 处理格式化字符串中的普通字符</span></span><br><span class="line"><span class="keyword">if</span> (*format != <span class="string">&#x27;%&#x27;</span> &amp;&amp; i &lt; sizeOfBuffer - <span class="number">1</span>) &#123;</span><br><span class="line">buffer[i++] = *format;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(format + <span class="number">1</span>) == <span class="string">&#x27;s&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 %s 格式符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="built_in">va_arg</span>(args, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计算字符串长度</span></span><br><span class="line"><span class="keyword">if</span> (str == <span class="string">&quot;-1&quot;</span>) &#123;</span><br><span class="line"><span class="comment">//参数不匹配</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (str[len] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + len &lt; sizeOfBuffer) &#123;</span><br><span class="line"><span class="comment">// 复制字符串到缓冲区</span></span><br><span class="line"><span class="type">size_t</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">buffer[i + j] = str[j];</span><br><span class="line">&#125;</span><br><span class="line">i += len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 缓冲区不足</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否能容纳整个字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动 format 指针到 %s 后面</span></span><br><span class="line">format += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(format + <span class="number">1</span>) == <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理 %d 格式符</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> num = <span class="built_in">va_arg</span>(args, <span class="type">long</span> <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配足够的内存来存储整数的字符串表示</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];  <span class="comment">// 调整大小以适应你的需要</span></span><br><span class="line"><span class="built_in">sprintf_s</span>(str, <span class="built_in">sizeof</span>(str), <span class="string">&quot; %d&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查参数是否匹配</span></span><br><span class="line"><span class="keyword">if</span> (str==<span class="string">&quot;-1&quot;</span>) &#123;</span><br><span class="line"><span class="comment">// 参数不匹配</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串长度</span></span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否能容纳整个字符串</span></span><br><span class="line"><span class="keyword">if</span> (i + len &lt; sizeOfBuffer) &#123;</span><br><span class="line"><span class="comment">// 复制字符串到缓冲区</span></span><br><span class="line"><span class="type">size_t</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">buffer[i + j] = str[j];</span><br><span class="line">&#125;</span><br><span class="line">i += len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 缓冲区不足</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">format += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 未知的格式化符号</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">++format;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在字符串末尾添加终止符</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; sizeOfBuffer) &#123;</span><br><span class="line">buffer[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 缓冲区不足</span></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">va_end</span>(args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;  <span class="comment">// 返回写入字符的数量（不包括终止符）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Normal output example:\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">safe_sprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;Hello, %s%d!&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">1111</span>, <span class="string">&quot;-1&quot;</span>);<span class="comment">//正常输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Formatted string: %s\n&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error occurred: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Example of Scalable Buffer:\n&quot;</span>);</span><br><span class="line">result = <span class="built_in">safe_sprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;Helloooooooooooooooooooooooooooooooooooooooo, %s%d!&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">11111</span>, <span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Formatted string: %s\n&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error occurred: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Example of viewing stack content:\n&quot;</span>);</span><br><span class="line">result = <span class="built_in">safe_sprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;Hello, %s%d%s%s%s!&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">11111</span>, <span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Formatted string: %s\n&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error occurred: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Memory Overwrite Example:\n&quot;</span>);</span><br><span class="line">result = <span class="built_in">safe_sprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;Hello, %s%d%s!&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">11111</span>, <span class="string">&quot;Memory Overwrite Memory Overwrite Memory Overwrite&quot;</span>, <span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Formatted string: %s\n&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error occurred: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>运行结果需要截图证明</p></li></ol><p><img src="/../../../images/Information_Security_Experiment/software_security/SSH2/wps111.jpg" alt="img"> </p><p>运行结果</p><p><img src="/../../../images/Information_Security_Experiment/software_security/SSH2/wps112.jpg" alt="img"> </p><p>测试样例</p><p>实验中第一次输出成功；</p><p>第二次验证可伸展的缓冲区和程序崩溃，报错中断；</p><p>第三次验证查看栈内容，报错中断；</p><p>第二次验证内容覆写，报错中断；</p>]]></content>
    
    
    <summary type="html">本次实现的sprintf函数需要实现以下功能，不会产生缓冲区溢出，不能被格式字符串控制输出内容，实现安全的变参</summary>
    
    
    
    <category term="信安课程实验" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="软件安全" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://shuita2333.github.io/project/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="软件安全实验" scheme="https://shuita2333.github.io/project/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>软件安全作业一——安全的strcpy_s函数</title>
    <link href="https://shuita2333.github.io/project/2023/12/31/Information_Security_Experiment/software_security/SSH1/"/>
    <id>https://shuita2333.github.io/project/2023/12/31/Information_Security_Experiment/software_security/SSH1/</id>
    <published>2023-12-30T20:00:00.000Z</published>
    <updated>2024-07-07T11:20:00.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详述函数编写思路和流程"><a href="#详述函数编写思路和流程" class="headerlink" title="详述函数编写思路和流程"></a>详述函数编写思路和流程</h1><p>本次实现的strcpy_s函数需要实现以下功能：</p><p>a) 不会产生缓冲区溢出</p><p>b) 不产生无结尾的字符串</p><p>c) 不意外截断字符串</p><p>因此需要对输入字符串进行判断。</p><p>定义符号：</p><table><thead><tr><th>RSIZE_MAX</th><th>栈空间大小</th></tr></thead><tbody><tr><td>s1</td><td>待复制空间</td></tr><tr><td>s1max</td><td>待复制字符串长度</td></tr><tr><td>s2</td><td>输入字符串</td></tr><tr><td>s1len</td><td>允许复制长度</td></tr></tbody></table><p>对于需求a：需要比对s1max和RSIZE_MAX的大小，即比较申请的复制空间是否超出缓冲区限制，如果s1max &gt; RSIZE_MAX就会发生栈溢出。</p><p>对于需求b和c:需要使得s1max &gt; s1len，否则会发生空结尾错误或发生截断。如果s1max &#x3D; s1len则没有给最后一位空值留出空间，发生空结尾错误。如果s1max &lt; s1len会发生截断。</p><h1 id="函数源代码"><a href="#函数源代码" class="headerlink" title="函数源代码"></a>函数源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">errno_t</span> <span class="title">strcpy_s</span><span class="params">(<span class="type">char</span> *s1, <span class="type">rsize_t</span> s1max, <span class="type">const</span> <span class="type">char</span> *s2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s1 == <span class="literal">NULL</span> || s2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 无效的参数</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s1max &gt; RSIZE_MAX) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// s1max 超过了允许的最大值</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> s1len = <span class="built_in">strlen</span>(s2); <span class="comment">// 查找s2的长度，不超过s1max</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s1len == s1max) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// s2的长度与s1max相同，发生空结尾错误</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s1len &lt; s1max) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(s1, s2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 复制成功</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>; <span class="comment">// s2的长度超过了s1max，会导致截断</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果需要截图证明（3种典型错误）"><a href="#运行结果需要截图证明（3种典型错误）" class="headerlink" title="运行结果需要截图证明（3种典型错误）"></a>运行结果需要截图证明（3种典型错误）</h1><p><img src="/../../../images/Information_Security_Experiment/software_security/SSH1/wps110.jpg" alt="img"> </p><p>实验中第一次复制成功；</p><p>第二次字符串长于复制空间，会被截断；</p><p>第三次字符串长度&#x3D;复制空间长度，发生空结尾错误；</p><p>最后一次申请的复制空间大于缓冲区空间（20），因此会发生缓冲区溢出。</p>]]></content>
    
    
    <summary type="html">本次实现的strcpy_s函数需要实现以下功能，不会产生缓冲区溢出，不产生无结尾的字符串，不意外截断字符串</summary>
    
    
    
    <category term="信安课程实验" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="软件安全" scheme="https://shuita2333.github.io/project/categories/%E4%BF%A1%E5%AE%89%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="北邮信安" scheme="https://shuita2333.github.io/project/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/"/>
    
    <category term="实验报告" scheme="https://shuita2333.github.io/project/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="软件安全实验" scheme="https://shuita2333.github.io/project/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
</feed>
