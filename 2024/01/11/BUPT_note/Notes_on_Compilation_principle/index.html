<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>编译原理与技术课程笔记 | ZYH's blog</title><meta name="author" content="Charmes"><meta name="copyright" content="Charmes"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="编译原理与技术的初步总结，供参考">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理与技术课程笔记">
<meta property="og:url" content="https://shuita2333.github.io/2024/01/11/BUPT_note/Notes_on_Compilation_principle/index.html">
<meta property="og:site_name" content="ZYH&#39;s blog">
<meta property="og:description" content="编译原理与技术的初步总结，供参考">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shuita2333.github.io/images/basic_configuration/tags1-1690700892780-1.png">
<meta property="article:published_time" content="2024-01-11T13:00:00.000Z">
<meta property="article:modified_time" content="2024-07-07T08:22:31.589Z">
<meta property="article:author" content="Charmes">
<meta property="article:tag" content="北邮信安">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shuita2333.github.io/images/basic_configuration/tags1-1690700892780-1.png"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://shuita2333.github.io/2024/01/11/BUPT_note/Notes_on_Compilation_principle/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Charmes","link":"链接: ","source":"来源: ZYH's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '编译原理与技术课程笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-07 16:22:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 8 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><span id="fps"></span><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ZYH's blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 有链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> 关于作者</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span> 随便看看</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../../images/basic_configuration/tags1-1690700892780-1.png')"><nav id="nav"><span id="blog-info"><a href="/" title="ZYH's blog"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo.png"/><span class="site-name">ZYH's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 有链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> 关于作者</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span> 随便看看</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">编译原理与技术课程笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-11T13:00:00.000Z" title="发表于 2024-01-11 21:00:00">2024-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-07T08:22:31.589Z" title="更新于 2024-07-07 16:22:31">2024-07-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="编译原理与技术课程笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="编译原理与技术-郭燕慧"><a href="#编译原理与技术-郭燕慧" class="headerlink" title="编译原理与技术 郭燕慧"></a>编译原理与技术 郭燕慧</h1><h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><table>
<thead>
<tr>
<th>Lexical Analyzer</th>
<th>词法分析</th>
</tr>
</thead>
<tbody><tr>
<td>Syntax Analyzer</td>
<td>语法分析</td>
</tr>
<tr>
<td>Semantic Analyzer</td>
<td>语义分析</td>
</tr>
<tr>
<td>Intermediate Code Generator</td>
<td>中间代码生成</td>
</tr>
<tr>
<td>Machine-Independent Code Optimizer</td>
<td>机器无关的代码优化</td>
</tr>
<tr>
<td>Code Generator</td>
<td>代码生成</td>
</tr>
<tr>
<td>Machine-Dependent Code Optimizer</td>
<td></td>
</tr>
</tbody></table>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul>
<li>将源程序分解为多个组成部分，并对其施加语法结构</li>
<li>使用语法结构创建一个中间表示intermediate representation(IR)的源程序</li>
<li>收集有关源程序的信息，并将其存储在称为符号表的数据结构中(将通过IR传递给后端)</li>
</ul>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul>
<li>根据IR和符号表中的信息构造目标程序(通常用机器语言)</li>
<li>在此过程中执行代码优化</li>
</ul>
<h3 id="词法分析-Lexical-Analyzer"><a href="#词法分析-Lexical-Analyzer" class="headerlink" title="词法分析 Lexical Analyzer"></a>词法分析 Lexical Analyzer</h3><p>&lt;token-name, attribute-value&gt;</p>
<aside>
💡 token-name 在语法分析中使用的抽象符号

</aside>

<aside>
💡 attribute-value 指向符号表中的一个项。表项中的信息用于语义分析和代码生成
</aside>

<p>position &#x3D; initial + rate * 60</p>
<p>Lexical Analyzer</p>
<p>&lt;id, 1&gt;<br>&lt;&#x3D;&gt;<br>&lt;id, 2&gt;<br>&lt;+&gt;<br>&lt;id, 3&gt;<br>&lt;*&gt;<br>&lt;60&gt;</p>
<h3 id="语法分析-Syntax-Analyzer"><a href="#语法分析-Syntax-Analyzer" class="headerlink" title="语法分析 Syntax Analyzer"></a>语法分析 Syntax Analyzer</h3><p>语法分析器(解析器)使用词法分析器生成的令牌名称来创建描述令牌流语法结构的中间表示，通常是语法树</p>
<p>每个内部节点表示一个操作，该节点的子节点表示该操作的参数</p>
<h3 id="语义分析-Semantic-Analysis"><a href="#语义分析-Semantic-Analysis" class="headerlink" title="语义分析 Semantic Analysis"></a>语义分析 Semantic Analysis</h3><p>语义分析器使用语法树和符号表中的信息来检查源程序与语言定义的语义一致性</p>
<p>还收集用于类型检查、类型转换和中间代码生成的类型信息</p>
<p>编程语言的语法描述了其程序的适当形式</p>
<p>编程语言的语义描述了其程序的含义，即每个程序在执行时所做的事情</p>
<h3 id="类型检查-Type-Checking"><a href="#类型检查-Type-Checking" class="headerlink" title="类型检查 Type Checking"></a>类型检查 Type Checking</h3><p>语义分析的一个重要部分是类型检查编译器检查每个操作符是否有匹配的操作数(类型正确)</p>
<h3 id="中间代码生成-Machine-Independent-Code-Optimizer"><a href="#中间代码生成-Machine-Independent-Code-Optimizer" class="headerlink" title="中间代码生成 Machine-Independent Code Optimizer"></a>中间代码生成 Machine-Independent Code Optimizer</h3><ul>
<li>经过语义分析后，编译器生成一个中间值representation, typically three-address code (Three-address code)</li>
<li>类汇编指令，每条指令有三个操作数，每个操作数就像一个寄存器</li>
<li>每个赋值指令在RHS上最多有一个操作符</li>
<li>易于翻译成目标机器的机器指令</li>
</ul>
<h3 id="机器无关的代码优化-Machine-Independent-Code-Optimization"><a href="#机器无关的代码优化-Machine-Independent-Code-Optimization" class="headerlink" title="机器无关的代码优化 Machine-Independent Code Optimization"></a>机器无关的代码优化 Machine-Independent Code Optimization</h3><p>类似于英文的文章编辑&#x2F;修改，改进中间代码以获得更好的目标代码</p>
<p>t1 &#x3D; inttofloat(60) </p>
<p>t2 &#x3D; id3 * t1<br>t3 &#x3D; id2 + t2</p>
<p>id1 &#x3D; t3</p>
<p>—&gt;</p>
<p>t1 &#x3D; id3 * 60.0 </p>
<p>id1 &#x3D; id2 + t1</p>
<h3 id="代码生成-Code-Generator"><a href="#代码生成-Code-Generator" class="headerlink" title="代码生成 Code Generator"></a>代码生成 Code Generator</h3><p>t1 &#x3D; id3 * 60.0 </p>
<p>id1 &#x3D; id2 + t1</p>
<p>Code<br>Generation</p>
<p>LDF R2, id3<br>MULF R2, R2, #60.0 </p>
<p>LDF R1, id2<br>ADDF R1, R1, R2</p>
<p> STF id1, R1</p>
<h3 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h3><ul>
<li>由前端执行，符号表与中间代码一起传递到后端</li>
<li>记录变量名称和存储分配的各种属性、类型、作用域</li>
<li>记录过程名称和各种属性<ul>
<li>参数的数量和类型</li>
<li>传递参数的方式(通过值或引用)</li>
<li>返回类型</li>
</ul>
</li>
</ul>
<h3 id="中间语言（Intermediate-Language）IL"><a href="#中间语言（Intermediate-Language）IL" class="headerlink" title="中间语言（Intermediate Language）IL"></a><strong><strong>中间语言（Intermediate Language）IL</strong></strong></h3><h3 id="编译器与解释器的区别"><a href="#编译器与解释器的区别" class="headerlink" title="编译器与解释器的区别"></a>编译器与解释器的区别</h3><ul>
<li><p>1</p>
<p>  编译器将用高级语言编写的源程序翻译成可以直接在目标计算机上运行的机器码。</p>
<p>  解释器直接执行源代码中的每条语句，而不需要将程序编译成机器码。</p>
</li>
<li><p>2</p>
<p>  解释器通常花费较少的时间来分析源代码:他们只是解析每个语句并执行它(例如，Python代码)。</p>
<p>  相比之下，编译器通常会分析语句之间的关系(例如，控制流和数据流)以实现优化。</p>
</li>
<li><p>3</p>
<p>  解释器继续执行程序，直到遇到第一个错误，在这种情况下它们停止。</p>
<p>  对于编译语言，程序只有在编译成功后才可执行。</p>
</li>
</ul>
<h2 id="编译器的结构-1"><a href="#编译器的结构-1" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><table>
<thead>
<tr>
<th>Lexical Analyzer</th>
<th>词法分析</th>
</tr>
</thead>
<tbody><tr>
<td>Syntax Analyzer</td>
<td>语法分析</td>
</tr>
<tr>
<td>Semantic Analyzer</td>
<td>语义分析</td>
</tr>
<tr>
<td>Intermediate Code Generator</td>
<td>中间代码生成</td>
</tr>
<tr>
<td>Machine-Independent Code Optimizer</td>
<td>机器无关的代码优化</td>
</tr>
<tr>
<td>Code Generator</td>
<td>代码生成</td>
</tr>
<tr>
<td>Machine-Dependent Code Optimizer</td>
<td></td>
</tr>
</tbody></table>
<h3 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h3><ul>
<li>将源程序分解为多个组成部分，并对其施加语法结构</li>
<li>使用语法结构创建一个中间表示intermediate representation(IR)的源程序</li>
<li>收集有关源程序的信息，并将其存储在称为符号表的数据结构中(将通过IR传递给后端)</li>
</ul>
<h3 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h3><ul>
<li>根据IR和符号表中的信息构造目标程序(通常用机器语言)</li>
<li>在此过程中执行代码优化</li>
</ul>
<h3 id="词法分析-Lexical-Analyzer-1"><a href="#词法分析-Lexical-Analyzer-1" class="headerlink" title="词法分析 Lexical Analyzer"></a>词法分析 Lexical Analyzer</h3><p>&lt;token-name, attribute-value&gt;</p>
<aside>
💡 token-name 在语法分析中使用的抽象符号

</aside>

<aside>
💡 attribute-value 指向符号表中的一个项。表项中的信息用于语义分析和代码生成

</aside>

<p>position &#x3D; initial + rate * 60</p>
<p>Lexical Analyzer</p>
<p>&lt;id, 1&gt;<br>&lt;&#x3D;&gt;<br>&lt;id, 2&gt;<br>&lt;+&gt;<br>&lt;id, 3&gt;<br>&lt;*&gt;<br>&lt;60&gt;</p>
<h3 id="语法分析-Syntax-Analyzer-1"><a href="#语法分析-Syntax-Analyzer-1" class="headerlink" title="语法分析 Syntax Analyzer"></a>语法分析 Syntax Analyzer</h3><p>语法分析器(解析器)使用词法分析器生成的令牌名称来创建描述令牌流语法结构的中间表示，通常是语法树</p>
<p>每个内部节点表示一个操作，该节点的子节点表示该操作的参数</p>
<h3 id="语义分析-Semantic-Analysis-1"><a href="#语义分析-Semantic-Analysis-1" class="headerlink" title="语义分析 Semantic Analysis"></a>语义分析 Semantic Analysis</h3><p>语义分析器使用语法树和符号表中的信息来检查源程序与语言定义的语义一致性</p>
<p>还收集用于类型检查、类型转换和中间代码生成的类型信息</p>
<p>编程语言的语法描述了其程序的适当形式</p>
<p>编程语言的语义描述了其程序的含义，即每个程序在执行时所做的事情</p>
<h3 id="类型检查-Type-Checking-1"><a href="#类型检查-Type-Checking-1" class="headerlink" title="类型检查 Type Checking"></a>类型检查 Type Checking</h3><p>语义分析的一个重要部分是类型检查编译器检查每个操作符是否有匹配的操作数(类型正确)</p>
<h3 id="中间代码生成-Machine-Independent-Code-Optimizer-1"><a href="#中间代码生成-Machine-Independent-Code-Optimizer-1" class="headerlink" title="中间代码生成 Machine-Independent Code Optimizer"></a>中间代码生成 Machine-Independent Code Optimizer</h3><ul>
<li>经过语义分析后，编译器生成一个中间值representation, typically three-address code (Three-address code)</li>
<li>类汇编指令，每条指令有三个操作数，每个操作数就像一个寄存器</li>
<li>每个赋值指令在RHS上最多有一个操作符</li>
<li>易于翻译成目标机器的机器指令</li>
</ul>
<h3 id="机器无关的代码优化-Machine-Independent-Code-Optimization-1"><a href="#机器无关的代码优化-Machine-Independent-Code-Optimization-1" class="headerlink" title="机器无关的代码优化 Machine-Independent Code Optimization"></a>机器无关的代码优化 Machine-Independent Code Optimization</h3><p>类似于英文的文章编辑&#x2F;修改，改进中间代码以获得更好的目标代码</p>
<p>t1 &#x3D; inttofloat(60) </p>
<p>t2 &#x3D; id3 * t1<br>t3 &#x3D; id2 + t2</p>
<p>id1 &#x3D; t3</p>
<p>—&gt;</p>
<p>t1 &#x3D; id3 * 60.0 </p>
<p>id1 &#x3D; id2 + t1</p>
<h3 id="代码生成-Code-Generator-1"><a href="#代码生成-Code-Generator-1" class="headerlink" title="代码生成 Code Generator"></a>代码生成 Code Generator</h3><p>t1 &#x3D; id3 * 60.0 </p>
<p>id1 &#x3D; id2 + t1</p>
<p>Code<br>Generation</p>
<p>LDF R2, id3<br>MULF R2, R2, #60.0 </p>
<p>LDF R1, id2<br>ADDF R1, R1, R2</p>
<p> STF id1, R1</p>
<h3 id="符号表管理-1"><a href="#符号表管理-1" class="headerlink" title="符号表管理"></a>符号表管理</h3><ul>
<li>由前端执行，符号表与中间代码一起传递到后端</li>
<li>记录变量名称和存储分配的各种属性、类型、作用域</li>
<li>记录过程名称和各种属性<ul>
<li>参数的数量和类型</li>
<li>传递参数的方式(通过值或引用)</li>
<li>返回类型</li>
</ul>
</li>
</ul>
<h3 id="中间语言（Intermediate-Language）IL-1"><a href="#中间语言（Intermediate-Language）IL-1" class="headerlink" title="中间语言（Intermediate Language）IL"></a><strong><strong>中间语言（Intermediate Language）IL</strong></strong></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%203.png" alt="Untitled"></p>
<h3 id="编译器与解释器的区别-1"><a href="#编译器与解释器的区别-1" class="headerlink" title="编译器与解释器的区别"></a>编译器与解释器的区别</h3><ul>
<li><p>1</p>
<p>  编译器将用高级语言编写的源程序翻译成可以直接在目标计算机上运行的机器码。</p>
<p>  解释器直接执行源代码中的每条语句，而不需要将程序编译成机器码。</p>
</li>
<li><p>2</p>
<p>  解释器通常花费较少的时间来分析源代码:他们只是解析每个语句并执行它(例如，Python代码)。</p>
<p>  相比之下，编译器通常会分析语句之间的关系(例如，控制流和数据流)以实现优化。</p>
</li>
<li><p>3</p>
<p>  解释器继续执行程序，直到遇到第一个错误，在这种情况下它们停止。</p>
<p>  对于编译语言，程序只有在编译成功后才可执行。</p>
</li>
</ul>
<h1 id="第二章词法分析器"><a href="#第二章词法分析器" class="headerlink" title="第二章词法分析器"></a>第二章词法分析器</h1><h2 id="词法分析器的作用"><a href="#词法分析器的作用" class="headerlink" title="词法分析器的作用"></a>词法分析器的作用</h2><ul>
<li>读取输入字符的源程序，将它们转换为词素，并生成一个标记序列</li>
<li>必要时向符号表中添加词素去掉注释和空白(空白、换行、制表符等)。</li>
<li>将错误消息与行号关联(跟踪换行)</li>
</ul>
<p>有效执行简单任务、提高编译器效率（比语法分析简单的多）、提高编译器可移植性</p>
<h3 id="Tokens-Patterns-and-Lexemes"><a href="#Tokens-Patterns-and-Lexemes" class="headerlink" title="Tokens, Patterns, and Lexemes"></a>Tokens, Patterns, and Lexemes</h3><p>token由一对&lt;token name, attribute value&gt;组成，&lt;抽象符号，字符表内容&gt;</p>
<p>patterns是对tokens的词素可能采取的形式的描述。</p>
<p>lexeme就是所表示的实例</p>
<p>例子：printf(“Total &#x3D;%d\n”, score)</p>
<table>
<thead>
<tr>
<th>Lexeme</th>
<th>printf</th>
<th>scorce</th>
<th>“Total &#x3D;%d\n”</th>
<th>(</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>Token</td>
<td>id</td>
<td>id</td>
<td>literal</td>
<td>left_parenthesis</td>
<td>…</td>
</tr>
</tbody></table>
<h3 id="token属性"><a href="#token属性" class="headerlink" title="token属性"></a>token属性</h3><p>token name：影响属性决策</p>
<p>attribute value：影响代码分析生成</p>
<h2 id="令牌规范-正则表达式"><a href="#令牌规范-正则表达式" class="headerlink" title="令牌规范(正则表达式)"></a>令牌规范(正则表达式)</h2><p>Regular expression (正则表达式,regexp)指词素模式的重要符号</p>
<ul>
<li>Strings and Languages (串和语言)</li>
<li>Operations on Languages (语言上的运算)</li>
<li>Regular Expressions</li>
<li>Regular Definitions (正则定义)</li>
<li>Extensions of Regular Expressions</li>
</ul>
<h3 id="字符串和语言"><a href="#字符串和语言" class="headerlink" title="字符串和语言"></a>字符串和语言</h3><p>Alphabet(字母表):任何有限的符号集合</p>
<p>符号的例子:字母、数字和标点符号</p>
<p>字母的例子:(1,0)，ASCII, Unicode</p>
<p>string（串)是从字母表中抽取的符号的有限序列</p>
<p>字符串s的长度，记为Isl，是数符号在s中的出现次数(即基数)</p>
<p>Empty string（空字符串）:长度为0，ε</p>
<p><strong>与字符串相关的术语</strong></p>
<p>Prefix 前缀:从的末尾删除0个或多个符号获得的任何字符串。</p>
<p>Proper prefix 真前缀:不是ε也不等于s本身的前缀。</p>
<p>Suffix 后缀:从s 的开头删除0个或多个符号后获得的任何字符串。</p>
<p>Proper suffix 真后缀:非ε且不等于s的后缀本身</p>
<p>Substring (子串):从s中删除任何前缀和后缀而得到的任何字符串。</p>
<p>Proper substring (真子串):不是ε且不等于s本身的子字符串。</p>
<p>Subsequence (子序列):从s中去掉0个或多个不一定连续的符号而形成的字符串</p>
<p>Concatenation (连接)：x &#x3D; dog, y &#x3D; house, xy &#x3D; doghouse</p>
<p>Exponentiation (幂&#x2F;指数运算)：</p>
<p>$$<br>x &#x3D; dog, x^0 &#x3D; ε,x^1 &#x3D; dog,x^3 &#x3D; dogdogdog<br>$$</p>
<p>language (语言):任何可数集合的一些固定字母</p>
<h3 id="Operations-on-Languages-语言的运算"><a href="#Operations-on-Languages-语言的运算" class="headerlink" title="Operations on Languages (语言的运算)"></a>Operations on Languages (语言的运算)</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%204.png" alt="Untitled"></p>
<p>优先级:closure*&gt; concatenation &gt; union</p>
<h2 id="令牌识别-转换图"><a href="#令牌识别-转换图" class="headerlink" title="令牌识别(转换图)"></a>令牌识别(转换图)</h2><p>词法分析器检查输入字符串并找到一个前缀匹配其中一个标记</p>
<p>构建词法分析器的第一件事是使用常规定义定义令牌的模式</p>
<p>一个特殊的token: ws→(blank I tab I newline)*</p>
<h2 id="Transition-Diagrams-状态转换图"><a href="#Transition-Diagrams-状态转换图" class="headerlink" title="Transition Diagrams (状态转换图)"></a>Transition Diagrams (状态转换图)</h2><p>构造词法分析器的一个重要步骤是将模式转换为“转换图”。</p>
<p>转换图有一组节点，称为状态(state)和边缘(edge)，从一个节点指向另一个节点</p>
<p><strong>States</strong></p>
<p>起始状态由标记为“start”的边表示，它从任何地方进入</p>
<p>接受状态，或者是最终的，表明已经找到了一个词素</p>
<p><strong>States Cont</strong></p>
<p>在某些接受状态下，找到的词素可能不包含我们从开始状态看到的所有字符</p>
<p>这样的状态用*来注释当进入状态时，需要收回指向输入字符串中下一个字符的前向指针。</p>
<p><strong>Edges</strong></p>
<p>边从一种状态指向另一种状态</p>
<p>每条边都用一个或一组符号来标记</p>
<p><strong>Recognition of Reserved Words and Identifiers (保留字和标识符的识别)</strong></p>
<p>在许多语言中，保留词或关键字(例如，then)还要匹配标识符的模式</p>
<h2 id="构建整个词法分析器"><a href="#构建整个词法分析器" class="headerlink" title="构建整个词法分析器"></a>构建整个词法分析器</h2><p>策略1:依次尝试每个令牌的转换图</p>
<p>Fail()向前重置指针并开始下一个图表</p>
<p>策略2:并行运行转换图</p>
<p>需要解决一个图找到一个词素，而其他图仍然能够处理输入的情况。</p>
<p>解决方案:使用与任何模式匹配的最长的输入前缀</p>
<p>策略3:将所有转换图组合为一个(首选)</p>
<p>允许转换图读取输入，直到没有可能下一个状态取与任何模式匹配的最长词素</p>
<h2 id="词法分析器生成器"><a href="#词法分析器生成器" class="headerlink" title="词法分析器生成器"></a>词法分析器生成器</h2><p>Lex程序有三个部分，用%%分隔</p>
<ul>
<li>Declaration (声明)</li>
<li>Translation rules (转换规则)</li>
<li>Auxiliary functions section (辅助函数)</li>
</ul>
<h2 id="Finite-Automata-有穷自动机"><a href="#Finite-Automata-有穷自动机" class="headerlink" title="Finite Automata (有穷自动机)"></a>Finite Automata (有穷自动机)</h2><h3 id="Nondeterministic-finite-automata-NFA-非确定有穷自动机"><a href="#Nondeterministic-finite-automata-NFA-非确定有穷自动机" class="headerlink" title="Nondeterministic finite automata (NFA, 非确定有穷自动机)"></a>Nondeterministic finite automata (NFA, 非确定有穷自动机)</h3><p>当一个状态面对一个输入符号的时候，所转换到的是一个唯一确定的状态。</p>
<p>S &#x3D; {0, 1, 2, 3}<br>Start state: 0<br>Accepting states: {3}<br>Transition function<br>▪ (0, a) → {0, 1} (0, b) → {0}<br>▪ (1, b) → {2} (2, b) → {3}</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%205.png" alt="Untitled"></p>
<h3 id="Transition-Table-转换表"><a href="#Transition-Table-转换表" class="headerlink" title="Transition Table 转换表"></a>Transition Table 转换表</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%206.png" alt="Untitled"></p>
<h3 id="Deterministic-finite-automata-DFA-确定有穷自动机"><a href="#Deterministic-finite-automata-DFA-确定有穷自动机" class="headerlink" title="Deterministic finite automata (DFA, 确定有穷自动机)"></a>Deterministic finite automata (DFA, 确定有穷自动机)</h3><p>当一个状态面对一个输入符号的时候，它所转换到的可能不只一个状态，可以是一个状态集合。</p>
<h1 id="第三章-语法分析"><a href="#第三章-语法分析" class="headerlink" title="第三章:语法分析"></a>第三章:语法分析</h1><h2 id="描述语法"><a href="#描述语法" class="headerlink" title="描述语法"></a>描述语法</h2><blockquote>
<p>编程语言结构的语法可以通过上下文无关语法或BNF（Backus Naur Form）表示法指定<br>语法为编程语言提供了精确但易于理解的语法规范<br>对于某些语法，我们可以自动构建一个高效的解析器<br>设计得当的语法定义了一种语言的结构，有助于将源程序翻译成正确的目标代码并检测错误<br>语法允许通过添加新的结构来执行新的任务来迭代地进化或开发一种语言</p>
</blockquote>
<h3 id="语法分析器的角色"><a href="#语法分析器的角色" class="headerlink" title="语法分析器的角色"></a>语法分析器的角色</h3><ul>
<li>语法分析器从词法分析器获得token串，并验证token名称是否可以由源语言的语法生成</li>
<li>以智能的方式报告语法错误</li>
<li>对于格式良好的程序，语法分析器构建一个语法分析树<br>语法分析树无需显式构建</li>
</ul>
<h2 id="语法分析器的分类"><a href="#语法分析器的分类" class="headerlink" title="语法分析器的分类"></a>语法分析器的分类</h2><p>· 通用语法分析器</p>
<p>· 一些方法（例如，Earley算法1）可以解析任何语法<br>· 然而，它们效率太低，无法在实践中使用</p>
<p>· 自顶向下语法分析器</p>
<p>· 构建从顶部（根）到底部（叶）的语法分析树</p>
<p>· 自底向上语法分析器</p>
<p>·从底部（叶子）到顶部（根）构建语法分析树</p>
<p>注意：自上而下和自下而上的解析都从左到右扫描输入，一次扫描一个符号。它们只适用于某些语法，这些语法具有足够的表达能力。</p>
<h3 id="Context-Free-Grammar-上下文无关文法"><a href="#Context-Free-Grammar-上下文无关文法" class="headerlink" title="Context-Free Grammar (上下文无关文法)"></a>Context-Free Grammar (上下文无关文法)</h3><p>上下文无关语法（CFG）由四个部分组成：<br>· Terminals终结符号: 形成字符串的基本符号（token名称）<br>· Nonterminals非终结符号: 表示字符串集的语法变量 通常对应于一个语言结构，如stmt（statements）      一个非终结符被区分为开始符号 由开始符号表示的字符串集是CFG生成的语言<br>·Productions 产生式: 指定终结符号和非终结符号组合形成字符串的方式<br>     格式：head（左侧）-&gt; body（右侧）<br>     head是非终结符号；body由零个或多个终结符号或非终结符号组成<br>     例如：expression -&gt; expression + term</p>
<p>下面的语法定义了简单的算术表达式</p>
<p>Terminal symbols: id, +, -, *, &#x2F;, (, )<br>Nonterminals: expression, term, factor<br>Start symbol: expression<br>Productions:</p>
<p>expression → expression + term<br>expression → expression – term<br>expression → term<br>term → term * factor<br>term → term &#x2F; factor<br>term → factor<br>factor → ( expression )<br>factor → id</p>
<blockquote>
<p>符号简化<br>E → E + T | E – T | T<br>T → T * F | T &#x2F; F | F<br>F → ( E ) | id</p>
</blockquote>
<p>“|”是指定备选方案的元符号<br>“(”和”)”不是元符号，而是终结符号</p>
<h3 id="Derivation-推导"><a href="#Derivation-推导" class="headerlink" title="Derivation (推导)"></a>Derivation (推导)</h3><p>推导: 从开始符号开始，使用产生式重写非终结符，直到只剩下终结符为止</p>
<h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>⇒ 意思是“一步到位”<br>⇒ ∗ 意思是“以零个或多个步骤推导”	𝛼 ⇒∗ 𝛼 适用于任何字符串𝛼<br>⇒ “ 意思是“以一个或多个步骤推导”</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>• 如果S⇒ ∗ α, 其中S是语法G的开始符号，我们说α是G文法的句型<br>· 文法的句型可以同时包含终结符号和非终结符号，并且可以为空<br>· 示例𝐸 ⇒ −𝐸 ⇒ −(𝐸)⇒ −(𝐸+𝐸) ⇒ −(𝐢𝐝+𝐸) ⇒ −(𝐢𝐝 + 𝐢𝐝) 这里所有的语法符号串都是文法的句型<br>• 一个G的句子是一个没有非终结符的文法句型<br>· 在上面的例子中，只有最后一个字符串−(𝐢𝐝 + 𝐢𝐝)是一个句子<br>•语法产生的语言是它的一组句子</p>
<h3 id="最左-最右推导"><a href="#最左-最右推导" class="headerlink" title="最左&#x2F;最右推导"></a>最左&#x2F;最右推导</h3><p>在推导的每一步，我们都需要选择要替换的非终结符<br>在最左推导中,总是选择每个句型中最左边的非终结符来替换<br>在最右推导中, 总是选择最右边的非终结符来替换</p>
<h3 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h3><p>语法分析树是一种推导的图形表示，它过滤掉了产生式应用的顺序<br>· 根结点是文法的开始符号<br>· 每个叶子结点由终结符或𝜖标记<br>· 每个内部结点由非终结符标记<br>· 每个内部结点代表产生式的应用<br>· 内部节点用产生式的头部中的非终结符进行标记；<br>· 子节点由产生式主体中的符号从左到右进行标记</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%207.png" alt="Untitled"></p>
<h2 id="Ambiguity-二义性"><a href="#Ambiguity-二义性" class="headerlink" title="Ambiguity (二义性)"></a>Ambiguity (二义性)</h2><p>如果一个语法为某个句子生成了多个语法分析树，则它具有二义性<br>示例：该文法为id+id*id生成了两种语法分析树。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%208.png" alt="Untitled"></p>
<p>程序设计语言的语法通常需要明确<br>· 否则，将有多种方法来解释程序<br>· 问题：给定𝐸 → 𝐸 + 𝐸 | 𝐸 ∗ 𝐸 | (𝐸) | 𝐢𝐝, 如何解读 𝑎 + 𝑏 ∗ 𝑐?<br>· 答案：该文法是上一张PPT的示例，根据两种语法分析树，第一种解释：应先处理b*c，然后与a相加；第二种解释：应先处理a+b，然后与c相乘<br>在某些情况下，使用精心选择的歧义语法以及消歧规则来丢弃不需要的语法分析树是很方便的 </p>
<h2 id="CFG与正则表达式比较-CFG-vs-Regular-Expressions"><a href="#CFG与正则表达式比较-CFG-vs-Regular-Expressions" class="headerlink" title="CFG与正则表达式比较 CFG vs. Regular Expressions"></a>CFG与正则表达式比较 CFG vs. Regular Expressions</h2><p>CFG比正则表达式更具表达能力<br>· 可以用正则表达式描述的每个构造都可以用语法描述，但反之不成立<br>· 每个正则语言都是上下文无关的语言，但反之不成立<br>示例：$𝐿 &#x3D;{𝑎^𝑛𝑏^𝑛 | 𝑛&gt; 0}$<br>语言L可以用CFG：𝑆 → 𝑎𝑆𝑏 | 𝑎𝑏 来描述<br>L不能用正则表达式来描述。换句话说，我们不能构造一个DFA来接受L</p>
<h3 id="任何正则语言都可以用CFG描述"><a href="#任何正则语言都可以用CFG描述" class="headerlink" title="任何正则语言都可以用CFG描述"></a>任何正则语言都可以用CFG描述</h3><p>（结构证明）NFA可以接受每种常规语言。我们可以构造一个CFG来描述语言：<br>· 对于每个在NFA中的状态 𝑖 ，创建一个非终结符𝐴𝑖<br>· 如果状态𝑖 在碰到输入a转为状态j 时, 添加产生式$𝐴_𝑖→ 𝐴_j$<br>· 如果状态𝑖 是一个接受状态，添加产生式𝐴𝑖→𝜖<br>· 如果状态𝑖 是开始状态，将𝐴𝑖作为文法的开始符号</p>
<h2 id="语法设计"><a href="#语法设计" class="headerlink" title="语法设计"></a>语法设计</h2><p>CFG能够描述编程语言的大部分（但不是全部）语法<br>· CFG不能描述“使用前应声明标识符”<br>· 后续阶段必须分析解析器的输出，以确保符合此类规则<br>在解析之前，我们通常对语法进行几种转换，使其更适合解析<br>· 消除二义性<br>· 消除左递归<br>· 提取左公因子</p>
<h3 id="消除二义性"><a href="#消除二义性" class="headerlink" title="消除二义性"></a>消除二义性</h3><p>接近原则：用最接近的未匹配的then匹配else<br>· 重写的想法：出现在then和else之间的语句必须匹配（不能以不匹配的the结束）<br>重写语法以消除歧义是困难的。没有指导这一过程的一般规则。</p>
<h3 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h3><p>如果语法中存在一个非终结符A，使得某个字符𝛼有相关的产生式𝐴 ⇒+ 𝐴𝛼 ，则该语法为左递归语法<br>立即左递归: 语法有产生式𝐴 -&gt; 𝐴𝛼<br>自顶向下分析方法无法处理左递归语法（自底向上的分析方法可以处理…）</p>
<p><strong>消除立即左递归</strong><br>简单语法：𝐴 → 𝐴𝛼 | 𝛽 它生成以符号𝛽开头的句子，后面跟零个或更多的𝛼’s<br>将语法替换为：<br>𝐴 → 𝛽A’<br>A’ → 𝛼A’ | 𝜖<br>它现在是右递归了</p>
<blockquote>
<p>𝐴 → 𝐴𝛼1|…|𝐴𝛼𝑚|𝛽1|… | 𝛽𝑛<br>将语法替换为：<br>𝐴 →𝛽1A’ | … |𝛽nA’<br>A’ → 𝛼1A’ | … | 𝛼mA’ |𝜖</p>
</blockquote>
<p>例子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%209.png" alt="Untitled"></p>
<p>消除左递归<br>消除立即左递归的技术不适用于非立即左递归<br>通用左递归消除算法（迭代）<br>· 输入：没有循环或𝜖-产生式<br>· 输出：没有左递归的等价语法</p>
<h2 id="Left-Factoring-提取左公因子"><a href="#Left-Factoring-提取左公因子" class="headerlink" title="Left Factoring (提取左公因子)"></a>Left Factoring (提取左公因子)</h2><p>如果我们有以下两个产生式</p>
<p>𝑠𝑡𝑚𝑡 → 𝐢𝐟 𝑒𝑥𝑝𝑟 𝐭𝐡𝐞𝐧 𝑠𝑡𝑚𝑡 𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡  |	𝐢𝐟 𝑒𝑥𝑝𝑟 𝐭𝐡𝐞𝐧 𝑠𝑡𝑚𝑡<br>看到输入时𝐢𝐟, 我们无法立即决定选择哪个产生式<br>一般来说，如果𝐴 → 𝛼𝛽1 | 𝛼𝛽2是两个产生式，并且输入以从𝛼派生的非空字符串开始. 我们可以通过扩大𝐴 到𝛼𝐴‘来推迟选择产生式</p>
<h2 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h2><p>问题定义：为输入字符串构建一个语法分析树，从根开始，按预序创建语法分析树的节点（深度优先）<br>· 相当于为输入字符串找到最左推导<br>基本思想（两个步骤）：<br>· 预测：在解析的每一步，确定最左边非终结符所用的生产式<br>· 匹配：将所选产生式主体中的终结符与输入字符串相匹配</p>
<h2 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h2><p>问题定义：为输入字符串构建一个从叶子（终结符）开始并向上延伸到根（语法的开始符号）的语法分析树<br>· 相当于为输入字符串找到最右推导（相反）<br>移入-归约分析技术是自底向上语法分析的通用方式（使用栈来保存语法符号）</p>
<p>自底向上语法分析可以看作是一个将字符串𝜔“归约”到开始符号的过程<br>在每一个归约步骤中，与产生式主体匹配的特定子串（位于堆栈顶部）都会被产生式的头部替换（与推导步骤相反）</p>
<h2 id="递归下降的语法分析"><a href="#递归下降的语法分析" class="headerlink" title="递归下降的语法分析"></a>递归下降的语法分析</h2><p>递归下降的语法分析程序对于每个非终结符都有一套程序<br>· 该程序会扫描与非终结符对应的结构（输入的子字符串）<br>从开始符号的程序开始执行<br>· 如果程序扫描整个输入字符串，则宣布成功</p>
<h2 id="Backtracking-回溯"><a href="#Backtracking-回溯" class="headerlink" title="Backtracking (回溯)"></a>Backtracking (回溯)</h2><p>一般的递归下降语法分析可能需要对输入进行重复扫描（回溯）</p>
<blockquote>
<p>算法流程更改：<br>与考察A-产生式不同，我们必须按照一定的顺序尝试每一种可能的产生式。<br>当第7行出现故障时，返回第1行并尝试另一个A产生式<br>为了尝试另一个A-产生式时，我们必须重置指向下一个要扫描的符号的输入指针（失败尝试的消耗符号）</p>
</blockquote>
<p>左递归带来的问题<br>如果CFG中有左递归，递归下降的语法分析器可能会进入无限循环，所以需要解析前修改CFG</p>
<h3 id="𝐹𝐼𝑅𝑆𝑇"><a href="#𝐹𝐼𝑅𝑆𝑇" class="headerlink" title="𝐹𝐼𝑅𝑆𝑇()"></a>𝐹𝐼𝑅𝑆𝑇()</h3><blockquote>
<p>假设输入字符串为𝒙𝒂<br>假设当前的句型是𝒙𝑨β<br>· 𝑨 是非终结符；β可以同时包含终结符和非终结符<br>如果我们知道产生式𝑨 → 𝑎 | 𝜸的以下事实:<br>·𝑎 ∈ 𝐹𝐼𝑅𝑆𝑇(𝛼) ：𝛼 可以推导以a开头的字符串<br>·𝑎 ∉ 𝐹𝐼𝑅𝑆𝑇(𝛾)：𝛾 不可以推导出以a开头的字符串<br>*𝐹𝐼𝑅𝑆𝑇(𝛼) 表示可从α推导得到的串的首符号的集合</p>
</blockquote>
<p>计算FIRST(𝑿) 𝑋 是语法符号<br>· 如果𝑋 是一个终结符，那么FIRST(𝑋) &#x3D; {𝑋}<br>· 如果X是一个非终结符，且𝑋 → 𝑌1𝑌2 … 𝑌𝑘 (𝑘 ≥ 1) 是一个产生式<br>    · 如果对于某个𝑖，𝑎在FIRST(𝑌i)中且𝜖在所有的FIRST(𝑌1), …, FIRST(𝑌i-1)中，就把𝑎加入到FIRST(𝑋)中<br>    · 如果对于所有的FIRST(𝑌1), …, FIRST(𝑌𝑘)，𝜖在其中，那么将𝜖加入到FIRST(𝑋)中<br>· 如果X是一个非终结符，并且存在产生式𝑋 → 𝜖，那么将𝜖加入到FIRST(𝑋)中</p>
<p>计算FIRST(𝑿𝟏𝑿𝟐 … 𝑿𝒏) 𝑿𝟏𝑿𝟐 … 𝑿𝒏是语法符号的串<br>· 向FIRST(𝑋1𝑋2 … 𝑋𝑛)加入FIRST(𝑋1)中所有的非𝜖符号<br>· 如果𝜖在FIRST(𝑋1)中，再加入FIRST(𝑋2)中所有的非𝜖符号；如果𝜖在FIRST(𝑋1)和FIRST(𝑋2)中，加入FIRST(𝑋3)中的所有非𝜖符号，以此类推。<br>· 最后，如果对于所有的i，𝜖都在FIRST(𝑋i)中，那么将加入到FIRST(𝑋1𝑋2 … 𝑋𝑛)中。</p>
<blockquote>
<p>假设输入字符串为𝒙𝒂<br>假设当前的句型是𝒙𝑨β<br>· 𝑨 是非终结符；β可以同时包含终结符和非终结符<br>如果我们知道生产𝑨 →𝛼, 𝜖 ∈ 𝐹𝐼𝑅𝑆𝑇(𝛼), 我们能选择重写A的产生式吗?<br>可以，只有在𝛽 可以推导以𝑎开头的字符串, 即，在一些句型中𝐴 后面可以跟着𝑎 （即，𝒂 ∈ 𝑭𝑶𝑳𝑳𝑶𝑾(𝑨))</p>
</blockquote>
<p>计算FOLLOW集<br>计算所有非终结符A的FOLLOW(A)集合<br>· 将$反复到中，其中S是开始符号，二是输入右端的结束标记<br>· 不断应用下面的规则，直到所有FOLLOW集不再改变<br>    · 如果存在一个产生式𝐴 → 𝛼𝐵𝛽，那么FIRST(𝛽)中除𝜖之外的所有符号都在FOLLOW(𝐵)<br>中<br>     · 如果存在一个产生式𝐴 → 𝛼𝐵 ，或存在产生式𝐴 → 𝛼𝐵𝛽且FIRST(𝛽)包含𝜖，那么FOLLOW(𝐴)中的所有符号都在FOLLOW(𝐵)<br>中<br>𝜖不会在任何FOLLOW集中</p>
<h2 id="LL-1-Grammars"><a href="#LL-1-Grammars" class="headerlink" title="LL(1) Grammars"></a>LL(1) Grammars</h2><p>我们可以为一类称为LL(1)的语法构造不需要回溯的递归下降语法分析器<br>从左到右扫描输入<br>产生最左推导<br>在每一步使用一个前瞻输入符号来作出分析决策</p>
<blockquote>
<p>语法𝑮 是LL(1)当且仅当对于任意两个不同的产生式𝐴 → 𝛼 | 𝛽, 以下条件成立：<br>1.不存在终结符𝑎 使得𝛼 和𝛽 都可以推导以𝑎开头的字符串<br>2.𝛼 和𝛽 中最多只有一个可以推导空字符串<br>3.如果𝛽 ⇒* 𝜖, 那么𝛼 不能推导出任何以FOLLOW(𝐴)中某个终结符开头的字符串，反之亦然<br>*这三个条件基本上排除了应用两个产生式的可能性<br>更正式地说：</p>
</blockquote>
<ol>
<li>FIRST(𝛼)∩ FIRST(𝛽)&#x3D; ∅ （上述条件1-2）<br>如果𝜖 ∈ FIRST(𝛽)，那么 FIRST(𝛼)∩ FOLLOW(𝐴)&#x3D; ∅ ，反之亦然<blockquote>
</blockquote>
</li>
</ol>
<p>对于LL(1)语法，在递归下降语法分析过程中，只需查看当前输入符号，就可以选择应用于非终结符的正确产生式：<br>给定文法<br>给出输入的分析步骤：<br>1.用产生式①重写开始符号stmt： 𝐢𝐟(𝐞𝐱𝐩𝐫)𝑠𝑡𝑚𝑡 𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡<br>2.用产生式②重写最左边的stmt：𝐢𝐟(𝐞𝐱𝐩𝐫)𝐰𝐡𝐢𝐥𝐞(𝐞𝐱𝐩𝐫) 𝑠𝑡𝑚𝑡  𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡<br>3.用产生式③重写最左边的stmt：𝐢𝐟(𝐞𝐱𝐩𝐫)𝐰𝐡𝐢𝐥𝐞(𝐞𝐱𝐩𝐫) 𝐚 𝐞𝐥𝐬𝐞 𝑠𝑡𝑚𝑡<br>4.用产生式③重写最左边的stmt：𝐢𝐟(𝐞𝐱𝐩𝐫)𝐰𝐡𝐢𝐥𝐞(𝐞𝐱𝐩𝐫) 𝐚 𝐞𝐥𝐬𝐞 a</p>
<h2 id="Parsing-Table-预测分析表"><a href="#Parsing-Table-预测分析表" class="headerlink" title="Parsing Table (预测分析表)"></a>Parsing Table (预测分析表)</h2><p>递归下降语法分析器（或LL分析器）是基于表的解析器<br>预测分析表是一个二维数组，用于确定解析器在看到非终结符A和符号a时应该选择哪个产生式<br>LL(1)解析器的预测分析表没有包含多个产生式的条目</p>
<h3 id="构造预测分析表"><a href="#构造预测分析表" class="headerlink" title="构造预测分析表"></a>构造预测分析表</h3><p>以下算法可以应用于任何CFG<br>输入：文法G<br>输出：预测分析表M<br>方法：对于每个产生式𝐴 → 𝛼 ，进行以下处理：<br>执行以下操作：<br>    ·对于FIRST(𝛼)中每个终结符𝑎，将𝐴 → 𝛼加入到𝑀[𝐴, 𝑎]<br>    · 如果𝜖在FIRST(𝛼)中，对于FOLLOW(𝐴)中每个终结符b，包括$，将𝐴 → 𝛼加入到𝑀[𝐴, b]<br>将表中的所有空条目设置为错误</p>
<h2 id="非递归的预测分析"><a href="#非递归的预测分析" class="headerlink" title="非递归的预测分析"></a>非递归的预测分析</h2><p>非递归的预测分析器可以通过显式维护堆栈（而不是通过递归调用隐式维护）来构建<br>· 输入缓冲区包含要解析的字符串，以$结尾<br>· 堆栈包含底部为$的语法符号序列。<br>最初，堆栈只包含$和在$顶部的开始符号𝑆</p>
<h3 id="表驱动的预测语法分析"><a href="#表驱动的预测语法分析" class="headerlink" title="表驱动的预测语法分析"></a>表驱动的预测语法分析</h3><p>输入：字符串𝜔 和文法G的预测分析表M<br>输出：如果𝜔 在𝐿(𝐺)中, 输出𝜔的一个最左边推导; 否则，给出一个错误指示<br>最初，输入缓冲区包含𝜔$<br>开始符号𝑆 位于堆栈顶部，在$上方。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%2010.png" alt="Untitled"></p>
<h2 id="自底向上分析"><a href="#自底向上分析" class="headerlink" title="自底向上分析"></a>自底向上分析</h2><p>自底向上的语法分析<br>问题定义：为输入字符串构建一个从叶子（终结符）开始并向上延伸到根（语法的开始符号）的语法分析树<br>· 相当于为输入字符串找到最右边的推导（相反）<br>移入-归约分析技术是一种自底向上语法分析的通用方式（使用栈来保存语法符号）</p>
<h3 id="Reductions-归约"><a href="#Reductions-归约" class="headerlink" title="Reductions (归约)"></a>Reductions (归约)</h3><p>自底向上语法分析可以看作是一个将字符串𝜔“归约”到开始符号的过程<br>在每一个归约步骤中，与产生式体匹配的特定子串（位于栈顶部）会被产生式的头部替换（与推导步骤相反）</p>
<h3 id="Handles-句柄"><a href="#Handles-句柄" class="headerlink" title="Handles (句柄)"></a>Handles (句柄)</h3><p>非正式地讲，句柄是和某个产生式体匹配的子串，对它的归约代表了相应的最右推导中的一个反向步骤<br>正式地讲，如果$S \Rightarrow^*_{rm} \alpha A<br>\omega\Rightarrow^*_{rm} \alpha \beta<br>\omega$，那么紧跟𝛼的产生式𝐴 → 𝛽 （或者简单地𝛽) 是句型𝛼𝛽𝜔的一个句柄</p>
<h3 id="Handle-Pruning-句柄剪枝"><a href="#Handle-Pruning-句柄剪枝" class="headerlink" title="Handle Pruning (句柄剪枝)"></a>Handle Pruning (句柄剪枝)</h3><p>在最右句型中， 句柄右侧的字符串必须仅包含终结符号<br>如果一个文法是无二义性的，那么该文法的每个右句型都有且只有一个句柄<br>通过句柄剪枝可以得到一个反向的最右推导</p>
<p>移入-归约语法分析技术是自底向上语法分析的一种通用方式，其中：</p>
<p>· 使用栈保存文法符号<br>· 使用输入缓冲区保存要进行语法分析的字符串的其余部分<br>· 栈内容（从底部到顶部）和输入缓冲区内容形成最右句型（假设没有错误）</p>
<p><strong>初始状态：</strong><br>移入-归约过程：<br>· 语法分析器将零个或多个输入符号转移到栈顶上，直到它可以对栈顶的一个文法符号串𝛽进行归约为止<br>· 将𝛽归约为某个产生式的头<br>语法分析器重复上述循环，直到检测到错误或栈包含开始符号且输入为空<br>*在移入-归约解析过程中，句柄最终总是出现在栈的顶部</p>
<h2 id="简单LR"><a href="#简单LR" class="headerlink" title="简单LR"></a>简单LR</h2><p>LR(k)语法分析器：最流行的自底向上的语法分析器类型<br>   · L： 从左到右扫描输入<br>   · R： 反向构造最右推导<br>   · k： 在做出解析决策时使用k个前瞻性输入符号<br>LR(0)和LR(1)语法分析器具有实际意义<br>当𝑘 ≥ 2时，语法分析器变得太复杂，无法构建（解析表太大，无法管理）</p>
<p>LR语法分析器的优势<br>· 表驱动（类似于非递归LL语法分析器）、强大<br>    · 尽管手工构建LR语法分析器工作量太大，但也有一些语法分析器生成器可以自动构建语法分析表<br>    · 相比之下，LL语法分析器往往更容易手工编写，但功能较弱（处理的语法较少）<br>· LR语法分析技术是已知的最通用的非回溯移入-归约语法分析方法<br>· LR语法分析器可以被构造为识别几乎所有可以为其编写CFG的编程语言结构<br>· LR语法比LL语法可以描述更多的语言<br>    · 回想文法成为LL(1)的严格条件</p>
<h2 id="LR-0-Items-LR-0-项"><a href="#LR-0-Items-LR-0-项" class="headerlink" title="LR(0) Items (LR(0)项)"></a>LR(0) Items (LR(0)项)</h2><p>一个LR语法分析器通过维护一些状态来跟踪在语法分析中所处的位置，从而来做出移入-归约的决策。<br>LR(0)项（简称item）是产生式再加上一个位于它的体中某处的点，表示在语法分析过程中的给定点上，我们已经看到了一个产生式的哪些部分。<br>𝐴 →} 𝑋𝑌𝑍        𝐴 → 𝑋 } 𝑌𝑍        𝐴 → 𝑋𝑌 } 𝑍         𝐴 → 𝑋𝑌𝑍 }<br>𝐴 → 𝑋 } 𝑌𝑍: 我们刚刚在输入中看到了一个可以由X推导得到的字符串，我们希望接下来看到一个能从YZ推导得到的字符串<br>状态：LR(0)项集<br>产生式𝐴 → 𝜖 仅生成一个item 𝐴 → ·</p>
<h3 id="规范LR-0-项集族"><a href="#规范LR-0-项集族" class="headerlink" title="规范LR(0)项集族"></a>规范LR(0)项集族</h3><p>LR(0)项集合的一个集合，称为规范LR(0)项集族, 为构建用于做出语法分析决定的DFA提供了基础<br>为了构造文法的LR(0)项集规范族，我们需要定义：<br>· 增广文法<br>· 两个函数：（1）项集闭包的CLOSURE 和（2）GOTO</p>
<h3 id="增广文法"><a href="#增广文法" class="headerlink" title="增广文法"></a>增广文法</h3><p>增广一个以S为开始符号的文法G：<br>· 引入一个新开始符号S‘代替S<br>· 增加产生式S‘ -&gt; S<br>明显地𝐿(𝐺)&#x3D;𝐿(𝐺’)<br>优点：通过增广，只有当语法分析器使用𝑆’ → 𝑆进行归约时输入符号串被接受。否则，输入符号串可能在多处被接受，因为可能存在多个𝑆-产生式</p>
<h3 id="项集闭包"><a href="#项集闭包" class="headerlink" title="项集闭包"></a>项集闭包</h3><p>如果𝐼 是文法𝐺的一组项集, 那么CLOSURE(𝐼)就是按照下面两条规则构造的项集：</p>
<ol>
<li>一开始，将𝐼中的各个项加入到CLOSURE(𝐼)</li>
<li>如果𝐴 → 𝛼 · 𝐵𝛽在CLOSURE(𝐼)中，𝐵 → 𝛾是一个产生式，并且𝐵 → ·𝛾不在CLOSURE(𝐼)中，那么将𝐵 → ·𝛾加入CLOSURE(𝐼)中。不断应用这条规则，直到没有新项可以加入到<br>直观地讲：𝐴 → 𝛼 · 𝐵𝛽 表示我们希望看到从一个能够从𝐵𝛽推导得到的子串。这个子串的某个前缀可以从B推导得到。因此，我们将所有𝐵-产生式加入到项集。</li>
</ol>
<h3 id="GOTO函数"><a href="#GOTO函数" class="headerlink" title="GOTO函数"></a>GOTO函数</h3><p>𝐆𝐎𝐓𝐎(𝑰, 𝑿) 其中𝑰是一个项集而𝑿是一个文法符号，被定义为𝑰中所有形如的项所对应的项的集合的闭包。</p>
<h3 id="LR-0-自动机"><a href="#LR-0-自动机" class="headerlink" title="LR(0)自动机"></a>LR(0)自动机</h3><p>“简单LR语法分析技术”（即SLR分析技术）的中心思想是根据文法构造出LR(0)自动机。<br>· 这个自动机的状态是规范LR(0)项集族<br>· 它的转换由GOTO函数给出<br>· 开始状态是CLOSURE({𝑆’ →· 𝑆})</p>
<h3 id="LR-0-自动机的使用"><a href="#LR-0-自动机的使用" class="headerlink" title="LR(0)自动机的使用"></a>LR(0)自动机的使用</h3><p>帮助做出移入-归约决定：<br>· 假设文法符号𝛾 使自动机从开始状态0运行到某个状态𝑗<br>· 如果下一个输入符号为𝑎且状态𝑗有一个在𝑎上的转换，那就移入𝑎<br>· 否则，归约；状态𝑗的项将会告诉我们使用哪个产生式进行归约</p>
<p>栈只保存状态，文法符号可以从相应状态中获取</p>
<h3 id="LR语法分析器结构"><a href="#LR语法分析器结构" class="headerlink" title="LR语法分析器结构"></a>LR语法分析器结构</h3><p>LR语法分析器由一个输入、一个输出、一个栈、一个驱动程序和一个语法分析表（ACTION+GOTO）组成<br>所有LR语法分析器的驱动程序都是相同的；只有语法分析表随语法分析器的不同而变化<br>栈保存一个状态序列<br>在SLR中，栈保存来自LR(0)自动机的状态<br>语法分析器根据（1）栈顶部的状态和（2）从输入缓冲区读取的终结符来决定下一个动作</p>
<h3 id="LR语法分析表：ACTION-GOTO"><a href="#LR语法分析表：ACTION-GOTO" class="headerlink" title="LR语法分析表：ACTION + GOTO"></a>LR语法分析表：ACTION + GOTO</h3><p>ACTION函数接受两个参数：（1）状态𝑖 和（2）终结符𝑎 （或$）<br>ACTION[𝒊, 𝒂] 可以具有以下四种形式的值之一：<br>· 移入𝒋: 其中𝑗是一个状态，把输入符号𝑎移入栈中，但使用状态𝑗 代表𝑎<br>· 归约𝑨 →𝛽: 将栈顶的𝛽归约为产生式头A<br>· 接受：语法分析器接受输入并完成语法分析过程<br>· 报错：存在语法错误<br>将定义在项集上的GOTO函数扩展为定义在状态集上的函数：如果GOTO(𝐼𝑖, 𝐴) &#x3D; 𝐼𝑗，那么GOTO也把状态𝑖和一个非终结符A映射到状态𝑗</p>
<h3 id="LR语法分析器的态势"><a href="#LR语法分析器的态势" class="headerlink" title="LR语法分析器的态势"></a>LR语法分析器的态势</h3><p>“态势”是表示语法分析器完整状态的符号。态势是一个形如：(𝑠0𝑠1 … 𝑠𝑚, 𝑎i𝑎i+1 … 𝑎𝑛$)的对<br>第一个分量是栈中的内容，第二个分量是余下的输入。<br>根据结构，每个状态（除𝑠0）对应于一组项和文法符号（导致状态转换的符号，即传入边上的符号）<br>· 假设𝑋i是状态𝑠i的文法符号<br>· 那么𝑋0𝑋1 … 𝑋𝑚𝑎i𝑎i+1 … 𝑎𝑛是最右句型（假设没有错误）</p>
<h3 id="构造SLR语法分析表"><a href="#构造SLR语法分析表" class="headerlink" title="构造SLR语法分析表"></a>构造SLR语法分析表</h3><p>SLR语法分析表𝐺以LR(0)项和LR(0)自动机为基础。</p>
<ol>
<li>构造增广文法G‘的规范LR(0)项集族{𝐼0, 𝐼1, … , 𝐼𝑛}</li>
<li>根据𝐼i构造得到状态i，状态i的语法分析动作按照下面的方法决定：<br>· 如果[𝐴 → 𝛼 · 𝑎𝛽]在𝐼𝑖中并且GOTO [𝐼𝑖, 𝑎 ]&#x3D; 𝐼j，那么将ACTION[ 𝑖, 𝑎]设置为“移入j”<br>· 如果[𝐴 → 𝛼·]在𝐼𝑖中，那么对于𝐅𝐎𝐋𝐋𝐎𝐖(𝑨)中的所有𝑎，将设置ACTION[ 𝑖, 𝑎]为“归约𝐴 → 𝛼”。这里𝐴不等于S’<br>· 如果[𝑆’ → 𝑆·]在𝐼𝑖中，那么将设置ACTION[𝑖, $]为“接受”</li>
<li>状态i对于各个非终结符号A的转换使用下面的规则构造得到：如果GOTO [𝐼i, 𝐴]&#x3D; 𝐼𝑗，那么GOTO[𝑖, 𝐴]&#x3D; 𝑗</li>
<li>规则2、3没有定义的所有条目都设置为“报错”</li>
<li>语法分析器的初始状态就是根据[𝑆′ → · 𝑆]所在项集构造得到的状态<br>如果在语法分析构造过程中没有冲突（即，一个表项的多个条目），则语法为SLR（1）</li>
</ol>
<p>在SLR中，状态𝑖 要求归约𝐴 → 𝛼，如果项集$𝐼_𝑖$包含项[𝐴 → 𝛼 · ] ，同时输入符号𝑎 在FOLLOW(𝐴)中<br>在某些情况下，归约后𝛽𝛼 在栈顶上会变成𝛽𝐴， 后面跟着的不是𝑎的任何最右句型</p>
<h2 id="规范LR"><a href="#规范LR" class="headerlink" title="规范LR"></a>规范LR</h2><h3 id="规范LR-1-项"><a href="#规范LR-1-项" class="headerlink" title="规范LR(1)项"></a>规范LR(1)项</h3><p>在状态中携带更多信息以排除一些无效的归约（通过分裂LR（0）状态）<br>LR(1)项的一般形式：[𝐴 → 𝛼 · 𝛽, 𝑎]<br>· 𝐴 → 𝛼𝛽是一个产生式，𝑎是一个终结符或右端结束标记<br>· 1指的是第二个分量𝑎的长度，第二个分量𝑎叫做向前看字符<br>· 当𝛽不为空时，向前看字符没有任何作用因为它决定是否归约<br>· 一个形如[𝐴 → 𝛼· , 𝑎]的项只有在下一个输入符号等于𝑎时，才会按照𝐴 → 𝛼进行归约。这样的𝑎的集合总是的FOLLOW(𝐴)子集<br>𝐴 → 𝛼𝛽 是一个生产和𝑎 是终端还是$“1”是指第二个组成部分的长度：展望(向前看字符)*如果𝛽 不是𝜖 因为它只帮助确定是否减少(𝑎 将在状态转换期间继承）表单中的一项𝐴 → 𝛼· , 𝑎要求减少𝐴 → 𝛼 仅当下一个输入符号𝑎 （𝑎’s是FOLLOW的子集(𝐴))*：LR（0）项没有先行符号，因此它们被称为LR（0</p>
<blockquote>
<p>构造LR（1）项集族本质上与构造规范LR（0）项集族相同。唯一的区别在于CLOSURE和GOTO函数。</p>
</blockquote>
<p>构造LR（1）项集族本质上与构造规范LR（0）项集族相同。唯一的区别在于CLOSURE和GOTO函数。<br>向前看符号从现有项传递到新项</p>
<h3 id="构造规范LR-1-语法分析表"><a href="#构造规范LR-1-语法分析表" class="headerlink" title="构造规范LR(1)语法分析表"></a>构造规范LR(1)语法分析表</h3><ol>
<li>构造增广文法G‘的规范LR(1)项集族{𝐼0, 𝐼1, … , 𝐼𝑛}</li>
<li>根据𝐼i构造得到状态i，状态i的语法分析动作按照下面的方法决定：<br>· 如果[𝐴 → 𝛼 · 𝑎𝛽, 𝑏 ]在𝐼𝑖中并且GOTO [𝐼𝑖, 𝑎 ]&#x3D; 𝐼j，那么将ACTION[ 𝑖, 𝑎]设置为“移入j”<br>· 如果[𝐴 → 𝛼·, 𝑎 ]在𝐼𝑖中，设置ACTION[ 𝑖, 𝑎]为“归约𝐴 → 𝛼”。这里𝐴不等于S’<br>· 如果[𝑆’ → 𝑆·, $ ]在𝐼𝑖中，那么将设置ACTION[𝑖, $]为“接受”<br>如果以上规则导致任何冲突的动作，我们就说这个文法不是LR(1)的。</li>
<li>状态i对于各个非终结符号A的转换使用下面的规则构造得到：如果GOTO [𝐼i, 𝐴]&#x3D; 𝐼𝑗，那么GOTO[𝑖, 𝐴]&#x3D; 𝑗</li>
<li>规则2、3没有定义的所有条目都设置为“报错”</li>
<li>语法分析器的初始状态就是根据[𝑆′ → · 𝑆, $]所在项集构造得到的状态</li>
</ol>
<h2 id="Lookahead-LR-LALR"><a href="#Lookahead-LR-LALR" class="headerlink" title="Lookahead LR (LALR)"></a>Lookahead LR (LALR)</h2><p>SLR(1)的功能不足以处理大量语法（回想一下以前的明确语法）<br>LR(1)在语法分析表中有一组庞大的状态（状态过于细粒度）<br>LALR(1)在实践中经常使用<br>· 在项中保留向前看符号<br>· 它的状态数与SLR(1)的状态数相同<br>· 可以处理现代程序设计语言中最常见的句法结构</p>
<p>寻找具有相同核心的LR(1)项集<br>LR(1)项集的核心是第一个分量的集合<br>· 𝐼4和𝐼7的核心是{𝐶 → 𝑑 ·}<br>· 𝐼3和𝐼6的核心是{𝐶 → 𝑐·𝐶,𝐶 → ·𝑐𝐶,𝐶 → ·𝑑}</p>
<blockquote>
<p>一般而言，一个核心就是LR(0)项集<br>我们可以将具有共同核心的LR(1)项集合并为一组项目<br>由于GOTO的核心(𝐼, 𝑋) 仅取决于𝐼, 合并项集的GOTO目标也具有相同的核心，因此可以合并</p>
</blockquote>
<h3 id="状态合并引发的冲突"><a href="#状态合并引发的冲突" class="headerlink" title="状态合并引发的冲突"></a>状态合并引发的冲突</h3><p>合并LR(1)语法分析表中的状态可能会导致冲突<br>合并不会导致移入&#x2F;归约冲突<br>· 假设合并后在向前看符号𝑎上存在移入&#x2F;归约冲突<br>· 有一个项[𝐴 → 𝛼·, 𝑎] 要求归约𝐴 → 𝛼<br>· 有其他项[𝐵 → 𝛽· 𝑎𝛾, ?]要求移入<br>· 由于要合并的集合的核心是相同的，因此合并前必须有一个集合同时包含[𝐴 → 𝛼· , 𝑎] 以及[𝐵 → 𝛽· 𝑎𝛾, ?]<br>· 那么根据LR(1)语法分析表构造算法，在合并之前，已经在𝑎上存在移入&#x2F;归约冲突 。该文法不是LR（1）。<br>合并状态可能导致归约&#x2F;归约冲突</p>
<p>构造LR(1)项集族$𝐶 &#x3D; {𝐼_0，𝐼_1，𝐼_𝑛}$<br>对于LR(1)项集中的每个核心，找出所有具有这个核心的项集，并将这些项集替换为它们的并集<br>令$𝐶’ &#x3D; {J_0，J_1，J_𝑛}$是合并后得到的项集族。<br>· 状态$𝑖$的语法分析动作是按照LR(1)语法分析表构造算法中的方法根据$𝐽_i$构造得到的<br>· 如果存在一个分析动作冲突，这个算法就不能生成语法分析器，这个文法不是LALR(1)的</p>
<p><strong>GOTO表构造方法如下：</strong></p>
<p>· 如果𝐽是一个或多个LR(1)项集的并集。也就是说 𝐽 &#x3D; 𝐼1 𝖴 𝐼2 𝖴 ⋯ 𝖴 𝐼𝑘，那么GOTO(𝐼1, 𝑋), GOTO(𝐼2, 𝑋), …, GOTO(𝐼𝑘, 𝑋)的核心是相同的，因为𝐼1, 𝐼2, … , 𝐼𝑘具有相同的核心<br>· 令𝐾是所有和GOTO(𝐼1, 𝑋)具有相同核心的项集的并集<br>· 那么GOTO(𝐽, 𝑋)&#x3D; 𝐾</p>
<h2 id="错误恢复"><a href="#错误恢复" class="headerlink" title="错误恢复"></a>错误恢复</h2><p><strong>LR语法分析中的错误恢复</strong></p>
<p>LR语法分析器应该能够处理错误：<br>· 报告错误的精确位置<br>· 从错误中恢复并继续分析<br>两种典型的错误<br>· 恐慌模式<br>· 短语层次的恢复</p>
<p><strong>恐慌模式</strong><br>基本思想：丢弃零个或多个输入符号，直到同步词法单元已找到<br>原理：<br>· 语法分析器总是查找可以从非终结符𝐴推导的输入的前缀<br>· 当出现错误时，意味着无法找到这样的前缀<br>· 如果错误仅发生在与𝐴相关的部分, 我们可以通过寻找一个可以合法跟随的符号来跳过这一部分<br>· 示例：如果𝐴 是𝑠𝑡𝑚𝑡, 则同步词法单元可以是分号</p>
<p><strong>短语层次的恢复</strong><br>基本思路：<br>· 检查语法分析表中的每个错误条目，并确定最有可能导致错误的程序员错误<br>· 修改栈顶部或第一个输入符号，并向程序员发出消息<br>短语层次的恢复示例：<br>· 删除右侧的）<br>· 提示“不匹配的右括号”。</p>
<h2 id="语法分析器生成工具"><a href="#语法分析器生成工具" class="headerlink" title="语法分析器生成工具"></a><strong>语法分析器生成工具</strong></h2><p>本节将介绍如何使用语法分析器生成工具来帮助构造一个编译器的前端，我们将使用LALR语法分析生成工具Yacc作为讨论的基础。Yacc，又一个编译器的编译器<br>Yacc在UNIX系统中是以命令的方式出现的，它已经用于实现多个编译器产品。Bison 是GNU项目的一部分，是对Yacc的扩展和改进。</p>
<p><strong>声明</strong><br>· 通常的C声明<br>· 对词法单元的声明<br><strong>翻译规则</strong><br>· 翻译规则 &#x3D; 产生式 + 语义动作<br><strong>辅助性C语言例程</strong><br>· 将会被直接拷贝至y.tab.c<br>· 可以在语义动作中调用<br>· 必须提供yylex()这一词法分析器，它将返回一个由词法单元和相关属性组成的词法单元<br>· 可以添加错误恢复例程等其他过程</p>
<blockquote>
<p><strong>翻译规则</strong><br>第一个产生式头符号被视为开始符号<br>一个语义动作是一个C语句的序列<br>· $$表示和相应产生时头部的非终结符关联的属性值<br>· $i表示和相应产生式体中第i个文法符号关联的属性值<br>当我们按照一个产生式归约时就会执行盒盖产生式相关联的语义动作<br>· 我们通常根据$i的值来计算$$的值</p>
</blockquote>
<h3 id="Yacc的冲突解决"><a href="#Yacc的冲突解决" class="headerlink" title="Yacc的冲突解决"></a>Yacc的冲突解决</h3><p>默认策略：<br>· 移入&#x2F;归约冲突：始终移入<br>· 归约&#x2F;归约冲突：归约第一个列出的产生式<br>指定终结符的优先级和结合性：<br>· 结核性：%left、%right、%nonassoc<br>· 移入𝒂&#x2F;归约𝑨 → 𝑎 冲突：比较的优先级𝑎 和𝐴 →𝛼 （优先级不够时使用结合性）<br>· 终结符的声明顺序决定了它们的优先级<br>· 一个产生式的优先级等于它最右边终结符的优先级。也可以使用%prec<terminal>指定，它将产生式的优先级定义为与终结符相同</p>
<h3 id="Yacc的错误恢复"><a href="#Yacc的错误恢复" class="headerlink" title="Yacc的错误恢复"></a>Yacc的错误恢复</h3><p>在Yacc中，错误恢复使用一种错误产生式的形式：<br>· 一般形式：𝐴 → 𝐞𝐫𝐫𝐨𝐫 𝛼<br>· 用户可以决定哪些非终结符（例如，生成表达式、语句、块等的非终结符）将具有错误产生式<br>错误示例：𝒔𝒕𝒎𝒕 → 𝐞𝐫𝐫𝐨𝐫 ;<br>· 该错误产生式规定当语法分析器遇到错误时，它要跳到下一个分号之后，并假设已经找到一条语句<br>· 将调用错误产生式的语义动作不需要处理输入，只需生成诊断消息</p>
<h1 id="Chapter-4-Syntax-Directed-Translation"><a href="#Chapter-4-Syntax-Directed-Translation" class="headerlink" title="Chapter 4:  Syntax-Directed Translation"></a>Chapter 4:  Syntax-Directed Translation</h1><h3 id="语法制导的翻译"><a href="#语法制导的翻译" class="headerlink" title="语法制导的翻译"></a><strong>语法制导的翻译</strong></h3><p>• 读取源程序的输入字符，将其归类为词素，并生成词素序列<br>• 必要时将词目添加到符号表中<br>• 删除注释和空白（空格、换行符、制表符等）<br>• 将错误信息与行号关联起来（跟踪换行符）</p>
<p>语法制导定义（SDD）是一种无上下文语法，同时包含属性和规则。<br>  一组属性（attributes）与每个语法符号相关联*。<br>    可以是任何属性，例如表达式的数据类型，# 生成代码中的指令<br>  语义规则（semantic rule）与语法生成相关联，描述如何计算属性<br>  属性代码表示结构体的后缀符号<br>  || 是字符串连接操作符</p>
<h3 id="合成属性"><a href="#合成属性" class="headerlink" title="合成属性"></a><strong>合成属性</strong></h3><p>如果一个属性在解析树节点 N 上的值仅由 N 的子节点和 N 本身的属性值决定，则称该属性为合成属性；</p>
<h3 id="SDD-不指定解析树上属性的计算顺序"><a href="#SDD-不指定解析树上属性的计算顺序" class="headerlink" title="SDD 不指定解析树上属性的计算顺序"></a><strong>SDD 不指定解析树上属性的计算顺序</strong></h3><p>任何顺序，只要能在依赖的所有其他属性之后计算一个属性就可以了合成属性有一个很好的特性，<br>即它们可以在解析树的一次自下而上的遍历中进行评估（通常不需要显式创建解析树）。</p>
<h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a><strong>继承属性</strong></h3><p>继承属性在解析树节点上的值由该节点本身、其父节点和解析树中同级节点的属性值决定<br>回答：继承属性在处理与上下文相关的问题时仍然是非常有用的。它为我们提供了一种在语法树中考虑外部信息的方法，从而使得我们可以更为精确和灵活地描述语法制导定义的属性</p>
<p>给定解析树节点 $N,M_1,M_2,M_3,…,M_k，$如果 N 的属性 a 定义为 $N.a &#x3D; f(M_1,a_1,M_2,a_2,…,M_k,a_k)$，那么为了计算 N.a，我们必须先计算 $M_1. a_1$。<br>依赖图 (依赖图) 是确定评估顺序的有用工具<br>    描述特定解析树中属性实例之间的信息流<br>    为属性实例之间的部分顺序建模</p>
<p>从一个属性实例$（a_1）$到另一个属性实例$（a_2）$的边表示计算 $a_2$ 的值需要 $a_1$ 的值。<br>如果依赖关系图中存在循环，我们就无法找到计算所有属性实例值的顺序ε</p>
<h3 id="S-属性定义"><a href="#S-属性定义" class="headerlink" title="S 属性定义"></a>S 属性定义</h3><p>如果每个属性都是合成的，那么语法制导定义就是 S 属性的<br>直观地说，任何解析树的依赖关系图中都不可能存在循环，因为边总是从子节点到父节点，而不是相反。</p>
<p>当 SDD 具有 S 属性时，我们可以按照解析树节点的任何自下而上的顺序评估其属性。<br>例如，解析树的后序遍历（postorder traversal)<br>S 属性定义可以在自下而上的解析过程中轻松实现（相当于后序遍历）</p>
<h3 id="L-属性定义"><a href="#L-属性定义" class="headerlink" title="L 属性定义"></a>L 属性定义</h3><p>如果对于每个产品 $A → X_1X_2…X_n$，对于每个 J &#x3D; 1 … n，$x_j$ 的每个继承属性仅取决于以下属性，则 SDD 是 L 属性 SDD：<br>$x_1,…x_{j-1}$ 的属性（合成的或继承的），<br>或 A 的继承属性<br>依赖关系图的边可以从左到右（对于解析树而言），但不能从右到左（因此称为 “L-属性”）。</p>
<h3 id="L-属性定义的属性评估"><a href="#L-属性定义的属性评估" class="headerlink" title="L 属性定义的属性评估"></a>L 属性定义的属性评估</h3><p>输入: 解析树 T 中的节点 n<br>输出: 以 n 为根的子树属性的评估顺序<br>程序 depth_first(n)*<br>开始<br>      对于 n 的每个子节点 m，从左到右依次执行 开始<br>      评估 m 的继承属性；<br>      depth_first(m); &#x2F;&#x2F; 这里将评估 m 的合成属性<br>      结束<br>      评估 n 的合成属性；<br>      保证：在评估节点的继承属性时，已评估了其左侧节点的属性<br>end</p>
<h2 id="构建语法树"><a href="#构建语法树" class="headerlink" title="构建语法树"></a>构建语法树</h2><p><strong>抽象语法树</strong></p>
<p>每个内部节点 N 代表一个结构体（对应一个运算符）<br>N 的子节点代表 N 所代表结构的有意义成分（相当于操作数）</p>
<p><strong>语法树与解析树</strong></p>
<p>在语法树中，内部节点代表编程结构，而在解析树中，内部节点代表非终结符*。<br>解析树也称为具体语法树，其底层语法称为语言的具体语法</p>
<p>为简单表达式构建语法树的 S 属性 SDD<br>语法树的每个节点都是一个对象，其中有一个字段 op（代表节点的标签）和一些附加字段<br>叶节点：一个包含词法值的附加字段<br>内部节点：额外的字段数量等于子节点的数量</p>
<h2 id="计算类型的结构"><a href="#计算类型的结构" class="headerlink" title="计算类型的结构"></a>计算类型的结构</h2><p>• 正则语言（regular language）是一种可由 regexp<br>• 如果两个 regexps r 和 s 表示相同的语言，那么它们是等价的，写成 r &#x3D; s</p>
<p><strong>合成属性</strong>：这种属性通常用于将信息从叶子节点向上传递到父节点。在这里，合成属性t代表一个类型，这意味着某个节点（可能是一个变量或表达式）的类型可以通过计算其子节点的属性来确定，并将这个类型作为其自己的t属性。<br><strong>继承属性</strong>：这种属性是从父节点传递给子节点的。在这个描述中，继承属性t在解析树中向下传递一个基本类型。这通常意味着上层节点（例如，声明或类型定义的上下文）已经确定了某种基本类型，这个类型需要向下传递给子节点，以确保子节点可以根据这个类型进行相应的操作或检查。</p>
<h2 id="Syntax-Directed-Translation-Schemes"><a href="#Syntax-Directed-Translation-Schemes" class="headerlink" title="Syntax-Directed Translation Schemes"></a>Syntax-Directed Translation Schemes</h2><p>SDD 告诉我们在翻译中要做什么（高级规范），但不告诉我们如何做<br>语法制导的翻译方案（SDT’s，Syntax-directed translation schemes）规定了如何进行翻译的更多细节。<br>SDT 是一种无上下文语法，其语义动作（程序片段）嵌入在生产体中 ：<br>与 SDD 的语义规则不同<br>语义动作可以出现在制作体的任何地方</p>
<p>任何 SDT 都可以通过以下方式实现：</p>
<p>首先构建一棵解析树<br>将语义操作视为 “虚拟 “解析树节点<br>执行从左到右的深度优先（即预排序）树遍历，并在访问相应节点时触发操作</p>
<p><strong>SDD（Syntax Directed Definition）</strong>：<br>SDD定义了与语法产生式关联的属性和规则。它为每个语法产生式指定一个或多个属性计算或语义动作。<br>SDD关注于如何为语法树中的节点计算属性值，但不一定涉及产生中间代码或目标代码的具体操作。<br>它可以有合成属性和继承属性，因此可以描述为S属性的（只有合成属性）或L属性的（允许继承属性但有限制）。<br><strong>SDT（Syntax Directed Translation）</strong>：<br>SDT是SDD的一个特例，它专门用于生成中间代码或目标代码。换句话说，SDT的目的是翻译，它定义了与语法产生式关联的动作，这些动作通常在解析时执行。<br>当解析器在处理产生式时，与该产生式关联的SDT动作被执行，从而生成代码或进行其他翻译工作。<br>动作可以嵌入到产生式中，例如，在YACC或Bison这样的工具中，可以直接在语法规则中插入C代码作为动作。<br><strong>总结差异</strong>：<br>SDD更为通用，关注于为语法树的节点计算属性。这些属性可以用于多种目的，如类型检查、变量绑定等。<br>SDT特化于翻译任务，即将源代码转换为中间代码或目标代码。它通常涉及在解析过程中执行特定的动作。<br>尽管有这些区别，但在实际应用中，SDD和SDT的界限可能会模糊，因为编译器的语义分析和翻译阶段通常是交织在一起的</p>
<p>$$<br>B-&gt;X{a}Y<br>$$</p>
<p>动作 a 应在我们识别完 X（如果 X 是终端）或由 X 派生的所有终端（如果 X 是非终端）后执行<br>如果解析是自下而上的，那么一旦 X 出现在解析栈顶端，我们就执行操作 a<br>如果解析是自上而下的，我们在尝试扩展 Y（如果 Y 是非终端）或检查输入中的 Y（如果 Y 是终端）之前执行操作 a</p>
<blockquote>
<p><strong>底层语法是LR，而SDD是S属性的</strong>：<br><strong>LR语法</strong>：这是一种可以用自底向上的方式进行解析的语法。LR解析器从左到右读取输入，但决策是基于右侧的上下文进行的。它使用一个堆栈来存储已经读取的符号，并在适当的时候进行规约。<br><strong>S属性的SDD</strong>：这意味着所有属性都是合成属性，它们只从子节点传递给父节点，没有从父节点传递给子节点的继承属性。这对于自底向上的LR解析是非常合适的，因为我们从叶子节点开始构建并向上移动，因此只需要合成属性即可。<br>底层语法是LL，而SDD是L属性的：<br><strong>LL语法</strong>：这是一种可以用自顶向下的方式进行解析的语法。LL解析器从左到右读取输入，并基于左侧的上下文来进行决策。它通常使用递归下降的方法，直接从起始符号开始，并尝试应用各种产生式。</p>
</blockquote>
<p>如果 SDD 的语法是 LR，而且 SDD 是 S 属性的，那么我们就可以构造一个后缀 SDT（后缀 SDT），在自下而上的解析中实现 SDD 语义动作总是出现在制作的末尾（因此称为 “后缀”）。</p>
<h3 id="SDT’s-for-L-Attributed-SDD’s"><a href="#SDT’s-for-L-Attributed-SDD’s" class="headerlink" title="SDT’s for L-Attributed SDD’s"></a>SDT’s for L-Attributed SDD’s</h3><p>如果基础语法是 LL，那么 L 归因 SDD 可以在自上而下的解析过程中实现。<br>将 L 属性 SDD 转化为 SDT 的方法是将语义动作放在相关语篇 A → X1X2…Xn 的适当位置上。<br>将计算非终端 Xi 的继承属性的动作紧接在生产体中 Xi 的前面<br>将为语篇头部计算合成属性的操作放在语篇主体的末尾</p>
<h3 id="构建整个词法分析器-1"><a href="#构建整个词法分析器-1" class="headerlink" title="构建整个词法分析器"></a>构建整个词法分析器</h3><p>• 策略 1：依次尝试每个标记的过渡图<br>fail() 重置指针并开始下一个图表<br>• 策略 2：并行运行过渡图<br>需要解决一个图找到一个词素，而其他图仍能处理输入的情况。<br>▪ 解决方法：取输入中与任何模式匹配的最长前缀<br>• 策略 3：将所有过渡图合并为一张图（首选）<br>允许过渡图读取输入，直到没有可能的下一个状态为止<br>取与任何模式匹配的最长词素<br>语义操作：<br>a) L1 &#x3D; new()；L2 &#x3D; new()；<br>b) C.false &#x3D; S.next; C.true &#x3D; L2；<br>c) S1.next &#x3D; L1；<br>d) S.code &#x3D; ⋯ ；<br>根据动作位置规则，<br>b) 应放在制作体之前，c) 应放在制作体之前，d) 应放在制作体末尾<br>a) 可以放在开头；没有限制条件</p>
<h2 id="Implementing-L-Attributed-SDD’s"><a href="#Implementing-L-Attributed-SDD’s" class="headerlink" title="Implementing L-Attributed SDD’s"></a>Implementing L-Attributed SDD’s</h2><p>许多翻译应用都可以使用 L 归因 SDD 来解决。如下所示，我们可以扩展递归-后裔解析器来实现 L 归因 SDD：<br>递归-迭代解析器为每个非终端 A 都有一个函数 A<br>使用函数 A 的参数传递 A 的继承属性<br>当函数 A 完成时，返回 A 的合成属性<br>通过上述扩展，在函数 A 的主体中，我们需要同时解析和处理属性</p>
<h1 id="Chapter-5-Intermediate-Code-Generation"><a href="#Chapter-5-Intermediate-Code-Generation" class="headerlink" title="Chapter 5: Intermediate-Code Generation"></a>Chapter 5: Intermediate-Code Generation</h1><h2 id="中间表示法"><a href="#中间表示法" class="headerlink" title="中间表示法"></a>中间表示法</h2><p>编译器的前端分析源程序并创建中间表示（IR，intermediate representation），后端据此生成目标代码。<br>理想情况下，源语言的细节仅限于前端，目标机的细节仅限于后端</p>
<h2 id="编译器可构建-IR-序列"><a href="#编译器可构建-IR-序列" class="headerlink" title="编译器可构建 IR 序列"></a>编译器可构建 IR 序列</h2><p>语法树等高级 IR 接近源语言。它们描述了源程序的结构，适用于静态类型检查等任务<br>低级 IR 接近目标机器，适用于寄存器分配和指令选择等与机器相关的任务。<br>三地址代码可以是高级或低级的，取决于运算符的选择</p>
<p>有趣的事实：C 经常被用作中间形式。第一个 C++ 编译器的前端生成 C，后端是 C 编译器</p>
<h2 id="DAG’s-for-Expressions"><a href="#DAG’s-for-Expressions" class="headerlink" title="DAG’s for Expressions"></a>DAG’s for Expressions</h2><p>在语法树中，一个普通子表达式的语法树将按该子表达式出现的次数复制</p>
<p>Example: $𝑎+𝑎∗(𝑏−𝑐)+(𝑏−c)∗𝑑$会重复两次，而$（b-c）$也重复了两次</p>
<p>有向无环图 (DAG, 有向无环图) 识别共同的子表达式，并简洁地表示表达式</p>
<p>蓝圈节点有两个父节点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/BUPT_note/Notes_on_Compilation_principle/Untitled%2011.png" alt="Untitled"></p>
<p>DAG 可以用构造语法树的 SDD 来构造<br>区别：在构建 DAG 时，只有当且仅当没有现存的相同节点时，才会创建新节点</p>
<h2 id="Three-Address-Code-三地址代码"><a href="#Three-Address-Code-三地址代码" class="headerlink" title="Three-Address Code (三地址代码)"></a>Three-Address Code (三地址代码)</h2><p>在三地址代码中，指令右侧最多只有一个运算符<br>指令的形式通常是 $𝑥 &#x3D; 𝑦\ 𝑜𝑝\ 𝑧$<br>运算符（或地址）可以是：</p>
<p>源程序中的名称<br>常量：编译器必须处理多种类型的常量<br>编译器生成的临时名称</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>赋值指令：</strong><br>𝑥 &#x3D; 𝑦 op 𝑧，其中 op 是二进制算术&#x2F;逻辑运算<br>𝑥&#x3D; op 𝑦，其中 op 是一元运算<br><strong>复制指令：</strong> 𝑥 &#x3D; 𝑦<br><strong>无条件跳转指令：</strong>goto 𝐿，其中 𝐿 是跳转目标的标记<br><strong>有条件跳转指令：</strong><br>if 𝑥 goto 𝐿<br>if Flase 𝑥 goto 𝐿<br>if 𝑥 relop 𝑦 goto 𝐿</p>
<p><strong>程序调用和返回：</strong></p>
<p>param 𝑥1<br>…<br>param 𝑥𝑛<br>call 𝑝, 𝑛 (procedure call)<br>y &#x3D; call p, n (function call)<br>return y<br><strong>索引复制指令：</strong> 𝑥 &#x3D; 𝑦[𝑖] 𝑥[𝑖] &#x3D; 𝑦<br>这里，𝑦[𝑖] 表示位置 𝑖 存储单元中超出位置 𝑦 的值。这里，𝑦[𝑖] 表示位置 𝑖存储单元中超出位置 𝑦 的值。<br><strong>地址和指针赋值指令：</strong><br>𝑥 &#x3D; &amp;𝑦 ，𝑥 &#x3D;∗ 𝑦， ∗ 𝑥 &#x3D; 𝑦</p>
<blockquote>
<p>对三地址指令的描述说明了每种指令的组成部分，但没有说明指令的表示方法。<br>在编译器中，这些指令可以作为对象&#x2F;记录来实现，并为运算符和操作数设置字段<br>三种典型的表示法:</p>
<p>四元式表示方法<br>三元式表示方法<br>间接三元式表示方法</p>
</blockquote>
<h3 id="Quadruples-四元式"><a href="#Quadruples-四元式" class="headerlink" title="Quadruples (四元式)"></a>Quadruples (四元式)</h3><p>一个四元组（或 “四元组”）有四个字段<br>    一般形式： op arg1 arg2 result<br>    op 包含运算符的内部代码<br>    arg1、arg2、result 是地址（操作数）<br>一元运算符（如 x &#x3D; 减 y 或 x &#x3D; y）不使用 arg2<br>参数运算符既不使用 arg2 也不使用 result<br>条件&#x2F;非条件跳转将目标标签放在 result 中</p>
<h3 id="Triples-三元式"><a href="#Triples-三元式" class="headerlink" title="Triples (三元式)"></a>Triples (三元式)</h3><p>三元组只有三个字段：操作、参数 1、参数 2。<br>我们用操作 x 操作 y 的位置来表示操作结果，而无需生成临时名称（这是对四元组的优化）</p>
<h3 id="Indirect-Triples-间接三元式"><a href="#Indirect-Triples-间接三元式" class="headerlink" title="Indirect Triples (间接三元式)"></a>Indirect Triples (间接三元式)</h3><p>间接三元组由一个指向三元组的指针列表（下面的指令数组）<br>优化可以通过重新排序指令列表来移动指令（无需修改三元组）<br>交换后，列表中的第一条和第二条指令仍然指向正确的指令</p>
<p>静态单赋值形式静态单赋值形式（SSA，Static Single-Assignment ForStatic single-assignment form）是一种 IR，有助于某些代码优化。<br>在 SSA 中，每个名称只接受一次赋值</p>
<p>SSA 使用一种称为 𝜙 函数的符号惯例来合并 x 的两个定义</p>
<h2 id="Types-and-Type-Checking"><a href="#Types-and-Type-Checking" class="headerlink" title="Types and Type Checking"></a>Types and Type Checking</h2><p>数据类型或简单的类型告诉编译器或解释器程序员打算如何使用数据<br>类型信息的作用<br>    查找源代码中的错误<br>    在运行时确定名称所需的存储空间<br>    计算数组元素的地址<br>    插入类型转换<br>选择算术运算符的正确版本（如 fadd、iadd）<br>类型检查(类型检查) 使用逻辑规则确保操作数的类型与运算符所期望的类型匹配</p>
<h2 id="Type-Expressions-类型表达式"><a href="#Type-Expressions-类型表达式" class="headerlink" title="Type Expressions (类型表达式)"></a>Type Expressions (类型表达式)</h2><p>类型具有结构，可以用类型表达式来表示<br>    类型表达式要么是基本类型，要么是通过对类型表达式应用类型构造算子而形成<br>array(2, array (3, integer ))是 int[2][3] 的类型表达式<br>    array 是一个类型构造函数，有两个参数：一个数字，一个类型表达式</p>
<h2 id="Name-Equivalence-名等价"><a href="#Name-Equivalence-名等价" class="headerlink" title="Name Equivalence (名等价)"></a>Name Equivalence (名等价)</h2><p>将命名的类型视为基本类型；类型表达式中的名称不会被其定义的类型表达式所替换<br>当且仅当两个类型表达式完全相同时，它们的名称才是等价的(由相同的语法树表示，具有相同的标签）</p>
<h2 id="Structural-Equivalence-结构等价"><a href="#Structural-Equivalence-结构等价" class="headerlink" title="Structural Equivalence (结构等价)"></a>Structural Equivalence (结构等价)</h2><p>对于已命名的类型，用其类型表达式替换类型名，并递归检查替换后的树</p>
<h2 id="Declarations-类型的声明"><a href="#Declarations-类型的声明" class="headerlink" title="Declarations (类型的声明)"></a>Declarations (类型的声明)</h2><p>下面的语法涉及基本类型、数组类型和记录类型</p>
<p>非终端 𝐷生成声明序列<br>𝑇 生成基本类型、数组类型或记录类型，记录类型是记录字段的声明序列，由大括号包围<br>𝐵 生成基本类型之一：int 和 float<br>𝐶 生成一个或多个整数的序列，每个整数都由大括号包围</p>
<h2 id="Storage-Layout-for-Local-Names-局部变量的存储布局"><a href="#Storage-Layout-for-Local-Names-局部变量的存储布局" class="headerlink" title="Storage Layout for Local Names (局部变量的存储布局)"></a>Storage Layout for Local Names (局部变量的存储布局)</h2><p>根据名称的类型，我们可以决定运行时名称所需的内存量。运行时名称所需的内存量<br>    类型的宽度（宽度）： 该类型对象所需的 # 内存单位<br>    对于长度不等的数据（如字符串），或在运行前无法确定大小的数据（如动态数组），我们只为数据指针预留固定的内存量。<br>    对于函数的局部名称，我们总是分配连续的字节*。<br>    对于每个这样的名称，我们可以在编译时计算出一个相对地址<br>类型信息和相对地址存储在符号表中</p>
<h2 id="表达式的翻译"><a href="#表达式的翻译" class="headerlink" title="表达式的翻译"></a>表达式的翻译</h2><p>包含多个运算符的表达式：𝑎 + 𝑏 ∗ 𝑐<br>转换为多条指令，每条指令最多使用一个运算符𝑡1 &#x3D; 𝑏 ∗ 𝑐,𝑡2 &#x3D; 𝑎 + 𝑡1<br>数组引用𝐴[𝑖][𝑗] 将扩展为一系列三地址指令，用于计算引用的地址</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://shuita2333.github.io">Charmes</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shuita2333.github.io/2024/01/11/BUPT_note/Notes_on_Compilation_principle/">https://shuita2333.github.io/2024/01/11/BUPT_note/Notes_on_Compilation_principle/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="null" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shuita2333.github.io" target="_blank">ZYH's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%97%E9%82%AE%E4%BF%A1%E5%AE%89/">北邮信安</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><div class="post_share"><div class="social-share" data-image="/../../images/basic_configuration/tags1-1690700892780-1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/14/BUPT_note/Notes_on_Information_System_Security/" title="信息系统安全课程笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/tags1-1690700892780-1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">信息系统安全课程笔记</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/10/BUPT_note/Notes_on_Complex_network/" title="复杂网络课程笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/tags1-1690700892780-1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">复杂网络课程笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/31/BUPT_note/BUPT_SCSS_introduce/" title="北邮网安大类课程介绍（21级）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/tags1-1690700892780-1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-31</div><div class="title">北邮网安大类课程介绍（21级）</div></div></a></div><div><a href="/2024/01/09/BUPT_note/Notes%20on%20Algorithm%20Design%20and%20Analysis/" title="算法设计与分析课程笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/tags1-1690700892780-1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-09</div><div class="title">算法设计与分析课程笔记</div></div></a></div><div><a href="/2024/01/10/BUPT_note/Notes_on_Complex_network/" title="复杂网络课程笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/tags1-1690700892780-1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="title">复杂网络课程笔记</div></div></a></div><div><a href="/2024/01/09/BUPT_note/Notes%20on%20network%20security/" title="网络安全课程笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/tags1-1690700892780-1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-09</div><div class="title">网络安全课程笔记</div></div></a></div><div><a href="/2024/01/14/BUPT_note/Notes_on_Information_System_Security/" title="信息系统安全课程笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/tags1-1690700892780-1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-14</div><div class="title">信息系统安全课程笔记</div></div></a></div><div><a href="/2024/01/15/BUPT_note/Notes_on_software_security/" title="软件安全课程笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/tags1-1690700892780-1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-15</div><div class="title">软件安全课程笔记</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="card-info-avatar"> <div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div></div><div class="author-info__name">Charmes</div><div class="author-info__description">敏于思 慎于行</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/shuita2333"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/shuita2333" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:603747072@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://gitee.com/bank-beaver" target="_blank" title="Gitee"><i class="fab fa-git-square" style="color: #d5382a;"></i></a><a class="social-icon" href="/img/image-20230729200147469.png" target="_blank" title="wechat"><i class="fab fa-weixin" style="color: #3CB371;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客 ━(*｀∀´*)ノ <br>
<i class="fas fa-exclamation-circle"style="color: red;"></i>
<i class="fas fa-exclamation-circle"style="color: red;"></i>
<i class="fas fa-exclamation-circle"style="color: red;"></i>
博客IP即将到期 
<i class="fas fa-exclamation-circle"style="color: red;"></i>
<i class="fas fa-exclamation-circle"style="color: red;"></i>
<i class="fas fa-exclamation-circle"style="color: red;"></i><br>
新地址迁移: <a href="https://shuita2333.github.io" target="_blank" style="color: red;">shuita2333.github.io</a> <br>
此外一些基础实验可以在CSDN查找 <br>
<a href="https://blog.csdn.net/weixin_62495164" target="_blank">CSDN-呆呆水獭</a>  <br><br>
有任何事宜可以在文末留言，链接过期可以私信我，我会尽快更新
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF-%E9%83%AD%E7%87%95%E6%85%A7"><span class="toc-number">1.</span> <span class="toc-text">编译原理与技术 郭燕慧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%AE%BA"><span class="toc-number">2.</span> <span class="toc-text">引论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">编译器的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF"><span class="toc-number">2.1.1.</span> <span class="toc-text">前端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF"><span class="toc-number">2.1.2.</span> <span class="toc-text">后端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-Lexical-Analyzer"><span class="toc-number">2.1.3.</span> <span class="toc-text">词法分析 Lexical Analyzer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-Syntax-Analyzer"><span class="toc-number">2.1.4.</span> <span class="toc-text">语法分析 Syntax Analyzer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90-Semantic-Analysis"><span class="toc-number">2.1.5.</span> <span class="toc-text">语义分析 Semantic Analysis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5-Type-Checking"><span class="toc-number">2.1.6.</span> <span class="toc-text">类型检查 Type Checking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-Machine-Independent-Code-Optimizer"><span class="toc-number">2.1.7.</span> <span class="toc-text">中间代码生成 Machine-Independent Code Optimizer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-Machine-Independent-Code-Optimization"><span class="toc-number">2.1.8.</span> <span class="toc-text">机器无关的代码优化 Machine-Independent Code Optimization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-Code-Generator"><span class="toc-number">2.1.9.</span> <span class="toc-text">代码生成 Code Generator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="toc-number">2.1.10.</span> <span class="toc-text">符号表管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80%EF%BC%88Intermediate-Language%EF%BC%89IL"><span class="toc-number">2.1.11.</span> <span class="toc-text">中间语言（Intermediate Language）IL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.12.</span> <span class="toc-text">编译器与解释器的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84-1"><span class="toc-number">2.2.</span> <span class="toc-text">编译器的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">前端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">后端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-Lexical-Analyzer-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">词法分析 Lexical Analyzer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-Syntax-Analyzer-1"><span class="toc-number">2.2.4.</span> <span class="toc-text">语法分析 Syntax Analyzer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90-Semantic-Analysis-1"><span class="toc-number">2.2.5.</span> <span class="toc-text">语义分析 Semantic Analysis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5-Type-Checking-1"><span class="toc-number">2.2.6.</span> <span class="toc-text">类型检查 Type Checking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-Machine-Independent-Code-Optimizer-1"><span class="toc-number">2.2.7.</span> <span class="toc-text">中间代码生成 Machine-Independent Code Optimizer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-Machine-Independent-Code-Optimization-1"><span class="toc-number">2.2.8.</span> <span class="toc-text">机器无关的代码优化 Machine-Independent Code Optimization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-Code-Generator-1"><span class="toc-number">2.2.9.</span> <span class="toc-text">代码生成 Code Generator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%AE%A1%E7%90%86-1"><span class="toc-number">2.2.10.</span> <span class="toc-text">符号表管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80%EF%BC%88Intermediate-Language%EF%BC%89IL-1"><span class="toc-number">2.2.11.</span> <span class="toc-text">中间语言（Intermediate Language）IL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB-1"><span class="toc-number">2.2.12.</span> <span class="toc-text">编译器与解释器的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">第二章词法分析器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">词法分析器的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tokens-Patterns-and-Lexemes"><span class="toc-number">3.1.1.</span> <span class="toc-text">Tokens, Patterns, and Lexemes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#token%E5%B1%9E%E6%80%A7"><span class="toc-number">3.1.2.</span> <span class="toc-text">token属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E8%A7%84%E8%8C%83-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">令牌规范(正则表达式)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E8%AF%AD%E8%A8%80"><span class="toc-number">3.2.1.</span> <span class="toc-text">字符串和语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Operations-on-Languages-%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.2.</span> <span class="toc-text">Operations on Languages (语言的运算)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E8%AF%86%E5%88%AB-%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-number">3.3.</span> <span class="toc-text">令牌识别(转换图)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transition-Diagrams-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-number">3.4.</span> <span class="toc-text">Transition Diagrams (状态转换图)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%95%B4%E4%B8%AA%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">构建整个词法分析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">词法分析器生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finite-Automata-%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">3.7.</span> <span class="toc-text">Finite Automata (有穷自动机)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nondeterministic-finite-automata-NFA-%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">3.7.1.</span> <span class="toc-text">Nondeterministic finite automata (NFA, 非确定有穷自动机)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transition-Table-%E8%BD%AC%E6%8D%A2%E8%A1%A8"><span class="toc-number">3.7.2.</span> <span class="toc-text">Transition Table 转换表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deterministic-finite-automata-DFA-%E7%A1%AE%E5%AE%9A%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">3.7.3.</span> <span class="toc-text">Deterministic finite automata (DFA, 确定有穷自动机)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">第三章:语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E8%AF%AD%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">描述语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">4.1.1.</span> <span class="toc-text">语法分析器的角色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">语法分析器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-Free-Grammar-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">Context-Free Grammar (上下文无关文法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Derivation-%E6%8E%A8%E5%AF%BC"><span class="toc-number">4.2.2.</span> <span class="toc-text">Derivation (推导)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7"><span class="toc-number">4.2.3.</span> <span class="toc-text">符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">4.2.4.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6-%E6%9C%80%E5%8F%B3%E6%8E%A8%E5%AF%BC"><span class="toc-number">4.2.5.</span> <span class="toc-text">最左&#x2F;最右推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91"><span class="toc-number">4.2.6.</span> <span class="toc-text">语法分析树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ambiguity-%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">Ambiguity (二义性)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CFG%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%AF%94%E8%BE%83-CFG-vs-Regular-Expressions"><span class="toc-number">4.4.</span> <span class="toc-text">CFG与正则表达式比较 CFG vs. Regular Expressions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E4%BD%95%E6%AD%A3%E5%88%99%E8%AF%AD%E8%A8%80%E9%83%BD%E5%8F%AF%E4%BB%A5%E7%94%A8CFG%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.4.1.</span> <span class="toc-text">任何正则语言都可以用CFG描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.5.</span> <span class="toc-text">语法设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">4.5.1.</span> <span class="toc-text">消除二义性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-number">4.5.2.</span> <span class="toc-text">消除左递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Left-Factoring-%E6%8F%90%E5%8F%96%E5%B7%A6%E5%85%AC%E5%9B%A0%E5%AD%90"><span class="toc-number">4.6.</span> <span class="toc-text">Left Factoring (提取左公因子)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">4.7.</span> <span class="toc-text">自顶向下语法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">4.8.</span> <span class="toc-text">自底向上语法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">4.9.</span> <span class="toc-text">递归下降的语法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtracking-%E5%9B%9E%E6%BA%AF"><span class="toc-number">4.10.</span> <span class="toc-text">Backtracking (回溯)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9D%90%B9%F0%9D%90%BC%F0%9D%91%85%F0%9D%91%86%F0%9D%91%87"><span class="toc-number">4.10.1.</span> <span class="toc-text">𝐹𝐼𝑅𝑆𝑇()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LL-1-Grammars"><span class="toc-number">4.11.</span> <span class="toc-text">LL(1) Grammars</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parsing-Table-%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-number">4.12.</span> <span class="toc-text">Parsing Table (预测分析表)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-number">4.12.1.</span> <span class="toc-text">构造预测分析表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.13.</span> <span class="toc-text">非递归的预测分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E7%9A%84%E9%A2%84%E6%B5%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">4.13.1.</span> <span class="toc-text">表驱动的预测语法分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%88%86%E6%9E%90"><span class="toc-number">4.14.</span> <span class="toc-text">自底向上分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reductions-%E5%BD%92%E7%BA%A6"><span class="toc-number">4.14.1.</span> <span class="toc-text">Reductions (归约)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handles-%E5%8F%A5%E6%9F%84"><span class="toc-number">4.14.2.</span> <span class="toc-text">Handles (句柄)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handle-Pruning-%E5%8F%A5%E6%9F%84%E5%89%AA%E6%9E%9D"><span class="toc-number">4.14.3.</span> <span class="toc-text">Handle Pruning (句柄剪枝)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95LR"><span class="toc-number">4.15.</span> <span class="toc-text">简单LR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR-0-Items-LR-0-%E9%A1%B9"><span class="toc-number">4.16.</span> <span class="toc-text">LR(0) Items (LR(0)项)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E8%8C%83LR-0-%E9%A1%B9%E9%9B%86%E6%97%8F"><span class="toc-number">4.16.1.</span> <span class="toc-text">规范LR(0)项集族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%B9%BF%E6%96%87%E6%B3%95"><span class="toc-number">4.16.2.</span> <span class="toc-text">增广文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E9%9B%86%E9%97%AD%E5%8C%85"><span class="toc-number">4.16.3.</span> <span class="toc-text">项集闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GOTO%E5%87%BD%E6%95%B0"><span class="toc-number">4.16.4.</span> <span class="toc-text">GOTO函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR-0-%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">4.16.5.</span> <span class="toc-text">LR(0)自动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR-0-%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.16.6.</span> <span class="toc-text">LR(0)自动机的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.16.7.</span> <span class="toc-text">LR语法分析器结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%A1%A8%EF%BC%9AACTION-GOTO"><span class="toc-number">4.16.8.</span> <span class="toc-text">LR语法分析表：ACTION + GOTO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E6%80%81%E5%8A%BF"><span class="toc-number">4.16.9.</span> <span class="toc-text">LR语法分析器的态势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0SLR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-number">4.16.10.</span> <span class="toc-text">构造SLR语法分析表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E8%8C%83LR"><span class="toc-number">4.17.</span> <span class="toc-text">规范LR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E8%8C%83LR-1-%E9%A1%B9"><span class="toc-number">4.17.1.</span> <span class="toc-text">规范LR(1)项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E8%A7%84%E8%8C%83LR-1-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-number">4.17.2.</span> <span class="toc-text">构造规范LR(1)语法分析表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lookahead-LR-LALR"><span class="toc-number">4.18.</span> <span class="toc-text">Lookahead LR (LALR)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6%E5%BC%95%E5%8F%91%E7%9A%84%E5%86%B2%E7%AA%81"><span class="toc-number">4.18.1.</span> <span class="toc-text">状态合并引发的冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D"><span class="toc-number">4.19.</span> <span class="toc-text">错误恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7"><span class="toc-number">4.20.</span> <span class="toc-text">语法分析器生成工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Yacc%E7%9A%84%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><span class="toc-number">4.20.1.</span> <span class="toc-text">Yacc的冲突解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Yacc%E7%9A%84%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D"><span class="toc-number">4.20.2.</span> <span class="toc-text">Yacc的错误恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-Syntax-Directed-Translation"><span class="toc-number">5.</span> <span class="toc-text">Chapter 4:  Syntax-Directed Translation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="toc-number">5.0.1.</span> <span class="toc-text">语法制导的翻译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%B1%9E%E6%80%A7"><span class="toc-number">5.0.2.</span> <span class="toc-text">合成属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDD-%E4%B8%8D%E6%8C%87%E5%AE%9A%E8%A7%A3%E6%9E%90%E6%A0%91%E4%B8%8A%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.0.3.</span> <span class="toc-text">SDD 不指定解析树上属性的计算顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7"><span class="toc-number">5.0.4.</span> <span class="toc-text">继承属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#S-%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="toc-number">5.0.5.</span> <span class="toc-text">S 属性定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L-%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="toc-number">5.0.6.</span> <span class="toc-text">L 属性定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L-%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AF%84%E4%BC%B0"><span class="toc-number">5.0.7.</span> <span class="toc-text">L 属性定义的属性评估</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">构建语法树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">计算类型的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Syntax-Directed-Translation-Schemes"><span class="toc-number">5.3.</span> <span class="toc-text">Syntax-Directed Translation Schemes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDT%E2%80%99s-for-L-Attributed-SDD%E2%80%99s"><span class="toc-number">5.3.1.</span> <span class="toc-text">SDT’s for L-Attributed SDD’s</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%95%B4%E4%B8%AA%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8-1"><span class="toc-number">5.3.2.</span> <span class="toc-text">构建整个词法分析器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementing-L-Attributed-SDD%E2%80%99s"><span class="toc-number">5.4.</span> <span class="toc-text">Implementing L-Attributed SDD’s</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-Intermediate-Code-Generation"><span class="toc-number">6.</span> <span class="toc-text">Chapter 5: Intermediate-Code Generation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">中间表示法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%AF%E6%9E%84%E5%BB%BA-IR-%E5%BA%8F%E5%88%97"><span class="toc-number">6.2.</span> <span class="toc-text">编译器可构建 IR 序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DAG%E2%80%99s-for-Expressions"><span class="toc-number">6.3.</span> <span class="toc-text">DAG’s for Expressions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Three-Address-Code-%E4%B8%89%E5%9C%B0%E5%9D%80%E4%BB%A3%E7%A0%81"><span class="toc-number">6.4.</span> <span class="toc-text">Three-Address Code (三地址代码)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">6.4.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quadruples-%E5%9B%9B%E5%85%83%E5%BC%8F"><span class="toc-number">6.4.2.</span> <span class="toc-text">Quadruples (四元式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Triples-%E4%B8%89%E5%85%83%E5%BC%8F"><span class="toc-number">6.4.3.</span> <span class="toc-text">Triples (三元式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Indirect-Triples-%E9%97%B4%E6%8E%A5%E4%B8%89%E5%85%83%E5%BC%8F"><span class="toc-number">6.4.4.</span> <span class="toc-text">Indirect Triples (间接三元式)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Types-and-Type-Checking"><span class="toc-number">6.5.</span> <span class="toc-text">Types and Type Checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Expressions-%E7%B1%BB%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.6.</span> <span class="toc-text">Type Expressions (类型表达式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Name-Equivalence-%E5%90%8D%E7%AD%89%E4%BB%B7"><span class="toc-number">6.7.</span> <span class="toc-text">Name Equivalence (名等价)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Structural-Equivalence-%E7%BB%93%E6%9E%84%E7%AD%89%E4%BB%B7"><span class="toc-number">6.8.</span> <span class="toc-text">Structural Equivalence (结构等价)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Declarations-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">6.9.</span> <span class="toc-text">Declarations (类型的声明)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Storage-Layout-for-Local-Names-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80"><span class="toc-number">6.10.</span> <span class="toc-text">Storage Layout for Local Names (局部变量的存储布局)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="toc-number">6.11.</span> <span class="toc-text">表达式的翻译</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/08/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/" title="pytorch安装全流程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/Software_and_App/Windows_docker/wallhaven-0jp71w_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pytorch安装全流程"/></a><div class="content"><a class="title" href="/2024/07/08/Software_and_App/pytorch%E5%AE%89%E8%A3%85%E5%85%A8%E6%B5%81%E7%A8%8B/" title="pytorch安装全流程">pytorch安装全流程</a><time datetime="2024-07-08T01:00:00.000Z" title="发表于 2024-07-08 09:00:00">2024-07-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/07/hexo/SSL%E8%AF%81%E4%B9%A6%E7%BB%AD%E6%9C%9F%E6%B5%81%E7%A8%8B/" title="Hexo博客搭建（14）——SSl证书续期"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/image-20230729155123532.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo博客搭建（14）——SSl证书续期"/></a><div class="content"><a class="title" href="/2024/07/07/hexo/SSL%E8%AF%81%E4%B9%A6%E7%BB%AD%E6%9C%9F%E6%B5%81%E7%A8%8B/" title="Hexo博客搭建（14）——SSl证书续期">Hexo博客搭建（14）——SSl证书续期</a><time datetime="2024-07-06T16:58:36.000Z" title="发表于 2024-07-07 00:58:36">2024-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/05/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="Windows文件加密驱动的设计与实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/wallhaven-0jp71w_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows文件加密驱动的设计与实现"/></a><div class="content"><a class="title" href="/2024/06/05/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/Windows%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="Windows文件加密驱动的设计与实现">Windows文件加密驱动的设计与实现</a><time datetime="2024-06-04T18:00:00.000Z" title="发表于 2024-06-05 02:00:00">2024-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/08/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/" title="同态加密算法实现及推导"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/wallhaven-0jp71w_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="同态加密算法实现及推导"/></a><div class="content"><a class="title" href="/2024/04/08/Information_Security_Experiment/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%8E%A8%E5%AF%BC/" title="同态加密算法实现及推导">同态加密算法实现及推导</a><time datetime="2024-04-07T18:00:00.000Z" title="发表于 2024-04-08 02:00:00">2024-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/08/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/" title="CNN简述与应用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../images/basic_configuration/wallhaven-0jp71w_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CNN简述与应用"/></a><div class="content"><a class="title" href="/2024/04/08/Information_Security_Experiment/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8/CNN%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/" title="CNN简述与应用">CNN简述与应用</a><time datetime="2024-04-07T18:00:00.000Z" title="发表于 2024-04-08 02:00:00">2024-04-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer-wrap"></div><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/link/">我的朋友</a></li><li> <a href="/about/">关于作者</a></li><li> <a href="/archives/">文章归档</a></li><li> <a href="/categories/">文章分类</a></li><li> <a href="/tags/">文章标签</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://zhangyuanhe.top/" title="Charmes"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zyhblog-1318929733.cos.ap-beijing.myqcloud.com/favicon1.png" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://liuruibin.com/" title="LRBlog"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lrblog-img-1304667442.file.myqcloud.com/method.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://akilar.top/" title="Akilarの糖果屋"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/6bf1ed05796db59c.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="http://www.azuredust.cc" title="de4dst4r blog"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://www.azuredust.cc/wp-content/themes/personalblogily/inc/starter_content/img/portrait.png" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2023 - 2024</b></span><span><b>&nbsp;&nbsp;By Charmes</b></span></div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=/img/icp.png>
<a href="https://beian.miit.gov.cn/" target="_blank">京ICP备2023019220号-1</a></div><div id="workboard"></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.zhangyuanhe.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.zhangyuanhe.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/light.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><script src="/js/sun_moon.js" async></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script defer src="/js/another.js"></script><script defer src="/js/runtime.js"></script><script async src="/js/fps.js"></script><script async src="/js/title.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://shuita2333.github.io/categories/博客搭建/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 Charmesの魔改教程 (14)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://shuita2333.github.io/categories/课程笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 Charmesの学习笔记 (11)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://shuita2333.github.io/categories/信安课程实验/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 Charmesの实验记录 (45)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://shuita2333.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>